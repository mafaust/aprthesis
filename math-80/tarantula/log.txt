[0] INFO ProjectConfiguration - Version of the JVM used: 1.8.0_202
[1] INFO main - Java version of the JDK used to run tests: 1.8.0_202
[1] INFO main - The compliance of the JVM is:  8
[2] INFO main - command line arguments: [-location  /Users/marekmazur/astor/defects4j/math-80  -mode  jgenprog  -package  org.apache.commons  -jvm4testexecution  /Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin  -failing  org.apache.commons.math.linear.EigenDecompositionImplTest  -srcjavafolder  /src/java/  -srctestfolder  /src/test/  -binjavafolder  /target/classes/  -bintestfolder  /target/test-classes/  -stopfirst  true  -dependencies  /Users/marekmazur/astor/examples/libs/junit-4.4.jar  -maxgen  1000000  -seed  10  -maxtime  60  -scope  local  -stopfirst  true  -flthreshold  0  -population  1  -faultlocalization  flacoco]
[5] INFO AstorMain - Running Astor on a JDK at /Users/marekmazur/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/jre
Source folders: [/Users/marekmazur/astor/defects4j/math-80/src/main/java]
Source Test folders: [/Users/marekmazur/astor/defects4j/math-80/src/test]
---- Creating spoon model
Creating model,  Code location from working folder: /Users/marekmazur/astor/defects4j/math-80/src/main/java
building model: /Users/marekmazur/astor/defects4j/math-80/src/main/java, compliance level: 8
Classpath (Dependencies) for building SpoonModel: [/Users/marekmazur/astor/examples/libs/junit-4.4.jar]
Spoon Model built from location: /Users/marekmazur/astor/defects4j/math-80/src/main/java
Number of CtTypes created: 393
Running chosen test detection strategy: CLASSLOADER
Test retrieved from classes: 225
Running Flacoco...
Running spectrum-based fault localization...
FlacocoConfig{workspace='/Users/marekmazur/astor/.', projectPath='/Users/marekmazur/astor/defects4j/math-80', srcJavaDir=[/Users/marekmazur/astor/defects4j/math-80/src/main/java], srcTestDir=[/Users/marekmazur/astor/defects4j/math-80/src/test], binJavaDir=[/Users/marekmazur/astor/defects4j/math-80/target/classes], binTestDir=[/Users/marekmazur/astor/defects4j/math-80/target/test-classes], classpath='/Users/marekmazur/astor/examples/libs/junit-4.4.jar', customJUnitClasspath='null', customJacocoClasspath='null', mavenHome='/Users/marekmazur/.m2/repository/', coverTests=false, testRunnerVerbose=false, testRunnerTimeoutInMs=3600000, testRunnerJVMArgs='null', threshold=0.0, includeZeros=false, complianceLevel=8, testDetectionStrategy=CLASSLOADER, ignoredTests=[], jUnit4Tests=[org.apache.commons.math.linear.SparseRealMatrixTest#testSerial, org.apache.commons.math.util.MathUtilsTest#testL2DistanceInt, org.apache.commons.math.linear.QRSolverTest#testOverdetermined, org.apache.commons.math.linear.SingularValueSolverTest#testSolveSingularityErrors, org.apache.commons.math.fraction.BigFractionTest#testPow, org.apache.commons.math.linear.BigMatrixImplTest#testSubMatrix, org.apache.commons.math.geometry.RotationTest#testCompose, org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testParameters, org.apache.commons.math.linear.RealMatrixImplTest#testAdd, org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowFieldMatrix, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testDimensions, org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.ode.FirstOrderConverterTest#testSmallStep, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithSplit, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNonDefaultSetting, org.apache.commons.math.stat.StatUtilsTest#testStats, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testSwissFertility, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeReal, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFitting, org.apache.commons.math.stat.regression.SimpleRegressionTest#testCorr, org.apache.commons.math.linear.BiDiagonalTransformerTest#testDimensions, org.apache.commons.math.util.MathUtilsTest#testNextAfterSpecialCases, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testPerfectFit, org.apache.commons.math.distribution.TDistributionTest#testConsistency, org.apache.commons.math.stat.inference.TTestTest#testOneSampleT, org.apache.commons.math.random.RandomAdaptorTest#testConfig, org.apache.commons.math.complex.ComplexTest#testConstructor, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testIllConditioned, org.apache.commons.math.complex.ComplexTest#testMultiplyNaN, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testConsistency, org.apache.commons.math.util.MathUtilsTest#testSubAndCheckLong, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowMatrix, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testGetValues, org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArguments, org.apache.commons.math.distribution.WeibullDistributionTest#testSampling, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSanityChecks, org.apache.commons.math.linear.BlockRealMatrixTest#testCopyFunctions, org.apache.commons.math.linear.LUSolverTest#testSolveDimensionErrors, org.apache.commons.math.linear.BigMatrixImplTest#testPlusMinus, org.apache.commons.math.distribution.CauchyDistributionTest#testIllegalArguments, org.apache.commons.math.random.ValueServerTest#testReplay, org.apache.commons.math.util.MathUtilsTest#testSignInt, org.apache.commons.math.distribution.GammaDistributionTest#testCumulativeProbabilities, org.apache.commons.math.linear.BlockFieldMatrixTest#testAddFail, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnLarge, org.apache.commons.math.fraction.FractionTest#testDoubleValue, org.apache.commons.math.linear.SparseFieldVectorTest#testMapFunctions, org.apache.commons.math.distribution.HypergeometricDistributionTest#testIllegalArguments, org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#checkClone, org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestNegative, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testIncrementation, org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewNewtonSolverValid, org.apache.commons.math.complex.ComplexTest#testGetArgumentNaN, org.apache.commons.math.geometry.Vector3DTest#testAdd, org.apache.commons.math.transform.FastSineTransformerTest#testSinFunction, org.apache.commons.math.stat.FrequencyTest#testSerial, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowMatrix, org.apache.commons.math.linear.LUDecompositionImplTest#testDimensions, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPlusMinus, org.apache.commons.math.special.BetaTest#testLogBetaPositiveZero, org.apache.commons.math.fraction.BigFractionFieldTest#testSerial, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testString, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerial, org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructor, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPermutation, org.apache.commons.math.linear.EigenSolverTest#testSolve, org.apache.commons.math.complex.ComplexTest#testTan, org.apache.commons.math.distribution.PoissonDistributionTest#testDensities, org.apache.commons.math.util.BigRealTest#testConstructor, org.apache.commons.math.linear.BigMatrixImplTest#testIsSingular, org.apache.commons.math.MaxIterationsExceededExceptionTest#testSimpleConstructor, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateSin, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonEqualCounts, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testMinStep, org.apache.commons.math.linear.SingularValueSolverTest#testSolveDimensionErrors, org.apache.commons.math.special.BetaTest#testLogBetaNanPositive, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testDeprecated, org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSimplistic, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTrivial, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEvaluation, org.apache.commons.math.util.MathUtilsTest#testPermutedArrayHash, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowLarge, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentEquations, org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#derivativesConsistency, org.apache.commons.math.linear.SparseRealMatrixTest#testTranspose, org.apache.commons.math.geometry.Vector3DTest#testNorm, org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumn, org.apache.commons.math.complex.ComplexTest#testCosNaN, org.apache.commons.math.linear.BigMatrixImplTest#testPremultiplyVector, org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testSinFunction, org.apache.commons.math.linear.CholeskySolverTest#testDeterminant, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataThatIsNotSquare, org.apache.commons.math.genetics.RandomKeyTest#testIsSame, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotSymmetricMatrixException, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testEqualsAndHashCode, org.apache.commons.math.random.RandomDataTest#testNextUniform, org.apache.commons.math.fraction.FractionTest#testCompareTo, org.apache.commons.math.linear.RealMatrixImplTest#testSetRow, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEvaluation, org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnVector, org.apache.commons.math.linear.FieldMatrixImplTest#testSetSubMatrix, org.apache.commons.math.stat.CertifiedDataTest#testSummaryStatistics, org.apache.commons.math.util.BigRealTest#testCompareTo, org.apache.commons.math.stat.descriptive.rank.MinTest#testConsistency, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonUnEqualCounts, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFittingBadInit, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsErrors, org.apache.commons.math.linear.RealMatrixImplTest#testToString, org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearFullRank, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexTest#testDivideInfinite, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNonInversible, org.apache.commons.math.fraction.FractionTest#testDoubleConstructor, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFittingBadInit, org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#serialization, org.apache.commons.math.genetics.RandomKeyMutationTest#testMutate, org.apache.commons.math.optimization.linear.SimplexSolverTest#testEpsilon, org.apache.commons.math.linear.RealMatrixImplTest#testGetRowVector, org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#serialization, org.apache.commons.math.estimation.WeightedMeasurementTest#testTheory, org.apache.commons.math.complex.ComplexTest#testSubtractNaN, org.apache.commons.math.random.RandomAdaptorTest#testNextPoisson, org.apache.commons.math.stat.descriptive.moment.MeanTest#testIncrementation, org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquare, org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedConsistency, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testNonSquare, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testInconsistentEquations, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleNoDecimals, org.apache.commons.math.complex.ComplexTest#testSqrtRealZero, org.apache.commons.math.linear.RealMatrixImplTest#testDimensions, org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproperNegative, org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testSinFunction, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveBadParameters, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testN0andN1Conditions, org.apache.commons.math.complex.ComplexFormatTest#testGetImaginaryFormat, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSetQuantile, org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryNegative, org.apache.commons.math.stat.FrequencyTest#testAddNonComparable, org.apache.commons.math.linear.BlockRealMatrixTest#testPlusMinus, org.apache.commons.math.linear.BigMatrixImplTest#testConstructors, org.apache.commons.math.complex.ComplexTest#testSinhNaN, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerial, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSerial, org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnVector, org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowVector, org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleTTest, org.apache.commons.math.fraction.BigFractionTest#testDoubleValue, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testWindowSize, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testQRColumnsPermutation, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testCopy, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerialization, org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvalues, org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate1, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testGetSummary, org.apache.commons.math.linear.BlockFieldMatrixTest#testPlusMinus, org.apache.commons.math.complex.FrenchComplexFormatTest#testPositiveInfinity, org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate0, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowLarge, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersSimple, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetFromEmpty, org.apache.commons.math.special.BetaTest#testRegularizedBetaNegativePositivePositive, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumn, org.apache.commons.math.stat.descriptive.summary.SumTest#testSerialization, org.apache.commons.math.linear.EigenDecompositionImplTest#testTridiagonal, org.apache.commons.math.linear.SparseFieldVectorTest#testBasicFunctions, org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.linear.SparseRealMatrixTest#testMath209, org.apache.commons.math.distribution.HypergeometricDistributionTest#testCumulativeProbabilities, org.apache.commons.math.linear.FieldMatrixImplTest#testGetVectors, org.apache.commons.math.geometry.RotationTest#testAngles, org.apache.commons.math.linear.BigMatrixImplTest#testEqualsAndHashCode, org.apache.commons.math.analysis.solvers.BrentSolverTest#testQuinticZero, org.apache.commons.math.optimization.linear.SimplexSolverTest#testSolutionWithNegativeDecisionVariable, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testMultiplication, org.apache.commons.math.distribution.ChiSquareDistributionTest#testDfAccessors, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLaguerrePolynomials, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnMatrix, org.apache.commons.math.ode.ContinuousOutputModelTest#testRandomAccess, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterInjection, org.apache.commons.math.genetics.RandomKeyTest#testIdentityPermutation, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testCovarianceConsistency, org.apache.commons.math.distribution.BetaDistributionTest#testDensity, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testIncreasingTolerance, org.apache.commons.math.fraction.BigFractionFormatTest#testParseBig, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testSanityChecks, org.apache.commons.math.linear.SparseRealMatrixTest#testSetSubMatrix, org.apache.commons.math.linear.QRSolverTest#testSolveRankErrors, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testShuffledStatistics, org.apache.commons.math.geometry.Vector3DTest#testDistanceSq, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterInjection, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumn, org.apache.commons.math.linear.EigenDecompositionImplTest#testMathpbx02, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHermiteDifferentials, org.apache.commons.math.distribution.NormalDistributionTest#testGetMean, org.apache.commons.math.genetics.RandomKeyTest#testComparatorPermutation, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIntegratorControls, org.apache.commons.math.stat.regression.SimpleRegressionTest#testSSENonNegative, org.apache.commons.math.linear.RealMatrixImplTest#testGetEntry, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSerialization, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension1, org.apache.commons.math.optimization.linear.SimplexSolverTest#testTrivialModel, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension2, org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#testDerivativesConsistency, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMatricesValues, org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeY, org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeZ, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFitting, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension3, org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnVector, org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeX, org.apache.commons.math.fraction.FractionFormatTest#testParseProperInvalidMinus, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSeparator, org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne2, org.apache.commons.math.genetics.GeneticAlgorithmTestBinary#test, org.apache.commons.math.complex.ComplexTest#testTanhCritical, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateDegenerate, org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne1, org.apache.commons.math.geometry.Vector3DTest#testSubtract, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testIllegalArguments, org.apache.commons.math.complex.ComplexFormatTest#testNegativeImaginary, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIncreasingTolerance, org.apache.commons.math.random.RandomAdaptorTest#testNextSample, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetFunctionValueAccuracy, org.apache.commons.math.linear.SparseRealMatrixTest#testTrace, org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnBigMatrix, org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumn, org.apache.commons.math.linear.ArrayFieldVectorTest#testMapFunctions, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTwoSets, org.apache.commons.math.stat.descriptive.rank.MaxTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.moment.MeanTest#testEvaluation, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testMomentSmallSamples, org.apache.commons.math.linear.BlockFieldMatrixTest#testDimensions, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEqualsAndHashCode, org.apache.commons.math.fraction.FractionFieldTest#testSerial, org.apache.commons.math.linear.SparseRealVectorTest#testMisc, org.apache.commons.math.special.GammaTest#testLogGammaPositive, org.apache.commons.math.stat.StatUtilsTest#testProduct, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterIllegalState, org.apache.commons.math.complex.ComplexTest#testCosInf, org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownAlmostLinear, org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest#testRosenbrock, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.estimation.MinpackTest#testMinpackBrownAlmostLinear, org.apache.commons.math.genetics.BinaryChromosomeTest#testInvalidConstructor, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testMomentSmallSamples, org.apache.commons.math.geometry.Vector3DTest#testNormalize, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction2, org.apache.commons.math.genetics.RandomKeyTest#testEqualRepr, org.apache.commons.math.complex.FrenchComplexFormatTest#testStaticFormatComplex, org.apache.commons.math.stat.correlation.CovarianceTest#testConstant, org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaTest, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutOnExisting, org.apache.commons.math.complex.ComplexFormatTest#testParseZeroReal, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParsePositiveInfinity, org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testExpm1Function, org.apache.commons.math.geometry.Vector3DFormatTest#testParsePositiveInfinity, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDimensionCheck, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimensions, org.apache.commons.math.geometry.Vector3DTest#testAngular, org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacity, org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testSinFunction, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testIllConditioned, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArguments, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testVariableSteps, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerial, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketSin, org.apache.commons.math.util.MathUtilsTest#testGcd, org.apache.commons.math.distribution.GammaDistributionTest#testValues, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeBoth, org.apache.commons.math.linear.FieldMatrixImplTest#testEqualsAndHashCode, org.apache.commons.math.linear.BigMatrixImplTest#testMultiply2, org.apache.commons.math.genetics.FitnessCachingTest#testFitnessCaching, org.apache.commons.math.random.RandomAdaptorTest#testNextUniform, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiplyVector, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeZ, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSample, org.apache.commons.math.distribution.WeibullDistributionTest#testConsistency, org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoSuccesses, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeX, org.apache.commons.math.stat.FrequencyTest#testAdd, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeY, org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeImaginary, org.apache.commons.math.distribution.BetaDistributionTest#testCumulative, org.apache.commons.math.random.RandomDataTest#testNextPoisson, org.apache.commons.math.distribution.ChiSquareDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290LEQ, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetMatrixLarge, org.apache.commons.math.distribution.HypergeometricDistributionTest#testLargeValues, org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexInf, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#backward, org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testQuinticMin, org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate1, org.apache.commons.math.special.BetaTest#testLogBetaNegativePositive, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testOneSet, org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate0, org.apache.commons.math.distribution.CauchyDistributionTest#testScale, org.apache.commons.math.util.MathUtilsTest#testSubAndCheck, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testNaNContracts, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testToString, org.apache.commons.math.fraction.BigFractionTest#testNegate, org.apache.commons.math.complex.ComplexTest#testExpInf, org.apache.commons.math.stat.regression.SimpleRegressionTest#testNorris, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroImaginary, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseIgnoredWhitespace, org.apache.commons.math.genetics.RandomKeyTest#testDecode, org.apache.commons.math.optimization.general.MinpackTest#testMinpackChebyquad, org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigMatrix, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConstant, org.apache.commons.math.analysis.integration.RombergIntegratorTest#testSinFunction, org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareIndependence, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testCopy, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBadParameters, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowVector, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testProductAndGeometricMean, org.apache.commons.math.genetics.FixedGenerationCountTest#testIsSatisfied, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGet, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveZeroPositive, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstChebyshevPolynomials, org.apache.commons.math.linear.RealMatrixImplTest#testTrace, org.apache.commons.math.optimization.direct.NelderMeadTest#testMinimizeMaximize, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopyConsistency, org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testInconsistentEquations, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testVariableSteps, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testConstructorSingleFormat, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testStepSize, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSpecialValues, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testIncrementation, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testNaN, org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSuffix, org.apache.commons.math.linear.QRSolverTest#testSolve, org.apache.commons.math.util.OpenIntToFieldTest#testGetAbsent, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testExamples, org.apache.commons.math.util.TransformerMapTest#testTransformers, org.apache.commons.math.util.OpenIntToFieldTest#testIterator, org.apache.commons.math.complex.ComplexFormatTest#testNegativeInfinity, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testConstants, org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply2, org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_fourthRoot, org.apache.commons.math.distribution.ZipfDistributionTest#testCumulativeProbabilities, org.apache.commons.math.special.GammaTest#testDigammaSmallArgs, org.apache.commons.math.linear.BlockRealMatrixTest#testGetVectors, org.apache.commons.math.stat.regression.SimpleRegressionTest#testInference, org.apache.commons.math.stat.descriptive.rank.PercentileTest#test5, org.apache.commons.math.linear.ArrayRealVectorTest#testMisc, org.apache.commons.math.distribution.WeibullDistributionTest#testIllegalArguments, org.apache.commons.math.optimization.direct.NelderMeadTest#testRosenbrock, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetEntry, org.apache.commons.math.stat.regression.SimpleRegressionTest#testClear, org.apache.commons.math.linear.SparseFieldMatrixTest#testAddFail, org.apache.commons.math.special.BetaTest#testRegularizedBetaZeroPositivePositive, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEvaluation, org.apache.commons.math.optimization.linear.SimplexSolverTest#testInfeasibleSolution, org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testQuinticFunction, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testSetterInjection, org.apache.commons.math.random.MersenneTwisterTest#testNextIntNeg, org.apache.commons.math.complex.ComplexTest#testEqualsTrue, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerial, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDecreasingSteps, org.apache.commons.math.complex.ComplexTest#testEqualsNull, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerialization, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply2, org.apache.commons.math.linear.SparseFieldMatrixTest#testSubMatrix, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArgumentCause, org.apache.commons.math.util.BigRealFieldTest#testOne, org.apache.commons.math.complex.ComplexTest#testScalarMultiply, org.apache.commons.math.linear.RealMatrixImplTest#testGetRow, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopy, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromSingle, org.apache.commons.math.util.TransformerMapTest#testClear, org.apache.commons.math.complex.ComplexTest#testSqrtPolar, org.apache.commons.math.random.ValueServerTest#testFill, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testWeightedConsistency, org.apache.commons.math.fraction.BigFractionFormatTest#testFormatZero, org.apache.commons.math.distribution.ChiSquareDistributionTest#testSmallDf, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNan, org.apache.commons.math.util.MathUtilsTest#testL1DistanceInt, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.stat.descriptive.summary.ProductTest#testSpecialValues, org.apache.commons.math.distribution.NormalDistributionTest#testMath280, org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareLargeTestStatistic, org.apache.commons.math.linear.EigenDecompositionImplTest#testDistinctEigenvalues, org.apache.commons.math.fraction.FractionFormatTest#testDoubleFormat, org.apache.commons.math.linear.BlockFieldMatrixTest#testSerial, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testDimensionCheck, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumn, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBigStep, org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testSerial, org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMath226, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLong, org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowVector, org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowMatrix, org.apache.commons.math.genetics.ElitisticListPopulationTest#testNextGeneration, org.apache.commons.math.analysis.integration.RombergIntegratorTest#testParameters, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureHex, org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexNaN, org.apache.commons.math.linear.RealVectorFormatTest#testParseZeroX, org.apache.commons.math.ConvergenceExceptionTest#testConstructor, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#checklone, org.apache.commons.math.estimation.MinpackTest#testMinpackHelicalValley, org.apache.commons.math.genetics.ListPopulationTest#testGetFittestChromosome, org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSeparator, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testLongly, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testMomentSmallSamples, org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowBigMatrix, org.apache.commons.math.linear.LUDecompositionImplTest#testLLowerTriangular, org.apache.commons.math.distribution.BinomialDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.util.MathUtilsTest#testLInfDistanceInt, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowVector, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNoDependency, org.apache.commons.math.linear.BiDiagonalTransformerTest#testUOrthogonal, org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiply, org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowRealMatrix, org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated2, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseManyComponents, org.apache.commons.math.special.GammaTest#testRegularizedGammaPositivePositive, org.apache.commons.math.util.TransformerMapTest#testPutTransformer, org.apache.commons.math.optimization.linear.SimplexSolverTest#testDegeneracy, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeAll, org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testQuinticFunction, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testDimension, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFittingBadInit, org.apache.commons.math.optimization.linear.SimplexTableauTest#testDropPhase1Objective, org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatObject, org.apache.commons.math.fraction.BigFractionFormatTest#testWholeFormat, org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testStepSize, org.apache.commons.math.util.MathUtilsTest#testNormalizeAngle, org.apache.commons.math.MathExceptionTest#testConstructorCause, org.apache.commons.math.complex.ComplexTest#testAbsNaN, org.apache.commons.math.stat.descriptive.rank.MinTest#testWeightedConsistency, org.apache.commons.math.util.MathUtilsTest#testIndicatorInt, org.apache.commons.math.linear.BlockRealMatrixTest#testAdd, org.apache.commons.math.linear.RealMatrixImplTest#testScalarAdd, org.apache.commons.math.special.GammaTest#testLogGammaZero, org.apache.commons.math.stat.StatUtilsTest#testPercentile, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareLargeTestStatistic, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopyConsistency, org.apache.commons.math.linear.RealMatrixImplTest#testOperate, org.apache.commons.math.stat.descriptive.rank.MaxTest#testMomentSmallSamples, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenPrefix, org.apache.commons.math.stat.correlation.CovarianceTest#testLongly, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTrivial, org.apache.commons.math.ode.ContinuousOutputModelTest#testErrorConditions, org.apache.commons.math.complex.ComplexFormatTest#testZeroImaginary, org.apache.commons.math.fraction.BigFractionFormatTest#testParseInteger, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testWeightedConsistency, org.apache.commons.math.random.MersenneTwisterTest#testNexBytes, org.apache.commons.math.complex.ComplexUtilsTest#testPolar2Complex, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testPercentileSetter, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testUnstableDerivative, org.apache.commons.math.complex.ComplexTest#testMath221, org.apache.commons.math.complex.ComplexTest#testSqrt1z, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnDistortedSine, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopy, org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowMatrix, org.apache.commons.math.geometry.RotationTest#testQuaternion, org.apache.commons.math.linear.ArrayFieldVectorTest#testDataInOut, org.apache.commons.math.random.RandomAdaptorTest#testNextPermutation, org.apache.commons.math.linear.RealMatrixImplTest#testMultiply, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testRedundantEquations, org.apache.commons.math.linear.QRDecompositionImplTest#testHTrapezoidal, org.apache.commons.math.linear.RealVectorFormatTest#testParseNan, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNoRoot, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testDimensions, org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.analysis.integration.RombergIntegratorTest#testQuinticFunction, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testN0andN1Conditions, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseZeroX, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterIllegalState, org.apache.commons.math.linear.QRDecompositionImplTest#testQOrthogonal, org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testMismatch, org.apache.commons.math.fraction.FractionFormatTest#testFormatZero, org.apache.commons.math.distribution.GammaDistributionTest#testConsistency, org.apache.commons.math.distribution.WeibullDistributionTest#testSetBeta, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDimensionCheck, org.apache.commons.math.linear.BiDiagonalTransformerTest#testMatricesValues, org.apache.commons.math.stat.data.LotteryTest#testCertifiedValues, org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testFixedState, org.apache.commons.math.fraction.BigFractionTest#testGetReducedFraction, org.apache.commons.math.linear.RealMatrixImplTest#testAddFail, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testSmallLastStep, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.util.TransformerMapTest#testContainsClass, org.apache.commons.math.linear.BlockFieldMatrixTest#testSeveralBlocks, org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFat, org.apache.commons.math.geometry.RotationTest#testMatrix, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerialization, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopy, org.apache.commons.math.stat.descriptive.summary.ProductTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.linear.SparseFieldMatrixTest#testCopyFunctions, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetAbsoluteAccuracy, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopyConsistency, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextHex, org.apache.commons.math.linear.BiDiagonalTransformerTest#testVOrthogonal, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMinimization, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testConsistency, org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHeterscedastic, org.apache.commons.math.geometry.Vector3DFormatTest#testParseIgnoredWhitespace, org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnMatrix, org.apache.commons.math.linear.RealVectorFormatTest#testNonDefaultSetting, org.apache.commons.math.fraction.FractionFieldTest#testZero, org.apache.commons.math.util.MathUtilsTest#test0Choose0, org.apache.commons.math.util.DefaultTransformerTest#testTransformString, org.apache.commons.math.distribution.NormalDistributionTest#testSetMean, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testCopy, org.apache.commons.math.linear.EigenDecompositionImplTest#testRepeatedEigenvalue, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerial, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerialization, org.apache.commons.math.stat.descriptive.rank.MinTest#testIncrementation, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testIncrementation, org.apache.commons.math.genetics.ChromosomeTest#testFindSameChromosome, org.apache.commons.math.linear.BlockFieldMatrixTest#testOperatePremultiplyLarge, org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimals, org.apache.commons.math.stat.descriptive.rank.MaxTest#testSpecialValues, org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiply, org.apache.commons.math.geometry.Vector3DFormatTest#testNan, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressandVariance, org.apache.commons.math.complex.ComplexTest#testConjugate, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testIncrementation, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevDifferentials, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNan, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsNoConvergence, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetEntry, org.apache.commons.math.distribution.WeibullDistributionTest#testAlpha, org.apache.commons.math.linear.BigMatrixImplTest#testTranspose, org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedUlps, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetRelativeAccuracy, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracySin, org.apache.commons.math.complex.FrenchComplexFormatTest#testNan, org.apache.commons.math.linear.ArrayRealVectorTest#testBasicFunctions, org.apache.commons.math.distribution.BinomialDistributionTest#testDensities, org.apache.commons.math.random.ValueServerTest#testEmptyDigestFile, org.apache.commons.math.fraction.BigFractionTest#testDivide, org.apache.commons.math.linear.BlockRealMatrixTest#testCopySubMatrix, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testConsistency, org.apache.commons.math.random.RandomAdaptorTest#testNextInt, org.apache.commons.math.complex.ComplexFormatTest#testParseZeroImaginary, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNullIntervalCheck, org.apache.commons.math.special.GammaTest#testTrigamma, org.apache.commons.math.fraction.BigFractionTest#testSerial, org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHeterscedastic, org.apache.commons.math.complex.ComplexTest#testDivideReal, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAdd, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testWeightedConsistency, org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply, org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testParameters, org.apache.commons.math.linear.MatrixUtilsTest#testCreateIdentityMatrix, org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove2, org.apache.commons.math.linear.FieldMatrixImplTest#testCopyFunctions, org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalid, org.apache.commons.math.distribution.NormalDistributionTest#testQuantiles, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testIncreasingTolerance, org.apache.commons.math.special.GammaTest#testDigammaLargeArgs, org.apache.commons.math.linear.ArrayRealVectorTest#testPredicates, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testVOrthogonal, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBackward, org.apache.commons.math.distribution.NormalDistributionTest#testCumulativeProbabilities, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRandom, org.apache.commons.math.linear.ArrayFieldVectorTest#testConstructors, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testRemoval, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetMaximalIterationCount, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testWalk, org.apache.commons.math.complex.ComplexTest#testDivideNaN, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnTwoPoints, org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testNoError, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnVector, org.apache.commons.math.fraction.FractionFormatTest#testParseProper, org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testSerialization, org.apache.commons.math.geometry.Vector3DTest#testScalarProduct, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArgumentsCause, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowMatrix, org.apache.commons.math.transform.FastCosineTransformerTest#testSinFunction, org.apache.commons.math.stat.descriptive.summary.SumTest#testEqualsAndHashCode, org.apache.commons.math.linear.RealMatrixImplTest#testTranspose, org.apache.commons.math.geometry.RotationTest#testVectorOnePair, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testIncreasingTolerance, org.apache.commons.math.linear.TriDiagonalTransformerTest#testQOrthogonal, org.apache.commons.math.special.BetaTest#testLogBetaPositiveNan, org.apache.commons.math.special.BetaTest#testLogBetaPositiveNegative, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testWrongDerivative, org.apache.commons.math.linear.SparseRealMatrixTest#testSubMatrix, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testQuinticFunction, org.apache.commons.math.distribution.PoissonDistributionTest#testNormalApproximateProbability, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMaximalTiesMinimum, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testMomentSmallSamples, org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#serialization, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationInside, org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleT, org.apache.commons.math.complex.ComplexTest#testNegateNaN, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNonDefaultSetting, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetVectors, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testStats, org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopy, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTranspose, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetEntry, org.apache.commons.math.linear.BigMatrixImplTest#testPremultiply, org.apache.commons.math.optimization.linear.SimplexTableauTest#testSerial, org.apache.commons.math.stat.descriptive.rank.MinTest#testMomentSmallSamples, org.apache.commons.math.fraction.BigFractionFormatTest#testDenominatorFormat, org.apache.commons.math.linear.BlockRealMatrixTest#testDimensions, org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#serialization, org.apache.commons.math.complex.ComplexTest#testSinNaN, org.apache.commons.math.complex.ComplexTest#testScalarMultiplyInf, org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testParaboloid2D, org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testEqualsAndHashCode, org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues2, org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues1, org.apache.commons.math.stat.descriptive.rank.MaxTest#testIncrementation, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentSizes, org.apache.commons.math.linear.RealVectorFormatTest#testNan, org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiplyVector, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwissFertility, org.apache.commons.math.genetics.RandomKeyTest#testConstructor2, org.apache.commons.math.genetics.RandomKeyTest#testConstructor1, org.apache.commons.math.util.BigRealTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexTest#testLogZero, org.apache.commons.math.util.ResizableDoubleArrayTest#testMinMax, org.apache.commons.math.linear.LUDecompositionImplTest#testUUpperTriangular, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNonInversible, org.apache.commons.math.random.RandomDataTest#testNextLongExtremeValues, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerialization, org.apache.commons.math.linear.TriDiagonalTransformerTest#testNonSquare, org.apache.commons.math.complex.ComplexTest#testCosh, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopyConsistency, org.apache.commons.math.linear.ArrayFieldVectorTest#testSerial, org.apache.commons.math.estimation.MinpackTest#testMinpackLinearFullRank, org.apache.commons.math.geometry.Vector3DFormatTest#testPositiveInfinity, org.apache.commons.math.stat.descriptive.rank.MinTest#testNaNs, org.apache.commons.math.stat.descriptive.summary.SumTest#testCopy, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testKepler, org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfect, org.apache.commons.math.linear.RealVectorFormatTest#testParseManyComponents, org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuinticFunction, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEqualsAndHashCode, org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply2, org.apache.commons.math.linear.ArrayFieldVectorTest#testBasicFunctions, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEqualsAndHashCode, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnLarge, org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeImaginary, org.apache.commons.math.linear.BlockFieldMatrixTest#testAdd, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNonDefaultSetting, org.apache.commons.math.fraction.BigFractionTest#testSubtract, org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnVector, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testConsistency, org.apache.commons.math.distribution.ChiSquareDistributionTest#testConsistency, org.apache.commons.math.fraction.FractionFormatTest#testParse, org.apache.commons.math.linear.FieldMatrixImplTest#testGetRow, org.apache.commons.math.linear.RealMatrixImplTest#testSetRowMatrix, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMaxIterations, org.apache.commons.math.linear.BigMatrixImplTest#testNorm, org.apache.commons.math.distribution.GammaDistributionTest#testDensity, org.apache.commons.math.fraction.BigFractionTest#testDigitLimitConstructor, org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnMatrix, org.apache.commons.math.linear.MatrixUtilsTest#testBigFractionConverter, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeInfinity, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#test20090720, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testIllConditioned, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTwoSets, org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testLinearFunction2D, org.apache.commons.math.linear.ArrayRealVectorTest#testSerial, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopyConsistency, org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGet, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMath199, org.apache.commons.math.linear.BlockFieldMatrixTest#testTrace, org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testStats, org.apache.commons.math.complex.ComplexFormatTest#testFormatObject, org.apache.commons.math.stat.descriptive.summary.SumTest#testCopyConsistency, org.apache.commons.math.transform.FastFourierTransformerTest#testSinFunction, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#serialization, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testContainsKey, org.apache.commons.math.complex.ComplexFormatTest#testSetRealFormatNull, org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantUnsolvable, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonBadCounts, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#backward, org.apache.commons.math.analysis.solvers.NewtonSolverTest#testSinZero, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testSmallStep, org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnMatrix, org.apache.commons.math.linear.FieldMatrixImplTest#testToString, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testKepler, org.apache.commons.math.linear.BlockRealMatrixTest#testWalk, org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated, org.apache.commons.math.linear.BlockFieldMatrixTest#testOperateLarge, org.apache.commons.math.stat.descriptive.rank.MinTest#testEvaluation, org.apache.commons.math.optimization.general.MinpackTest#testMinpackBox3Dimensional, org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeImaginary, org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnMatrix, org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArgumentsCause, org.apache.commons.math.linear.BlockRealMatrixTest#testOperateLarge, org.apache.commons.math.geometry.Vector3DTest#testDistanceInf, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBigStep, org.apache.commons.math.linear.BlockFieldMatrixTest#testTranspose, org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiplyVector, org.apache.commons.math.fraction.BigFractionTest#testGoldenRatio, org.apache.commons.math.linear.ArrayRealVectorTest#testDataInOut, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEvaluation, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEvaluation, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMaxIterations, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnOnePoint, org.apache.commons.math.ode.sampling.StepNormalizerTest#testBoundaries, org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiply, org.apache.commons.math.geometry.Vector3DTest#testAngularSeparation, org.apache.commons.math.random.RandomAdaptorTest#testNextSecureInt, org.apache.commons.math.linear.BigMatrixImplTest#testInverse, org.apache.commons.math.linear.SparseRealMatrixTest#testToString, org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testBackward, org.apache.commons.math.util.DefaultTransformerTest#testTransformDouble, org.apache.commons.math.MathExceptionTest#testSerialization, org.apache.commons.math.util.MathUtilsTest#testCosh, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterInjection, org.apache.commons.math.optimization.linear.SimplexTableauTest#testTableauWithNoArtificialVars, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetSubMatrix, org.apache.commons.math.util.MathUtilsTest#testScalb, org.apache.commons.math.genetics.BinaryChromosomeTest#testRandomConstructor, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeZ, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquare, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeY, org.apache.commons.math.estimation.EstimatedParameterTest#testEstimate, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeX, org.apache.commons.math.optimization.general.MinpackTest#testMinpackPowellSingular, org.apache.commons.math.util.OpenIntToFieldTest#testContainsKey, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testDeprecated, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testUUpperTriangular, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testConsistency, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopy, org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_thirdRoot, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNan, org.apache.commons.math.linear.BigMatrixImplTest#testToString, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath272, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleNoDecimals, org.apache.commons.math.stat.inference.TTestTest#testOneSampleTTest, org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSeparator, org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testSerialization, org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeReal, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMinimizeMaximize, org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply, org.apache.commons.math.stat.descriptive.summary.ProductTest#testConsistency, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnStraightLine, org.apache.commons.math.complex.ComplexTest#testSinh, org.apache.commons.math.random.RandomAdaptorTest#testNextExponential, org.apache.commons.math.linear.LUSolverTest#testDeterminant, org.apache.commons.math.stat.StatUtilsTest#testArrayIndexConditions, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testNaN, org.apache.commons.math.estimation.WeightedMeasurementTest#testConstruction, org.apache.commons.math.linear.SparseFieldMatrixTest#testMath209, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testVariableSteps, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testToString, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testGetSummary, org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedConsistency, org.apache.commons.math.util.MathUtilsTest#testNormalizeArray, org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath288, org.apache.commons.math.linear.EigenDecompositionImplTest#testDiagonal, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath286, org.apache.commons.math.analysis.solvers.BrentSolverTest#testInitialGuess, org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnRealMatrix, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testDimensionCheck, org.apache.commons.math.fraction.BigFractionFormatTest#testFormat, org.apache.commons.math.util.MathUtilsTest#testSignByte, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFitting, org.apache.commons.math.ode.ContinuousOutputModelTest#testBoundaries, org.apache.commons.math.complex.ComplexFormatTest#testPaseNegativeInfinity, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNan, org.apache.commons.math.random.RandomAdaptorTest#testNextSecureLong, org.apache.commons.math.distribution.PascalDistributionTest#testCumulativeProbabilities, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSpecialValues, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConsistency, org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopy, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeInfinity, org.apache.commons.math.stat.StatUtilsTest#testN0andN1Conditions, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath293, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopySubMatrix, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseZeroX, org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#derivativesConsistency, org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.linear.FieldMatrixImplTest#testOperate, org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testConstructor, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testOperate, org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWith0ExpectedSize, org.apache.commons.math.special.ErfTest#testErf3291, org.apache.commons.math.complex.ComplexTest#testHashCode, org.apache.commons.math.linear.EigenDecompositionImplTest#testMath308, org.apache.commons.math.linear.SparseRealMatrixTest#testNorm, org.apache.commons.math.linear.ArrayRealVectorTest#testConstructors, org.apache.commons.math.linear.EigenSolverTest#testSolveDimensionErrors, org.apache.commons.math.complex.ComplexTest#testAddNaN, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testFrobeniusNorm, org.apache.commons.math.linear.SparseFieldMatrixTest#testPlusMinus, org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne2, org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimals, org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnMatrix, org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testDistance, org.apache.commons.math.linear.BlockRealMatrixTest#testTrace, org.apache.commons.math.linear.QRDecompositionImplTest#testRUpperTriangular, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowVector, org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne1, org.apache.commons.math.linear.BlockFieldMatrixTest#testCopySubMatrix, org.apache.commons.math.linear.BlockRealMatrixTest#testOperatePremultiplyLarge, org.apache.commons.math.complex.ComplexTest#testConjugateNaN, org.apache.commons.math.linear.FieldMatrixImplTest#testMath209, org.apache.commons.math.stat.inference.TTestTest#testSmallSamples, org.apache.commons.math.linear.RealMatrixImplTest#testSetSubMatrix, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreRows, org.apache.commons.math.linear.BigMatrixImplTest#testMath209, org.apache.commons.math.distribution.ChiSquareDistributionTest#testDensity, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTwoSets, org.apache.commons.math.complex.FrenchComplexFormatTest#testConstructorSingleFormat, org.apache.commons.math.linear.BlockFieldMatrixTest#testScalarAdd, org.apache.commons.math.complex.ComplexTest#testCos, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSuffix, org.apache.commons.math.special.BetaTest#testRegularizedBetaNanPositivePositive, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testMinStep, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuintic, org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#checklone, org.apache.commons.math.linear.BlockFieldMatrixTest#testCopyFunctions, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextIntExtremeValues, org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testSinMin, org.apache.commons.math.random.RandomDataTest#testConfig, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedVariance, org.apache.commons.math.complex.ComplexTest#testAsinInf, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testNorm, org.apache.commons.math.distribution.PoissonDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNISTExample, org.apache.commons.math.complex.ComplexTest#testAtanNaN, org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbability2, org.apache.commons.math.complex.ComplexTest#testAcosInf, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testKepler, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testInsufficientBandwidth, org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterEmpty, org.apache.commons.math.complex.ComplexTest#testDivideImaginary, org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuadraticFunction, org.apache.commons.math.linear.BlockFieldMatrixTest#testExamples, org.apache.commons.math.distribution.HypergeometricDistributionTest#testMoreLargeValues, org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedMean, org.apache.commons.math.complex.ComplexTest#testPow, org.apache.commons.math.linear.RealVectorFormatTest#testFormatObject, org.apache.commons.math.distribution.FDistributionTest#testDfAccessors, org.apache.commons.math.util.MathUtilsTest#testArrayEquals, org.apache.commons.math.stat.descriptive.moment.MeanTest#testEqualsAndHashCode, org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownDennis, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRow, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesMaximum, org.apache.commons.math.stat.correlation.CovarianceTest#testSwissFertility, org.apache.commons.math.random.RandomDataTest#testNextSecureInt, org.apache.commons.math.geometry.Vector3DTest#testOrthogonal, org.apache.commons.math.geometry.Vector3DTest#testDistance, org.apache.commons.math.distribution.WeibullDistributionTest#testCumulativeProbabilities, org.apache.commons.math.distribution.CauchyDistributionTest#testSetScale, org.apache.commons.math.stat.FrequencyTest#testEmptyTable, org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxIterations, org.apache.commons.math.linear.RealMatrixImplTest#testMultiply2, org.apache.commons.math.special.BetaTest#testLogBetaZeroPositive, org.apache.commons.math.fraction.BigFractionFormatTest#testFormatNegative, org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientLarge, org.apache.commons.math.random.RandomAdaptorTest#testNextIntExtremeValues, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testWindowSize, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesAverage, org.apache.commons.math.stat.descriptive.rank.MinTest#testCopyConsistency, org.apache.commons.math.complex.ComplexFormatTest#testConstructorSingleFormat, org.apache.commons.math.linear.LUDecompositionImplTest#testNonSquare, org.apache.commons.math.fraction.FractionFormatTest#testWholeFormat, org.apache.commons.math.distribution.PascalDistributionTest#testFloatingPointArguments, org.apache.commons.math.stat.StatUtilsTest#testVariance, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testNaNContracts, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNegative, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerialization, org.apache.commons.math.geometry.Vector3DTest#testConstructors, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testWeightedConsistency, org.apache.commons.math.util.MathUtilsTest#testIndicatorLong, org.apache.commons.math.stat.descriptive.rank.MaxTest#testNaNs, org.apache.commons.math.util.TransformerMapTest#testRemoveTransformer, org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimals, org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldMatrix, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testNaNContracts, org.apache.commons.math.linear.BlockRealMatrixTest#testSerial, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeX, org.apache.commons.math.linear.BiDiagonalTransformerTest#testUpperOrLower, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeY, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeZ, org.apache.commons.math.distribution.ExponentialDistributionTest#testIllegalArguments, org.apache.commons.math.random.MersenneTwisterTest#testDouble, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersSimple, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testStepSize, org.apache.commons.math.MaxIterationsExceededExceptionTest#testComplexConstructor, org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHeterscedastic, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testUnstableDerivative, org.apache.commons.math.stat.FrequencyTest#testPcts, org.apache.commons.math.geometry.Vector3DTest#testAngle, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testMomentSmallSamples, org.apache.commons.math.random.MersenneTwisterTest#testGaussian, org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction2, org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBrentSolverValid, org.apache.commons.math.fraction.FractionFormatTest#testLongFormat, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSerialization, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testStats, org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testProductAndGeometricMean, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextGaussian, org.apache.commons.math.linear.BigMatrixImplTest#testLUDecomposition, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerial, org.apache.commons.math.random.ValueServerTest#testProperties, org.apache.commons.math.linear.RealMatrixImplTest#testEqualsAndHashCode, org.apache.commons.math.geometry.Vector3DTest#testNorm1, org.apache.commons.math.complex.ComplexTest#testAtanInf, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowVector, org.apache.commons.math.special.ErfTest#testErf2807, org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testArrayIsReference, org.apache.commons.math.random.AbstractRandomGeneratorTest#testConfig, org.apache.commons.math.random.MersenneTwisterTest#testNexBoolean, org.apache.commons.math.linear.BigMatrixImplTest#testOperate, org.apache.commons.math.util.TransformerMapTest#testClasses, org.apache.commons.math.linear.SparseRealVectorTest#testMapFunctions, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testCovarianceConsistency, org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilities, org.apache.commons.math.complex.ComplexTest#testSqrt1zNaN, org.apache.commons.math.stat.correlation.CovarianceTest#testConsistency, org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.util.MathUtilsTest#testSignShort, org.apache.commons.math.stat.descriptive.summary.SumTest#testSerial, org.apache.commons.math.special.ErfTest#testErf1960, org.apache.commons.math.util.MathUtilsTest#testHash, org.apache.commons.math.linear.RealVectorFormatTest#testSimpleNoDecimals, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, org.apache.commons.math.fraction.FractionTest#testReciprocal, org.apache.commons.math.linear.BlockRealMatrixTest#testNorm, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEvaluation, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testMomentSmallSamples, org.apache.commons.math.linear.ArrayFieldVectorTest#testMisc, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testDimensions, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testIncrementation, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testWeightedConsistency, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testInconsistentEquations, org.apache.commons.math.fraction.BigFractionTest#testConstructor, org.apache.commons.math.complex.ComplexTest#testGetArgumentInf, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testStats, org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest#dimension2, org.apache.commons.math.stat.FrequencyTest#testIntegerValues, org.apache.commons.math.linear.SparseRealMatrixTest#testPlusMinus, org.apache.commons.math.linear.QRSolverTest#testSolveDimensionErrors, org.apache.commons.math.estimation.EstimatedParameterTest#testConstruction, org.apache.commons.math.genetics.BinaryMutationTest#testMutate, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.linear.BigMatrixImplTest#testGetRowMatrix, org.apache.commons.math.fraction.FractionTest#testIntValue, org.apache.commons.math.util.OpenIntToFieldTest#testRemoveAbsent, org.apache.commons.math.complex.ComplexTest#testAcosNaN, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerial, org.apache.commons.math.complex.ComplexTest#testAddInfinite, org.apache.commons.math.stat.descriptive.rank.MinTest#testSpecialValues, org.apache.commons.math.linear.SparseRealMatrixTest#testGetVectors, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testDimension, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testQRColumnsPermutation, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNonInversible, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testToString, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetSubMatrix, org.apache.commons.math.distribution.FDistributionTest#testLargeDegreesOfFreedom, org.apache.commons.math.random.MersenneTwisterTest#testNextInt, org.apache.commons.math.linear.FieldMatrixImplTest#testWalk, org.apache.commons.math.complex.ComplexTest#testLog, org.apache.commons.math.distribution.CauchyDistributionTest#testCumulativeProbabilities, org.apache.commons.math.complex.ComplexTest#testScalarMultiplyNaN, org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiplyVector, org.apache.commons.math.linear.MatrixUtilsTest#testCreateRealMatrix, org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.linear.BlockRealMatrixTest#testExamples, org.apache.commons.math.genetics.BinaryChromosomeTest#testIsSame, org.apache.commons.math.linear.RealVectorFormatTest#testParseNonDefaultSetting, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testEvaluation, org.apache.commons.math.fraction.FractionFieldTest#testOne, org.apache.commons.math.linear.BlockRealMatrixTest#testAddFail, org.apache.commons.math.estimation.MinpackTest#testMinpackKowalikOsborne, org.apache.commons.math.MathExceptionTest#testConstructorPatternArgumentsCause, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureLong, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTrivial, org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedSum, org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testNoReset, org.apache.commons.math.fraction.BigFractionTest#testBigDecimalValue, org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRootMatrix, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevBounds, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopy, org.apache.commons.math.util.MathUtilsTest#testMulAndCheckLong, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConstant, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniform, org.apache.commons.math.complex.ComplexFormatTest#testParsePositiveInfinity, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseIgnoredWhitespace, org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumn, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testRedundantEquations, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareIndependence, org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacityAndExpansionFactor, org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuadraticFunction, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMath209, org.apache.commons.math.linear.RealMatrixImplTest#testPremultiply, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testCopy, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNullEmpty, org.apache.commons.math.complex.ComplexTest#testEqualsSame, org.apache.commons.math.random.EmpiricalDistributionTest#testNext, org.apache.commons.math.util.MathUtilsTest#testRoundDouble, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnMatrix, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSerialization, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withWeights, org.apache.commons.math.DuplicateSampleAbscissaExceptionTest#testConstructor, org.apache.commons.math.complex.ComplexTest#testMultiplyNaNInf, org.apache.commons.math.linear.FieldMatrixImplTest#testPlusMinus, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNull, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinear, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopy, org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerial, org.apache.commons.math.complex.ComplexFormatTest#testGetRealFormat, org.apache.commons.math.random.RandomAdaptorTest#testNextPoissonConsistency, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testNullIntervalCheck, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testPercentile, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateSpecialValues, org.apache.commons.math.util.ResizableDoubleArrayTest#testGetValues, org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnMatrix, org.apache.commons.math.fraction.BigFractionFormatTest#testParseNegative, org.apache.commons.math.complex.ComplexFormatTest#testParseDifferentImaginaryChar, org.apache.commons.math.linear.CholeskySolverTest#testSolve, org.apache.commons.math.fraction.FractionTest#testToString, org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullURL, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonUnEqualCounts, org.apache.commons.math.random.RandomDataTest#testNextExponential, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290GEQ, org.apache.commons.math.linear.BlockRealMatrixTest#testFrobeniusNorm, org.apache.commons.math.fraction.BigFractionTest#testEpsilonLimitConstructor, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregationConsistency, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimals, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnVectorLarge, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testShuffledStatistics, org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientFail, org.apache.commons.math.util.MathUtilsTest#testRoundFloat, org.apache.commons.math.distribution.NormalDistributionTest#testSetStandardDeviation, org.apache.commons.math.stat.descriptive.summary.ProductTest#testMomentSmallSamples, org.apache.commons.math.complex.ComplexTest#testLogInf, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testShuffledStatistics, org.apache.commons.math.util.ResizableDoubleArrayTest#testSubstitute, org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testParameters, org.apache.commons.math.linear.RealMatrixImplTest#testPlusMinus, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregate, org.apache.commons.math.estimation.MinpackTest#testMinpackPowellSingular, org.apache.commons.math.complex.ComplexTest#testCoshNaN, org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testSinMin, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoisson, org.apache.commons.math.ode.FirstOrderConverterTest#testBigStep, org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiply, org.apache.commons.math.linear.LUSolverTest#testSolve, org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testCentroid, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEqualsAndHashCode, org.apache.commons.math.linear.InvalidMatrixExceptionTest#testConstructorMessage, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoissonConsistency, org.apache.commons.math.distribution.NormalDistributionTest#testIllegalArguments, org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBisectionSolverValid, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testIllConditioned, org.apache.commons.math.transform.FastCosineTransformerTest#testParameters, org.apache.commons.math.linear.QRDecompositionImplTest#testAEqualQR, org.apache.commons.math.fraction.BigFractionFormatTest#testNumeratorFormat, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testEvents, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnMatrixLarge, org.apache.commons.math.complex.FrenchComplexFormatTest#testSetRealFormatNull, org.apache.commons.math.special.GammaTest#testLogGammaNegative, org.apache.commons.math.transform.FastFourierTransformerTest#testAdHocData, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withoutWeights, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeAll, org.apache.commons.math.linear.BigMatrixImplTest#testCopyFunctions, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLegendrePolynomials, org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiplyVector, org.apache.commons.math.fraction.BigFractionTest#testReciprocal, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowVectorLarge, org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilityExtremes, org.apache.commons.math.random.RandomAdaptorTest#testNextSecureHex, org.apache.commons.math.random.UniformRandomGeneratorTest#testMeanAndStandardDeviation, org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testMismatch, org.apache.commons.math.linear.SparseRealVectorTest#testBasicFunctions, org.apache.commons.math.distribution.PascalDistributionTest#testIllegalArguments, org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testParameters, org.apache.commons.math.linear.RealVectorFormatTest#testPositiveInfinity, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLLowerTriangular, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testCopy, org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#serialization, org.apache.commons.math.estimation.EstimatedParameterTest#testBound, org.apache.commons.math.transform.FastHadamardTransformerTest#test8Points, org.apache.commons.math.stat.ranking.NaturalRankingTest#testDefault, org.apache.commons.math.util.ResizableDoubleArrayTest#testConstructors, org.apache.commons.math.transform.FastSineTransformerTest#testAdHocData, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddNullYSampleData, org.apache.commons.math.linear.BigMatrixImplTest#testGetVectors, org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAbsentOnExisting, org.apache.commons.math.complex.ComplexFormatTest#testPositiveInfinity, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testControlParameters, org.apache.commons.math.genetics.TournamentSelectionTest#testSelect, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testPopulation, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregation, org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilities, org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowMatrix, org.apache.commons.math.distribution.TDistributionTest#testIllegalArguments, org.apache.commons.math.complex.FrenchComplexFormatTest#testForgottenImaginaryCharacter, org.apache.commons.math.fraction.FractionFormatTest#testFormat, org.apache.commons.math.analysis.solvers.BrentSolverTest#testRootEndpoints, org.apache.commons.math.optimization.general.MinpackTest#testMinpackWatson, org.apache.commons.math.fraction.BigFractionTest#testDoubleConstructor, org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryFormatNull, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#polynomial, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNoDependency, org.apache.commons.math.optimization.linear.SimplexSolverTest#testModelWithNoArtificialVars, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopyFunctions, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testSingular, org.apache.commons.math.linear.FieldMatrixImplTest#testCopySubMatrix, org.apache.commons.math.complex.ComplexTest#testEqualsImaginaryDifference, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testEqualsAndHashCode, org.apache.commons.math.optimization.general.MinpackTest#testMinpackFreudensteinRoth, org.apache.commons.math.fraction.FractionTest#testDivide, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveSingle, org.apache.commons.math.complex.ComplexTest#testAbs, org.apache.commons.math.linear.ArrayRealVectorTest#testMapFunctions, org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.random.RandomAdaptorTest#testAdaptor, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNonSquare, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testCircleFitting, org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares3, org.apache.commons.math.distribution.ExponentialDistributionTest#testMeanAccessors, org.apache.commons.math.complex.ComplexTest#testGetArgument, org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares1, org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares2, org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnMatrix, org.apache.commons.math.random.RandomDataTest#testNextInt, org.apache.commons.math.stat.inference.TestUtilsTest#testSmallSamples, org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullDoubleArray, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testDecreasingSteps, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testToString, org.apache.commons.math.linear.BlockRealMatrixTest#testMath209, org.apache.commons.math.estimation.MinpackTest#testMinpackBox3Dimensional, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowMatrix, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply, org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilityExtremes, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSerialization, org.apache.commons.math.complex.ComplexTest#testDivideNaNInf, org.apache.commons.math.linear.FieldMatrixImplTest#testExamples, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRow, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSmallStep, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithoutSplit, org.apache.commons.math.distribution.ZipfDistributionTest#testIllegalArguments, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetSubMatrix, org.apache.commons.math.complex.ComplexTest#testSqrtNaN, org.apache.commons.math.distribution.NormalDistributionTest#testGetStandardDeviation, org.apache.commons.math.linear.MatrixIndexExceptionTest#testConstructorMessage, org.apache.commons.math.distribution.HypergeometricDistributionTest#testDensities, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDecreasingSteps, org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testParameters, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareIndependence, org.apache.commons.math.fraction.BigFractionTest#testConstructorDouble, org.apache.commons.math.stat.descriptive.rank.MaxTest#testConsistency, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsRemovedTiesSequential, org.apache.commons.math.fraction.FractionFormatTest#testNumeratorFormat, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues1, org.apache.commons.math.util.OpenIntToFieldTest#testPutAbsentOnExisting, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues2, org.apache.commons.math.linear.BigMatrixImplTest#testDeterminant, org.apache.commons.math.complex.ComplexTest#testEqualsClass, org.apache.commons.math.fraction.BigFractionTest#testEqualsAndHashCode, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollision2, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testStepSize, org.apache.commons.math.complex.ComplexTest#testCoshInf, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreColumns, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiple, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetAbsoluteAccuracy, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testSetterInjection, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSingleton, org.apache.commons.math.fraction.BigFractionFormatTest#testLongFormat, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#notEnoughData, org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilityAgaintStackOverflow, org.apache.commons.math.stat.inference.TestUtilsTest#testOneWayAnovaUtils, org.apache.commons.math.optimization.direct.NelderMeadTest#testPowell, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testIllConditioned, org.apache.commons.math.geometry.Vector3DFormatTest#testParseZeroX, org.apache.commons.math.util.MathUtilsTest#testL2DistanceDouble, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testLongly, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testHighPercentile, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testMinStep, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveSin, org.apache.commons.math.util.MathUtilsTest#testNextAfter, org.apache.commons.math.linear.LUDecompositionImplTest#testSingular, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testGetValues, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonEqualCounts, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveFromEmpty, org.apache.commons.math.geometry.Vector3DTest#testCoordinates, org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollisions, org.apache.commons.math.complex.ComplexTest#testAsinNaN, org.apache.commons.math.util.MathUtilsTest#testIndicatorDouble, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTwoSets, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLongExtremeValues, org.apache.commons.math.random.RandomDataTest#testNextSecureLong, org.apache.commons.math.linear.SparseFieldMatrixTest#testScalarAdd, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateResiduals, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testOneSet, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDecreasingSteps, org.apache.commons.math.stat.descriptive.summary.SumTest#testMomentSmallSamples, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBackward, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testNaN, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.linear.MatrixUtilsTest#testFractionConverter, org.apache.commons.math.util.BigRealFieldTest#testSerial, org.apache.commons.math.random.RandomAdaptorTest#testNextLong, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testWeightedConsistency, org.apache.commons.math.stat.descriptive.rank.MinTest#testEqualsAndHashCode, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPAEqualLU, org.apache.commons.math.distribution.PoissonDistributionTest#testMean, org.apache.commons.math.distribution.PoissonDistributionTest#testIllegalArguments, org.apache.commons.math.stat.descriptive.rank.MedianTest#testCopy, org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.analysis.solvers.BrentSolverTest#testSinZero, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNonInversible, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testProductAndGeometricMean, org.apache.commons.math.util.ResizableDoubleArrayTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexTest#testAdd, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareLargeTestStatistic, org.apache.commons.math.special.GammaTest#testRegularizedGammaNegativePositive, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBigStep, org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#checkClone, org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuinticFunction, org.apache.commons.math.complex.ComplexTest#testSqrtInf, org.apache.commons.math.distribution.NormalDistributionTest#testConsistency, org.apache.commons.math.complex.ComplexTest#testAbsInfinite, org.apache.commons.math.complex.ComplexFieldTest#testZero, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataWithSampleSizeMismatch, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#exceedMaxEvaluations, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testStdErrorConsistency, org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproper, org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWithExpectedSize, org.apache.commons.math.random.MersenneTwisterTest#testFloat, org.apache.commons.math.stat.descriptive.rank.MaxTest#testEvaluation, org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_realPartZero, org.apache.commons.math.complex.ComplexTest#testEqualsNaN, org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryZero, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopyConsistency, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEvaluation, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextFloat, org.apache.commons.math.stat.inference.TTestTest#testPaired, org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testImpossibleSerialization, org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroImaginary, org.apache.commons.math.linear.QRDecompositionImplTest#testDimensions, org.apache.commons.math.distribution.GammaDistributionTest#testParameterAccessors, org.apache.commons.math.random.ValueServerTest#testNextDigestFail, org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperInvalidMinus, org.apache.commons.math.complex.ComplexFormatTest#testNegativeBoth, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testMomentSmallSamples, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEqualsAndHashCode, org.apache.commons.math.linear.SparseRealVectorTest#testDataInOut, org.apache.commons.math.random.RandomAdaptorTest#testNextUniformExclusiveEndpoints, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBackward, org.apache.commons.math.complex.FrenchComplexFormatTest#testParsePositiveInfinity, org.apache.commons.math.stat.StatUtilsTest#testMax, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopyConsistency, org.apache.commons.math.optimization.linear.SimplexSolverTest#testRestrictVariablesToNonNegative, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerialization, org.apache.commons.math.stat.correlation.CovarianceTest#testInsufficientData, org.apache.commons.math.optimization.linear.SimplexTableauTest#testInitialization, org.apache.commons.math.linear.EigenSolverTest#testNonInvertible, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveXY, org.apache.commons.math.linear.RealMatrixImplTest#testGetRowMatrix, org.apache.commons.math.ode.ContinuousOutputModelTest#testModelsMerging, org.apache.commons.math.stat.FrequencyTest#testToString, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testEqualsAndHashCode, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNonDefaultSetting, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testStats, org.apache.commons.math.complex.ComplexTest#testPowInf, org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testValues, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#noReset, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testRedundantEquations, org.apache.commons.math.stat.descriptive.summary.ProductTest#testEvaluation, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth1, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth2, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.transform.FastCosineTransformerTest#testAdHocData, org.apache.commons.math.distribution.ChiSquareDistributionTest#testIllegalArguments, org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterNull, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testIncrementation, org.apache.commons.math.complex.ComplexTest#testTanh, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testConsistency, org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerial, org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerialization, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testIncrementation, org.apache.commons.math.linear.RealMatrixImplTest#testGetColumn, org.apache.commons.math.linear.RealMatrixImplTest#testMath209, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#serialization, org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMax, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testN0andN1Conditions, org.apache.commons.math.util.OpenIntToFieldTest#testRemove2, org.apache.commons.math.complex.ComplexTest#testSqrtRealNegative, org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArguments, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testUOrthogonal, org.apache.commons.math.linear.BiDiagonalTransformerTest#testBBiDiagonal, org.apache.commons.math.linear.BigMatrixImplTest#testGetColumnMatrix, org.apache.commons.math.complex.ComplexTest#testpowNull, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBigStep, org.apache.commons.math.stat.descriptive.summary.SumTest#testSpecialValues, org.apache.commons.math.linear.BlockRealMatrixTest#testScalarAdd, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSerialization, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEqualsAndHashCode, org.apache.commons.math.fraction.FractionTest#testConstructor, org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetMatrixLarge, org.apache.commons.math.linear.EigenDecompositionImplTest#testVOrthogonal, org.apache.commons.math.distribution.PoissonDistributionTest#testDegenerateInverseCumulativeProbability, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#polynomial, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSinZero, org.apache.commons.math.fraction.FractionTest#testGetReducedFraction, org.apache.commons.math.distribution.FDistributionTest#testConsistency, org.apache.commons.math.analysis.solvers.BrentSolverTest#testDeprecated, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues2, org.apache.commons.math.fraction.FractionFormatTest#testParseInteger, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testStaticFormatRealVectorImpl, org.apache.commons.math.estimation.MinpackTest#testMinpackMeyer, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues1, org.apache.commons.math.random.RandomAdaptorTest#testNextGaussian, org.apache.commons.math.util.BigRealTest#testDoubleValue, org.apache.commons.math.linear.FieldMatrixImplTest#testSerial, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNanPositive, org.apache.commons.math.linear.FieldMatrixImplTest#testDimensions, org.apache.commons.math.linear.RealMatrixImplTest#testGetSubMatrix, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetMaximalIterationCount, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterInjection, org.apache.commons.math.linear.TriDiagonalTransformerTest#testTTriDiagonal, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testRedundantEquations, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracyNull, org.apache.commons.math.complex.ComplexTest#testConstructorNaN, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersSimple, org.apache.commons.math.stat.descriptive.summary.SumTest#testConsistency, org.apache.commons.math.fraction.BigFractionFieldTest#testZero, org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigIdentityMatrix, org.apache.commons.math.linear.SparseRealVectorTest#testPredicates, org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testLinearFunction, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositivePositive, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testStepSize, org.apache.commons.math.linear.SparseFieldMatrixTest#testOperate, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopyConsistency, org.apache.commons.math.linear.BlockRealMatrixTest#testSetRow, org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest#testMeanAndCorrelation, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testConcurrentModification, org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopyConsistency, org.apache.commons.math.linear.SparseFieldMatrixTest#testTranspose, org.apache.commons.math.optimization.general.MinpackTest#testMinpackRosenbrok, org.apache.commons.math.util.MathUtilsTest#testSignFloat, org.apache.commons.math.util.MathUtilsTest#testSignDouble, org.apache.commons.math.fraction.FractionFormatTest#testParseInvalid, org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowVector, org.apache.commons.math.geometry.RotationTest#testVectorTwoPairs, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetVectors, org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#serialization, org.apache.commons.math.distribution.NormalDistributionTest#testExtremeValues, org.apache.commons.math.linear.LUSolverTest#testThreshold, org.apache.commons.math.geometry.RotationOrderTest#testName, org.apache.commons.math.util.MathUtilsTest#testIndicatorShort, org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanCumulativeProbability, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTrivial, org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollisions, org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeInfinity, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testMinStep, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testConsistency, org.apache.commons.math.complex.ComplexFormatTest#testStaticFormatComplex, org.apache.commons.math.linear.TriDiagonalTransformerTest#testAEqualQTQt, org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerialization, org.apache.commons.math.util.MathUtilsTest#testSinh, org.apache.commons.math.complex.FrenchComplexFormatTest#testGetImaginaryFormat, org.apache.commons.math.distribution.GammaDistributionTest#testIllegalArguments, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testKepler, org.apache.commons.math.linear.BlockFieldMatrixTest#testEqualsAndHashCode, org.apache.commons.math.linear.SparseRealMatrixTest#testAddFail, org.apache.commons.math.linear.BlockRealMatrixTest#testSetSubMatrix, org.apache.commons.math.complex.ComplexTest#testTanNaN, org.apache.commons.math.genetics.RandomKeyTest#testInducedPermutation, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTrace, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnVectorLarge, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSeparator, org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaPValue, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#dimensionCheck, org.apache.commons.math.ConvergenceExceptionTest#testConstructorCause, org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnMatrix, org.apache.commons.math.estimation.MinpackTest#testMinpackRosenbrok, org.apache.commons.math.fraction.BigFractionTest#testAdd, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testNaNContracts, org.apache.commons.math.random.RandomDataTest#testNextSample, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroReal, org.apache.commons.math.linear.RealVectorFormatTest#testParseIgnoredWhitespace, org.apache.commons.math.distribution.PoissonDistributionTest#testFloatingPointArguments, org.apache.commons.math.linear.EigenDecompositionImplTest#testZeroDivide, org.apache.commons.math.linear.CholeskySolverTest#testSolveDimensionErrors, org.apache.commons.math.linear.EigenDecompositionImplTest#testBigMatrix, org.apache.commons.math.linear.QRSolverTest#testRank, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddXSampleData, org.apache.commons.math.linear.EigenDecompositionImplTest#testAEqualVDVt, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSubMatrix, org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.geometry.RotationTest#testSingularities, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerialization, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullCovarianceData, org.apache.commons.math.fraction.BigFractionFormatTest#testDoubleFormat, org.apache.commons.math.util.MathUtilsTest#testFactorialFail, org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply2, org.apache.commons.math.linear.TriDiagonalTransformerTest#testQTOrthogonal, org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSimplistic, org.apache.commons.math.fraction.BigFractionTest#testAbs, org.apache.commons.math.linear.SparseFieldMatrixTest#testAdd, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testParameters, org.apache.commons.math.linear.RealMatrixImplTest#testCopySubMatrix, org.apache.commons.math.distribution.WeibullDistributionTest#testSetAlpha, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLaguerreDifferentials, org.apache.commons.math.complex.ComplexFieldTest#testOne, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, org.apache.commons.math.linear.RealMatrixImplTest#testSetRowVector, org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedConsistency, org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testTrivial, org.apache.commons.math.linear.BigMatrixImplTest#testTrace, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSuffix, org.apache.commons.math.linear.FieldMatrixImplTest#testGetEntry, org.apache.commons.math.linear.SparseRealMatrixTest#testExamples, org.apache.commons.math.distribution.NormalDistributionTest#testDensity, org.apache.commons.math.geometry.Vector3DTest#testNormInf, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSerial, org.apache.commons.math.random.MersenneTwisterTest#testMakotoNishimura, org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantSolvable, org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowMatrix, org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply, org.apache.commons.math.complex.ComplexTest#testLogNaN, org.apache.commons.math.distribution.ZipfDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative, org.apache.commons.math.transform.FastHadamardTransformerTest#testNoIntInverse, org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterEmpty, org.apache.commons.math.random.EmpiricalDistributionTest#testBinIndexOverflow, org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor, org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaFValue, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testSwissFertility, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBackward, org.apache.commons.math.util.MathUtilsTest#testFactorial, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterIllegalState, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testStats, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLegendreDifferentials, org.apache.commons.math.linear.SparseFieldVectorTest#testMisc, org.apache.commons.math.linear.BlockRealMatrixTest#testGetEntry, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopyConsistency, org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentSizes, org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMin, org.apache.commons.math.random.RandomDataTest#testNextUniformExclusiveEndpoints, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.optimization.general.MinpackTest#testMinpackJennrichSampson, org.apache.commons.math.distribution.ChiSquareDistributionTest#testSampling, org.apache.commons.math.distribution.PascalDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateTwoSegment, org.apache.commons.math.linear.RealMatrixImplTest#testSetColumn, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedConsistency, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testBoundParameters, org.apache.commons.math.linear.RealMatrixImplTest#testGetVectors, org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTwoSets, org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilitySpecial, org.apache.commons.math.estimation.MinpackTest#testMinpackFreudensteinRoth, org.apache.commons.math.MathExceptionTest#testConstructor, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEqualsAndHashCode, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateResiduals, org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.random.RandomDataTest#testNextLong, org.apache.commons.math.util.MathUtilsTest#testIndicatorByte, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testAEqualLLT, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testIncrementation, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testKepler, org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollision2, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testDimensionCheck, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testDeprecated, org.apache.commons.math.geometry.RotationTest#testComposeInverse, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testMinStep, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWithExpectedSize, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNan, org.apache.commons.math.estimation.MinpackTest#testMinpackBrownDennis, org.apache.commons.math.linear.LUSolverTest#testSingular, org.apache.commons.math.stat.descriptive.InteractionTest#testInteraction, org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testBasicStats, org.apache.commons.math.stat.descriptive.summary.SumTest#testEvaluation, org.apache.commons.math.util.MathUtilsTest#testAddAndCheckLong, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopy, org.apache.commons.math.analysis.solvers.MullerSolverTest#testParameters, org.apache.commons.math.random.RandomDataTest#testNextSecureHex, org.apache.commons.math.random.RandomAdaptorTest#testNextHex, org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatNumber, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testToString, org.apache.commons.math.MathConfigurationExceptionTest#testConstructor, org.apache.commons.math.util.BigRealFieldTest#testZero, org.apache.commons.math.linear.QRDecompositionImplTest#testMatricesValues, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.rank.MaxTest#testWeightedConsistency, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeBoth, org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply2, org.apache.commons.math.fraction.BigFractionTest#testMultiply, org.apache.commons.math.util.ResizableDoubleArrayTest#testDiscard, org.apache.commons.math.util.ResizableDoubleArrayTest#testAdd1000, org.apache.commons.math.distribution.TDistributionTest#testSmallDf, org.apache.commons.math.distribution.HypergeometricDistributionTest#testFloatingPointArguments, org.apache.commons.math.linear.RealMatrixImplTest#testWalk, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniformExclusiveEndpoints, org.apache.commons.math.special.GammaTest#testRegularizedGammaZeroPositive, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testWeightedConsistency, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSkewAndKurtosis, org.apache.commons.math.MathExceptionTest#testConstructorPatternArguments, org.apache.commons.math.util.TransformerMapTest#testSerial, org.apache.commons.math.linear.RealMatrixImplTest#testCopyFunctions, org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnFieldMatrix, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.fraction.FractionTest#testIntegerOverflow, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testConsistency, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testPopulation, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers, org.apache.commons.math.distribution.BinomialDistributionTest#testFloatingPointArguments, org.apache.commons.math.linear.SparseRealMatrixTest#testDimensions, org.apache.commons.math.complex.ComplexTest#testSinInf, org.apache.commons.math.special.GammaTest#testRegularizedGammaNanPositive, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParsePositiveInfinity, org.apache.commons.math.linear.RealVectorFormatTest#testForgottenPrefix, org.apache.commons.math.complex.ComplexFormatTest#testNegativeReal, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testFunctionEvaluationExceptions, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketEndpointRoot, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNoDependency, org.apache.commons.math.complex.ComplexFormatTest#testParseNan, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerialization, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testPositiveInfinity, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWith0ExpectedSize, org.apache.commons.math.stat.descriptive.rank.MedianTest#testEvaluation, org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArgumentsCause, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentEquations, org.apache.commons.math.util.TransformerMapTest#testContainsTransformer, org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues5, org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues3, org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestPositive, org.apache.commons.math.linear.SparseRealMatrixTest#testOperate, org.apache.commons.math.linear.FieldMatrixImplTest#testGetSubMatrix, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testControlParameters, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeInfinity, org.apache.commons.math.complex.ComplexTest#testAsin, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeInfinity, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowVectorLarge, org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalidDenominator, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, org.apache.commons.math.util.ResizableDoubleArrayTest#testSetElementArbitraryExpansion, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testLinear, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testWeightedConsistency, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testHat, org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_NAN_Inf, org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveZero, org.apache.commons.math.linear.FieldMatrixImplTest#testTranspose, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsAndInfs, org.apache.commons.math.geometry.RotationTest#testAxisAngle, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetRelativeAccuracy, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstHermitePolynomials, org.apache.commons.math.stat.inference.TTestFactoryTest#testPaired, org.apache.commons.math.geometry.RotationTest#testRevert, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerial, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFitting, org.apache.commons.math.optimization.linear.SimplexSolverTest#testLargeModel, org.apache.commons.math.geometry.Vector3DTest#testVectorialProducts, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerial, org.apache.commons.math.genetics.OnePointCrossoverTest#testCrossover, org.apache.commons.math.util.OpenIntToFieldTest#testRemove, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMath283, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowMatrixLarge, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#exceedMaxEvaluations, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing1, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testConditionNumber, org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testParameters, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing2, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testStaticFormatVector3D, org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureInt, org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnVector, org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations#test, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testRedundantEquations, org.apache.commons.math.linear.LUSolverTest#testSolveSingularityErrors, org.apache.commons.math.analysis.solvers.NewtonSolverTest#testDeprecated, org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testLinearFunction, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonBadCounts, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testPercentileSetter, org.apache.commons.math.util.MathUtilsTest#testCoshNaN, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseDifferentImaginaryChar, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testPositiveInfinity, org.apache.commons.math.complex.ComplexTest#testPowNaNExponent, org.apache.commons.math.stat.StatUtilsTest#testSumLog, org.apache.commons.math.complex.ComplexFormatTest#testDifferentImaginaryChar, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testBackward, org.apache.commons.math.linear.BlockFieldMatrixTest#testMath209, org.apache.commons.math.transform.FastSineTransformerTest#testParameters, org.apache.commons.math.util.DefaultTransformerTest#testTransformNull, org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testNoOptimum, org.apache.commons.math.linear.BigMatrixImplTest#testAdd, org.apache.commons.math.complex.ComplexTest#testPowZero, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testOneSet, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsFixedTiesRandom, org.apache.commons.math.fraction.BigFractionFormatTest#testParseProper, org.apache.commons.math.optimization.linear.SimplexSolverTest#testSingleVariableAndConstraint, org.apache.commons.math.geometry.Vector3DTest#testDistance1, org.apache.commons.math.linear.RealMatrixImplTest#testFrobeniusNorm, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNegativePositive, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareZeroCount, org.apache.commons.math.linear.RealMatrixImplTest#testPremultiplyVector, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationAtBounds, org.apache.commons.math.stat.descriptive.rank.MinTest#testCopy, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeY, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeZ, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNan, org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSerial, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeX, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromEmpty, org.apache.commons.math.optimization.general.MinpackTest#testMinpackMeyer, org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleTTest, org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimals, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNonInversible, org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.fraction.FractionTest#testFloatValue, org.apache.commons.math.complex.ComplexTest#testDivide, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetAbsent, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testOneSet, org.apache.commons.math.random.MersenneTwisterTest#testNextIntN, org.apache.commons.math.complex.ComplexTest#testSubtract, org.apache.commons.math.linear.LUDecompositionImplTest#testPPermutation, org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoFailures, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRow, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testKepler, org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testUnsorted, org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest#testCircleFitting, org.apache.commons.math.fraction.FractionTest#testMultiply, org.apache.commons.math.estimation.WeightedMeasurementTest#testIgnored, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopyConsistency, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiply, org.apache.commons.math.fraction.BigFractionTest#testFloatValue, org.apache.commons.math.distribution.FDistributionTest#testSmallDegreesOfFreedom, org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testExpm1Function, org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopyConsistency, org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function2, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimals, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testIncreasingTolerance, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testMinStep, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testKepler, org.apache.commons.math.complex.ComplexTest#testAtan, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testIncrementation, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuadraticFunction, org.apache.commons.math.distribution.TDistributionTest#testDfAccessors, org.apache.commons.math.distribution.CauchyDistributionTest#testConsistency, org.apache.commons.math.special.BetaTest#testLogBetaPositivePositive, org.apache.commons.math.util.OpenIntToFieldTest#testPutOnExisting, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testProductAndGeometricMean, org.apache.commons.math.estimation.MinpackTest#testMinpackBard, org.apache.commons.math.random.MersenneTwisterTest#testNextLong, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLTTransposed, org.apache.commons.math.linear.TriDiagonalTransformerTest#testNoAccessBelowDiagonal, org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRank, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testAEqualUSVt, org.apache.commons.math.stat.descriptive.moment.MeanTest#testConsistency, org.apache.commons.math.stat.descriptive.rank.MinTest#testSerial, org.apache.commons.math.transform.FastFourierTransformerTest#test2DData, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateThreeSegment, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextInt, org.apache.commons.math.linear.SparseRealMatrixTest#testEqualsAndHashCode, org.apache.commons.math.linear.RealMatrixImplTest#testSerial, org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testSkewAndKurtosis, org.apache.commons.math.stat.StatUtilsTest#testMean, org.apache.commons.math.linear.SingularValueSolverTest#testConditionNumber, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopy, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFittingBadInit, org.apache.commons.math.fraction.FractionFormatTest#testParseNegative, org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerial, org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiplyVector, org.apache.commons.math.util.ResizableDoubleArrayTest#testMutators, org.apache.commons.math.linear.SparseFieldMatrixTest#testEqualsAndHashCode, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRow, org.apache.commons.math.util.ContinuedFractionTest#testGoldenRatio, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testEvents, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testParameters, org.apache.commons.math.stat.StatUtilsTest#testDifferenceStats, org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testInitialGuess, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testSmallStep, org.apache.commons.math.complex.ComplexTest#testSin, org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateFullSample, org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHomoscedastic, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMath199, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextExponential, org.apache.commons.math.linear.RealMatrixImplTest#testExamples, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerialization, org.apache.commons.math.complex.ComplexTest#testExpNaN, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testSmallStep, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowMatrix, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetFunctionValueAccuracy, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testAddition, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerial, org.apache.commons.math.fraction.BigFractionTest#testIntValue, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHighDegreeLegendre, org.apache.commons.math.optimization.fitting.HarmonicFitterTest#test1PercentError, org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedProduct, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEqualsAndHashCode, org.apache.commons.math.estimation.MinpackTest#testMinpackJennrichSampson, org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowVector, org.apache.commons.math.util.BigRealTest#testBigDecimalValue, org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleNoDecimals, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#serialization, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testQRColumnsPermutation, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testMomentSmallSamples, org.apache.commons.math.linear.EigenSolverTest#testInvertible, org.apache.commons.math.linear.BlockRealMatrixTest#testTranspose, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNoDenseOutput, org.apache.commons.math.distribution.BinomialDistributionTest#testIllegalArguments, org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullFile, org.apache.commons.math.util.MathUtilsTest#testPow, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnVector, org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopyConsistency, org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testN0andN1Conditions, org.apache.commons.math.distribution.ChiSquareDistributionTest#testCumulativeProbabilities, org.apache.commons.math.distribution.HypergeometricDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testSinFunction, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenPrefix, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testRemoval, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testScalarAdd, org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHomoscedastic, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNoDependency, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEvaluation, org.apache.commons.math.distribution.ExponentialDistributionTest#testDensity, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnMatrixLarge, org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexIllegalModulus, org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterNull, org.apache.commons.math.linear.RealVectorFormatTest#testParseNoComponents, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnVector, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testInsufficientData, org.apache.commons.math.estimation.MinpackTest#testMinpackWatson, org.apache.commons.math.linear.SparseRealMatrixTest#testCopyFunctions, org.apache.commons.math.geometry.RotationTest#testIdentity, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testLongly, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testColumnsPermutation, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testDimensions, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArguments, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopy, org.apache.commons.math.random.ValueServerTest#testNextDigest, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArgumentsCause, org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFine, org.apache.commons.math.random.RandomDataTest#testNextGaussian, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testIterator, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuadratic, org.apache.commons.math.distribution.GammaDistributionTest#testProbabilities, org.apache.commons.math.linear.RealMatrixImplTest#testNorm, org.apache.commons.math.stat.inference.TestUtilsTest#testPaired, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTrivial, org.apache.commons.math.MathExceptionTest#testPrintStackTrace, org.apache.commons.math.util.OpenIntToFieldTest#testConcurrentModification, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperNegative, org.apache.commons.math.complex.ComplexFormatTest#testNan, org.apache.commons.math.random.RandomDataTest#testNextPermutation, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenPrefix, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testEmptyData, org.apache.commons.math.linear.BlockFieldMatrixTest#testWalk, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testQuinticZero, org.apache.commons.math.complex.ComplexTest#testEqualsRealDifference, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultipleToEmpty, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressandVariance, org.apache.commons.math.util.MathUtilsTest#testAddAndCheck, org.apache.commons.math.special.ErfTest#testErf2576, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullYSampleData, org.apache.commons.math.stat.descriptive.summary.ProductTest#testIncrementation, org.apache.commons.math.linear.BigMatrixImplTest#testSetSubMatrix, org.apache.commons.math.geometry.Vector3DFormatTest#testNonDefaultSetting, org.apache.commons.math.distribution.CauchyDistributionTest#testMedian, org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnVector, org.apache.commons.math.linear.BigMatrixImplTest#testScalarAdd, org.apache.commons.math.util.MathUtilsTest#testCompareTo, org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply2, org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#serialization, org.apache.commons.math.random.RandomAdaptorTest#testNextLongExtremeValues, org.apache.commons.math.util.MathUtilsTest#testArrayHash, org.apache.commons.math.distribution.BinomialDistributionTest#testCumulativeProbabilities, org.apache.commons.math.distribution.WeibullDistributionTest#testBeta, org.apache.commons.math.util.MathUtilsTest#testLcm, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#dimensionCheck, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBackward, org.apache.commons.math.util.MathUtilsTest#testIndicatorFloat, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testNaN, org.apache.commons.math.linear.BlockRealMatrixTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testWeightedConsistency, org.apache.commons.math.random.EmpiricalDistributionTest#testLoad, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveZero, org.apache.commons.math.linear.SparseFieldMatrixTest#testExamples, org.apache.commons.math.complex.FrenchComplexFormatTest#testDifferentImaginaryChar, org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroReal, org.apache.commons.math.complex.ComplexTest#testTanInf, org.apache.commons.math.complex.ComplexFormatTest#testForgottenImaginaryCharacter, org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSuffix, org.apache.commons.math.complex.ComplexTest#testSerial, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetVectors, org.apache.commons.math.ode.FirstOrderConverterTest#testDoubleDimension, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexTest#testTanhInf, org.apache.commons.math.stat.FrequencyTest#testCounts, org.apache.commons.math.linear.SparseFieldVectorTest#testPredicates, org.apache.commons.math.linear.BigMatrixImplTest#testSolve, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParameters, org.apache.commons.math.geometry.Vector3DFormatTest#testConstructorSingleFormat, org.apache.commons.math.util.ResizableDoubleArrayTest#testSetNumberOfElements, org.apache.commons.math.optimization.general.MinpackTest#testMinpackKowalikOsborne, org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvectors, org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanInverseCumulativeProbability, org.apache.commons.math.linear.SparseRealMatrixTest#testAdd, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConsistency, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testMomentSmallSamples, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnMatrix, org.apache.commons.math.fraction.BigFractionFormatTest#testParse, org.apache.commons.math.fraction.BigFractionTest#testCompareTo, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopy, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerialization, org.apache.commons.math.complex.ComplexTest#testTanhNaN, org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testUnstableDerivative, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEvaluation, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testN0andN1Conditions, org.apache.commons.math.util.MathUtilsTest#testSubAndCheckErrorMessage, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopy, org.apache.commons.math.fraction.FractionTest#testAbs, org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#derivativesConsistency, org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testMinEndpoints, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEvaluation, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testIncrementation, org.apache.commons.math.stat.descriptive.rank.MinTest#testSerialization, org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative, org.apache.commons.math.util.MathUtilsTest#testEquals, org.apache.commons.math.random.EmpiricalDistributionTest#testNexFail, org.apache.commons.math.complex.ComplexFormatTest#testFormatNumber, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testHadamard, org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDecreasingSteps, org.apache.commons.math.stat.descriptive.moment.MeanTest#testSmallSamples, org.apache.commons.math.util.DefaultTransformerTest#testTransformBigDecimal, org.apache.commons.math.linear.BigMatrixImplTest#testDimensions, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterIllegalState, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testColumnsPermutation, org.apache.commons.math.optimization.direct.NelderMeadTest#testFunctionEvaluationExceptions, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumn, org.apache.commons.math.complex.FrenchComplexFormatTest#testGetRealFormat, org.apache.commons.math.complex.ComplexTest#testSqrtRealPositive, org.apache.commons.math.linear.BlockFieldMatrixTest#testToString, org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiply, org.apache.commons.math.linear.BigMatrixImplTest#testAddFail, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiplePastEmpty, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSpecialValues, org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply, org.apache.commons.math.util.MathUtilsTest#testLog, org.apache.commons.math.transform.FastFourierTransformerTest#testParameters, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testFormatObject, org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowVector, org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNan, org.apache.commons.math.util.MathUtilsTest#testSignLong, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testUnequalSizeArguments, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testWeightedConsistency, org.apache.commons.math.complex.ComplexTest#testMultiply, org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleNoDecimals, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testMomentSmallSamples, org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testBasicStats, org.apache.commons.math.random.GaussianRandomGeneratorTest#testMeanAndStandardDeviation, org.apache.commons.math.util.OpenIntToFieldTest#testRemoveFromEmpty, org.apache.commons.math.util.MathUtilsTest#testMulAndCheck, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testIncreasingTolerance, org.apache.commons.math.stat.StatUtilsTest#testGeometricMean, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEvents, org.apache.commons.math.fraction.FractionTest#testAdd, org.apache.commons.math.complex.ComplexTest#testNegate, org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSerial, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowVector, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testConsistency, org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficient, org.apache.commons.math.linear.FieldMatrixImplTest#testSetRow, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testConsistency, org.apache.commons.math.complex.ComplexTest#testSinhInf, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDimensionCheck, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testOneSet, org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction2, org.apache.commons.math.distribution.ExponentialDistributionTest#testConsistency, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeZ, org.apache.commons.math.complex.ComplexFormatTest#testZeroReal, org.apache.commons.math.linear.SparseFieldMatrixTest#testTrace, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testLLowerTriangular, org.apache.commons.math.linear.FieldMatrixImplTest#testAddFail, org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testSmallError, org.apache.commons.math.distribution.ZipfDistributionTest#testFloatingPointArguments, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopyConsistency, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeX, org.apache.commons.math.linear.BlockRealMatrixTest#testGetRow, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeY, org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPPermutation, org.apache.commons.math.stat.descriptive.summary.SumTest#testIncrementation, org.apache.commons.math.util.MathUtilsTest#testL1DistanceDouble, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testRosenbrock, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testConsistency, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#test20090720, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testLinearFunction, org.apache.commons.math.optimization.linear.SimplexSolverTest#testUnboundedSolution, org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewSecantSolverValid, org.apache.commons.math.distribution.FDistributionTest#testIllegalArguments, org.apache.commons.math.stat.StatUtilsTest#testSumSq, org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryFormatNull, org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testNoError, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testN0andN1Conditions, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testShuffledStatistics, org.apache.commons.math.complex.ComplexTest#testAcos, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveAbsent, org.apache.commons.math.ode.FirstOrderConverterTest#testDecreasingSteps, org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeReal, org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleT, org.apache.commons.math.ode.sampling.StepNormalizerTest#testBeforeEnd, org.apache.commons.math.util.DefaultTransformerTest#testSerial, org.apache.commons.math.random.RandomDataTest#testNextPoissonConsistency, org.apache.commons.math.linear.SparseRealVectorTest#testConstructors, org.apache.commons.math.util.DefaultTransformerTest#testTransformInteger, org.apache.commons.math.stat.descriptive.rank.MedianTest#testWeightedConsistency, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNoDependency, org.apache.commons.math.complex.ComplexTest#testConjugateInfiinite, org.apache.commons.math.util.OpenIntToFieldTest#testCopy, org.apache.commons.math.optimization.linear.SimplexSolverTest#testSimplexSolver, org.apache.commons.math.linear.RealVectorFormatTest#testStaticFormatRealVectorImpl, org.apache.commons.math.linear.BigMatrixImplTest#testMultiply, org.apache.commons.math.fraction.FractionFormatTest#testParseInvalidDenominator, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnVector, org.apache.commons.math.linear.SparseFieldMatrixTest#testDimensions, org.apache.commons.math.util.ResizableDoubleArrayTest#testAddElementRolling, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBigStep, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testIncrementation, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddXSampleData, org.apache.commons.math.linear.BlockRealMatrixTest#testSeveralBlocks, org.apache.commons.math.distribution.PascalDistributionTest#testDensities, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeAll, org.apache.commons.math.complex.FrenchComplexFormatTest#testPaseNegativeInfinity, org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#testDerivativesConsistency, org.apache.commons.math.linear.BlockRealMatrixTest#testToString, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArray, org.apache.commons.math.linear.RealVectorFormatTest#testNegativeX, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDimensionCheck, org.apache.commons.math.complex.ComplexTest#testTanCritical, org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnVector, org.apache.commons.math.complex.ComplexFormatTest#testSimpleNoDecimals, org.apache.commons.math.linear.RealVectorFormatTest#testNegativeZ, org.apache.commons.math.geometry.RotationTest#testApplyInverseTo, org.apache.commons.math.linear.RealVectorFormatTest#testNegativeY, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeZ, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNan, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersSimple, org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMeanAndCovariance, org.apache.commons.math.complex.ComplexTest#testExp, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testEvents, org.apache.commons.math.stat.StatUtilsTest#testMin, org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumn, org.apache.commons.math.util.OpenIntToFieldTest#testGetFromEmpty, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeX, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeY, org.apache.commons.math.stat.inference.TTestFactoryTest#testSmallSamples, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareZeroCount, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParameters, org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnVector, org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNegative, org.apache.commons.math.MathConfigurationExceptionTest#testConstructorCause, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testQuinticFunction, org.apache.commons.math.fraction.FractionTest#testConstructorDouble, org.apache.commons.math.transform.FastHadamardTransformerTest#test4Points, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSpecialValues, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEvaluation, org.apache.commons.math.util.DefaultTransformerTest#testTransformObject, org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareZeroCount, org.apache.commons.math.fraction.FractionTest#testSubtract, org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove, org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowMatrix, org.apache.commons.math.geometry.Vector3DFormatTest#testStaticFormatVector3D, org.apache.commons.math.complex.ComplexTest#testPowNaNBase, org.apache.commons.math.linear.LUDecompositionImplTest#testPAEqualLU, org.apache.commons.math.genetics.RandomKeyTest#testRandomPermutation, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAddFail, org.apache.commons.math.linear.SparseRealVectorTest#testSerial, org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfectNegative, org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilities, org.apache.commons.math.complex.ComplexTest#testDivideZero, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwiss, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testBackward, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testFormatObject, org.apache.commons.math.genetics.ChromosomeTest#testCompareTo, org.apache.commons.math.special.GammaTest#testLogGammaNan, org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply, org.apache.commons.math.linear.FieldMatrixImplTest#testScalarAdd, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testMomentSmallSamples, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNoComponents, org.apache.commons.math.util.MathUtilsTest#testSinhNaN, org.apache.commons.math.random.RandomDataTest#testNextHex, org.apache.commons.math.analysis.solvers.BrentSolverTest#testBadEndpoints, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testWeightedConsistency, org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldIdentityMatrix, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextBoolean, org.apache.commons.math.fraction.BigFractionTest#testLongValue, org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHomoscedastic, org.apache.commons.math.distribution.HypergeometricDistributionTest#testPopulationSize, org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testSinFunction, org.apache.commons.math.random.EmpiricalDistributionTest#testGetBinUpperBounds, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquare, org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeBoth, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testCopy, org.apache.commons.math.linear.BlockRealMatrixTest#testOperate, org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopy, org.apache.commons.math.linear.FieldMatrixImplTest#testAdd, org.apache.commons.math.random.ValueServerTest#testModes, org.apache.commons.math.fraction.FractionTest#testSerial, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testfirstDerivativeComparison, org.apache.commons.math.stat.regression.SimpleRegressionTest#testNaNs, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerial, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersSimple, org.apache.commons.math.linear.RealVectorFormatTest#testParsePositiveInfinity, org.apache.commons.math.fraction.FractionTest#testLongValue, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testExpm1Function, org.apache.commons.math.random.RandomDataTest#testNextIntExtremeValues, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testInsufficientData, org.apache.commons.math.ArgumentOutsideDomainExceptionTest#testConstructor, org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.fraction.BigFractionFieldTest#testOne, org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilities, org.apache.commons.math.transform.FastHadamardTransformerTest#test3Points, org.apache.commons.math.optimization.general.MinpackTest#testMinpackHelicalValley, org.apache.commons.math.linear.SparseRealMatrixTest#testScalarAdd, org.apache.commons.math.geometry.Vector3DFormatTest#testFormatObject, org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedDelta, org.apache.commons.math.stat.data.LewTest#testCertifiedValues, org.apache.commons.math.analysis.solvers.NewtonSolverTest#testQuinticZero, org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testPowell, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingBandwidthIncreasesSmoothness, org.apache.commons.math.linear.FieldMatrixImplTest#testTrace, org.apache.commons.math.fraction.FractionFormatTest#testDenominatorFormat, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal3, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal4, org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxEvaluations, org.apache.commons.math.linear.RealVectorFormatTest#testConstructorSingleFormat, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal5, org.apache.commons.math.linear.SparseRealMatrixTest#testGetEntry, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal6, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testStdErrorConsistency, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal1, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal2, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNonDefaultSetting, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnMatrix, org.apache.commons.math.stat.CertifiedDataTest#testDescriptiveStatistics, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testSmallStep, org.apache.commons.math.linear.QRSolverTest#testUnderdetermined, org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testExactIntegration, org.apache.commons.math.linear.SparseFieldMatrixTest#testSetSubMatrix, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerialization, org.apache.commons.math.distribution.ZipfDistributionTest#testDensities, org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1, org.apache.commons.math.linear.SingularValueSolverTest#testSolve, org.apache.commons.math.fraction.FractionTest#testGoldenRatio, org.apache.commons.math.linear.BiDiagonalTransformerTest#testAEqualUSVt, org.apache.commons.math.random.EmpiricalDistributionTest#testSerialization, org.apache.commons.math.stat.descriptive.moment.MeanTest#testMomentSmallSamples, org.apache.commons.math.complex.ComplexFieldTest#testSerial, org.apache.commons.math.random.EmpiricalDistributionTest#testDoubleLoad, org.apache.commons.math.util.MathUtilsTest#testLInfDistanceDouble, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testConstructorSingleFormat, org.apache.commons.math.optimization.general.MinpackTest#testMinpackBard, org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testSinFunction, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSubtraction, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeAll, org.apache.commons.math.special.ErfTest#testErf0, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayArgumentCause, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testBackward, org.apache.commons.math.fraction.FractionTest#testNegate, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSubMatrix, org.apache.commons.math.estimation.MinpackTest#testMinpackChebyquad, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowMatrixLarge, org.apache.commons.math.linear.BlockFieldMatrixTest#testOperate, org.apache.commons.math.random.ValueServerTest#testEmptyReplayFile], jUnit5Tests=[], jacocoIncludes=[org.apache.commons.*], jacocoExcludes=[java.*], family=SPECTRUM_BASED, spectrumFormula=TARANTULA, computeSpoonResults=false}
Computing tests from config.
Running TestContext{testMethods=[[Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL2DistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testOverdetermined, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolveSingularityErrors, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testCompose, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowFieldMatrix, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithSplit, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeReal, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testCorr, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNextAfterSpecialCases, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testPerfectFit, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testConfig, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiplyNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheckLong, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSampling, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSanityChecks, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testReplay, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignInt, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnLarge, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#checkClone, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewNewtonSolverValid, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgumentNaN, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAdd, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveZero, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTan, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testIsSingular, [Manual]TestMethod=org.apache.commons.math.MaxIterationsExceededExceptionTest#testSimpleConstructor, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateSin, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonEqualCounts, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaNanPositive, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSimplistic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testPermutedArrayHash, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowLarge, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNorm, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosNaN, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataThatIsNotSquare, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testIsSame, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotSymmetricMatrixException, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.CertifiedDataTest#testSummaryStatistics, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonUnEqualCounts, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsErrors, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearFullRank, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideInfinite, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDoubleConstructor, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyMutationTest#testMutate, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testEpsilon, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testTheory, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSubtractNaN, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealZero, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproperNegative, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveBadParameters, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testGetImaginaryFormat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSetQuantile, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryNegative, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testAddNonComparable, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinhNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testWindowSize, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvalues, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate1, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testGetSummary, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate0, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowLarge, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetFromEmpty, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaNegativePositivePositive, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testTridiagonal, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testAngles, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSolutionWithNegativeDecisionVariable, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testMultiplication, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLaguerrePolynomials, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testRandomAccess, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testIdentityPermutation, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testCovarianceConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.BetaDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseBig, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testSanityChecks, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolveRankErrors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistanceSq, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testMathpbx02, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHermiteDifferentials, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testGetMean, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testComparatorPermutation, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIntegratorControls, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testSSENonNegative, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension1, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testTrivialModel, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#testDerivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension3, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProperInvalidMinus, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne2, [Manual]TestMethod=org.apache.commons.math.genetics.GeneticAlgorithmTestBinary#test, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhCritical, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateDegenerate, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne1, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetFunctionValueAccuracy, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaPositive, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testProduct, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosInf, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownAlmostLinear, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBrownAlmostLinear, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testInvalidConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNormalize, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction2, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testEqualRepr, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testStaticFormatComplex, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testConstant, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaTest, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutOnExisting, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseZeroReal, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngular, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacity, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketSin, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testGcd, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testValues, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeBoth, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.genetics.FitnessCachingTest#testFitnessCaching, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoSuccesses, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.distribution.BetaDistributionTest#testCumulative, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290LEQ, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetMatrixLarge, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testLargeValues, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#backward, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testQuinticMin, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate1, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaNegativePositive, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate0, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testScale, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheck, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testNegate, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExpInf, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testNorris, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroImaginary, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testDecode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackChebyquad, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigMatrix, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConstant, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBadParameters, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.genetics.FixedGenerationCountTest#testIsSatisfied, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGet, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveZeroPositive, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstChebyshevPolynomials, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMinimizeMaximize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testNaN, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testGetAbsent, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testTransformers, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testIterator, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testConstants, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_fourthRoot, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testDigammaSmallArgs, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testInference, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#test5, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testClear, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaZeroPositivePositive, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testInfeasibleSolution, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextIntNeg, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsTrue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsNull, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArgumentCause, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiply, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromSingle, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testClear, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtPolar, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testFill, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatZero, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testSmallDf, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL1DistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testMath280, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDistinctEigenvalues, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testDoubleFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMath226, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.genetics.ElitisticListPopulationTest#testNextGeneration, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexNaN, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#checklone, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackHelicalValley, [Manual]TestMethod=org.apache.commons.math.genetics.ListPopulationTest#testGetFittestChromosome, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testLongly, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLInfDistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testUOrthogonal, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowRealMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseManyComponents, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositivePositive, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testPutTransformer, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testDegeneracy, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testDimension, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testDropPhase1Objective, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testWholeFormat, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNormalizeAngle, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbsNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaZero, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testPercentile, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testLongly, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testErrorConditions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testZeroImaginary, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInteger, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNexBytes, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2Complex, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testPercentileSetter, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMath221, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrt1z, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnDistortedSine, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testQuaternion, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testHTrapezoidal, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNoRoot, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testQOrthogonal, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testMismatch, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatZero, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSetBeta, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.stat.data.LotteryTest#testCertifiedValues, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testFixedState, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testGetReducedFraction, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testSmallLastStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testContainsClass, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSeveralBlocks, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFat, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetAbsoluteAccuracy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMinimization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#test0Choose0, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformString, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testSetMean, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testRepeatedEigenvalue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.genetics.ChromosomeTest#testFindSameChromosome, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperatePremultiplyLarge, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressandVariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevDifferentials, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsNoConvergence, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testAlpha, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedUlps, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetRelativeAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracySin, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testEmptyDigestFile, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDivide, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseZeroImaginary, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNullIntervalCheck, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testTrigamma, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideReal, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove2, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalid, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testQuantiles, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testDigammaLargeArgs, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRandom, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testRemoval, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetMaximalIterationCount, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideNaN, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnTwoPoints, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testNoError, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProper, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testScalarProduct, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testVectorOnePair, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testQOrthogonal, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveNan, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveNegative, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testWrongDerivative, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testNormalApproximateProbability, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMaximalTiesMinimum, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationInside, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNegateNaN, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testDenominatorFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinNaN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiplyInf, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testParaboloid2D, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentSizes, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testConstructor2, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testConstructor1, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogZero, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testMinMax, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testUUpperTriangular, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearFullRank, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testCopy, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfect, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseManyComponents, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParse, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testNorm, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDigitLimitConstructor, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testBigFractionConverter, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#test20090720, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testLinearFunction2D, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGet, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMath199, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testStats, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testContainsKey, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetRealFormatNull, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantUnsolvable, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonBadCounts, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#backward, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperateLarge, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBox3Dimensional, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperateLarge, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistanceInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnOnePoint, [Manual]TestMethod=org.apache.commons.math.ode.sampling.StepNormalizerTest#testBoundaries, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngularSeparation, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testInverse, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformDouble, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCosh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testTableauWithNoArtificialVars, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testScalb, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testRandomConstructor, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testEstimate, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackPowellSingular, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testContainsKey, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testUUpperTriangular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_thirdRoot, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath272, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeReal, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMinimizeMaximize, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnStraightLine, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinh, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testArrayIndexConditions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testNaN, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testConstruction, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testGetSummary, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNormalizeArray, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath288, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDiagonal, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath286, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testInitialGuess, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnRealMatrix, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignByte, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testBoundaries, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testPaseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath293, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWith0ExpectedSize, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf3291, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testHashCode, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testMath308, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAddNaN, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne2, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testDistance, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testRUpperTriangular, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne1, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperatePremultiplyLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugateNaN, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreRows, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCos, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaNanPositivePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuintic, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#checklone, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testSinMin, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testConfig, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedVariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsinInf, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNISTExample, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtanNaN, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbability2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcosInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testInsufficientBandwidth, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterEmpty, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideImaginary, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testMoreLargeValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedMean, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testArrayEquals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownDennis, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesMaximum, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testOrthogonal, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistance, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testSetScale, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testEmptyTable, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaZeroPositive, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatNegative, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientLarge, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testWindowSize, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesAverage, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testWholeFormat, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testVariance, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testRemoveTransformer, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testUpperOrLower, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testDouble, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.MaxIterationsExceededExceptionTest#testComplexConstructor, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testPcts, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngle, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testGaussian, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction2, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBrentSolverValid, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testLongFormat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testLUDecomposition, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testProperties, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNorm1, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtanInf, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf2807, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testArrayIsReference, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testConfig, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNexBoolean, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testClasses, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testCovarianceConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrt1zNaN, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignShort, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSerial, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf1960, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testHash, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testReciprocal, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgumentInf, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest#dimension2, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testIntegerValues, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testConstruction, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryMutationTest#testMutate, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testIntValue, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemoveAbsent, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcosNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerial, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAddInfinite, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testDimension, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testLargeDegreesOfFreedom, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLog, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiplyNaN, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRealMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testIsSame, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackKowalikOsborne, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedSum, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testNoReset, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testBigDecimalValue, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRootMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevBounds, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testMulAndCheckLong, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConstant, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacityAndExpansionFactor, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNullEmpty, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsSame, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testNext, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testRoundDouble, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withWeights, [Manual]TestMethod=org.apache.commons.math.DuplicateSampleAbscissaExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiplyNaNInf, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNull, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinear, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerial, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testGetRealFormat, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testNullIntervalCheck, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testPercentile, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateSpecialValues, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseNegative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testToString, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullURL, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonUnEqualCounts, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290GEQ, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testEpsilonLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregationConsistency, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnVectorLarge, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientFail, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testRoundFloat, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testSetStandardDeviation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogInf, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSubstitute, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregate, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackPowellSingular, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCoshNaN, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testSinMin, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testCentroid, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.InvalidMatrixExceptionTest#testConstructorMessage, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBisectionSolverValid, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testAEqualQR, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testNumeratorFormat, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnMatrixLarge, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetRealFormatNull, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaNegative, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withoutWeights, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLegendrePolynomials, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testReciprocal, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowVectorLarge, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.random.UniformRandomGeneratorTest#testMeanAndStandardDeviation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testMismatch, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testCopy, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testBound, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test8Points, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testDefault, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddNullYSampleData, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAbsentOnExisting, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testControlParameters, [Manual]TestMethod=org.apache.commons.math.genetics.TournamentSelectionTest#testSelect, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testPopulation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregation, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testForgottenImaginaryCharacter, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormat, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testRootEndpoints, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackWatson, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDoubleConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryFormatNull, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#polynomial, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testModelWithNoArtificialVars, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testSingular, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsImaginaryDifference, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackFreudensteinRoth, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDivide, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveSingle, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbs, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testAdaptor, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares3, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testMeanAccessors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgument, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares1, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares2, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullDoubleArray, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBox3Dimensional, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideNaNInf, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testExamples, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithoutSplit, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtNaN, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testGetStandardDeviation, [Manual]TestMethod=org.apache.commons.math.linear.MatrixIndexExceptionTest#testConstructorMessage, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testConstructorDouble, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsRemovedTiesSequential, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testNumeratorFormat, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAbsentOnExisting, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsClass, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollision2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCoshInf, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreColumns, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiple, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetAbsoluteAccuracy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSingleton, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testLongFormat, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#notEnoughData, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilityAgaintStackOverflow, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneWayAnovaUtils, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testPowell, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL2DistanceDouble, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testLongly, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testHighPercentile, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveSin, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNextAfter, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testSingular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonEqualCounts, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveFromEmpty, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testCoordinates, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollisions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsinNaN, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorDouble, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateResiduals, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testNaN, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testFractionConverter, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPAEqualLU, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testMean, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testCopy, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaNegativePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#checkClone, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtInf, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbsInfinite, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataWithSampleSizeMismatch, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#exceedMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testStdErrorConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproper, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWithExpectedSize, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testFloat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_realPartZero, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsNaN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryZero, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextFloat, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testPaired, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testImpossibleSerialization, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroImaginary, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testParameterAccessors, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testNextDigestFail, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperInvalidMinus, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeBoth, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMax, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testRestrictVariablesToNonNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testInitialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testNonInvertible, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveXY, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testModelsMerging, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testToString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowInf, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testValues, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#noReset, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth1, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterNull, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMax, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemove2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealNegative, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testUOrthogonal, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testBBiDiagonal, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testpowNull, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetMatrixLarge, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testDegenerateInverseCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#polynomial, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testGetReducedFraction, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInteger, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testStaticFormatRealVectorImpl, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackMeyer, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSerial, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNanPositive, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetMaximalIterationCount, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testTTriDiagonal, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracyNull, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConstructorNaN, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositivePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest#testMeanAndCorrelation, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testConcurrentModification, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackRosenbrok, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignFloat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignDouble, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInvalid, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testVectorTwoPairs, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testExtremeValues, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testThreshold, [Manual]TestMethod=org.apache.commons.math.geometry.RotationOrderTest#testName, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorShort, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollisions, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testStaticFormatComplex, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testAEqualQTQt, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSinh, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testGetImaginaryFormat, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanNaN, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testInducedPermutation, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnVectorLarge, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaPValue, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#dimensionCheck, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackRosenbrok, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroReal, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testZeroDivide, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testRank, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddXSampleData, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testAEqualVDVt, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testSingularities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullCovarianceData, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testDoubleFormat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testFactorialFail, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testQTOrthogonal, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSimplistic, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testAbs, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSetAlpha, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLaguerreDifferentials, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNormInf, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testMakotoNishimura, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantSolvable, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogNaN, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#testNoIntInverse, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterEmpty, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testBinIndexOverflow, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaFValue, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testFactorial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLegendreDifferentials, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentSizes, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMin, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackJennrichSampson, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testSampling, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateTwoSegment, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testBoundParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilitySpecial, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackFreudensteinRoth, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateResiduals, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorByte, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testAEqualLLT, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollision2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testComposeInverse, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWithExpectedSize, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBrownDennis, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSingular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.InteractionTest#testInteraction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testBasicStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testAddAndCheckLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatNumber, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeBoth, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testDiscard, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testAdd1000, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testSmallDf, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testWalk, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaZeroPositive, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSkewAndKurtosis, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnFieldMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testIntegerOverflow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testPopulation, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinInf, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaNanPositive, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeReal, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testFunctionEvaluationExceptions, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketEndpointRoot, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWith0ExpectedSize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testContainsTransformer, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues5, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues3, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestPositive, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testControlParameters, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsin, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowVectorLarge, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalidDenominator, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSetElementArbitraryExpansion, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testLinear, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testHat, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_NAN_Inf, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveZero, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsAndInfs, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testAxisAngle, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetRelativeAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstHermitePolynomials, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testPaired, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testRevert, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerial, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testLargeModel, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testVectorialProducts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.genetics.OnePointCrossoverTest#testCrossover, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemove, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMath283, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowMatrixLarge, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#exceedMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing1, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testConditionNumber, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testParameters, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing2, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testStaticFormatVector3D, [Manual]TestMethod=org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations#test, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolveSingularityErrors, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonBadCounts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testPercentileSetter, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCoshNaN, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowNaNExponent, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testSumLog, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformNull, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testNoOptimum, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowZero, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsFixedTiesRandom, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProper, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSingleVariableAndConstraint, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistance1, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNegativePositive, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationAtBounds, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testCopy, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromEmpty, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackMeyer, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testFloatValue, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivide, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetAbsent, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextIntN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testPPermutation, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoFailures, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testUnsorted, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testIgnored, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testFloatValue, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testSmallDegreesOfFreedom, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositivePositive, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutOnExisting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBard, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLTTransposed, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testNoAccessBelowDiagonal, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRank, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testAEqualUSVt, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSerial, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#test2DData, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateThreeSegment, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testSkewAndKurtosis, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMean, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testConditionNumber, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopy, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testMutators, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.util.ContinuedFractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testDifferenceStats, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testInitialGuess, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSin, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateFullSample, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMath199, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testExamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExpNaN, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetFunctionValueAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testAddition, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testIntValue, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHighDegreeLegendre, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#test1PercentError, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedProduct, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackJennrichSampson, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testBigDecimalValue, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testInvertible, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNoDenseOutput, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullFile, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testRemoval, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnMatrixLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexIllegalModulus, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterNull, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNoComponents, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackWatson, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testIdentity, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testLongly, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopy, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testNextDigest, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFine, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testIterator, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuadratic, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testNorm, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testPaired, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testPrintStackTrace, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testConcurrentModification, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperNegative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testEmptyData, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsRealDifference, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultipleToEmpty, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressandVariance, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testAddAndCheck, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf2576, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullYSampleData, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testMedian, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testArrayHash, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testBeta, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLcm, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#dimensionCheck, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorFloat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testNaN, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoad, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveZero, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroReal, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanInf, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testForgottenImaginaryCharacter, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testDoubleDimension, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhInf, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testCounts, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSolve, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParameters, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSetNumberOfElements, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackKowalikOsborne, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvectors, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanInverseCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParse, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhNaN, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheckErrorMessage, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopy, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testAbs, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testMinEndpoints, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEquals, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testNexFail, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testFormatNumber, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testHadamard, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformBigDecimal, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testFunctionEvaluationExceptions, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testGetRealFormat, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealPositive, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiplePastEmpty, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLog, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNan, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignLong, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testUnequalSizeArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testBasicStats, [Manual]TestMethod=org.apache.commons.math.random.GaussianRandomGeneratorTest#testMeanAndStandardDeviation, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemoveFromEmpty, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testMulAndCheck, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testGeometricMean, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNegate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficient, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinhInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction2, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testZeroReal, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testSmallError, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL1DistanceDouble, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#test20090720, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testUnboundedSolution, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewSecantSolverValid, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testSumSq, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryFormatNull, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testNoError, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcos, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveAbsent, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeReal, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.ode.sampling.StepNormalizerTest#testBeforeEnd, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformInteger, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugateInfiinite, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testCopy, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSimplexSolver, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testStaticFormatRealVectorImpl, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInvalidDenominator, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testAddElementRolling, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddXSampleData, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSeveralBlocks, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testPaseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#testDerivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArray, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanCritical, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testApplyInverseTo, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNan, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMeanAndCovariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExp, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMin, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testGetFromEmpty, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParameters, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNegative, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testConstructorDouble, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test4Points, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformObject, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testStaticFormatVector3D, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowNaNBase, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testPAEqualLU, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testRandomPermutation, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfectNegative, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideZero, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwiss, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.genetics.ChromosomeTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaNan, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNoComponents, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSinhNaN, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testBadEndpoints, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextBoolean, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testLongValue, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testPopulationSize, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGetBinUpperBounds, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeBoth, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testModes, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testfirstDerivativeComparison, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testLongValue, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.ArgumentOutsideDomainExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test3Points, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackHelicalValley, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedDelta, [Manual]TestMethod=org.apache.commons.math.stat.data.LewTest#testCertifiedValues, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testPowell, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingBandwidthIncreasesSmoothness, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testDenominatorFormat, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal3, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal4, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal5, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal6, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testStdErrorConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal1, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal2, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.CertifiedDataTest#testDescriptiveStatistics, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testUnderdetermined, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testExactIntegration, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testAEqualUSVt, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testDoubleLoad, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLInfDistanceDouble, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBard, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSubtraction, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf0, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayArgumentCause, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testNegate, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackChebyquad, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowMatrixLarge, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testEmptyReplayFile], testFrameworkStrategy=fr.spoonlabs.flacoco.core.coverage.framework.JUnit4Strategy@6256ac4f}
Running TestContext{testMethods=[[Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL2DistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testOverdetermined, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolveSingularityErrors, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testCompose, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowFieldMatrix, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithSplit, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeReal, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testCorr, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNextAfterSpecialCases, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testPerfectFit, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testConfig, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiplyNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheckLong, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSampling, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSanityChecks, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testReplay, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignInt, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnLarge, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#checkClone, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewNewtonSolverValid, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgumentNaN, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAdd, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveZero, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTan, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testIsSingular, [Manual]TestMethod=org.apache.commons.math.MaxIterationsExceededExceptionTest#testSimpleConstructor, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateSin, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonEqualCounts, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaNanPositive, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSimplistic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testPermutedArrayHash, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowLarge, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNorm, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosNaN, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataThatIsNotSquare, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testIsSame, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotSymmetricMatrixException, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.CertifiedDataTest#testSummaryStatistics, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonUnEqualCounts, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsErrors, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearFullRank, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideInfinite, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDoubleConstructor, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyMutationTest#testMutate, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testEpsilon, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testTheory, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSubtractNaN, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealZero, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproperNegative, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveBadParameters, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testGetImaginaryFormat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSetQuantile, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryNegative, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testAddNonComparable, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinhNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testWindowSize, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvalues, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate1, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testGetSummary, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate0, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowLarge, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetFromEmpty, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaNegativePositivePositive, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testTridiagonal, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testAngles, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSolutionWithNegativeDecisionVariable, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testMultiplication, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLaguerrePolynomials, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testRandomAccess, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testIdentityPermutation, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testCovarianceConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.BetaDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseBig, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testSanityChecks, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolveRankErrors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistanceSq, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testMathpbx02, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHermiteDifferentials, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testGetMean, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testComparatorPermutation, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIntegratorControls, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testSSENonNegative, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension1, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testTrivialModel, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#testDerivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension3, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProperInvalidMinus, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne2, [Manual]TestMethod=org.apache.commons.math.genetics.GeneticAlgorithmTestBinary#test, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhCritical, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateDegenerate, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne1, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetFunctionValueAccuracy, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaPositive, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testProduct, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosInf, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownAlmostLinear, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBrownAlmostLinear, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testInvalidConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNormalize, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction2, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testEqualRepr, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testStaticFormatComplex, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testConstant, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaTest, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutOnExisting, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseZeroReal, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngular, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacity, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketSin, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testGcd, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testValues, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeBoth, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.genetics.FitnessCachingTest#testFitnessCaching, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoSuccesses, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.distribution.BetaDistributionTest#testCumulative, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290LEQ, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetMatrixLarge, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testLargeValues, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#backward, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testQuinticMin, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate1, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaNegativePositive, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate0, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testScale, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheck, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testNegate, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExpInf, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testNorris, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroImaginary, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testDecode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackChebyquad, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigMatrix, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConstant, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBadParameters, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.genetics.FixedGenerationCountTest#testIsSatisfied, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGet, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveZeroPositive, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstChebyshevPolynomials, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMinimizeMaximize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testNaN, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testGetAbsent, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testTransformers, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testIterator, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testConstants, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_fourthRoot, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testDigammaSmallArgs, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testInference, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#test5, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testClear, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaZeroPositivePositive, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testInfeasibleSolution, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextIntNeg, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsTrue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsNull, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArgumentCause, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiply, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromSingle, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testClear, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtPolar, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testFill, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatZero, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testSmallDf, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL1DistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testMath280, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDistinctEigenvalues, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testDoubleFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMath226, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.genetics.ElitisticListPopulationTest#testNextGeneration, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexNaN, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#checklone, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackHelicalValley, [Manual]TestMethod=org.apache.commons.math.genetics.ListPopulationTest#testGetFittestChromosome, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testLongly, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLInfDistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testUOrthogonal, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowRealMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseManyComponents, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositivePositive, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testPutTransformer, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testDegeneracy, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testDimension, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testDropPhase1Objective, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testWholeFormat, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNormalizeAngle, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbsNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaZero, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testPercentile, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testLongly, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testErrorConditions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testZeroImaginary, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInteger, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNexBytes, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2Complex, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testPercentileSetter, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMath221, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrt1z, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnDistortedSine, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testQuaternion, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testHTrapezoidal, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNoRoot, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testQOrthogonal, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testMismatch, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatZero, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSetBeta, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.stat.data.LotteryTest#testCertifiedValues, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testFixedState, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testGetReducedFraction, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testSmallLastStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testContainsClass, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSeveralBlocks, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFat, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetAbsoluteAccuracy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMinimization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#test0Choose0, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformString, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testSetMean, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testRepeatedEigenvalue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.genetics.ChromosomeTest#testFindSameChromosome, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperatePremultiplyLarge, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressandVariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevDifferentials, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsNoConvergence, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testAlpha, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedUlps, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetRelativeAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracySin, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testEmptyDigestFile, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDivide, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseZeroImaginary, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNullIntervalCheck, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testTrigamma, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideReal, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove2, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalid, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testQuantiles, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testDigammaLargeArgs, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRandom, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testRemoval, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetMaximalIterationCount, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideNaN, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnTwoPoints, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testNoError, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProper, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testScalarProduct, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testVectorOnePair, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testQOrthogonal, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveNan, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveNegative, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testWrongDerivative, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testNormalApproximateProbability, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMaximalTiesMinimum, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationInside, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNegateNaN, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testDenominatorFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinNaN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiplyInf, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testParaboloid2D, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentSizes, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testConstructor2, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testConstructor1, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogZero, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testMinMax, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testUUpperTriangular, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearFullRank, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testCopy, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfect, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseManyComponents, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParse, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testNorm, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDigitLimitConstructor, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testBigFractionConverter, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#test20090720, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testLinearFunction2D, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGet, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMath199, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testStats, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testContainsKey, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetRealFormatNull, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantUnsolvable, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonBadCounts, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#backward, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperateLarge, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBox3Dimensional, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperateLarge, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistanceInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnOnePoint, [Manual]TestMethod=org.apache.commons.math.ode.sampling.StepNormalizerTest#testBoundaries, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngularSeparation, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testInverse, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformDouble, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCosh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testTableauWithNoArtificialVars, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testScalb, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testRandomConstructor, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testEstimate, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackPowellSingular, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testContainsKey, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testUUpperTriangular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_thirdRoot, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath272, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeReal, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMinimizeMaximize, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnStraightLine, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinh, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testArrayIndexConditions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testNaN, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testConstruction, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testGetSummary, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNormalizeArray, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath288, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDiagonal, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath286, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testInitialGuess, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnRealMatrix, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignByte, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testBoundaries, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testPaseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath293, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWith0ExpectedSize, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf3291, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testHashCode, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testMath308, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAddNaN, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne2, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testDistance, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testRUpperTriangular, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne1, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperatePremultiplyLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugateNaN, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreRows, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCos, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaNanPositivePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuintic, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#checklone, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testSinMin, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testConfig, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedVariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsinInf, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNISTExample, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtanNaN, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbability2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcosInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testInsufficientBandwidth, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterEmpty, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideImaginary, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testMoreLargeValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedMean, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testArrayEquals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownDennis, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesMaximum, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testOrthogonal, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistance, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testSetScale, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testEmptyTable, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaZeroPositive, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatNegative, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientLarge, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testWindowSize, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesAverage, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testWholeFormat, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testVariance, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testRemoveTransformer, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testUpperOrLower, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testDouble, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.MaxIterationsExceededExceptionTest#testComplexConstructor, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testPcts, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngle, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testGaussian, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction2, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBrentSolverValid, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testLongFormat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testLUDecomposition, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testProperties, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNorm1, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtanInf, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf2807, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testArrayIsReference, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testConfig, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNexBoolean, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testClasses, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testCovarianceConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrt1zNaN, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignShort, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSerial, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf1960, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testHash, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testReciprocal, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgumentInf, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest#dimension2, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testIntegerValues, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testConstruction, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryMutationTest#testMutate, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testIntValue, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemoveAbsent, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcosNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerial, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAddInfinite, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testDimension, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testLargeDegreesOfFreedom, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLog, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiplyNaN, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRealMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testIsSame, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackKowalikOsborne, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedSum, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testNoReset, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testBigDecimalValue, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRootMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevBounds, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testMulAndCheckLong, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConstant, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacityAndExpansionFactor, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNullEmpty, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsSame, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testNext, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testRoundDouble, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withWeights, [Manual]TestMethod=org.apache.commons.math.DuplicateSampleAbscissaExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiplyNaNInf, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNull, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinear, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerial, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testGetRealFormat, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testNullIntervalCheck, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testPercentile, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateSpecialValues, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseNegative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testToString, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullURL, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonUnEqualCounts, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290GEQ, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testEpsilonLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregationConsistency, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnVectorLarge, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientFail, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testRoundFloat, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testSetStandardDeviation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogInf, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSubstitute, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregate, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackPowellSingular, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCoshNaN, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testSinMin, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testCentroid, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.InvalidMatrixExceptionTest#testConstructorMessage, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBisectionSolverValid, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testAEqualQR, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testNumeratorFormat, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnMatrixLarge, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetRealFormatNull, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaNegative, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withoutWeights, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLegendrePolynomials, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testReciprocal, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowVectorLarge, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.random.UniformRandomGeneratorTest#testMeanAndStandardDeviation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testMismatch, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testCopy, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testBound, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test8Points, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testDefault, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddNullYSampleData, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAbsentOnExisting, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testControlParameters, [Manual]TestMethod=org.apache.commons.math.genetics.TournamentSelectionTest#testSelect, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testPopulation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregation, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testForgottenImaginaryCharacter, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormat, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testRootEndpoints, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackWatson, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDoubleConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryFormatNull, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#polynomial, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testModelWithNoArtificialVars, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testSingular, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsImaginaryDifference, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackFreudensteinRoth, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDivide, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveSingle, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbs, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testAdaptor, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares3, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testMeanAccessors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgument, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares1, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares2, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullDoubleArray, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBox3Dimensional, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideNaNInf, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testExamples, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithoutSplit, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtNaN, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testGetStandardDeviation, [Manual]TestMethod=org.apache.commons.math.linear.MatrixIndexExceptionTest#testConstructorMessage, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testConstructorDouble, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsRemovedTiesSequential, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testNumeratorFormat, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAbsentOnExisting, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsClass, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollision2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCoshInf, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreColumns, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiple, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetAbsoluteAccuracy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSingleton, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testLongFormat, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#notEnoughData, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilityAgaintStackOverflow, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneWayAnovaUtils, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testPowell, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL2DistanceDouble, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testLongly, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testHighPercentile, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveSin, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNextAfter, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testSingular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonEqualCounts, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveFromEmpty, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testCoordinates, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollisions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsinNaN, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorDouble, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateResiduals, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testNaN, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testFractionConverter, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPAEqualLU, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testMean, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testCopy, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaNegativePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#checkClone, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtInf, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbsInfinite, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataWithSampleSizeMismatch, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#exceedMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testStdErrorConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproper, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWithExpectedSize, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testFloat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_realPartZero, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsNaN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryZero, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextFloat, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testPaired, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testImpossibleSerialization, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroImaginary, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testParameterAccessors, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testNextDigestFail, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperInvalidMinus, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeBoth, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMax, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testRestrictVariablesToNonNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testInitialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testNonInvertible, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveXY, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testModelsMerging, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testToString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowInf, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testValues, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#noReset, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth1, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterNull, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMax, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemove2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealNegative, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testUOrthogonal, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testBBiDiagonal, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testpowNull, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetMatrixLarge, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testDegenerateInverseCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#polynomial, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testGetReducedFraction, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInteger, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testStaticFormatRealVectorImpl, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackMeyer, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSerial, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNanPositive, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetMaximalIterationCount, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testTTriDiagonal, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracyNull, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConstructorNaN, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositivePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest#testMeanAndCorrelation, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testConcurrentModification, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackRosenbrok, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignFloat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignDouble, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInvalid, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testVectorTwoPairs, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testExtremeValues, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testThreshold, [Manual]TestMethod=org.apache.commons.math.geometry.RotationOrderTest#testName, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorShort, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollisions, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testStaticFormatComplex, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testAEqualQTQt, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSinh, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testGetImaginaryFormat, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanNaN, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testInducedPermutation, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnVectorLarge, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaPValue, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#dimensionCheck, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackRosenbrok, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroReal, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testZeroDivide, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testRank, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddXSampleData, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testAEqualVDVt, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testSingularities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullCovarianceData, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testDoubleFormat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testFactorialFail, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testQTOrthogonal, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSimplistic, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testAbs, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSetAlpha, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLaguerreDifferentials, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNormInf, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testMakotoNishimura, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantSolvable, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogNaN, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#testNoIntInverse, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterEmpty, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testBinIndexOverflow, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaFValue, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testFactorial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLegendreDifferentials, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentSizes, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMin, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackJennrichSampson, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testSampling, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateTwoSegment, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testBoundParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilitySpecial, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackFreudensteinRoth, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateResiduals, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorByte, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testAEqualLLT, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollision2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testComposeInverse, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWithExpectedSize, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBrownDennis, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSingular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.InteractionTest#testInteraction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testBasicStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testAddAndCheckLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatNumber, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeBoth, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testDiscard, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testAdd1000, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testSmallDf, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testWalk, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaZeroPositive, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSkewAndKurtosis, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnFieldMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testIntegerOverflow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testPopulation, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinInf, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaNanPositive, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeReal, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testFunctionEvaluationExceptions, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketEndpointRoot, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWith0ExpectedSize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testContainsTransformer, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues5, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues3, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestPositive, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testControlParameters, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsin, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowVectorLarge, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalidDenominator, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSetElementArbitraryExpansion, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testLinear, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testHat, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_NAN_Inf, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveZero, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsAndInfs, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testAxisAngle, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetRelativeAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstHermitePolynomials, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testPaired, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testRevert, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerial, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testLargeModel, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testVectorialProducts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.genetics.OnePointCrossoverTest#testCrossover, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemove, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMath283, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowMatrixLarge, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#exceedMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing1, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testConditionNumber, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testParameters, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing2, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testStaticFormatVector3D, [Manual]TestMethod=org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations#test, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolveSingularityErrors, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonBadCounts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testPercentileSetter, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCoshNaN, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowNaNExponent, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testSumLog, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformNull, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testNoOptimum, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowZero, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsFixedTiesRandom, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProper, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSingleVariableAndConstraint, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistance1, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNegativePositive, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationAtBounds, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testCopy, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromEmpty, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackMeyer, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testFloatValue, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivide, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetAbsent, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextIntN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testPPermutation, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoFailures, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testUnsorted, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testIgnored, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testFloatValue, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testSmallDegreesOfFreedom, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositivePositive, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutOnExisting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBard, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLTTransposed, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testNoAccessBelowDiagonal, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRank, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testAEqualUSVt, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSerial, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#test2DData, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateThreeSegment, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testSkewAndKurtosis, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMean, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testConditionNumber, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopy, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testMutators, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.util.ContinuedFractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testDifferenceStats, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testInitialGuess, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSin, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateFullSample, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMath199, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testExamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExpNaN, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetFunctionValueAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testAddition, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testIntValue, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHighDegreeLegendre, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#test1PercentError, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedProduct, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackJennrichSampson, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testBigDecimalValue, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testInvertible, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNoDenseOutput, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullFile, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testRemoval, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnMatrixLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexIllegalModulus, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterNull, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNoComponents, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackWatson, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testIdentity, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testLongly, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopy, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testNextDigest, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFine, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testIterator, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuadratic, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testNorm, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testPaired, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testPrintStackTrace, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testConcurrentModification, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperNegative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testEmptyData, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsRealDifference, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultipleToEmpty, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressandVariance, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testAddAndCheck, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf2576, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullYSampleData, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testMedian, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testArrayHash, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testBeta, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLcm, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#dimensionCheck, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorFloat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testNaN, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoad, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveZero, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroReal, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanInf, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testForgottenImaginaryCharacter, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testDoubleDimension, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhInf, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testCounts, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSolve, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParameters, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSetNumberOfElements, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackKowalikOsborne, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvectors, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanInverseCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParse, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhNaN, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheckErrorMessage, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopy, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testAbs, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testMinEndpoints, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEquals, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testNexFail, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testFormatNumber, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testHadamard, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformBigDecimal, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testFunctionEvaluationExceptions, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testGetRealFormat, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealPositive, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiplePastEmpty, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLog, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNan, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignLong, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testUnequalSizeArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testBasicStats, [Manual]TestMethod=org.apache.commons.math.random.GaussianRandomGeneratorTest#testMeanAndStandardDeviation, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemoveFromEmpty, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testMulAndCheck, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testGeometricMean, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNegate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficient, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinhInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction2, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testZeroReal, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testSmallError, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL1DistanceDouble, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#test20090720, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testUnboundedSolution, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewSecantSolverValid, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testSumSq, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryFormatNull, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testNoError, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcos, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveAbsent, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeReal, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.ode.sampling.StepNormalizerTest#testBeforeEnd, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformInteger, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugateInfiinite, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testCopy, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSimplexSolver, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testStaticFormatRealVectorImpl, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInvalidDenominator, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testAddElementRolling, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddXSampleData, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSeveralBlocks, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testPaseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#testDerivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArray, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanCritical, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testApplyInverseTo, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNan, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMeanAndCovariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExp, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMin, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testGetFromEmpty, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParameters, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNegative, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testConstructorDouble, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test4Points, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformObject, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testStaticFormatVector3D, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowNaNBase, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testPAEqualLU, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testRandomPermutation, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfectNegative, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideZero, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwiss, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.genetics.ChromosomeTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaNan, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNoComponents, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSinhNaN, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testBadEndpoints, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextBoolean, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testLongValue, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testPopulationSize, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGetBinUpperBounds, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeBoth, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testModes, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testfirstDerivativeComparison, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testLongValue, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.ArgumentOutsideDomainExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test3Points, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackHelicalValley, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedDelta, [Manual]TestMethod=org.apache.commons.math.stat.data.LewTest#testCertifiedValues, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testPowell, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingBandwidthIncreasesSmoothness, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testDenominatorFormat, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal3, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal4, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal5, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal6, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testStdErrorConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal1, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal2, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.CertifiedDataTest#testDescriptiveStatistics, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testUnderdetermined, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testExactIntegration, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testAEqualUSVt, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testDoubleLoad, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLInfDistanceDouble, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBard, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSubtraction, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf0, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayArgumentCause, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testNegate, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackChebyquad, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowMatrixLarge, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testEmptyReplayFile], testFrameworkStrategy=fr.spoonlabs.flacoco.core.coverage.framework.JUnit4Strategy@6256ac4f}
Path to runner Classes: /Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
Tests found: 2104
Tests executed: 2104
Suspicious: 1 line org.apache.commons.math.linear.EigenDecompositionImpl l: 871, susp 1.0
Suspicious: 2 line org.apache.commons.math.linear.EigenDecompositionImpl l: 872, susp 1.0
Suspicious: 3 line org.apache.commons.math.linear.EigenDecompositionImpl l: 944, susp 1.0
Suspicious: 4 line org.apache.commons.math.linear.EigenDecompositionImpl l: 945, susp 1.0
Suspicious: 5 line org.apache.commons.math.linear.EigenDecompositionImpl l: 957, susp 1.0
Suspicious: 6 line org.apache.commons.math.linear.EigenDecompositionImpl l: 958, susp 1.0
Suspicious: 7 line org.apache.commons.math.linear.EigenDecompositionImpl l: 959, susp 1.0
Suspicious: 8 line org.apache.commons.math.linear.EigenDecompositionImpl l: 960, susp 1.0
Suspicious: 9 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1055, susp 1.0
Suspicious: 10 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1056, susp 1.0
Suspicious: 11 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1057, susp 1.0
Suspicious: 12 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1058, susp 1.0
Suspicious: 13 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1059, susp 1.0
Suspicious: 14 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1060, susp 1.0
Suspicious: 15 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1061, susp 1.0
Suspicious: 16 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1062, susp 1.0
Suspicious: 17 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1063, susp 1.0
Suspicious: 18 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1135, susp 1.0
Suspicious: 19 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1136, susp 1.0
Suspicious: 20 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1137, susp 1.0
Suspicious: 21 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1138, susp 1.0
Suspicious: 22 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1139, susp 1.0
Suspicious: 23 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1140, susp 1.0
Suspicious: 24 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1142, susp 1.0
Suspicious: 25 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1144, susp 1.0
Suspicious: 26 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1384, susp 1.0
Suspicious: 27 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1385, susp 1.0
Suspicious: 28 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1386, susp 1.0
Suspicious: 29 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1387, susp 1.0
Suspicious: 30 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1404, susp 1.0
Suspicious: 31 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1405, susp 1.0
Suspicious: 32 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1406, susp 1.0
Suspicious: 33 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1407, susp 1.0
Suspicious: 34 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1414, susp 1.0
Suspicious: 35 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1415, susp 1.0
Suspicious: 36 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1090, susp 0.9995235826584088
Suspicious: 37 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1091, susp 0.9995235826584088
Suspicious: 38 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1092, susp 0.9995235826584088
Suspicious: 39 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1093, susp 0.9995235826584088
Suspicious: 40 line org.apache.commons.math.linear.EigenDecompositionImpl l: 336, susp 0.9990476190476191
Suspicious: 41 line org.apache.commons.math.linear.EigenDecompositionImpl l: 337, susp 0.9990476190476191
Suspicious: 42 line org.apache.commons.math.linear.EigenDecompositionImpl l: 339, susp 0.9990476190476191
Suspicious: 43 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1088, susp 0.9985721085197525
Suspicious: 44 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1105, susp 0.9985721085197525
Suspicious: 45 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1106, susp 0.9985721085197525
Suspicious: 46 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1530, susp 0.9985721085197525
Suspicious: 47 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1531, susp 0.9985721085197525
Suspicious: 48 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1534, susp 0.9985721085197525
Suspicious: 49 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1535, susp 0.9985721085197525
Suspicious: 50 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1536, susp 0.9985721085197525
Suspicious: 51 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1537, susp 0.9985721085197525
Suspicious: 52 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1538, susp 0.9985721085197525
Suspicious: 53 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1541, susp 0.9985721085197525
Suspicious: 54 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1544, susp 0.9985721085197525
Suspicious: 55 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1564, susp 0.9985721085197525
Suspicious: 56 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1565, susp 0.9985721085197525
Suspicious: 57 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1570, susp 0.9985721085197525
Suspicious: 58 line org.apache.commons.math.linear.ArrayRealVector l: 225, susp 0.9976224441274371
Suspicious: 59 line org.apache.commons.math.linear.ArrayRealVector l: 870, susp 0.9976224441274371
Suspicious: 60 line org.apache.commons.math.linear.ArrayRealVector l: 175, susp 0.9971482889733841
Suspicious: 61 line org.apache.commons.math.linear.ArrayRealVector l: 176, susp 0.9971482889733841
Suspicious: 62 line org.apache.commons.math.linear.ArrayRealVector l: 177, susp 0.9971482889733841
Suspicious: 63 line org.apache.commons.math.linear.ArrayRealVector l: 900, susp 0.9971482889733841
Suspicious: 64 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1488, susp 0.9962013295346628
Suspicious: 65 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1489, susp 0.9962013295346628
Suspicious: 66 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1490, susp 0.9962013295346628
Suspicious: 67 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1491, susp 0.9962013295346628
Suspicious: 68 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1494, susp 0.9962013295346628
Suspicious: 69 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1495, susp 0.9962013295346628
Suspicious: 70 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1498, susp 0.9962013295346628
Suspicious: 71 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1499, susp 0.9962013295346628
Suspicious: 72 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1085, susp 0.9957285239677266
Suspicious: 73 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1094, susp 0.9957285239677266
Suspicious: 74 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1096, susp 0.9957285239677266
Suspicious: 75 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1099, susp 0.9957285239677266
Suspicious: 76 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1101, susp 0.9957285239677266
Suspicious: 77 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1102, susp 0.9957285239677266
Suspicious: 78 line org.apache.commons.math.linear.EigenDecompositionImpl l: 666, susp 0.9952561669829222
Suspicious: 79 line org.apache.commons.math.linear.EigenDecompositionImpl l: 667, susp 0.9952561669829222
Suspicious: 80 line org.apache.commons.math.linear.ArrayRealVector l: 905, susp 0.9952561669829222
Suspicious: 81 line org.apache.commons.math.linear.ArrayRealVector l: 906, susp 0.9952561669829222
Suspicious: 82 line org.apache.commons.math.linear.ArrayRealVector l: 907, susp 0.9952561669829222
Suspicious: 83 line org.apache.commons.math.linear.ArrayRealVector l: 909, susp 0.9952561669829222
Suspicious: 84 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1475, susp 0.9952561669829222
Suspicious: 85 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1476, susp 0.9952561669829222
Suspicious: 86 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1479, susp 0.9952561669829222
Suspicious: 87 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1503, susp 0.9952561669829222
Suspicious: 88 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1504, susp 0.9952561669829222
Suspicious: 89 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1518, susp 0.9952561669829222
Suspicious: 90 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1521, susp 0.9952561669829222
Suspicious: 91 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1522, susp 0.9952561669829222
Suspicious: 92 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1524, susp 0.9952561669829222
Suspicious: 93 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1027, susp 0.9929010884997634
Suspicious: 94 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1028, susp 0.9929010884997634
Suspicious: 95 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1029, susp 0.9929010884997634
Suspicious: 96 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1030, susp 0.9929010884997634
Suspicious: 97 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1034, susp 0.9929010884997634
Suspicious: 98 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1035, susp 0.9929010884997634
Suspicious: 99 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1036, susp 0.9929010884997634
Suspicious: 100 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1356, susp 0.9929010884997634
Suspicious: 101 line org.apache.commons.math.linear.EigenDecompositionImpl l: 191, susp 0.9924314096499528
Suspicious: 102 line org.apache.commons.math.linear.EigenDecompositionImpl l: 193, susp 0.9924314096499528
Suspicious: 103 line org.apache.commons.math.linear.EigenDecompositionImpl l: 194, susp 0.9924314096499528
Suspicious: 104 line org.apache.commons.math.linear.EigenDecompositionImpl l: 195, susp 0.9924314096499528
Suspicious: 105 line org.apache.commons.math.linear.EigenDecompositionImpl l: 198, susp 0.9924314096499528
Suspicious: 106 line org.apache.commons.math.linear.EigenDecompositionImpl l: 199, susp 0.9924314096499528
Suspicious: 107 line org.apache.commons.math.linear.EigenDecompositionImpl l: 200, susp 0.9924314096499528
Suspicious: 108 line org.apache.commons.math.linear.EigenDecompositionImpl l: 201, susp 0.9924314096499528
Suspicious: 109 line org.apache.commons.math.linear.EigenDecompositionImpl l: 204, susp 0.9924314096499528
Suspicious: 110 line org.apache.commons.math.linear.EigenDecompositionImpl l: 205, susp 0.9924314096499528
Suspicious: 111 line org.apache.commons.math.linear.EigenDecompositionImpl l: 207, susp 0.9924314096499528
Suspicious: 112 line org.apache.commons.math.linear.EigenDecompositionImpl l: 644, susp 0.9924314096499528
Suspicious: 113 line org.apache.commons.math.linear.EigenDecompositionImpl l: 645, susp 0.9924314096499528
Suspicious: 114 line org.apache.commons.math.linear.EigenDecompositionImpl l: 646, susp 0.9924314096499528
Suspicious: 115 line org.apache.commons.math.linear.EigenDecompositionImpl l: 647, susp 0.9924314096499528
Suspicious: 116 line org.apache.commons.math.linear.EigenDecompositionImpl l: 648, susp 0.9924314096499528
Suspicious: 117 line org.apache.commons.math.linear.EigenDecompositionImpl l: 649, susp 0.9924314096499528
Suspicious: 118 line org.apache.commons.math.linear.EigenDecompositionImpl l: 650, susp 0.9924314096499528
Suspicious: 119 line org.apache.commons.math.linear.EigenDecompositionImpl l: 652, susp 0.9924314096499528
Suspicious: 120 line org.apache.commons.math.linear.EigenDecompositionImpl l: 655, susp 0.9924314096499528
Suspicious: 121 line org.apache.commons.math.linear.EigenDecompositionImpl l: 658, susp 0.9924314096499528
Suspicious: 122 line org.apache.commons.math.linear.EigenDecompositionImpl l: 661, susp 0.9924314096499528
Suspicious: 123 line org.apache.commons.math.linear.EigenDecompositionImpl l: 827, susp 0.9924314096499528
Suspicious: 124 line org.apache.commons.math.linear.EigenDecompositionImpl l: 828, susp 0.9924314096499528
Suspicious: 125 line org.apache.commons.math.linear.EigenDecompositionImpl l: 829, susp 0.9924314096499528
Suspicious: 126 line org.apache.commons.math.linear.EigenDecompositionImpl l: 830, susp 0.9924314096499528
Suspicious: 127 line org.apache.commons.math.linear.EigenDecompositionImpl l: 831, susp 0.9924314096499528
Suspicious: 128 line org.apache.commons.math.linear.EigenDecompositionImpl l: 834, susp 0.9924314096499528
Suspicious: 129 line org.apache.commons.math.linear.EigenDecompositionImpl l: 840, susp 0.9924314096499528
Suspicious: 130 line org.apache.commons.math.linear.EigenDecompositionImpl l: 843, susp 0.9924314096499528
Suspicious: 131 line org.apache.commons.math.linear.EigenDecompositionImpl l: 846, susp 0.9924314096499528
Suspicious: 132 line org.apache.commons.math.linear.EigenDecompositionImpl l: 847, susp 0.9924314096499528
Suspicious: 133 line org.apache.commons.math.linear.EigenDecompositionImpl l: 848, susp 0.9924314096499528
Suspicious: 134 line org.apache.commons.math.linear.EigenDecompositionImpl l: 849, susp 0.9924314096499528
Suspicious: 135 line org.apache.commons.math.linear.EigenDecompositionImpl l: 850, susp 0.9924314096499528
Suspicious: 136 line org.apache.commons.math.linear.EigenDecompositionImpl l: 851, susp 0.9924314096499528
Suspicious: 137 line org.apache.commons.math.linear.EigenDecompositionImpl l: 852, susp 0.9924314096499528
Suspicious: 138 line org.apache.commons.math.linear.EigenDecompositionImpl l: 855, susp 0.9924314096499528
Suspicious: 139 line org.apache.commons.math.linear.EigenDecompositionImpl l: 856, susp 0.9924314096499528
Suspicious: 140 line org.apache.commons.math.linear.EigenDecompositionImpl l: 857, susp 0.9924314096499528
Suspicious: 141 line org.apache.commons.math.linear.EigenDecompositionImpl l: 860, susp 0.9924314096499528
Suspicious: 142 line org.apache.commons.math.linear.EigenDecompositionImpl l: 861, susp 0.9924314096499528
Suspicious: 143 line org.apache.commons.math.linear.EigenDecompositionImpl l: 864, susp 0.9924314096499528
Suspicious: 144 line org.apache.commons.math.linear.EigenDecompositionImpl l: 865, susp 0.9924314096499528
Suspicious: 145 line org.apache.commons.math.linear.EigenDecompositionImpl l: 866, susp 0.9924314096499528
Suspicious: 146 line org.apache.commons.math.linear.EigenDecompositionImpl l: 867, susp 0.9924314096499528
Suspicious: 147 line org.apache.commons.math.linear.EigenDecompositionImpl l: 868, susp 0.9924314096499528
Suspicious: 148 line org.apache.commons.math.linear.EigenDecompositionImpl l: 869, susp 0.9924314096499528
Suspicious: 149 line org.apache.commons.math.linear.EigenDecompositionImpl l: 870, susp 0.9924314096499528
Suspicious: 150 line org.apache.commons.math.linear.EigenDecompositionImpl l: 874, susp 0.9924314096499528
Suspicious: 151 line org.apache.commons.math.linear.EigenDecompositionImpl l: 875, susp 0.9924314096499528
Suspicious: 152 line org.apache.commons.math.linear.EigenDecompositionImpl l: 876, susp 0.9924314096499528
Suspicious: 153 line org.apache.commons.math.linear.EigenDecompositionImpl l: 878, susp 0.9924314096499528
Suspicious: 154 line org.apache.commons.math.linear.EigenDecompositionImpl l: 879, susp 0.9924314096499528
Suspicious: 155 line org.apache.commons.math.linear.EigenDecompositionImpl l: 881, susp 0.9924314096499528
Suspicious: 156 line org.apache.commons.math.linear.EigenDecompositionImpl l: 884, susp 0.9924314096499528
Suspicious: 157 line org.apache.commons.math.linear.EigenDecompositionImpl l: 886, susp 0.9924314096499528
Suspicious: 158 line org.apache.commons.math.linear.EigenDecompositionImpl l: 887, susp 0.9924314096499528
Suspicious: 159 line org.apache.commons.math.linear.EigenDecompositionImpl l: 888, susp 0.9924314096499528
Suspicious: 160 line org.apache.commons.math.linear.EigenDecompositionImpl l: 889, susp 0.9924314096499528
Suspicious: 161 line org.apache.commons.math.linear.EigenDecompositionImpl l: 894, susp 0.9924314096499528
Suspicious: 162 line org.apache.commons.math.linear.EigenDecompositionImpl l: 895, susp 0.9924314096499528
Suspicious: 163 line org.apache.commons.math.linear.EigenDecompositionImpl l: 899, susp 0.9924314096499528
Suspicious: 164 line org.apache.commons.math.linear.EigenDecompositionImpl l: 927, susp 0.9924314096499528
Suspicious: 165 line org.apache.commons.math.linear.EigenDecompositionImpl l: 929, susp 0.9924314096499528
Suspicious: 166 line org.apache.commons.math.linear.EigenDecompositionImpl l: 937, susp 0.9924314096499528
Suspicious: 167 line org.apache.commons.math.linear.EigenDecompositionImpl l: 938, susp 0.9924314096499528
Suspicious: 168 line org.apache.commons.math.linear.EigenDecompositionImpl l: 941, susp 0.9924314096499528
Suspicious: 169 line org.apache.commons.math.linear.EigenDecompositionImpl l: 942, susp 0.9924314096499528
Suspicious: 170 line org.apache.commons.math.linear.EigenDecompositionImpl l: 943, susp 0.9924314096499528
Suspicious: 171 line org.apache.commons.math.linear.EigenDecompositionImpl l: 947, susp 0.9924314096499528
Suspicious: 172 line org.apache.commons.math.linear.EigenDecompositionImpl l: 952, susp 0.9924314096499528
Suspicious: 173 line org.apache.commons.math.linear.EigenDecompositionImpl l: 953, susp 0.9924314096499528
Suspicious: 174 line org.apache.commons.math.linear.EigenDecompositionImpl l: 954, susp 0.9924314096499528
Suspicious: 175 line org.apache.commons.math.linear.EigenDecompositionImpl l: 955, susp 0.9924314096499528
Suspicious: 176 line org.apache.commons.math.linear.EigenDecompositionImpl l: 956, susp 0.9924314096499528
Suspicious: 177 line org.apache.commons.math.linear.EigenDecompositionImpl l: 961, susp 0.9924314096499528
Suspicious: 178 line org.apache.commons.math.linear.EigenDecompositionImpl l: 963, susp 0.9924314096499528
Suspicious: 179 line org.apache.commons.math.linear.EigenDecompositionImpl l: 964, susp 0.9924314096499528
Suspicious: 180 line org.apache.commons.math.linear.EigenDecompositionImpl l: 965, susp 0.9924314096499528
Suspicious: 181 line org.apache.commons.math.linear.EigenDecompositionImpl l: 966, susp 0.9924314096499528
Suspicious: 182 line org.apache.commons.math.linear.EigenDecompositionImpl l: 971, susp 0.9924314096499528
Suspicious: 183 line org.apache.commons.math.linear.EigenDecompositionImpl l: 974, susp 0.9924314096499528
Suspicious: 184 line org.apache.commons.math.linear.EigenDecompositionImpl l: 978, susp 0.9924314096499528
Suspicious: 185 line org.apache.commons.math.linear.EigenDecompositionImpl l: 993, susp 0.9924314096499528
Suspicious: 186 line org.apache.commons.math.linear.EigenDecompositionImpl l: 996, susp 0.9924314096499528
Suspicious: 187 line org.apache.commons.math.linear.EigenDecompositionImpl l: 997, susp 0.9924314096499528
Suspicious: 188 line org.apache.commons.math.linear.EigenDecompositionImpl l: 999, susp 0.9924314096499528
Suspicious: 189 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1001, susp 0.9924314096499528
Suspicious: 190 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1004, susp 0.9924314096499528
Suspicious: 191 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1006, susp 0.9924314096499528
Suspicious: 192 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1012, susp 0.9924314096499528
Suspicious: 193 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1013, susp 0.9924314096499528
Suspicious: 194 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1015, susp 0.9924314096499528
Suspicious: 195 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1020, susp 0.9924314096499528
Suspicious: 196 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1026, susp 0.9924314096499528
Suspicious: 197 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1038, susp 0.9924314096499528
Suspicious: 198 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1039, susp 0.9924314096499528
Suspicious: 199 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1040, susp 0.9924314096499528
Suspicious: 200 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1044, susp 0.9924314096499528
Suspicious: 201 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1048, susp 0.9924314096499528
Suspicious: 202 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1050, susp 0.9924314096499528
Suspicious: 203 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1053, susp 0.9924314096499528
Suspicious: 204 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1054, susp 0.9924314096499528
Suspicious: 205 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1067, susp 0.9924314096499528
Suspicious: 206 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1068, susp 0.9924314096499528
Suspicious: 207 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1069, susp 0.9924314096499528
Suspicious: 208 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1072, susp 0.9924314096499528
Suspicious: 209 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1075, susp 0.9924314096499528
Suspicious: 210 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1078, susp 0.9924314096499528
Suspicious: 211 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1081, susp 0.9924314096499528
Suspicious: 212 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1083, susp 0.9924314096499528
Suspicious: 213 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1084, susp 0.9924314096499528
Suspicious: 214 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1119, susp 0.9924314096499528
Suspicious: 215 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1121, susp 0.9924314096499528
Suspicious: 216 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1133, susp 0.9924314096499528
Suspicious: 217 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1146, susp 0.9924314096499528
Suspicious: 218 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1158, susp 0.9924314096499528
Suspicious: 219 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1159, susp 0.9924314096499528
Suspicious: 220 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1160, susp 0.9924314096499528
Suspicious: 221 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1161, susp 0.9924314096499528
Suspicious: 222 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1162, susp 0.9924314096499528
Suspicious: 223 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1163, susp 0.9924314096499528
Suspicious: 224 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1164, susp 0.9924314096499528
Suspicious: 225 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1168, susp 0.9924314096499528
Suspicious: 226 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1169, susp 0.9924314096499528
Suspicious: 227 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1170, susp 0.9924314096499528
Suspicious: 228 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1171, susp 0.9924314096499528
Suspicious: 229 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1172, susp 0.9924314096499528
Suspicious: 230 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1173, susp 0.9924314096499528
Suspicious: 231 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1176, susp 0.9924314096499528
Suspicious: 232 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1177, susp 0.9924314096499528
Suspicious: 233 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1178, susp 0.9924314096499528
Suspicious: 234 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1180, susp 0.9924314096499528
Suspicious: 235 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1181, susp 0.9924314096499528
Suspicious: 236 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1182, susp 0.9924314096499528
Suspicious: 237 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1184, susp 0.9924314096499528
Suspicious: 238 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1187, susp 0.9924314096499528
Suspicious: 239 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1188, susp 0.9924314096499528
Suspicious: 240 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1189, susp 0.9924314096499528
Suspicious: 241 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1191, susp 0.9924314096499528
Suspicious: 242 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1195, susp 0.9924314096499528
Suspicious: 243 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1198, susp 0.9924314096499528
Suspicious: 244 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1199, susp 0.9924314096499528
Suspicious: 245 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1200, susp 0.9924314096499528
Suspicious: 246 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1202, susp 0.9924314096499528
Suspicious: 247 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1203, susp 0.9924314096499528
Suspicious: 248 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1204, susp 0.9924314096499528
Suspicious: 249 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1206, susp 0.9924314096499528
Suspicious: 250 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1209, susp 0.9924314096499528
Suspicious: 251 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1210, susp 0.9924314096499528
Suspicious: 252 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1211, susp 0.9924314096499528
Suspicious: 253 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1213, susp 0.9924314096499528
Suspicious: 254 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1217, susp 0.9924314096499528
Suspicious: 255 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1219, susp 0.9924314096499528
Suspicious: 256 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1231, susp 0.9924314096499528
Suspicious: 257 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1232, susp 0.9924314096499528
Suspicious: 258 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1233, susp 0.9924314096499528
Suspicious: 259 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1234, susp 0.9924314096499528
Suspicious: 260 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1235, susp 0.9924314096499528
Suspicious: 261 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1236, susp 0.9924314096499528
Suspicious: 262 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1239, susp 0.9924314096499528
Suspicious: 263 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1254, susp 0.9924314096499528
Suspicious: 264 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1255, susp 0.9924314096499528
Suspicious: 265 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1256, susp 0.9924314096499528
Suspicious: 266 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1257, susp 0.9924314096499528
Suspicious: 267 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1258, susp 0.9924314096499528
Suspicious: 268 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1259, susp 0.9924314096499528
Suspicious: 269 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1260, susp 0.9924314096499528
Suspicious: 270 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1261, susp 0.9924314096499528
Suspicious: 271 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1262, susp 0.9924314096499528
Suspicious: 272 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1264, susp 0.9924314096499528
Suspicious: 273 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1274, susp 0.9924314096499528
Suspicious: 274 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1275, susp 0.9924314096499528
Suspicious: 275 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1276, susp 0.9924314096499528
Suspicious: 276 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1277, susp 0.9924314096499528
Suspicious: 277 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1279, susp 0.9924314096499528
Suspicious: 278 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1280, susp 0.9924314096499528
Suspicious: 279 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1289, susp 0.9924314096499528
Suspicious: 280 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1300, susp 0.9924314096499528
Suspicious: 281 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1301, susp 0.9924314096499528
Suspicious: 282 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1302, susp 0.9924314096499528
Suspicious: 283 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1303, susp 0.9924314096499528
Suspicious: 284 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1304, susp 0.9924314096499528
Suspicious: 285 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1305, susp 0.9924314096499528
Suspicious: 286 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1306, susp 0.9924314096499528
Suspicious: 287 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1307, susp 0.9924314096499528
Suspicious: 288 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1309, susp 0.9924314096499528
Suspicious: 289 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1310, susp 0.9924314096499528
Suspicious: 290 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1311, susp 0.9924314096499528
Suspicious: 291 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1312, susp 0.9924314096499528
Suspicious: 292 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1313, susp 0.9924314096499528
Suspicious: 293 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1314, susp 0.9924314096499528
Suspicious: 294 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1315, susp 0.9924314096499528
Suspicious: 295 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1317, susp 0.9924314096499528
Suspicious: 296 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1318, susp 0.9924314096499528
Suspicious: 297 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1320, susp 0.9924314096499528
Suspicious: 298 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1331, susp 0.9924314096499528
Suspicious: 299 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1332, susp 0.9924314096499528
Suspicious: 300 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1333, susp 0.9924314096499528
Suspicious: 301 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1335, susp 0.9924314096499528
Suspicious: 302 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1336, susp 0.9924314096499528
Suspicious: 303 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1337, susp 0.9924314096499528
Suspicious: 304 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1338, susp 0.9924314096499528
Suspicious: 305 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1343, susp 0.9924314096499528
Suspicious: 306 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1345, susp 0.9924314096499528
Suspicious: 307 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1346, susp 0.9924314096499528
Suspicious: 308 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1347, susp 0.9924314096499528
Suspicious: 309 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1348, susp 0.9924314096499528
Suspicious: 310 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1352, susp 0.9924314096499528
Suspicious: 311 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1353, susp 0.9924314096499528
Suspicious: 312 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1378, susp 0.9924314096499528
Suspicious: 313 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1379, susp 0.9924314096499528
Suspicious: 314 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1380, susp 0.9924314096499528
Suspicious: 315 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1381, susp 0.9924314096499528
Suspicious: 316 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1382, susp 0.9924314096499528
Suspicious: 317 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1383, susp 0.9924314096499528
Suspicious: 318 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1388, susp 0.9924314096499528
Suspicious: 319 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1390, susp 0.9924314096499528
Suspicious: 320 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1391, susp 0.9924314096499528
Suspicious: 321 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1392, susp 0.9924314096499528
Suspicious: 322 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1393, susp 0.9924314096499528
Suspicious: 323 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1397, susp 0.9924314096499528
Suspicious: 324 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1399, susp 0.9924314096499528
Suspicious: 325 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1400, susp 0.9924314096499528
Suspicious: 326 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1401, susp 0.9924314096499528
Suspicious: 327 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1402, susp 0.9924314096499528
Suspicious: 328 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1403, susp 0.9924314096499528
Suspicious: 329 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1408, susp 0.9924314096499528
Suspicious: 330 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1410, susp 0.9924314096499528
Suspicious: 331 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1411, susp 0.9924314096499528
Suspicious: 332 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1412, susp 0.9924314096499528
Suspicious: 333 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1413, susp 0.9924314096499528
Suspicious: 334 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1417, susp 0.9924314096499528
Suspicious: 335 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1419, susp 0.9924314096499528
Suspicious: 336 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1420, susp 0.9924314096499528
Suspicious: 337 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1422, susp 0.9924314096499528
Suspicious: 338 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1433, susp 0.9924314096499528
Suspicious: 339 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1434, susp 0.9924314096499528
Suspicious: 340 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1435, susp 0.9924314096499528
Suspicious: 341 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1439, susp 0.9924314096499528
Suspicious: 342 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1445, susp 0.9924314096499528
Suspicious: 343 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1446, susp 0.9924314096499528
Suspicious: 344 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1449, susp 0.9924314096499528
Suspicious: 345 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1451, susp 0.9924314096499528
Suspicious: 346 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1452, susp 0.9924314096499528
Suspicious: 347 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1453, susp 0.9924314096499528
Suspicious: 348 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1455, susp 0.9924314096499528
Suspicious: 349 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1457, susp 0.9924314096499528
Suspicious: 350 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1458, susp 0.9924314096499528
Suspicious: 351 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1459, susp 0.9924314096499528
Suspicious: 352 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1460, susp 0.9924314096499528
Suspicious: 353 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1461, susp 0.9924314096499528
Suspicious: 354 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1473, susp 0.9924314096499528
Suspicious: 355 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1527, susp 0.9924314096499528
Suspicious: 356 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1673, susp 0.9924314096499528
Suspicious: 357 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1683, susp 0.9924314096499528
Suspicious: 358 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1684, susp 0.9924314096499528
Suspicious: 359 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1685, susp 0.9924314096499528
Suspicious: 360 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1686, susp 0.9924314096499528
Suspicious: 361 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1687, susp 0.9924314096499528
Suspicious: 362 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1688, susp 0.9924314096499528
Suspicious: 363 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1689, susp 0.9924314096499528
Suspicious: 364 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1690, susp 0.9924314096499528
Suspicious: 365 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1691, susp 0.9924314096499528
Suspicious: 366 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1693, susp 0.9924314096499528
Suspicious: 367 line org.apache.commons.math.linear.EigenDecompositionImpl l: 312, susp 0.9900896649362906
Suspicious: 368 line org.apache.commons.math.linear.ArrayRealVector l: 884, susp 0.9900896649362906
Suspicious: 369 line org.apache.commons.math.linear.ArrayRealVector l: 885, susp 0.9900896649362906
Suspicious: 370 line org.apache.commons.math.linear.ArrayRealVector l: 886, susp 0.9900896649362906
Suspicious: 371 line org.apache.commons.math.linear.ArrayRealVector l: 887, susp 0.9900896649362906
Suspicious: 372 line org.apache.commons.math.linear.ArrayRealVector l: 889, susp 0.9900896649362906
Suspicious: 373 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1751, susp 0.9900896649362906
Suspicious: 374 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1752, susp 0.9900896649362906
Suspicious: 375 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1770, susp 0.9900896649362906
Suspicious: 376 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1771, susp 0.9900896649362906
Suspicious: 377 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1772, susp 0.9900896649362906
Suspicious: 378 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1700, susp 0.9896226415094339
Suspicious: 379 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1701, susp 0.9896226415094339
Suspicious: 380 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1704, susp 0.9896226415094339
Suspicious: 381 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1705, susp 0.9896226415094339
Suspicious: 382 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1707, susp 0.9896226415094339
Suspicious: 383 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1708, susp 0.9896226415094339
Suspicious: 384 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1709, susp 0.9896226415094339
Suspicious: 385 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1710, susp 0.9896226415094339
Suspicious: 386 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1711, susp 0.9896226415094339
Suspicious: 387 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1712, susp 0.9896226415094339
Suspicious: 388 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1713, susp 0.9896226415094339
Suspicious: 389 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1714, susp 0.9896226415094339
Suspicious: 390 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1715, susp 0.9896226415094339
Suspicious: 391 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1719, susp 0.9896226415094339
Suspicious: 392 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1720, susp 0.9896226415094339
Suspicious: 393 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1723, susp 0.9896226415094339
Suspicious: 394 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1739, susp 0.9896226415094339
Suspicious: 395 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1740, susp 0.9896226415094339
Suspicious: 396 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1741, susp 0.9896226415094339
Suspicious: 397 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1745, susp 0.9896226415094339
Suspicious: 398 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1746, susp 0.9896226415094339
Suspicious: 399 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1747, susp 0.9896226415094339
Suspicious: 400 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1748, susp 0.9896226415094339
Suspicious: 401 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1749, susp 0.9896226415094339
Suspicious: 402 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1750, susp 0.9896226415094339
Suspicious: 403 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1754, susp 0.9896226415094339
Suspicious: 404 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1759, susp 0.9896226415094339
Suspicious: 405 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1760, susp 0.9896226415094339
Suspicious: 406 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1761, susp 0.9896226415094339
Suspicious: 407 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1762, susp 0.9896226415094339
Suspicious: 408 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1763, susp 0.9896226415094339
Suspicious: 409 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1764, susp 0.9896226415094339
Suspicious: 410 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1765, susp 0.9896226415094339
Suspicious: 411 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1766, susp 0.9896226415094339
Suspicious: 412 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1768, susp 0.9896226415094339
Suspicious: 413 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1769, susp 0.9896226415094339
Suspicious: 414 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1776, susp 0.9896226415094339
Suspicious: 415 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1777, susp 0.9896226415094339
Suspicious: 416 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1778, susp 0.9896226415094339
Suspicious: 417 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1781, susp 0.9896226415094339
Suspicious: 418 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1797, susp 0.9896226415094339
Suspicious: 419 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1798, susp 0.9896226415094339
Suspicious: 420 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1799, susp 0.9896226415094339
Suspicious: 421 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1800, susp 0.9896226415094339
Suspicious: 422 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1801, susp 0.9896226415094339
Suspicious: 423 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1802, susp 0.9896226415094339
Suspicious: 424 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1803, susp 0.9896226415094339
Suspicious: 425 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1804, susp 0.9896226415094339
Suspicious: 426 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1805, susp 0.9896226415094339
Suspicious: 427 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1806, susp 0.9896226415094339
Suspicious: 428 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1807, susp 0.9896226415094339
Suspicious: 429 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1808, susp 0.9896226415094339
Suspicious: 430 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1809, susp 0.9896226415094339
Suspicious: 431 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1811, susp 0.9896226415094339
Suspicious: 432 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1812, susp 0.9896226415094339
Suspicious: 433 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1813, susp 0.9896226415094339
Suspicious: 434 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1825, susp 0.9896226415094339
Suspicious: 435 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1826, susp 0.9896226415094339
Suspicious: 436 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1827, susp 0.9896226415094339
Suspicious: 437 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1828, susp 0.9896226415094339
Suspicious: 438 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1829, susp 0.9896226415094339
Suspicious: 439 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1830, susp 0.9896226415094339
Suspicious: 440 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1831, susp 0.9896226415094339
Suspicious: 441 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1832, susp 0.9896226415094339
Suspicious: 442 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1833, susp 0.9896226415094339
Suspicious: 443 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1834, susp 0.9896226415094339
Suspicious: 444 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1835, susp 0.9896226415094339
Suspicious: 445 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1836, susp 0.9896226415094339
Suspicious: 446 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1837, susp 0.9896226415094339
Suspicious: 447 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1839, susp 0.9896226415094339
Suspicious: 448 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1840, susp 0.9896226415094339
Suspicious: 449 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1841, susp 0.9896226415094339
Suspicious: 450 line org.apache.commons.math.linear.EigenDecompositionImpl l: 581, susp 0.9840525328330205
Suspicious: 451 line org.apache.commons.math.linear.EigenDecompositionImpl l: 582, susp 0.9840525328330205
Suspicious: 452 line org.apache.commons.math.linear.EigenDecompositionImpl l: 583, susp 0.9840525328330205
Suspicious: 453 line org.apache.commons.math.linear.EigenDecompositionImpl l: 584, susp 0.9840525328330205
Suspicious: 454 line org.apache.commons.math.linear.EigenDecompositionImpl l: 585, susp 0.9840525328330205
Suspicious: 455 line org.apache.commons.math.linear.EigenDecompositionImpl l: 587, susp 0.9840525328330205
Suspicious: 456 line org.apache.commons.math.linear.EigenDecompositionImpl l: 588, susp 0.9840525328330205
Suspicious: 457 line org.apache.commons.math.linear.EigenDecompositionImpl l: 589, susp 0.9840525328330205
Suspicious: 458 line org.apache.commons.math.linear.EigenDecompositionImpl l: 591, susp 0.9840525328330205
Suspicious: 459 line org.apache.commons.math.linear.EigenDecompositionImpl l: 592, susp 0.9840525328330205
Suspicious: 460 line org.apache.commons.math.linear.EigenDecompositionImpl l: 593, susp 0.9840525328330205
Suspicious: 461 line org.apache.commons.math.linear.EigenDecompositionImpl l: 679, susp 0.9840525328330205
Suspicious: 462 line org.apache.commons.math.linear.EigenDecompositionImpl l: 680, susp 0.9840525328330205
Suspicious: 463 line org.apache.commons.math.linear.EigenDecompositionImpl l: 681, susp 0.9840525328330205
Suspicious: 464 line org.apache.commons.math.linear.EigenDecompositionImpl l: 682, susp 0.9840525328330205
Suspicious: 465 line org.apache.commons.math.linear.EigenDecompositionImpl l: 698, susp 0.9840525328330205
Suspicious: 466 line org.apache.commons.math.linear.EigenDecompositionImpl l: 699, susp 0.9840525328330205
Suspicious: 467 line org.apache.commons.math.linear.EigenDecompositionImpl l: 700, susp 0.9840525328330205
Suspicious: 468 line org.apache.commons.math.linear.EigenDecompositionImpl l: 701, susp 0.9840525328330205
Suspicious: 469 line org.apache.commons.math.linear.EigenDecompositionImpl l: 237, susp 0.9835911861228316
Suspicious: 470 line org.apache.commons.math.linear.EigenDecompositionImpl l: 238, susp 0.9835911861228316
Suspicious: 471 line org.apache.commons.math.linear.EigenDecompositionImpl l: 239, susp 0.9835911861228316
Suspicious: 472 line org.apache.commons.math.linear.EigenDecompositionImpl l: 240, susp 0.9835911861228316
Suspicious: 473 line org.apache.commons.math.linear.EigenDecompositionImpl l: 243, susp 0.9835911861228316
Suspicious: 474 line org.apache.commons.math.linear.EigenDecompositionImpl l: 246, susp 0.9835911861228316
Suspicious: 475 line org.apache.commons.math.linear.EigenDecompositionImpl l: 249, susp 0.9835911861228316
Suspicious: 476 line org.apache.commons.math.linear.EigenDecompositionImpl l: 251, susp 0.9835911861228316
Suspicious: 477 line org.apache.commons.math.linear.ArrayRealVector l: 269, susp 0.9835911861228316
Suspicious: 478 line org.apache.commons.math.linear.EigenDecompositionImpl l: 571, susp 0.9835911861228316
Suspicious: 479 line org.apache.commons.math.linear.EigenDecompositionImpl l: 572, susp 0.9835911861228316
Suspicious: 480 line org.apache.commons.math.linear.EigenDecompositionImpl l: 573, susp 0.9835911861228316
Suspicious: 481 line org.apache.commons.math.linear.EigenDecompositionImpl l: 574, susp 0.9835911861228316
Suspicious: 482 line org.apache.commons.math.linear.EigenDecompositionImpl l: 575, susp 0.9835911861228316
Suspicious: 483 line org.apache.commons.math.linear.EigenDecompositionImpl l: 576, susp 0.9835911861228316
Suspicious: 484 line org.apache.commons.math.linear.EigenDecompositionImpl l: 578, susp 0.9835911861228316
Suspicious: 485 line org.apache.commons.math.linear.EigenDecompositionImpl l: 579, susp 0.9835911861228316
Suspicious: 486 line org.apache.commons.math.linear.EigenDecompositionImpl l: 597, susp 0.9835911861228316
Suspicious: 487 line org.apache.commons.math.linear.EigenDecompositionImpl l: 598, susp 0.9835911861228316
Suspicious: 488 line org.apache.commons.math.linear.EigenDecompositionImpl l: 599, susp 0.9835911861228316
Suspicious: 489 line org.apache.commons.math.linear.EigenDecompositionImpl l: 600, susp 0.9835911861228316
Suspicious: 490 line org.apache.commons.math.linear.EigenDecompositionImpl l: 601, susp 0.9835911861228316
Suspicious: 491 line org.apache.commons.math.linear.EigenDecompositionImpl l: 602, susp 0.9835911861228316
Suspicious: 492 line org.apache.commons.math.linear.EigenDecompositionImpl l: 603, susp 0.9835911861228316
Suspicious: 493 line org.apache.commons.math.linear.EigenDecompositionImpl l: 604, susp 0.9835911861228316
Suspicious: 494 line org.apache.commons.math.linear.EigenDecompositionImpl l: 606, susp 0.9835911861228316
Suspicious: 495 line org.apache.commons.math.linear.EigenDecompositionImpl l: 616, susp 0.9835911861228316
Suspicious: 496 line org.apache.commons.math.linear.EigenDecompositionImpl l: 619, susp 0.9835911861228316
Suspicious: 497 line org.apache.commons.math.linear.EigenDecompositionImpl l: 620, susp 0.9835911861228316
Suspicious: 498 line org.apache.commons.math.linear.EigenDecompositionImpl l: 621, susp 0.9835911861228316
Suspicious: 499 line org.apache.commons.math.linear.EigenDecompositionImpl l: 622, susp 0.9835911861228316
Suspicious: 500 line org.apache.commons.math.linear.EigenDecompositionImpl l: 623, susp 0.9835911861228316
Suspicious: 501 line org.apache.commons.math.linear.EigenDecompositionImpl l: 624, susp 0.9835911861228316
Suspicious: 502 line org.apache.commons.math.linear.EigenDecompositionImpl l: 672, susp 0.9835911861228316
Suspicious: 503 line org.apache.commons.math.linear.EigenDecompositionImpl l: 673, susp 0.9835911861228316
Suspicious: 504 line org.apache.commons.math.linear.EigenDecompositionImpl l: 676, susp 0.9835911861228316
Suspicious: 505 line org.apache.commons.math.linear.EigenDecompositionImpl l: 677, susp 0.9835911861228316
Suspicious: 506 line org.apache.commons.math.linear.EigenDecompositionImpl l: 678, susp 0.9835911861228316
Suspicious: 507 line org.apache.commons.math.linear.EigenDecompositionImpl l: 685, susp 0.9835911861228316
Suspicious: 508 line org.apache.commons.math.linear.EigenDecompositionImpl l: 693, susp 0.9835911861228316
Suspicious: 509 line org.apache.commons.math.linear.EigenDecompositionImpl l: 696, susp 0.9835911861228316
Suspicious: 510 line org.apache.commons.math.linear.EigenDecompositionImpl l: 697, susp 0.9835911861228316
Suspicious: 511 line org.apache.commons.math.linear.EigenDecompositionImpl l: 708, susp 0.9835911861228316
Suspicious: 512 line org.apache.commons.math.linear.EigenDecompositionImpl l: 709, susp 0.9835911861228316
Suspicious: 513 line org.apache.commons.math.linear.ArrayRealVector l: 283, susp 0.9831302717900655
Suspicious: 514 line org.apache.commons.math.linear.ArrayRealVector l: 284, susp 0.9831302717900655
Suspicious: 515 line org.apache.commons.math.linear.ArrayRealVector l: 285, susp 0.9831302717900655
Suspicious: 516 line org.apache.commons.math.linear.ArrayRealVector l: 286, susp 0.9831302717900655
Suspicious: 517 line org.apache.commons.math.linear.ArrayRealVector l: 288, susp 0.9831302717900655
Suspicious: 518 line org.apache.commons.math.linear.ArrayRealVector l: 299, susp 0.9831302717900655
Suspicious: 519 line org.apache.commons.math.linear.ArrayRealVector l: 1292, susp 0.9758139534883721
Suspicious: 520 line org.apache.commons.math.linear.ArrayRealVector l: 1287, susp 0.9753602975360298
Suspicious: 521 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 254, susp 0.9721964782205745
Suspicious: 522 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 271, susp 0.96726602120793
Suspicious: 523 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 273, susp 0.96726602120793
Suspicious: 524 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 274, susp 0.96726602120793
Suspicious: 525 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 275, susp 0.96726602120793
Suspicious: 526 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 276, susp 0.96726602120793
Suspicious: 527 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 277, susp 0.96726602120793
Suspicious: 528 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 278, susp 0.96726602120793
Suspicious: 529 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 279, susp 0.96726602120793
Suspicious: 530 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 280, susp 0.96726602120793
Suspicious: 531 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 281, susp 0.96726602120793
Suspicious: 532 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 282, susp 0.96726602120793
Suspicious: 533 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 283, susp 0.96726602120793
Suspicious: 534 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 285, susp 0.96726602120793
Suspicious: 535 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 289, susp 0.96726602120793
Suspicious: 536 line org.apache.commons.math.linear.AbstractRealMatrix l: 603, susp 0.9628269848554383
Suspicious: 537 line org.apache.commons.math.linear.AbstractRealMatrix l: 604, susp 0.9628269848554383
Suspicious: 538 line org.apache.commons.math.linear.AbstractRealMatrix l: 605, susp 0.9628269848554383
Suspicious: 539 line org.apache.commons.math.linear.AbstractRealMatrix l: 606, susp 0.9628269848554383
Suspicious: 540 line org.apache.commons.math.linear.AbstractRealMatrix$5 l: 606, susp 0.9628269848554383
Suspicious: 541 line org.apache.commons.math.linear.AbstractRealMatrix$5 l: 611, susp 0.9628269848554383
Suspicious: 542 line org.apache.commons.math.linear.AbstractRealMatrix$5 l: 612, susp 0.9628269848554383
Suspicious: 543 line org.apache.commons.math.linear.AbstractRealMatrix l: 616, susp 0.9628269848554383
Suspicious: 544 line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 35, susp 0.9615032080659947
Suspicious: 545 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 482, susp 0.961062757672927
Suspicious: 546 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 483, susp 0.961062757672927
Suspicious: 547 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 484, susp 0.961062757672927
Suspicious: 548 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 485, susp 0.961062757672927
Suspicious: 549 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 486, susp 0.961062757672927
Suspicious: 550 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 487, susp 0.961062757672927
Suspicious: 551 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 488, susp 0.961062757672927
Suspicious: 552 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 491, susp 0.961062757672927
Suspicious: 553 line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 30, susp 0.959304983996342
Suspicious: 554 line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 44, susp 0.959304983996342
Suspicious: 555 line org.apache.commons.math.linear.AbstractRealMatrix l: 919, susp 0.959304983996342
Suspicious: 556 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 160, susp 0.9588665447897623
Suspicious: 557 line org.apache.commons.math.linear.MatrixUtils l: 650, susp 0.9579908675799087
Suspicious: 558 line org.apache.commons.math.linear.MatrixUtils l: 656, susp 0.9579908675799087
Suspicious: 559 line org.apache.commons.math.linear.MatrixUtils l: 106, susp 0.9566803465572276
Suspicious: 560 line org.apache.commons.math.linear.ArrayRealVector l: 96, susp 0.947606142728094
Suspicious: 561 line org.apache.commons.math.linear.ArrayRealVector l: 97, susp 0.947606142728094
Suspicious: 562 line org.apache.commons.math.linear.ArrayRealVector l: 100, susp 0.947606142728094
Suspicious: 563 line org.apache.commons.math.linear.ArrayRealVector l: 103, susp 0.947606142728094
Suspicious: 564 line org.apache.commons.math.linear.ArrayRealVector l: 104, susp 0.947606142728094
Suspicious: 565 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 130, susp 0.947606142728094
Suspicious: 566 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 114, susp 0.9471783295711061
Suspicious: 567 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 115, susp 0.9471783295711061
Suspicious: 568 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 118, susp 0.9471783295711061
Suspicious: 569 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 121, susp 0.9471783295711061
Suspicious: 570 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 122, susp 0.9471783295711061
Suspicious: 571 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 125, susp 0.9471783295711061
Suspicious: 572 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 126, susp 0.9471783295711061
Suspicious: 573 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 129, susp 0.9471783295711061
Suspicious: 574 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 136, susp 0.9471783295711061
Suspicious: 575 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 138, susp 0.9471783295711061
Suspicious: 576 line org.apache.commons.math.linear.ArrayRealVector l: 77, susp 0.9387024608501118
Suspicious: 577 line org.apache.commons.math.linear.ArrayRealVector l: 78, susp 0.9387024608501118
Suspicious: 578 line org.apache.commons.math.linear.ArrayRealVector l: 79, susp 0.9387024608501118
Suspicious: 579 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 76, susp 0.9270879363676535
Suspicious: 580 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 77, susp 0.9270879363676535
Suspicious: 581 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 78, susp 0.9270879363676535
Suspicious: 582 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 367, susp 0.9262693156732892
Suspicious: 583 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 372, susp 0.9262693156732892
Suspicious: 584 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 373, susp 0.9262693156732892
Suspicious: 585 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 94, susp 0.9250440917107584
Suspicious: 586 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 95, susp 0.9250440917107584
Suspicious: 587 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 96, susp 0.9250440917107584
Suspicious: 588 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 314, susp 0.9246364037020715
Suspicious: 589 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 315, susp 0.9246364037020715
Suspicious: 590 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 320, susp 0.9246364037020715
Suspicious: 591 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 325, susp 0.9246364037020715
Suspicious: 592 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 326, susp 0.9246364037020715
Suspicious: 593 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 330, susp 0.9246364037020715
Suspicious: 594 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 331, susp 0.9246364037020715
Suspicious: 595 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 334, susp 0.9246364037020715
Suspicious: 596 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 335, susp 0.9246364037020715
Suspicious: 597 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 336, susp 0.9246364037020715
Suspicious: 598 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 341, susp 0.9246364037020715
Suspicious: 599 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 343, susp 0.9246364037020715
Suspicious: 600 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 347, susp 0.9246364037020715
Suspicious: 601 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 622, susp 0.9246364037020715
Suspicious: 602 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 623, susp 0.9246364037020715
Suspicious: 603 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 410, susp 0.9047003018542475
Suspicious: 604 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 404, susp 0.9043103448275862
Suspicious: 605 line org.apache.commons.math.linear.AbstractRealMatrix l: 43, susp 0.8920068027210883
Suspicious: 606 line org.apache.commons.math.linear.AbstractRealMatrix l: 44, susp 0.8920068027210883
Suspicious: 607 line org.apache.commons.math.linear.AbstractRealMatrix l: 45, susp 0.8920068027210883
Suspicious: 608 line org.apache.commons.math.linear.AbstractRealMatrix l: 61, susp 0.8752607425949103
Suspicious: 609 line org.apache.commons.math.linear.AbstractRealMatrix l: 66, susp 0.8752607425949103
Suspicious: 610 line org.apache.commons.math.linear.AbstractRealMatrix l: 67, susp 0.8752607425949103
Suspicious: 611 line org.apache.commons.math.linear.AbstractRealMatrix l: 55, susp 0.8745310546060859
Suspicious: 612 line org.apache.commons.math.linear.AbstractRealMatrix l: 56, susp 0.8745310546060859
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 871, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 872, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 944, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 945, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 957, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 958, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 959, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 960, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1055, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1056, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1057, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1058, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1059, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1060, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1061, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1062, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1063, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1135, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1136, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1137, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1138, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1139, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1140, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1142, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1144, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1384, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1385, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1386, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1387, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1404, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1405, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1406, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1407, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1414, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1415, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1090, susp 0.9995235826584088
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1091, susp 0.9995235826584088
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1092, susp 0.9995235826584088
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1093, susp 0.9995235826584088
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 336, susp 0.9990476190476191
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 337, susp 0.9990476190476191
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 339, susp 0.9990476190476191
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1088, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1105, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1106, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1530, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1531, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1534, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1535, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1536, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1537, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1538, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1541, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1544, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1564, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1565, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1570, susp 0.9985721085197525
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 225, susp 0.9976224441274371
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 870, susp 0.9976224441274371
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 175, susp 0.9971482889733841
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 176, susp 0.9971482889733841
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 177, susp 0.9971482889733841
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 900, susp 0.9971482889733841
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1488, susp 0.9962013295346628
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1489, susp 0.9962013295346628
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1490, susp 0.9962013295346628
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1491, susp 0.9962013295346628
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1494, susp 0.9962013295346628
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1495, susp 0.9962013295346628
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1498, susp 0.9962013295346628
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1499, susp 0.9962013295346628
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1085, susp 0.9957285239677266
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1094, susp 0.9957285239677266
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1096, susp 0.9957285239677266
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1099, susp 0.9957285239677266
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1101, susp 0.9957285239677266
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1102, susp 0.9957285239677266
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 666, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 667, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 905, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 906, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 907, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 909, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1475, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1476, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1479, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1503, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1504, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1518, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1521, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1522, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1524, susp 0.9952561669829222
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1027, susp 0.9929010884997634
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1028, susp 0.9929010884997634
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1029, susp 0.9929010884997634
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1030, susp 0.9929010884997634
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1034, susp 0.9929010884997634
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1035, susp 0.9929010884997634
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1036, susp 0.9929010884997634
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1356, susp 0.9929010884997634
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 191, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 193, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 194, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 195, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 198, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 199, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 200, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 201, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 204, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 205, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 207, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 644, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 645, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 646, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 647, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 648, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 649, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 650, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 652, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 655, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 658, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 661, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 827, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 828, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 829, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 830, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 831, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 834, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 840, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 843, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 846, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 847, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 848, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 849, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 850, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 851, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 852, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 855, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 856, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 857, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 860, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 861, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 864, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 865, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 866, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 867, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 868, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 869, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 870, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 874, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 875, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 876, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 878, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 879, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 881, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 884, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 886, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 887, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 888, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 889, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 894, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 895, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 899, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 927, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 929, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 937, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 938, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 941, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 942, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 943, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 947, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 952, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 953, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 954, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 955, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 956, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 961, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 963, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 964, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 965, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 966, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 971, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 974, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 978, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 993, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 996, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 997, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 999, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1001, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1004, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1006, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1012, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1013, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1015, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1020, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1026, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1038, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1039, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1040, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1044, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1048, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1050, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1053, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1054, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1067, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1068, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1069, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1072, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1075, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1078, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1081, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1083, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1084, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1119, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1121, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1133, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1146, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1158, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1159, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1160, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1161, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1162, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1163, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1164, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1168, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1169, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1170, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1171, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1172, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1173, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1176, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1177, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1178, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1180, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1181, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1182, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1184, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1187, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1188, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1189, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1191, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1195, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1198, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1199, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1200, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1202, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1203, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1204, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1206, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1209, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1210, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1211, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1213, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1217, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1219, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1231, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1232, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1233, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1234, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1235, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1236, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1239, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1254, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1255, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1256, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1257, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1258, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1259, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1260, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1261, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1262, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1264, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1274, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1275, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1276, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1277, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1279, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1280, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1289, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1300, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1301, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1302, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1303, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1304, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1305, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1306, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1307, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1309, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1310, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1311, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1312, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1313, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1314, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1315, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1317, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1318, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1320, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1331, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1332, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1333, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1335, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1336, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1337, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1338, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1343, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1345, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1346, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1347, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1348, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1352, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1353, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1378, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1379, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1380, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1381, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1382, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1383, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1388, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1390, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1391, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1392, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1393, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1397, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1399, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1400, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1401, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1402, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1403, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1408, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1410, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1411, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1412, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1413, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1417, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1419, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1420, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1422, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1433, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1434, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1435, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1439, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1445, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1446, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1449, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1451, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1452, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1453, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1455, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1457, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1458, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1459, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1460, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1461, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1473, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1527, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1673, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1683, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1684, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1685, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1686, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1687, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1688, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1689, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1690, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1691, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1693, susp 0.9924314096499528
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 312, susp 0.9900896649362906
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 884, susp 0.9900896649362906
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 885, susp 0.9900896649362906
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 886, susp 0.9900896649362906
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 887, susp 0.9900896649362906
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 889, susp 0.9900896649362906
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1751, susp 0.9900896649362906
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1752, susp 0.9900896649362906
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1770, susp 0.9900896649362906
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1771, susp 0.9900896649362906
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1772, susp 0.9900896649362906
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1700, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1701, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1704, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1705, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1707, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1708, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1709, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1710, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1711, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1712, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1713, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1714, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1715, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1719, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1720, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1723, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1739, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1740, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1741, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1745, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1746, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1747, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1748, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1749, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1750, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1754, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1759, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1760, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1761, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1762, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1763, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1764, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1765, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1766, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1768, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1769, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1776, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1777, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1778, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1781, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1797, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1798, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1799, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1800, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1801, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1802, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1803, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1804, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1805, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1806, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1807, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1808, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1809, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1811, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1812, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1813, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1825, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1826, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1827, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1828, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1829, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1830, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1831, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1832, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1833, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1834, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1835, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1836, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1837, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1839, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1840, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1841, susp 0.9896226415094339
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 581, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 582, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 583, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 584, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 585, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 587, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 588, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 589, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 591, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 592, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 593, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 679, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 680, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 681, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 682, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 698, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 699, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 700, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 701, susp 0.9840525328330205
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 237, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 238, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 239, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 240, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 243, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 246, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 249, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 251, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 269, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 571, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 572, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 573, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 574, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 575, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 576, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 578, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 579, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 597, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 598, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 599, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 600, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 601, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 602, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 603, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 604, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 606, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 616, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 619, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 620, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 621, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 622, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 623, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 624, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 672, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 673, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 676, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 677, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 678, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 685, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 693, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 696, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 697, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 708, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 709, susp 0.9835911861228316
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 283, susp 0.9831302717900655
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 284, susp 0.9831302717900655
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 285, susp 0.9831302717900655
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 286, susp 0.9831302717900655
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 288, susp 0.9831302717900655
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 299, susp 0.9831302717900655
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 1292, susp 0.9758139534883721
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 1287, susp 0.9753602975360298
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 254, susp 0.9721964782205745
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 271, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 273, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 274, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 275, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 276, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 277, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 278, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 279, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 280, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 281, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 282, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 283, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 285, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 289, susp 0.96726602120793
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 603, susp 0.9628269848554383
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 604, susp 0.9628269848554383
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 605, susp 0.9628269848554383
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 606, susp 0.9628269848554383
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 606, susp 0.9628269848554383
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 611, susp 0.9628269848554383
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 612, susp 0.9628269848554383
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 616, susp 0.9628269848554383
Suspicious:  line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 35, susp 0.9615032080659947
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 482, susp 0.961062757672927
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 483, susp 0.961062757672927
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 484, susp 0.961062757672927
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 485, susp 0.961062757672927
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 486, susp 0.961062757672927
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 487, susp 0.961062757672927
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 488, susp 0.961062757672927
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 491, susp 0.961062757672927
Suspicious:  line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 30, susp 0.959304983996342
Suspicious:  line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 44, susp 0.959304983996342
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 919, susp 0.959304983996342
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 160, susp 0.9588665447897623
Suspicious:  line org.apache.commons.math.linear.MatrixUtils l: 650, susp 0.9579908675799087
Suspicious:  line org.apache.commons.math.linear.MatrixUtils l: 656, susp 0.9579908675799087
Suspicious:  line org.apache.commons.math.linear.MatrixUtils l: 106, susp 0.9566803465572276
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 96, susp 0.947606142728094
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 97, susp 0.947606142728094
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 100, susp 0.947606142728094
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 103, susp 0.947606142728094
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 104, susp 0.947606142728094
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 130, susp 0.947606142728094
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 114, susp 0.9471783295711061
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 115, susp 0.9471783295711061
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 118, susp 0.9471783295711061
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 121, susp 0.9471783295711061
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 122, susp 0.9471783295711061
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 125, susp 0.9471783295711061
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 126, susp 0.9471783295711061
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 129, susp 0.9471783295711061
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 136, susp 0.9471783295711061
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 138, susp 0.9471783295711061
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 77, susp 0.9387024608501118
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 78, susp 0.9387024608501118
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 79, susp 0.9387024608501118
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 76, susp 0.9270879363676535
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 77, susp 0.9270879363676535
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 78, susp 0.9270879363676535
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 367, susp 0.9262693156732892
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 372, susp 0.9262693156732892
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 373, susp 0.9262693156732892
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 94, susp 0.9250440917107584
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 95, susp 0.9250440917107584
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 96, susp 0.9250440917107584
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 314, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 315, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 320, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 325, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 326, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 330, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 331, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 334, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 335, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 336, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 341, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 343, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 347, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 622, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 623, susp 0.9246364037020715
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 410, susp 0.9047003018542475
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 404, susp 0.9043103448275862
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 43, susp 0.8920068027210883
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 44, susp 0.8920068027210883
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 45, susp 0.8920068027210883
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 61, susp 0.8752607425949103
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 66, susp 0.8752607425949103
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 67, susp 0.8752607425949103
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 55, susp 0.8745310546060859
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 56, susp 0.8745310546060859
Executing time Fault localization: 76 sec
Setting up the max to 765690 milliseconds (765 sec)
---- Initial suspicious size: 612
Creating variant 1
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 871, file EigenDecompositionImpl.java
--ModifPoint:CtBreakImpl, suspValue 1.0, line 872, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 944, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 945, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 957, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 958, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 959, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 960, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1055, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1056, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1059, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1062, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1063, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 1.0, line 1135, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 1.0, line 1136, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 1.0, line 1137, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 1.0, line 1138, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1139, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1140, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 1.0, line 1142, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 1.0, line 1144, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1384, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1385, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1386, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1387, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1404, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1405, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1406, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1407, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1414, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1415, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9995235826584088, line 1090, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9995235826584088, line 1091, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9995235826584088, line 1092, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9995235826584088, line 1093, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9990476190476191, line 336, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9990476190476191, line 337, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9990476190476191, line 339, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9985721085197525, line 1105, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9985721085197525, line 1106, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9985721085197525, line 1530, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9985721085197525, line 1531, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9985721085197525, line 1534, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9985721085197525, line 1535, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9985721085197525, line 1536, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9985721085197525, line 1537, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9985721085197525, line 1538, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9985721085197525, line 1541, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9985721085197525, line 1544, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9985721085197525, line 1564, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9985721085197525, line 1565, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9976224441274371, line 225, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9976224441274371, line 870, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9971482889733841, line 176, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9971482889733841, line 900, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9962013295346628, line 1488, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9962013295346628, line 1489, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9962013295346628, line 1490, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9962013295346628, line 1491, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9962013295346628, line 1494, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9962013295346628, line 1495, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9962013295346628, line 1498, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9962013295346628, line 1499, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9957285239677266, line 1085, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9957285239677266, line 1094, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9957285239677266, line 1096, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9957285239677266, line 1099, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9957285239677266, line 1101, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9957285239677266, line 1102, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9952561669829222, line 666, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9952561669829222, line 667, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9952561669829222, line 905, file ArrayRealVector.java
--ModifPoint:CtForEachImpl, suspValue 0.9952561669829222, line 906, file ArrayRealVector.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9952561669829222, line 907, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9952561669829222, line 909, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9952561669829222, line 1475, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9952561669829222, line 1476, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9952561669829222, line 1479, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9952561669829222, line 1503, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9952561669829222, line 1504, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9952561669829222, line 1518, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9952561669829222, line 1521, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9952561669829222, line 1522, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9952561669829222, line 1524, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9929010884997634, line 1027, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9929010884997634, line 1028, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9929010884997634, line 1029, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9929010884997634, line 1030, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9929010884997634, line 1034, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9929010884997634, line 1035, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9929010884997634, line 1036, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9929010884997634, line 1356, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 193, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 194, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 195, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 198, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 199, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 200, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 201, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 204, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9924314096499528, line 205, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 827, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 828, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 829, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 830, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9924314096499528, line 831, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 834, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9924314096499528, line 840, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9924314096499528, line 843, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 846, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 847, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 848, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 849, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 850, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 851, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 852, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 855, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 856, file EigenDecompositionImpl.java
--ModifPoint:CtWhileImpl, suspValue 0.9924314096499528, line 857, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 860, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 861, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 864, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 865, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 866, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 867, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 868, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 869, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 870, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 874, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 875, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 876, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 878, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 879, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 881, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 884, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 886, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 887, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 888, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 889, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 894, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 895, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 899, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 937, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 938, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 941, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 942, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 943, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9924314096499528, line 947, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 952, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 953, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 954, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 955, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 956, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 961, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 963, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 964, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9924314096499528, line 965, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 971, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 974, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 993, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 996, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 997, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 999, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9924314096499528, line 1001, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1004, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1006, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1012, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9924314096499528, line 1013, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1015, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1020, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1026, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1038, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1039, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9924314096499528, line 1040, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1044, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1050, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1053, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1054, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1067, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9924314096499528, line 1072, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 1075, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9924314096499528, line 1078, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1081, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9924314096499528, line 1083, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9924314096499528, line 1084, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9924314096499528, line 1119, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9924314096499528, line 1121, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1133, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9924314096499528, line 1146, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1158, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1159, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1160, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1161, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 1162, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1163, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1164, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1168, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1169, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1170, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1171, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1173, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1176, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1177, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 1178, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1180, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1181, file EigenDecompositionImpl.java
--ModifPoint:CtBreakImpl, suspValue 0.9924314096499528, line 1184, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1187, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1188, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1189, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1191, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1195, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1198, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1199, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 1200, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1202, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1203, file EigenDecompositionImpl.java
--ModifPoint:CtBreakImpl, suspValue 0.9924314096499528, line 1206, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1209, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1210, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1211, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1213, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1217, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9924314096499528, line 1219, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1231, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1232, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 1233, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1234, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1235, file EigenDecompositionImpl.java
--ModifPoint:CtUnaryOperatorImpl, suspValue 0.9924314096499528, line 1236, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9924314096499528, line 1239, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1254, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1255, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 1256, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1257, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1258, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1259, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1260, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1261, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1262, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1274, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1275, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1276, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1277, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1279, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 1280, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 1289, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1300, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1301, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1302, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1303, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1304, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1305, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1306, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1307, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1309, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1310, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1311, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1312, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1313, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1314, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1315, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1317, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1318, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1331, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1332, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1333, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1335, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9924314096499528, line 1336, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1337, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1338, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1343, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1345, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1346, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9924314096499528, line 1347, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1352, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1353, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1378, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1379, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1380, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1381, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1382, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1383, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1388, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1390, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1391, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1392, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1397, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1399, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1400, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1401, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1402, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1403, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1408, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1410, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1411, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1412, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1417, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1419, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1420, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1433, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1434, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1435, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1439, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1445, file EigenDecompositionImpl.java
--ModifPoint:CtSwitchImpl, suspValue 0.9924314096499528, line 1446, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1451, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1452, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1453, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1455, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1457, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1458, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1459, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1460, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1461, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1527, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9924314096499528, line 1683, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9924314096499528, line 1684, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1685, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9924314096499528, line 1686, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1687, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9924314096499528, line 1689, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9924314096499528, line 1690, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9924314096499528, line 1691, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9900896649362906, line 312, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9900896649362906, line 884, file ArrayRealVector.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9900896649362906, line 885, file ArrayRealVector.java
--ModifPoint:CtForImpl, suspValue 0.9900896649362906, line 886, file ArrayRealVector.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9900896649362906, line 887, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9900896649362906, line 889, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9900896649362906, line 1751, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9900896649362906, line 1752, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9900896649362906, line 1770, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9900896649362906, line 1771, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9900896649362906, line 1772, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1700, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1701, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1704, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1705, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1707, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1708, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1709, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9896226415094339, line 1710, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1711, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1712, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1713, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1714, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1715, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9896226415094339, line 1719, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1720, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1739, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9896226415094339, line 1740, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9896226415094339, line 1741, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1745, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1746, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1747, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9896226415094339, line 1748, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1749, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9896226415094339, line 1750, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9896226415094339, line 1754, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1759, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1760, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1761, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1762, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9896226415094339, line 1763, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9896226415094339, line 1764, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1765, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9896226415094339, line 1766, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1768, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9896226415094339, line 1769, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1776, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9896226415094339, line 1777, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9896226415094339, line 1778, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9896226415094339, line 1781, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1797, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1798, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1799, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9896226415094339, line 1800, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1801, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1802, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1803, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1804, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1805, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1806, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1807, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1808, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9896226415094339, line 1809, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1811, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1812, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1825, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1826, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1827, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9896226415094339, line 1828, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1829, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1830, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1831, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9896226415094339, line 1832, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1833, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1834, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1835, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1836, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9896226415094339, line 1837, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1839, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9896226415094339, line 1840, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9840525328330205, line 581, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9840525328330205, line 582, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9840525328330205, line 583, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9840525328330205, line 584, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9840525328330205, line 585, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9840525328330205, line 587, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9840525328330205, line 588, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9840525328330205, line 589, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9840525328330205, line 591, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9840525328330205, line 592, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9840525328330205, line 593, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9840525328330205, line 679, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9840525328330205, line 680, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9840525328330205, line 681, file EigenDecompositionImpl.java
--ModifPoint:CtUnaryOperatorImpl, suspValue 0.9840525328330205, line 682, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9840525328330205, line 698, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9840525328330205, line 699, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9840525328330205, line 700, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9840525328330205, line 701, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 237, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 238, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 239, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 240, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9835911861228316, line 243, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9835911861228316, line 246, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 249, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9835911861228316, line 269, file ArrayRealVector.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 571, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 572, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 573, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 574, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 575, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 576, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 578, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9835911861228316, line 579, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 597, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 598, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 599, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 600, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 601, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 602, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 603, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 604, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 616, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 619, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 620, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 621, file EigenDecompositionImpl.java
--ModifPoint:CtForEachImpl, suspValue 0.9835911861228316, line 622, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 623, file EigenDecompositionImpl.java
--ModifPoint:CtSwitchImpl, suspValue 0.9835911861228316, line 624, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9835911861228316, line 672, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9835911861228316, line 676, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 677, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9835911861228316, line 678, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 693, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9835911861228316, line 696, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9835911861228316, line 697, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9835911861228316, line 708, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9835911861228316, line 709, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9831302717900655, line 283, file ArrayRealVector.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9831302717900655, line 284, file ArrayRealVector.java
--ModifPoint:CtForImpl, suspValue 0.9831302717900655, line 285, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9831302717900655, line 286, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9831302717900655, line 288, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9831302717900655, line 299, file ArrayRealVector.java
--ModifPoint:CtIfImpl, suspValue 0.9753602975360298, line 1287, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9721964782205745, line 254, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.96726602120793, line 271, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.96726602120793, line 273, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.96726602120793, line 274, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.96726602120793, line 275, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.96726602120793, line 276, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.96726602120793, line 277, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.96726602120793, line 278, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.96726602120793, line 279, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.96726602120793, line 280, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.96726602120793, line 281, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.96726602120793, line 282, file Array2DRowRealMatrix.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.96726602120793, line 283, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.96726602120793, line 285, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.96726602120793, line 289, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9628269848554383, line 603, file AbstractRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9628269848554383, line 604, file AbstractRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9628269848554383, line 605, file AbstractRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9628269848554383, line 606, file AbstractRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9628269848554383, line 606, file AbstractRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9628269848554383, line 611, file AbstractRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9628269848554383, line 616, file AbstractRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.961062757672927, line 482, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.961062757672927, line 483, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.961062757672927, line 484, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.961062757672927, line 485, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.961062757672927, line 486, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.961062757672927, line 487, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.961062757672927, line 488, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.961062757672927, line 491, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.959304983996342, line 44, file DefaultRealMatrixPreservingVisitor.java
--ModifPoint:CtReturnImpl, suspValue 0.959304983996342, line 919, file AbstractRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9588665447897623, line 160, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9579908675799087, line 650, file MatrixUtils.java
--ModifPoint:CtReturnImpl, suspValue 0.9566803465572276, line 106, file MatrixUtils.java
--ModifPoint:CtIfImpl, suspValue 0.947606142728094, line 97, file ArrayRealVector.java
--ModifPoint:CtIfImpl, suspValue 0.947606142728094, line 100, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.947606142728094, line 103, file ArrayRealVector.java
--ModifPoint:CtIfImpl, suspValue 0.947606142728094, line 130, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9471783295711061, line 115, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9471783295711061, line 118, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9471783295711061, line 121, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9471783295711061, line 122, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9471783295711061, line 125, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9471783295711061, line 126, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9471783295711061, line 129, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9471783295711061, line 136, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9387024608501118, line 78, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9270879363676535, line 77, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9262693156732892, line 367, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9250440917107584, line 95, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9246364037020715, line 314, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9246364037020715, line 315, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9246364037020715, line 320, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9246364037020715, line 325, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9246364037020715, line 326, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9246364037020715, line 330, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9246364037020715, line 331, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9246364037020715, line 334, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9246364037020715, line 335, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9246364037020715, line 336, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9246364037020715, line 341, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9246364037020715, line 622, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9047003018542475, line 410, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9043103448275862, line 404, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.8920068027210883, line 44, file AbstractRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.8752607425949103, line 61, file AbstractRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.8752607425949103, line 66, file AbstractRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.8745310546060859, line 56, file AbstractRealMatrix.java
Total suspicious from FL: 612,  539
Total ModPoint created: 539
Creating program variant #1, [Variant id: 1, #gens: 539, #ops: 0, parent:-]
Calculating fitness
Calculating fitness for original program variant.
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Test Failing is passing, Executing regression
Executing process: (timeout765secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.stat.data.LotteryTest  org.apache.commons.math.linear.FieldMatrixImplTest  org.apache.commons.math.ode.sampling.StepNormalizerTest  org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest  org.apache.commons.math.geometry.RotationOrderTest  org.apache.commons.math.analysis.solvers.NewtonSolverTest  org.apache.commons.math.estimation.EstimatedParameterTest  org.apache.commons.math.linear.CholeskyDecompositionImplTest  org.apache.commons.math.linear.Array2DRowRealMatrixTest  org.apache.commons.math.linear.SparseRealMatrixTest  org.apache.commons.math.util.OpenIntToFieldTest  org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest  org.apache.commons.math.optimization.fitting.PolynomialFitterTest  org.apache.commons.math.linear.ArrayRealVectorTest  org.apache.commons.math.distribution.HypergeometricDistributionTest  org.apache.commons.math.random.RandomAdaptorTest  org.apache.commons.math.ode.FirstOrderConverterTest  org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest  org.apache.commons.math.stat.inference.TestUtilsTest  org.apache.commons.math.stat.data.LewTest  org.apache.commons.math.distribution.GammaDistributionTest  org.apache.commons.math.stat.descriptive.rank.MedianTest  org.apache.commons.math.distribution.ZipfDistributionTest  org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest  org.apache.commons.math.stat.CertifiedDataTest  org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest  org.apache.commons.math.complex.FrenchComplexFormatTest  org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest  org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest  org.apache.commons.math.DuplicateSampleAbscissaExceptionTest  org.apache.commons.math.estimation.MinpackTest  org.apache.commons.math.genetics.FixedGenerationCountTest  org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest  org.apache.commons.math.fraction.BigFractionFormatTest  org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest  org.apache.commons.math.random.RandomDataTest  org.apache.commons.math.distribution.FDistributionTest  org.apache.commons.math.FunctionEvaluationExceptionTest  org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest  org.apache.commons.math.stat.inference.TTestFactoryTest  org.apache.commons.math.stat.descriptive.moment.SkewnessTest  org.apache.commons.math.special.GammaTest  org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest  org.apache.commons.math.analysis.integration.RombergIntegratorTest  org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest  org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest  org.apache.commons.math.stat.descriptive.SummaryStatisticsTest  org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest  org.apache.commons.math.stat.descriptive.moment.FirstMomentTest  org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest  org.apache.commons.math.complex.ComplexTest  org.apache.commons.math.distribution.BetaDistributionTest  org.apache.commons.math.special.ErfTest  org.apache.commons.math.special.BetaTest  org.apache.commons.math.ode.nonstiff.GillIntegratorTest  org.apache.commons.math.random.EmpiricalDistributionTest  org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest  org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest  org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest  org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest  org.apache.commons.math.random.AbstractRandomGeneratorTest  org.apache.commons.math.fraction.BigFractionFieldTest  org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest  org.apache.commons.math.genetics.GeneticAlgorithmTestBinary  org.apache.commons.math.linear.BiDiagonalTransformerTest  org.apache.commons.math.util.DefaultTransformerTest  org.apache.commons.math.linear.LUDecompositionImplTest  org.apache.commons.math.random.ValueServerTest  org.apache.commons.math.stat.descriptive.moment.MeanTest  org.apache.commons.math.util.BigRealFieldTest  org.apache.commons.math.linear.QRDecompositionImplTest  org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest  org.apache.commons.math.stat.descriptive.moment.VarianceTest  org.apache.commons.math.genetics.OnePointCrossoverTest  org.apache.commons.math.stat.ranking.NaturalRankingTest  org.apache.commons.math.optimization.linear.SimplexSolverTest  org.apache.commons.math.stat.descriptive.moment.FourthMomentTest  org.apache.commons.math.linear.BlockRealMatrixTest  org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest  org.apache.commons.math.random.MersenneTwisterTest  org.apache.commons.math.genetics.RandomKeyTest  org.apache.commons.math.stat.descriptive.summary.ProductTest  org.apache.commons.math.fraction.FractionTest  org.apache.commons.math.util.OpenIntToDoubleHashMapTest  org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest  org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest  org.apache.commons.math.genetics.ChromosomeTest  org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest  org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest  org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest  org.apache.commons.math.geometry.Vector3DTest  org.apache.commons.math.stat.descriptive.rank.MinTest  org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest  org.apache.commons.math.linear.FieldLUDecompositionImplTest  org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest  org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest  org.apache.commons.math.transform.FastHadamardTransformerTest  org.apache.commons.math.optimization.fitting.HarmonicFitterTest  org.apache.commons.math.stat.correlation.PearsonsCorrelationTest  org.apache.commons.math.random.GaussianRandomGeneratorTest  org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest  org.apache.commons.math.linear.FrenchRealVectorFormatTest  org.apache.commons.math.fraction.BigFractionTest  org.apache.commons.math.util.ContinuedFractionTest  org.apache.commons.math.util.TransformerMapTest  org.apache.commons.math.analysis.solvers.BisectionSolverTest  org.apache.commons.math.genetics.BinaryChromosomeTest  org.apache.commons.math.linear.BlockFieldMatrixTest  org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest  org.apache.commons.math.linear.SingularValueDecompositionImplTest  org.apache.commons.math.distribution.TDistributionTest  org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest  org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest  org.apache.commons.math.linear.InvalidMatrixExceptionTest  org.apache.commons.math.distribution.BinomialDistributionTest  org.apache.commons.math.linear.EigenSolverTest  org.apache.commons.math.stat.inference.TTestTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest  org.apache.commons.math.random.UniformRandomGeneratorTest  org.apache.commons.math.stat.descriptive.rank.PercentileTest  org.apache.commons.math.analysis.solvers.RiddersSolverTest  org.apache.commons.math.linear.ArrayFieldVectorTest  org.apache.commons.math.ode.ContinuousOutputModelTest  org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest  org.apache.commons.math.optimization.linear.SimplexTableauTest  org.apache.commons.math.ConvergenceExceptionTest  org.apache.commons.math.util.ResizableDoubleArrayTest  org.apache.commons.math.complex.ComplexFormatTest  org.apache.commons.math.linear.RealMatrixImplTest  org.apache.commons.math.stat.descriptive.summary.SumTest  org.apache.commons.math.linear.SparseFieldVectorTest  org.apache.commons.math.genetics.ElitisticListPopulationTest  org.apache.commons.math.stat.descriptive.summary.SumSqTest  org.apache.commons.math.linear.SparseRealVectorTest  org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest  org.apache.commons.math.linear.EigenDecompositionImplTest  org.apache.commons.math.analysis.integration.SimpsonIntegratorTest  org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest  org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest  org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations  org.apache.commons.math.stat.descriptive.moment.KurtosisTest  org.apache.commons.math.transform.FastFourierTransformerTest  org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest  org.apache.commons.math.distribution.NormalDistributionTest  org.apache.commons.math.distribution.PoissonDistributionTest  org.apache.commons.math.geometry.Vector3DFormatTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest  org.apache.commons.math.genetics.TournamentSelectionTest  org.apache.commons.math.optimization.general.MinpackTest  org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest  org.apache.commons.math.analysis.solvers.BrentSolverTest  org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest  org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest  org.apache.commons.math.estimation.WeightedMeasurementTest  org.apache.commons.math.stat.inference.ChiSquareTestTest  org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest  org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest  org.apache.commons.math.linear.MatrixIndexExceptionTest  org.apache.commons.math.genetics.BinaryMutationTest  org.apache.commons.math.fraction.FractionFormatTest  org.apache.commons.math.distribution.PascalDistributionTest  org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest  org.apache.commons.math.util.MathUtilsTest  org.apache.commons.math.complex.ComplexUtilsTest  org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest  org.apache.commons.math.optimization.direct.MultiDirectionalTest  org.apache.commons.math.genetics.FitnessCachingTest  org.apache.commons.math.linear.BigMatrixImplTest  org.apache.commons.math.stat.inference.ChiSquareFactoryTest  org.apache.commons.math.fraction.FractionFieldTest  org.apache.commons.math.stat.descriptive.InteractionTest  org.apache.commons.math.stat.correlation.CovarianceTest  org.apache.commons.math.optimization.univariate.BrentMinimizerTest  org.apache.commons.math.linear.QRSolverTest  org.apache.commons.math.linear.RealVectorFormatTest  org.apache.commons.math.analysis.solvers.LaguerreSolverTest  org.apache.commons.math.linear.CholeskySolverTest  org.apache.commons.math.distribution.WeibullDistributionTest  org.apache.commons.math.stat.StatUtilsTest  org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest  org.apache.commons.math.analysis.solvers.MullerSolverTest  org.apache.commons.math.linear.TriDiagonalTransformerTest  org.apache.commons.math.distribution.ChiSquareDistributionTest  org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest  org.apache.commons.math.transform.FastSineTransformerTest  org.apache.commons.math.stat.inference.OneWayAnovaTest  org.apache.commons.math.transform.FastCosineTransformerTest  org.apache.commons.math.ArgumentOutsideDomainExceptionTest  org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest  org.apache.commons.math.ode.nonstiff.EulerIntegratorTest  org.apache.commons.math.stat.descriptive.rank.MaxTest  org.apache.commons.math.complex.ComplexFieldTest  org.apache.commons.math.stat.descriptive.ListUnivariateImplTest  org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest  org.apache.commons.math.MaxIterationsExceededExceptionTest  org.apache.commons.math.linear.MatrixUtilsTest  org.apache.commons.math.optimization.direct.NelderMeadTest  org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest  org.apache.commons.math.geometry.RotationTest  org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest  org.apache.commons.math.linear.SingularValueSolverTest  org.apache.commons.math.genetics.RandomKeyMutationTest  org.apache.commons.math.util.BigRealTest  org.apache.commons.math.distribution.ExponentialDistributionTest  org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest  org.apache.commons.math.geometry.FrenchVector3DFormatTest  org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest  org.apache.commons.math.stat.regression.SimpleRegressionTest  org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest  org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest  org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest  org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest  org.apache.commons.math.linear.LUSolverTest  org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest  org.apache.commons.math.MathConfigurationExceptionTest  org.apache.commons.math.estimation.GaussNewtonEstimatorTest  org.apache.commons.math.genetics.ListPopulationTest  org.apache.commons.math.MathExceptionTest  org.apache.commons.math.distribution.CauchyDistributionTest  org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest  org.apache.commons.math.linear.SparseFieldMatrixTest  org.apache.commons.math.stat.descriptive.summary.SumLogTest  org.apache.commons.math.stat.FrequencyTest  org.apache.commons.math.stat.descriptive.moment.SecondMomentTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 2104] ,[]
The original fitness is : 1.0
----------------------------
---Configuration properties
p:lastJUnitVersion= ./examples/libs/junit-4.11.jar
p:alternativecompliancelevel= 8
p:ignoredTestCases= 
p:workingDirectory= /Users/marekmazur/astor/./output_astor
p:manipulatesuper= false
p:validation= process
p:jvm4testexecution= /Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin
p:operatorspace= irr-statements
p:diffcontext= 0
p:binjavafolder= /target/classes/
p:synthesis_depth= 3
p:gzoltartestpackagetoexclude= junit.framework
p:skipfitnessinitialpopulation= false
p:evosuiteresultfolder= evosuite
p:flthreshold= 0
p:regressionforfaultlocalization= true
p:collectonlyusedmethod= false
p:folderDiff= ./diffSolutions
p:preservelinenumbers= true
p:tmax2= 765690
p:tmax1= 10000
p:probagenmutation= false
p:nomodificationconvergence= 100
p:diff_type= relative
p:nolog= False
p:targetelementprocessor= statements
p:srctestfolder= /src/test/
p:forceExecuteRegression= false
p:clusteringfilename= clustering.csv
p:failing= org.apache.commons.math.linear.EigenDecompositionImplTest
p:logtestexecution= false
p:evo_buggy_class= true
p:numberExecutions= 1
p:maxnumbersolutions= 1000000
p:evo_affected_by_op= true
p:population= 1
p:maxCombinationVariableLimit= false
p:savesolution= true
p:javacompliancelevel= 8
p:uniqueoptogen= false
p:gzoltarpackagetonotinstrument= junit.framework
p:projectIdentifier= 
p:modificationpointnavigation= weight
p:stopfirst= true
p:multipointmodification= false
p:elementsToMutate= 10
p:jsonoutputname= astor_output
p:evoDSE= false
p:bintestfolder= /target/test-classes/
p:testbystep= false
p:version-location= ./math-version/
p:gzoltarVersion= 1.7.3
p:locationGzoltarJar= ./lib/
p:reintroduce= PARENTS:ORIGINAL
p:executorjar= ./lib/jtestex7.jar
p:maxGeneration= 1000000
p:max_synthesis_step= 10000
p:projectinfocommand= com.github.tdurieux:project-config-maven-plugin:info
p:maxVarCombination= 1000
p:includeZeros= false
p:maxtime= 60
p:evosuitejar= ./lib/evosuite-master-1.0.4-SNAPSHOT.jar
p:jvmversion= 1.8.0_202
p:commandTrunk= 50000
p:faultlocalization= flacoco
p:resetmodel= true
p:maxsuspcandidates= 1000
p:mode= jgenprog
p:learningdir= 
p:jvm4evosuitetestexecution= /Users/marekmazur/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin
p:filterfaultlocalization= true
p:mutationrate= 1 
p:pathToMVNRepository= 
p:resourcesfolder= /src/main/resources:/src/test/resources:
p:timezone= America/Los_Angeles
p:runjava7code= false
p:evoRunOnBuggyClass= true
p:compiler= fr.inria.astor.core.manipulation.bytecode.compiler.SpoonClassCompiler
p:limitbysuspicious= true
p:logsattemps= true
p:dependenciespath= /Users/marekmazur/astor/examples/libs/junit-4.4.jar
p:packageToInstrument= org.apache.commons
p:skipfaultlocalization= false
p:scope= local
p:transformingredient= false
p:fitnessfunction= fr.inria.astor.core.solutionsearch.population.TestCaseFitnessFunction
p:maxnumvariablesperingredient= 10
p:parsesourcefromoriginal= true
p:pvariantfoldername= variant-
p:savespoonmodelondisk= false
p:srcjavafolder= /src/java/
p:populationcontroller= fr.inria.astor.core.solutionsearch.population.TestCaseBasedFitnessPopulationController
p:ignoreflakyinfl= false
p:cleantemplates= true
p:applyCrossover= false
p:maxmodificationpoints= 1000
p:duplicateingredientsinspace= false
p:metid= 0
p:continuewhenmodelfail= true
p:saveall= false
p:seed= 10
p:savecompletepatched= true
p:resetoperations= false
p:keepcomments= true
p:processoutputinfile= false
p:location= /Users/marekmazur/astor/defects4j/math-80
p:probabilistictransformation= true
p:overridemaxtime= true
p:outputjsonresult= true
p:allpoints= false
p:antipattern= false
p:bugId= 280
p:evosuitetimeout= 120
p:maxtimefactor= 10
p:nrPlaceholders= 1
p:forcesubprocesskilling= false
----------------------------
----Starting Solution Search
----------Running generation: 1, population size: 1

***** Generation 1 : 0
**Parent Variant: [Variant id: 1, #gens: 539, #ops: 0, parent:-]

--Child created id: 2
--Creating new operations for variant [Variant id: 2, #gens: 539, #ops: 0, parent:1]
---analyzing modificationPoint position: 390
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  double pi = d[nM1] - lambda
---analyzing modificationPoint position: 137
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  for (int k = 0; i0 < n0; ++k) { 	if (k >= maxIter) { 		throw new org.apache.commons.math.linear.Inva[...]
---analyzing modificationPoint position: 31
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  // convergence hidden by negative DN. work[((4 * deflatedEnd) - 3) - pingPong] = 0.0
---analyzing modificationPoint position: 130
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2])
---analyzing modificationPoint position: 439
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java597
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double dCurrent = main[m - 1] ` -topatch--> `// process split segments int i0 = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 597, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double dCurrent = main[m - 1] ` -topatch--> `// process split segments int i0 = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 2, #gens: 540, #ops: 1, parent:1] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child does NOT compile: 2, errors: [EigenDecompositionImpl.java:862: error: <identifier> expected
					if (chooseLeft) { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda + work[4 * i];}} else { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda - work[4 * i];}}} 			begin = end;} 		// sort the realEigenvalues in decreasing order 		java.util.Arrays.sort(realEigenvalues); 		int j = realEigenvalues.length - 1; 		for (int i = 0; i < j; ++i) { 			final double tmp = realEigenvalues[i]; 			realEigenvalues[i] = realEigenvalues[j]; 			realEigenvalues[j] = tmp; 			--j;}} 	/**
					                  						                              							                                                            						                              							                                                      			     ^, EigenDecompositionImpl.java:863: error: class, interface, or enum expected
	 * Compute splitting points.
	 ^, EigenDecompositionImpl.java:865: error: <identifier> expected
	 * @return list of indices after matrix can be split
	    ^, EigenDecompositionImpl.java:865: error: class, interface, or enum expected
	 * @return list of indices after matrix can be split
	           ^, EigenDecompositionImpl.java:866: error: class, interface, or enum expected
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	                                                            		      ^, EigenDecompositionImpl.java:867: error: class, interface, or enum expected
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:870: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:872: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                    ^, EigenDecompositionImpl.java:872: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                                 		                                     ^, EigenDecompositionImpl.java:880: error: class, interface, or enum expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                     ^, EigenDecompositionImpl.java:884: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:886: error: class, interface, or enum expected
	 * @exception InvalidMatrixException
	              ^, EigenDecompositionImpl.java:888: error: class, interface, or enum expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                     ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                       ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			       ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		                                ^, EigenDecompositionImpl.java:902: error: class, interface, or enum expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                       ^, EigenDecompositionImpl.java:903: error: class, interface, or enum expected
			return;} 		// initial checks for splits (see Parlett & Marques section 3.3) 		flipIfWarranted(n, 2); 		// two iterations with Li's test for initial splits 		initialSplits(n); 		// initialize parameters used by goodStep 		tType = 0; 		dMin1 = 0; 		dMin2 = 0; 		dN = 0; 		dN1 = 0; 		dN2 = 0; 		tau = 0; 		// process split segments 		int i0 = 0; 		int n0 = n; 		while (n0 > 0) { 			// retrieve shift that was temporarily stored as a negative off-diagonal element 			sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2]; 			sigmaLow = 0; 			// find start of a new split segment to process 			double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6]; 			double offDiagMax = 0; 			double diagMax = work[(4 * n0) - 4]; 			double diagMin = diagMax; 			i0 = 0; 			for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { 				if (work[i + 2] <= 0) { 					i0 = 1 + (i / 4); 					break;} 				if (diagMin >= (4 * offDiagMax)) { 					diagMin = java.lang.Math.min(diagMin, work[i + 4]); 					offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);} 				diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]); 				offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);} 			work[(4 * n0) - 2] = offDiagMin; 			// lower bound of Gershgorin disk 			dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax))); 			pingPong = 0; 			int maxIter = 30 * (n0 - i0); 			for (int k = 0; i0 < n0; ++k) { 				if (k >= maxIter) { 					throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));} 				// perform one step 				n0 = goodStep(i0, n0); 				pingPong = 1 - pingPong; 				// check for new splits after "ping" steps 				// when the last elements of qd array are very small
			       ^, EigenDecompositionImpl.java:904: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0];
				                                                                                                                                                                                                                                                              					                    					^, EigenDecompositionImpl.java:905: error: class, interface, or enum expected
					offDiagMin = work[(4 * i0) + 2];
					^, EigenDecompositionImpl.java:906: error: class, interface, or enum expected
					double previousEMin = work[(4 * i0) + 3];
					^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					                     ^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					                                          ^, EigenDecompositionImpl.java:912: error: class, interface, or enum expected
							split = i / 4;
							^, EigenDecompositionImpl.java:913: error: class, interface, or enum expected
							diagMax = 0;
							^, EigenDecompositionImpl.java:914: error: class, interface, or enum expected
							offDiagMin = work[i + 6];
							^, EigenDecompositionImpl.java:915: error: class, interface, or enum expected
							previousEMin = work[i + 7];
							^, EigenDecompositionImpl.java:916: error: class, interface, or enum expected
						} else {
						^, EigenDecompositionImpl.java:918: error: class, interface, or enum expected
							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);
							^, EigenDecompositionImpl.java:919: error: class, interface, or enum expected
							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);
							^, EigenDecompositionImpl.java:920: error: class, interface, or enum expected
						}
						^, EigenDecompositionImpl.java:923: error: class, interface, or enum expected
					work[(4 * n0) - 1] = previousEMin;
					^, EigenDecompositionImpl.java:924: error: class, interface, or enum expected
					i0 = split + 1;
					^, EigenDecompositionImpl.java:925: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:937: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) {
	    	                                 ^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		                ^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		                       ^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			                                       ^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			                                               ^, EigenDecompositionImpl.java:946: error: class, interface, or enum expected
					d = work[i];
					^, EigenDecompositionImpl.java:947: error: class, interface, or enum expected
				} else {
				^, EigenDecompositionImpl.java:949: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			                           ^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			                                              ^, EigenDecompositionImpl.java:955: error: class, interface, or enum expected
				final int j = (i - (2 * pingPong)) - 1;
				      ^, EigenDecompositionImpl.java:956: error: class, interface, or enum expected
				work[j] = d + work[i];
				^, EigenDecompositionImpl.java:957: error: class, interface, or enum expected
				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {
				^, EigenDecompositionImpl.java:959: error: class, interface, or enum expected
					work[j] = d;
					^, EigenDecompositionImpl.java:960: error: class, interface, or enum expected
					work[j + 2] = 0.0;
					^, EigenDecompositionImpl.java:961: error: class, interface, or enum expected
					d = work[i + 2];
					^, EigenDecompositionImpl.java:962: error: class, interface, or enum expected
				} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && 
				^, EigenDecompositionImpl.java:964: error: class, interface, or enum expected
					final double tmp = work[i + 2] / work[j];
					      ^, EigenDecompositionImpl.java:965: error: class, interface, or enum expected
					work[j + 2] = work[i] * tmp;
					^, EigenDecompositionImpl.java:966: error: class, interface, or enum expected
					d *= tmp;
					^, EigenDecompositionImpl.java:967: error: class, interface, or enum expected
				} else {
				^, EigenDecompositionImpl.java:969: error: class, interface, or enum expected
					d *= work[i + 2] / work[j];
					^, EigenDecompositionImpl.java:970: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:975: error: class, interface, or enum expected
			pingPong = 1 - pingPong;
			^, EigenDecompositionImpl.java:977: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:994: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0;
	    	                           ^, EigenDecompositionImpl.java:994: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0;
	    	                                            ^, EigenDecompositionImpl.java:997: error: class, interface, or enum expected
		int deflatedEnd = end;
		^, EigenDecompositionImpl.java:998: error: class, interface, or enum expected
		for (boolean deflating = true; deflating;) {
		^, EigenDecompositionImpl.java:998: error: class, interface, or enum expected
		for (boolean deflating = true; deflating;) {
		                               ^, EigenDecompositionImpl.java:998: error: class, interface, or enum expected
		for (boolean deflating = true; deflating;) {
		                                         ^, EigenDecompositionImpl.java:1003: error: class, interface, or enum expected
			}
			^, EigenDecompositionImpl.java:1005: error: class, interface, or enum expected
			final int k = ((4 * deflatedEnd) + pingPong) - 1;
			      ^, EigenDecompositionImpl.java:1007: error: class, interface, or enum expected
			if ((start == (deflatedEnd - 1)) || 
			^, EigenDecompositionImpl.java:1014: error: class, interface, or enum expected
				deflatedEnd -= 1;
				^, EigenDecompositionImpl.java:1016: error: class, interface, or enum expected
			} else if (((start == (deflatedEnd - 2)) || 
			^, EigenDecompositionImpl.java:1022: error: class, interface, or enum expected
					final double tmp = work[k - 3];
					      ^, EigenDecompositionImpl.java:1023: error: class, interface, or enum expected
					work[k - 3] = work[k - 7];
					^, EigenDecompositionImpl.java:1024: error: class, interface, or enum expected
					work[k - 7] = tmp;
					^, EigenDecompositionImpl.java:1025: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:1029: error: class, interface, or enum expected
					double s = work[k - 3] * (work[k - 5] / t);
					^]
Ingredient counter is Zero
---Undoing: gnrtn(1): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double dCurrent = main[m - 1] ` -topatch--> `// process split segments int i0 = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (1(f=1.0), 2(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (1(f=1.0), )
----------Running generation: 2, population size: 1

***** Generation 2 : 0
**Parent Variant: [Variant id: 3, #gens: 539, #ops: 0, parent:-]

--Child created id: 4
--Creating new operations for variant [Variant id: 4, #gens: 539, #ops: 0, parent:3]
---analyzing modificationPoint position: 320
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  sigma = t
---analyzing modificationPoint position: 457
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  for (int i = 0; i < j; ++i) { 	final double tmp = realEigenvalues[i]; 	realEigenvalues[i] = realEige[...]
---analyzing modificationPoint position: 97
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  final double s = secondary[i]
---analyzing modificationPoint position: 250
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 3 not mutation generated in  int j4p2 = (j4 + (2 * pingPong)) - 1
---analyzing modificationPoint position: 185
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  // perform a dqd step (i.e. no shift) dqd(start, deflatedEnd)
---analyzing modificationPoint position: 195
location: EigenDecompositionImpl.java1164
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 4, #gens: 538, #ops: 1, parent:3] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 4
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-4/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 10, was successful: false, cases executed: 18] ,[]
-Valid?: |false|10|18|[]|, fitness 10.0
Ingredient counter is Zero
---Undoing: gnrtn(2): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (3(f=1.0), 4(f=10.0), )
Selected to next generation: IDs2--> (3(f=1.0), )
----------Running generation: 3, population size: 1

***** Generation 3 : 0
**Parent Variant: [Variant id: 5, #gens: 539, #ops: 0, parent:-]

--Child created id: 6
--Creating new operations for variant [Variant id: 6, #gens: 539, #ops: 0, parent:5]
---analyzing modificationPoint position: 251
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  work[j4 - 2] = dN2 + work[j4p2]
---analyzing modificationPoint position: 390
---modifPoint 1 not mutation generated in  double pi = d[nM1] - lambda
---analyzing modificationPoint position: 14
Templates availables42
Attempts Base Ingredients  1 total 42
---modifPoint 2 not mutation generated in  for (int i = 0; i < j; i += 4) { 	for (int k = 0; k < 4; k += step) { 		final double tmp = work[i + [...]
---analyzing modificationPoint position: 118
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  while (n0 > 0) {  	// retrieve shift that was temporarily stored as a negative off-diagonal element [...]
---analyzing modificationPoint position: 201
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1176
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// search lower eigenvalue double left = lower - margin ` -topatch--> `double s = 0.0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1176, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// search lower eigenvalue double left = lower - margin ` -topatch--> `double s = 0.0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 6, #gens: 540, #ops: 1, parent:5] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child does NOT compile: 6, errors: [EigenDecompositionImpl.java:1465: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			^, EigenDecompositionImpl.java:1465: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                    ^, EigenDecompositionImpl.java:1465: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                     ^, EigenDecompositionImpl.java:1465: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                           ^, EigenDecompositionImpl.java:1465: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                     ^, EigenDecompositionImpl.java:1465: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                 ^, EigenDecompositionImpl.java:1465: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                     ^, EigenDecompositionImpl.java:1465: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				    ^, EigenDecompositionImpl.java:1465: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				               ^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				      ^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			      ^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				               ^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				              ^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		                                    ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                   ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                    ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                       ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				        ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				           		             ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                          ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                       ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			      ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			      ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			      ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			                                     ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                        ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                         ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                               ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                      ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				      ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                          ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                               ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                      ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				      ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				                                              ^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1504: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                       ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                        ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                               ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                     ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					           ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                          ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                               ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                     ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					           ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                              ^]
Ingredient counter is Zero
---Undoing: gnrtn(3): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// search lower eigenvalue double left = lower - margin ` -topatch--> `double s = 0.0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (5(f=1.0), 6(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (5(f=1.0), )
----------Running generation: 4, population size: 1

***** Generation 4 : 0
**Parent Variant: [Variant id: 7, #gens: 539, #ops: 0, parent:-]

--Child created id: 8
--Creating new operations for variant [Variant id: 8, #gens: 539, #ops: 0, parent:7]
---analyzing modificationPoint position: 527
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  if (nCols == 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException[...]
---analyzing modificationPoint position: 195
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dMin1, dN1, tau]
--> var from patch: dMin1 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: dN1 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1164
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `if (dMin1 == dN1) { 	tau = 0.5 * dMin1; }` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1164, pointed element: CtIfImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `if (dMin1 == dN1) { 	tau = 0.5 * dMin1; }` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 8, #gens: 540, #ops: 1, parent:7] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 8, errors: [EigenDecompositionImpl.java:1627: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			^, EigenDecompositionImpl.java:1627: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                    ^, EigenDecompositionImpl.java:1627: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                     ^, EigenDecompositionImpl.java:1627: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                           ^, EigenDecompositionImpl.java:1627: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                     ^, EigenDecompositionImpl.java:1627: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                 ^, EigenDecompositionImpl.java:1627: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                     ^, EigenDecompositionImpl.java:1627: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				    ^, EigenDecompositionImpl.java:1627: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				               ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				      ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			      ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				               ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				              ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		                                    ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                   ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                    ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                       ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				        ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				           		             ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                          ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                       ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			      ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			      ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			      ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			                                     ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                        ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                         ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                               ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                      ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				      ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                          ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                               ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                      ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				      ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				                                              ^, EigenDecompositionImpl.java:1664: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1666: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                       ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                        ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                               ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                     ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					           ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                          ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                               ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                     ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					           ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                              ^]
Ingredient counter is Zero
---Undoing: gnrtn(4): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `if (dMin1 == dN1) { 	tau = 0.5 * dMin1; }` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (7(f=1.0), 8(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (7(f=1.0), )
----------Running generation: 5, population size: 1

***** Generation 5 : 0
**Parent Variant: [Variant id: 9, #gens: 539, #ops: 0, parent:-]

--Child created id: 10
--Creating new operations for variant [Variant id: 10, #gens: 539, #ops: 0, parent:9]
---analyzing modificationPoint position: 430
location: ArrayRealVector.java269
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtReturnImpl) `return subtract(((org.apache.commons.math.linear.ArrayRealVector) (v))) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 10, #gens: 538, #ops: 1, parent:9] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 10, errors: [ArrayRealVector.java:279: error: missing return statement
	}
	^]
Ingredient counter is Zero
---Undoing: gnrtn(5): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtReturnImpl) `return subtract(((org.apache.commons.math.linear.ArrayRealVector) (v))) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (9(f=1.0), 10(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (9(f=1.0), )
----------Running generation: 6, population size: 1

***** Generation 6 : 0
**Parent Variant: [Variant id: 11, #gens: 539, #ops: 0, parent:-]

--Child created id: 12
--Creating new operations for variant [Variant id: 12, #gens: 539, #ops: 0, parent:11]
---analyzing modificationPoint position: 29
location: EigenDecompositionImpl.java1414
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 12, #gens: 538, #ops: 1, parent:11] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 12
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-12/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(6): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (11(f=1.0), 12(f=1.0), )
Selected to next generation: IDs2--> (11(f=1.0), )
----------Running generation: 7, population size: 1

***** Generation 7 : 0
**Parent Variant: [Variant id: 13, #gens: 539, #ops: 0, parent:-]

--Child created id: 14
--Creating new operations for variant [Variant id: 14, #gens: 539, #ops: 0, parent:13]
---analyzing modificationPoint position: 303
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...]
---analyzing modificationPoint position: 293
location: EigenDecompositionImpl.java1408
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) &&  ((org.ap[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 14, #gens: 538, #ops: 1, parent:13] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 14
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-14/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 18] ,[]
-Valid?: |false|9|18|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(7): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) &&  ((org.ap[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (13(f=1.0), 14(f=9.0), )
Selected to next generation: IDs2--> (13(f=1.0), )
----------Running generation: 8, population size: 1

***** Generation 8 : 0
**Parent Variant: [Variant id: 15, #gens: 539, #ops: 0, parent:-]

--Child created id: 16
--Creating new operations for variant [Variant id: 16, #gens: 539, #ops: 0, parent:15]
---analyzing modificationPoint position: 477
---modifPoint 0 not mutation generated in  final double[] dataRow = data[row]
---analyzing modificationPoint position: 269
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  work[j4 - 2] = d + work[j4 - 1]
---analyzing modificationPoint position: 517
Templates availables83
Attempts Base Ingredients  1 total 83
---modifPoint 2 not mutation generated in  data = d.clone()
---analyzing modificationPoint position: 368
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  z = 1
---analyzing modificationPoint position: 22
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  dN1 = work[j4p2 + 2]
---analyzing modificationPoint position: 271
location: EigenDecompositionImpl.java1343
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) &&  ((org.apac[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 16, #gens: 538, #ops: 1, parent:15] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 16
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-16/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 18] ,[]
-Valid?: |false|9|18|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(8): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) &&  ((org.apac[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (15(f=1.0), 16(f=9.0), )
Selected to next generation: IDs2--> (15(f=1.0), )
----------Running generation: 9, population size: 1

***** Generation 9 : 0
**Parent Variant: [Variant id: 17, #gens: 539, #ops: 0, parent:-]

--Child created id: 18
--Creating new operations for variant [Variant id: 18, #gens: 539, #ops: 0, parent:17]
---analyzing modificationPoint position: 342
Templates availables42
Attempts Base Ingredients  1 total 42
---modifPoint 0 not mutation generated in  for (int i = 1; i < m; ++i) { 	final double eiM1 = secondary[i - 1]; 	final double ratio = eiM1 / di[...]
---analyzing modificationPoint position: 329
Templates availables45
Attempts Base Ingredients  1 total 45
vars from patch []
location: ArrayRealVector.java889
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return dot ` -topatch--> `return true` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.ArrayRealVector line: 889, pointed element: CtReturnImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return dot ` -topatch--> `return true` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 18, #gens: 539, #ops: 1, parent:17] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 18, errors: [ArrayRealVector.java:1302: error: incompatible types: boolean cannot be converted to double
		return true;} 	/**
		       ^]
Ingredient counter is Zero
---Undoing: gnrtn(9): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return dot ` -topatch--> `return true` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (17(f=1.0), 18(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (17(f=1.0), )
----------Running generation: 10, population size: 1

***** Generation 10 : 0
**Parent Variant: [Variant id: 19, #gens: 539, #ops: 0, parent:-]

--Child created id: 20
--Creating new operations for variant [Variant id: 20, #gens: 539, #ops: 0, parent:19]
---analyzing modificationPoint position: 485
---modifPoint 0 not mutation generated in  final int nRows = getRowDimension()
---analyzing modificationPoint position: 481
Templates availables120
Attempts Base Ingredients  1 total 120
vars from patch []
location: Array2DRowRealMatrix.java282
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < nSum; i++) { 	sum += dataRow[i] * m.data[i][col]; } ` -topatch--> `final int columnCount = getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 282, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < nSum; i++) { 	sum += dataRow[i] * m.data[i][col]; } ` -topatch--> `final int columnCount = getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 20, #gens: 540, #ops: 1, parent:19] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 20
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-20/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(10): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < nSum; i++) { 	sum += dataRow[i] * m.data[i][col]; } ` -topatch--> `final int columnCount = getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (19(f=1.0), 20(f=1.0), )
Selected to next generation: IDs2--> (19(f=1.0), )
----------Running generation: 11, population size: 1

***** Generation 11 : 0
**Parent Variant: [Variant id: 21, #gens: 539, #ops: 0, parent:-]

--Child created id: 22
--Creating new operations for variant [Variant id: 22, #gens: 539, #ops: 0, parent:21]
---analyzing modificationPoint position: 180
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // step 4a: dqds for (boolean loop = true; loop;) {  	// perform one dqds step with the chosen shift[...]
---analyzing modificationPoint position: 73
Templates availables281
Attempts Base Ingredients  1 total 281
---modifPoint 1 not mutation generated in  sum += a * a
---analyzing modificationPoint position: 369
location: EigenDecompositionImpl.java1769
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = r + 1; i < m; ++i) { 	z *= -work[(6 * i) - 1]; 	eigenvector[i] = z; 	n2 += z * z; } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 22, #gens: 538, #ops: 1, parent:21] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 22
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-22/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 7, was successful: false, cases executed: 18] ,[]
-Valid?: |false|7|18|[]|, fitness 7.0
Ingredient counter is Zero
---Undoing: gnrtn(11): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = r + 1; i < m; ++i) { 	z *= -work[(6 * i) - 1]; 	eigenvector[i] = z; 	n2 += z * z; } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (21(f=1.0), 22(f=7.0), )
Selected to next generation: IDs2--> (21(f=1.0), )
----------Running generation: 12, population size: 1

***** Generation 12 : 0
**Parent Variant: [Variant id: 23, #gens: 539, #ops: 0, parent:-]

--Child created id: 24
--Creating new operations for variant [Variant id: 24, #gens: 539, #ops: 0, parent:23]
---analyzing modificationPoint position: 353
---modifPoint 0 not mutation generated in  // select the twist index leading to // the least diagonal element in the twisted factorization int [...]
---analyzing modificationPoint position: 523
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 1 not mutation generated in  if (column > 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalStateException( 	[...]
---analyzing modificationPoint position: 396
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  final double t = di / diP1
---analyzing modificationPoint position: 411
Templates availables241
Attempts Base Ingredients  1 total 241
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [cachedV, m]
--> var from patch: cachedV spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: m spoon.support.reflect.code.CtVariableReadImpl
location: EigenDecompositionImpl.java589
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Math.min(lowerSpectra, lower) ` -topatch--> `cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 589, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Math.min(lowerSpectra, lower) ` -topatch--> `cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 24, #gens: 539, #ops: 1, parent:23] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 24
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-24/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 6, was successful: false, cases executed: 18] ,[]
-Valid?: |false|6|18|[]|, fitness 6.0
Ingredient counter is Zero
---Undoing: gnrtn(12): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Math.min(lowerSpectra, lower) ` -topatch--> `cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (23(f=1.0), 24(f=6.0), )
Selected to next generation: IDs2--> (23(f=1.0), )
----------Running generation: 13, population size: 1

***** Generation 13 : 0
**Parent Variant: [Variant id: 25, #gens: 539, #ops: 0, parent:-]

--Child created id: 26
--Creating new operations for variant [Variant id: 26, #gens: 539, #ops: 0, parent:25]
---analyzing modificationPoint position: 422
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 0 not mutation generated in  if (java.lang.Math.abs(secondary[i]) <= max) { 	list.add(i + 1); 	secondary[i] = 0; 	squaredSecondar[...]
---analyzing modificationPoint position: 231
Templates availables156
Attempts Base Ingredients  1 total 156
vars from patch [main, index]
--> var from patch: main spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: index spoon.support.reflect.code.CtVariableReadImpl
location: EigenDecompositionImpl.java1254
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double di = main[index] - lambda ` -topatch--> `final double q1 = main[index + 1]` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1254, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double di = main[index] - lambda ` -topatch--> `final double q1 = main[index + 1]` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 26, #gens: 539, #ops: 1, parent:25] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 26, errors: [EigenDecompositionImpl.java:1257: error: cannot find symbol
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		final double q1 = main[index + 1]; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                                                    		                                   		                             ^
  symbol:   variable di
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1260: error: cannot find symbol
			final double ratio = eiM1 / di;
			                            ^
  symbol:   variable di
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1261: error: cannot find symbol
			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di);
			                                                       ^
  symbol:   variable di
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1262: error: cannot find symbol
			di = (main[index + i] - lambda) - (eiM1 * ratio);
			^
  symbol:   variable di
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1263: error: cannot find symbol
			work[fourI] = java.lang.Math.abs(di);
			                                 ^
  symbol:   variable di
  location: class org.apache.commons.math.linear.EigenDecompositionImpl]
Ingredient counter is Zero
---Undoing: gnrtn(13): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double di = main[index] - lambda ` -topatch--> `final double q1 = main[index + 1]` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (25(f=1.0), 26(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (25(f=1.0), )
----------Running generation: 14, population size: 1

***** Generation 14 : 0
**Parent Variant: [Variant id: 27, #gens: 539, #ops: 0, parent:-]

--Child created id: 28
--Creating new operations for variant [Variant id: 28, #gens: 539, #ops: 0, parent:27]
---analyzing modificationPoint position: 482
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  sum += dataRow[i] * m.data[i][col]
---analyzing modificationPoint position: 537
location: AbstractRealMatrix.java66
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `lu = null ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 28, #gens: 538, #ops: 1, parent:27] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 28
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-28/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(14): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `lu = null ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (27(f=1.0), 28(f=1.0), )
Selected to next generation: IDs2--> (27(f=1.0), )
----------Running generation: 15, population size: 1

***** Generation 15 : 0
**Parent Variant: [Variant id: 29, #gens: 539, #ops: 0, parent:-]

--Child created id: 30
--Creating new operations for variant [Variant id: 30, #gens: 539, #ops: 0, parent:29]
---analyzing modificationPoint position: 178
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  if ((dMin < 0) ||  ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(wo[...]
---analyzing modificationPoint position: 55
location: EigenDecompositionImpl.java1488
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `np = nn - (2 * pingPong) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 30, #gens: 538, #ops: 1, parent:29] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 30, errors: [EigenDecompositionImpl.java:1490: error: variable np might not have been initialized
							b2 = work[np - 2];
							          ^]
Ingredient counter is Zero
---Undoing: gnrtn(15): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `np = nn - (2 * pingPong) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (29(f=1.0), 30(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (29(f=1.0), )
----------Running generation: 16, population size: 1

***** Generation 16 : 0
**Parent Variant: [Variant id: 31, #gens: 539, #ops: 0, parent:-]

--Child created id: 32
--Creating new operations for variant [Variant id: 32, #gens: 539, #ops: 0, parent:31]
---analyzing modificationPoint position: 300
Templates availables156
Attempts Base Ingredients  1 total 156
vars from patch []
location: EigenDecompositionImpl.java1433
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double cnst1 = 0.563 ` -topatch--> `// check decomposed matrix data range double sumOffDiag = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1433, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double cnst1 = 0.563 ` -topatch--> `// check decomposed matrix data range double sumOffDiag = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 32, #gens: 539, #ops: 1, parent:31] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 32, errors: [EigenDecompositionImpl.java:1515: error: cannot find symbol
							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {
							                                                  ^
  symbol:   variable cnst1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1522: error: cannot find symbol
						if (a2 < cnst1) {
						         ^
  symbol:   variable cnst1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1558: error: cannot find symbol
							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {
							                                                  ^
  symbol:   variable cnst1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1565: error: cannot find symbol
					if (a2 < cnst1) {
					         ^
  symbol:   variable cnst1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1615: error: cannot find symbol
						tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));
						                                         ^
  symbol:   variable cnst2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1617: error: cannot find symbol
						tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));
						                                       ^
  symbol:   variable cnst2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1659: error: cannot find symbol
						tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));
						                                         ^
  symbol:   variable cnst2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1661: error: cannot find symbol
						tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));
						                                       ^
  symbol:   variable cnst2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl]
Ingredient counter is Zero
---Undoing: gnrtn(16): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double cnst1 = 0.563 ` -topatch--> `// check decomposed matrix data range double sumOffDiag = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (31(f=1.0), 32(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (31(f=1.0), )
----------Running generation: 17, population size: 1

***** Generation 17 : 0
**Parent Variant: [Variant id: 33, #gens: 539, #ops: 0, parent:-]

--Child created id: 34
--Creating new operations for variant [Variant id: 34, #gens: 539, #ops: 0, parent:33]
---analyzing modificationPoint position: 424
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  cachedD = null
---analyzing modificationPoint position: 371
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [cachedD]
--> var from patch: cachedD spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1777
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < m; ++i) { 	eigenvector[i] *= inv; } ` -topatch--> `cachedD = null` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1777, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < m; ++i) { 	eigenvector[i] *= inv; } ` -topatch--> `cachedD = null` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 34, #gens: 540, #ops: 1, parent:33] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 34
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-34/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(17): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < m; ++i) { 	eigenvector[i] *= inv; } ` -topatch--> `cachedD = null` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (33(f=1.0), 34(f=1.0), )
Selected to next generation: IDs2--> (33(f=1.0), )
----------Running generation: 18, population size: 1

***** Generation 18 : 0
**Parent Variant: [Variant id: 35, #gens: 539, #ops: 0, parent:-]

--Child created id: 36
--Creating new operations for variant [Variant id: 36, #gens: 539, #ops: 0, parent:35]
---analyzing modificationPoint position: 191
---modifPoint 0 not mutation generated in  double lower = java.lang.Double.POSITIVE_INFINITY
---analyzing modificationPoint position: 300
---modifPoint 1 not mutation generated in  final double cnst1 = 0.563
---analyzing modificationPoint position: 520
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 2 not mutation generated in  copyIn(d)
---analyzing modificationPoint position: 491
---modifPoint 3 not mutation generated in  return out
---analyzing modificationPoint position: 380
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  final double diP1 = di + si
---analyzing modificationPoint position: 126
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 5 not mutation generated in  for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { 	if (work[i + 2] <= 0) { 		i0 = 1 + (i / 4); 		break; 	[...]
---analyzing modificationPoint position: 194
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 6 not mutation generated in  lower = java.lang.Math.min(lower, work[(lowerStart + index) + i])
---analyzing modificationPoint position: 299
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 7 not mutation generated in  work[((4 * end) - pingPong) - 1] = eMin
---analyzing modificationPoint position: 298
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [dMin, dN1]
--> var from patch: dMin spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dN1 spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1419
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 + 2] = dN ` -topatch--> `dMin = java.lang.Math.min(dMin, dN1)` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1419, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 + 2] = dN ` -topatch--> `dMin = java.lang.Math.min(dMin, dN1)` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 36, #gens: 539, #ops: 1, parent:35] gen mutated: 1 , gen not mut: 8, gen not applied  0
-The child compiles: id 36
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-36/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 18] ,[]
-Valid?: |false|8|18|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(18): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 + 2] = dN ` -topatch--> `dMin = java.lang.Math.min(dMin, dN1)` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (35(f=1.0), 36(f=8.0), )
Selected to next generation: IDs2--> (35(f=1.0), )
----------Running generation: 19, population size: 1

***** Generation 19 : 0
**Parent Variant: [Variant id: 37, #gens: 539, #ops: 0, parent:-]

--Child created id: 38
--Creating new operations for variant [Variant id: 38, #gens: 539, #ops: 0, parent:37]
---analyzing modificationPoint position: 377
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  for (int i = 0; i < nM1; ++i) { 	final double di = d[i]; 	final double li = l[i]; 	final double diP1[...]
---analyzing modificationPoint position: 56
location: EigenDecompositionImpl.java1489
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `b2 = work[np - 2] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 38, #gens: 538, #ops: 1, parent:37] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 38
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-38/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(19): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `b2 = work[np - 2] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (37(f=1.0), 38(f=1.0), )
Selected to next generation: IDs2--> (37(f=1.0), )
----------Running generation: 20, population size: 1

***** Generation 20 : 0
**Parent Variant: [Variant id: 39, #gens: 539, #ops: 0, parent:-]

--Child created id: 40
--Creating new operations for variant [Variant id: 40, #gens: 539, #ops: 0, parent:39]
---analyzing modificationPoint position: 50
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2)
---analyzing modificationPoint position: 231
---modifPoint 1 not mutation generated in  double di = main[index] - lambda
---analyzing modificationPoint position: 446
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  minPivot = org.apache.commons.math.util.MathUtils.SAFE_MIN * java.lang.Math.max(1.0, eMax * eMax)
---analyzing modificationPoint position: 159
location: EigenDecompositionImpl.java993
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `g = 0.0 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 40, #gens: 538, #ops: 1, parent:39] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 40
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-40/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(20): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `g = 0.0 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (39(f=1.0), 40(f=1.0), )
Selected to next generation: IDs2--> (39(f=1.0), )
----------Running generation: 21, population size: 1

***** Generation 21 : 0
**Parent Variant: [Variant id: 41, #gens: 539, #ops: 0, parent:-]

--Child created id: 42
--Creating new operations for variant [Variant id: 42, #gens: 539, #ops: 0, parent:41]
---analyzing modificationPoint position: 533
---modifPoint 0 not mutation generated in  return (data == null) || (data[0] == null) ? 0 : data[0].length
---analyzing modificationPoint position: 289
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [work, j4]
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: j4 spoon.support.reflect.code.CtVariableReadImpl
location: EigenDecompositionImpl.java1400
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `j4 = j4 + 4 ` -topatch--> `work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2])` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1400, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `j4 = j4 + 4 ` -topatch--> `work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2])` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 42, #gens: 540, #ops: 1, parent:41] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 42
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-42/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(21): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `j4 = j4 + 4 ` -topatch--> `work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2])` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (41(f=1.0), 42(f=1.0), )
Selected to next generation: IDs2--> (41(f=1.0), )
----------Running generation: 22, population size: 1

***** Generation 22 : 0
**Parent Variant: [Variant id: 43, #gens: 539, #ops: 0, parent:-]

--Child created id: 44
--Creating new operations for variant [Variant id: 44, #gens: 539, #ops: 0, parent:43]
---analyzing modificationPoint position: 213
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  right = upper + margin
---analyzing modificationPoint position: 415
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tau]
--> var from patch: tau spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java679
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double tmp = realEigenvalues[i] ` -topatch--> `// the shift was good updateSigma(tau)` (spoon.support.reflect.code.CtInvocationImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 679, pointed element: CtInvocationImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double tmp = realEigenvalues[i] ` -topatch--> `// the shift was good updateSigma(tau)` (spoon.support.reflect.code.CtInvocationImpl) 

--Summary Creation: for variant [Variant id: 44, #gens: 540, #ops: 1, parent:43] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 44, errors: [EigenDecompositionImpl.java:1089: error: illegal start of expression
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:1089: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	       ^, EigenDecompositionImpl.java:1089: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	                     ^, EigenDecompositionImpl.java:1089: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	                             ^, EigenDecompositionImpl.java:1089: error: not a statement
	 * Find eigenvalue in a block with 1 row.
	                              ^, EigenDecompositionImpl.java:1089: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	                                  ^, EigenDecompositionImpl.java:1089: error: <identifier> expected
	 * Find eigenvalue in a block with 1 row.
	                                         ^, EigenDecompositionImpl.java:1090: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	      ^, EigenDecompositionImpl.java:1090: error: not a statement
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	 ^, EigenDecompositionImpl.java:1090: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                           ^, EigenDecompositionImpl.java:1090: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                        ^, EigenDecompositionImpl.java:1090: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                           ^, EigenDecompositionImpl.java:1090: error: illegal start of type
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                        ^, EigenDecompositionImpl.java:1090: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                          ^, EigenDecompositionImpl.java:1092: error: illegal start of expression
	 * @param index
	 ^, EigenDecompositionImpl.java:1092: error: illegal start of expression
	 * @param index
	   ^, EigenDecompositionImpl.java:1093: error: not a statement
	 * 		index of the first row of the block
	 ^, EigenDecompositionImpl.java:1093: error: ';' expected
	 * 		index of the first row of the block
	   		     ^, EigenDecompositionImpl.java:1093: error: ';' expected
	 * 		index of the first row of the block
	   		            ^, EigenDecompositionImpl.java:1093: error: ';' expected
	 * 		index of the first row of the block
	   		                      ^, EigenDecompositionImpl.java:1093: error: ';' expected
	 * 		index of the first row of the block
	   		                             ^, EigenDecompositionImpl.java:1094: error: illegal start of expression
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	  ^, EigenDecompositionImpl.java:1094: error: illegal start of expression
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	^, EigenDecompositionImpl.java:1094: error: illegal start of expression
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	        ^, EigenDecompositionImpl.java:1094: error: ';' expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                             ^, EigenDecompositionImpl.java:1094: error: ';' expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                             ^, EigenDecompositionImpl.java:1102: error: illegal start of expression
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	^, EigenDecompositionImpl.java:1102: error: illegal start of expression
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	        ^, EigenDecompositionImpl.java:1102: error: ';' expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                              ^, EigenDecompositionImpl.java:1102: error: ';' expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                              ^, EigenDecompositionImpl.java:1102: error: not a statement
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                                                                     ^, EigenDecompositionImpl.java:1102: error: ';' expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                                                                                            ^, EigenDecompositionImpl.java:1103: error: illegal start of expression
	 * Find realEigenvalues in a block with 3 rows.
	 ^, EigenDecompositionImpl.java:1103: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	       ^, EigenDecompositionImpl.java:1103: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                          ^, EigenDecompositionImpl.java:1103: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                                  ^, EigenDecompositionImpl.java:1103: error: not a statement
	 * Find realEigenvalues in a block with 3 rows.
	                                   ^, EigenDecompositionImpl.java:1103: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                                       ^, EigenDecompositionImpl.java:1103: error: <identifier> expected
	 * Find realEigenvalues in a block with 3 rows.
	                                               ^, EigenDecompositionImpl.java:1104: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	      ^, EigenDecompositionImpl.java:1104: error: not a statement
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	 ^, EigenDecompositionImpl.java:1104: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                           ^, EigenDecompositionImpl.java:1104: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                        ^, EigenDecompositionImpl.java:1104: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                           ^, EigenDecompositionImpl.java:1104: error: illegal start of type
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                        ^, EigenDecompositionImpl.java:1104: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                          ^, EigenDecompositionImpl.java:1106: error: illegal start of expression
	 * @param index
	 ^, EigenDecompositionImpl.java:1106: error: illegal start of expression
	 * @param index
	   ^, EigenDecompositionImpl.java:1107: error: not a statement
	 * 		index of the first row of the block
	 ^, EigenDecompositionImpl.java:1107: error: ';' expected
	 * 		index of the first row of the block
	   		     ^, EigenDecompositionImpl.java:1107: error: ';' expected
	 * 		index of the first row of the block
	   		            ^, EigenDecompositionImpl.java:1107: error: ';' expected
	 * 		index of the first row of the block
	   		                      ^, EigenDecompositionImpl.java:1107: error: ';' expected
	 * 		index of the first row of the block
	   		                             ^, EigenDecompositionImpl.java:1108: error: illegal start of expression
	 * @exception InvalidMatrixException
	   ^, EigenDecompositionImpl.java:1109: error: illegal start of expression
	 * 		if diagonal elements are not positive
	   		^, EigenDecompositionImpl.java:1109: error: not a statement
	 * 		if diagonal elements are not positive
	 ^, EigenDecompositionImpl.java:1109: error: ';' expected
	 * 		if diagonal elements are not positive
	   		                    ^, EigenDecompositionImpl.java:1109: error: ';' expected
	 * 		if diagonal elements are not positive
	   		                            ^, EigenDecompositionImpl.java:1110: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	  ^, EigenDecompositionImpl.java:1110: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	^, EigenDecompositionImpl.java:1110: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	        ^, EigenDecompositionImpl.java:1110: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                              ^, EigenDecompositionImpl.java:1110: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                              ^, EigenDecompositionImpl.java:1110: error: not a statement
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                                                                     ^, EigenDecompositionImpl.java:1110: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                                                                                            ^, EigenDecompositionImpl.java:1124: error: illegal start of expression
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	^, EigenDecompositionImpl.java:1124: error: illegal start of expression
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	        ^, EigenDecompositionImpl.java:1124: error: ';' expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                ^, EigenDecompositionImpl.java:1124: error: ';' expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                            ^, EigenDecompositionImpl.java:1124: error: not a statement
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                                                                   ^, EigenDecompositionImpl.java:1124: error: ';' expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                                                                                          ^, EigenDecompositionImpl.java:1127: error: illegal start of expression
	 * Perform two iterations with Li's tests for initial splits.
	 ^, EigenDecompositionImpl.java:1127: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	          ^, EigenDecompositionImpl.java:1127: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                         ^, EigenDecompositionImpl.java:1127: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1127: error: not a statement
	 * Perform two iterations with Li's tests for initial splits.
	                                    ^, EigenDecompositionImpl.java:1127: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                         ^, EigenDecompositionImpl.java:1127: error: '(' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                             ^, EigenDecompositionImpl.java:1127: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                                            ^, EigenDecompositionImpl.java:1129: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1129: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1130: error: ';' expected
	 * 		number of rows of the matrix to process
	   		      ^, EigenDecompositionImpl.java:1130: error: not a statement
	 * 		number of rows of the matrix to process
	   		       ^, EigenDecompositionImpl.java:1130: error: ')' expected
	 * 		number of rows of the matrix to process
	   		         ^, EigenDecompositionImpl.java:1130: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                 ^, EigenDecompositionImpl.java:1130: error: variable declaration not allowed here
	 * 		number of rows of the matrix to process
	   		               ^, EigenDecompositionImpl.java:1130: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                            ^, EigenDecompositionImpl.java:1130: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                                       ^, EigenDecompositionImpl.java:1131: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	^, EigenDecompositionImpl.java:1131: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	        ^, EigenDecompositionImpl.java:1131: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                          ^, EigenDecompositionImpl.java:1131: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1132: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1132: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1132: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1132: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1132: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1132: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1132: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1133: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^]
Ingredient counter is Zero
---Undoing: gnrtn(22): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double tmp = realEigenvalues[i] ` -topatch--> `// the shift was good updateSigma(tau)` (spoon.support.reflect.code.CtInvocationImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (43(f=1.0), 44(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (43(f=1.0), )
----------Running generation: 23, population size: 1

***** Generation 23 : 0
**Parent Variant: [Variant id: 45, #gens: 539, #ops: 0, parent:-]

--Child created id: 46
--Creating new operations for variant [Variant id: 46, #gens: 539, #ops: 0, parent:45]
---analyzing modificationPoint position: 474
Templates availables23
Attempts Base Ingredients  1 total 23
---modifPoint 0 not mutation generated in  final int nSum = this.getColumnDimension()
---analyzing modificationPoint position: 234
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1257
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int fourI = 4 * i ` -topatch--> `return true` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1257, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int fourI = 4 * i ` -topatch--> `return true` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 46, #gens: 540, #ops: 1, parent:45] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 46, errors: [EigenDecompositionImpl.java:1257: error: incompatible types: unexpected return value
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			return true;
	    	                                                                                    		                                  		                                  		                              			       ^]
Ingredient counter is Zero
---Undoing: gnrtn(23): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int fourI = 4 * i ` -topatch--> `return true` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (45(f=1.0), 46(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (45(f=1.0), )
----------Running generation: 24, population size: 1

***** Generation 24 : 0
**Parent Variant: [Variant id: 47, #gens: 539, #ops: 0, parent:-]

--Child created id: 48
--Creating new operations for variant [Variant id: 48, #gens: 539, #ops: 0, parent:47]
---analyzing modificationPoint position: 516
Templates availables12
Attempts Base Ingredients  1 total 12
---modifPoint 0 not mutation generated in  data = d
---analyzing modificationPoint position: 218
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  final double middle = 0.5 * (left + right)
---analyzing modificationPoint position: 512
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 2 not mutation generated in  if (nRows == 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException[...]
---analyzing modificationPoint position: 195
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tau]
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1164
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `tau = 0.0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1164, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `tau = 0.0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 48, #gens: 540, #ops: 1, parent:47] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 48
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-48/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(24): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `tau = 0.0` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (47(f=1.0), 48(f=1.0), )
Selected to next generation: IDs2--> (47(f=1.0), )
----------Running generation: 25, population size: 1

***** Generation 25 : 0
**Parent Variant: [Variant id: 49, #gens: 539, #ops: 0, parent:-]

--Child created id: 50
--Creating new operations for variant [Variant id: 50, #gens: 539, #ops: 0, parent:49]
---analyzing modificationPoint position: 529
Templates availables31
Attempts Base Ingredients  1 total 31
---modifPoint 0 not mutation generated in  for (int i = 0; i < data.length; ++i) { 	if (subMatrix[i].length != nCols) { 		throw org.apache.comm[...]
---analyzing modificationPoint position: 390
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  double pi = d[nM1] - lambda
---analyzing modificationPoint position: 497
location: Array2DRowRealMatrix.java487
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int j = 0; j < columns; ++j) { 	visitor.visit(i, j, rowI[j]); } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 50, #gens: 538, #ops: 1, parent:49] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 50, errors: [Array2DRowRealMatrix.java:487: error: variable declaration not allowed here
			final double[] rowI = data[i];
			               ^]
Ingredient counter is Zero
---Undoing: gnrtn(25): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int j = 0; j < columns; ++j) { 	visitor.visit(i, j, rowI[j]); } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (49(f=1.0), 50(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (49(f=1.0), )
----------Running generation: 26, population size: 1

***** Generation 26 : 0
**Parent Variant: [Variant id: 51, #gens: 539, #ops: 0, parent:-]

--Child created id: 52
--Creating new operations for variant [Variant id: 52, #gens: 539, #ops: 0, parent:51]
---analyzing modificationPoint position: 286
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  dN1 = dN2 * tmp
---analyzing modificationPoint position: 151
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  work[j] = d + work[i]
---analyzing modificationPoint position: 513
Templates availables23
Attempts Base Ingredients  1 total 23
---modifPoint 2 not mutation generated in  final int nCols = d[0].length
---analyzing modificationPoint position: 195
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  upper = java.lang.Math.max(upper, work[(upperStart + index) + i])
---analyzing modificationPoint position: 156
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  d *= tmp
---analyzing modificationPoint position: 338
Templates availables595
Attempts Base Ingredients  1 total 595
Name Conflict [cachedV, eigenvectors, eigenvectors.length]
---modifPoint 5 not mutation generated in  final double[] l = new double[m - 1]
---analyzing modificationPoint position: 227
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 6 not mutation generated in  ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t
---analyzing modificationPoint position: 217
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 7 not mutation generated in  // search has converged break
---analyzing modificationPoint position: 42
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dN]
--> var from patch: dN spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1534
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// compute contribution to norm squared from i > nn-2. final int np = nn - (2 * pingPong) ` -topatch--> `dN = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1534, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// compute contribution to norm squared from i > nn-2. final int np = nn - (2 * pingPong) ` -topatch--> `dN = 0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 52, #gens: 540, #ops: 1, parent:51] gen mutated: 1 , gen not mut: 8, gen not applied  0
-The child compiles: id 52
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-52/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(26): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// compute contribution to norm squared from i > nn-2. final int np = nn - (2 * pingPong) ` -topatch--> `dN = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (51(f=1.0), 52(f=1.0), )
Selected to next generation: IDs2--> (51(f=1.0), )
----------Running generation: 27, population size: 1

***** Generation 27 : 0
**Parent Variant: [Variant id: 53, #gens: 539, #ops: 0, parent:-]

--Child created id: 54
--Creating new operations for variant [Variant id: 54, #gens: 539, #ops: 0, parent:53]
---analyzing modificationPoint position: 423
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  cachedV = null
---analyzing modificationPoint position: 326
---modifPoint 1 not mutation generated in  double dot = 0
---analyzing modificationPoint position: 193
location: EigenDecompositionImpl.java1162
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < n; ++i) { 	lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 	u[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 54, #gens: 538, #ops: 1, parent:53] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 54
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-54/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 10, was successful: false, cases executed: 18] ,[]
-Valid?: |false|10|18|[]|, fitness 10.0
Ingredient counter is Zero
---Undoing: gnrtn(27): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < n; ++i) { 	lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 	u[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (53(f=1.0), 54(f=10.0), )
Selected to next generation: IDs2--> (53(f=1.0), )
----------Running generation: 28, population size: 1

***** Generation 28 : 0
**Parent Variant: [Variant id: 55, #gens: 539, #ops: 0, parent:-]

--Child created id: 56
--Creating new operations for variant [Variant id: 56, #gens: 539, #ops: 0, parent:55]
---analyzing modificationPoint position: 413
location: EigenDecompositionImpl.java592
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[upperStart + i] = upper ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 56, #gens: 538, #ops: 1, parent:55] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 56
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-56/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 5, was successful: false, cases executed: 18] ,[]
-Valid?: |false|5|18|[]|, fitness 5.0
Ingredient counter is Zero
---Undoing: gnrtn(28): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[upperStart + i] = upper ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (55(f=1.0), 56(f=5.0), )
Selected to next generation: IDs2--> (55(f=1.0), )
----------Running generation: 29, population size: 1

***** Generation 29 : 0
**Parent Variant: [Variant id: 57, #gens: 539, #ops: 0, parent:-]

--Child created id: 58
--Creating new operations for variant [Variant id: 58, #gens: 539, #ops: 0, parent:57]
---analyzing modificationPoint position: 264
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  eMin = work[((4 * start) + pingPong) + 4]
---analyzing modificationPoint position: 342
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [imagEigenvalues]
--> var from patch: imagEigenvalues spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1710
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 1; i < m; ++i) { 	final double eiM1 = secondary[i - 1]; 	final double ratio = eiM1 / di[...] ` -topatch--> `return imagEigenvalues.clone()` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1710, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 1; i < m; ++i) { 	final double eiM1 = secondary[i - 1]; 	final double ratio = eiM1 / di[...] ` -topatch--> `return imagEigenvalues.clone()` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 58, #gens: 540, #ops: 1, parent:57] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 58, errors: [EigenDecompositionImpl.java:1717: error: incompatible types: unexpected return value
		} 		return imagEigenvalues.clone();
		  		                            ^]
Ingredient counter is Zero
---Undoing: gnrtn(29): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 1; i < m; ++i) { 	final double eiM1 = secondary[i - 1]; 	final double ratio = eiM1 / di[...] ` -topatch--> `return imagEigenvalues.clone()` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (57(f=1.0), 58(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (57(f=1.0), )
----------Running generation: 30, population size: 1

***** Generation 30 : 0
**Parent Variant: [Variant id: 59, #gens: 539, #ops: 0, parent:-]

--Child created id: 60
--Creating new operations for variant [Variant id: 60, #gens: 539, #ops: 0, parent:59]
---analyzing modificationPoint position: 377
Templates availables42
Attempts Base Ingredients  1 total 42
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 0 not mutation generated in  for (int i = 0; i < nM1; ++i) { 	final double di = d[i]; 	final double li = l[i]; 	final double diP1[...]
---analyzing modificationPoint position: 117
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 1 not mutation generated in  int n0 = n
---analyzing modificationPoint position: 40
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [main]
--> var from patch: main spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1530
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `// case 5. tType = -5 ` -topatch--> `// splitting preserving relative accuracy double absDCurrent = java.lang.Math.abs(main[0])` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1530, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `// case 5. tType = -5 ` -topatch--> `// splitting preserving relative accuracy double absDCurrent = java.lang.Math.abs(main[0])` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 60, #gens: 540, #ops: 1, parent:59] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 60
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-60/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(30): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `// case 5. tType = -5 ` -topatch--> `// splitting preserving relative accuracy double absDCurrent = java.lang.Math.abs(main[0])` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (59(f=1.0), 60(f=1.0), )
Selected to next generation: IDs2--> (59(f=1.0), )
----------Running generation: 31, population size: 1

***** Generation 31 : 0
**Parent Variant: [Variant id: 61, #gens: 539, #ops: 0, parent:-]

--Child created id: 62
--Creating new operations for variant [Variant id: 62, #gens: 539, #ops: 0, parent:61]
---analyzing modificationPoint position: 271
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) &&  ((org.apac[...]
---analyzing modificationPoint position: 521
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 1 not mutation generated in  if (data == null) { 	if (row > 0) { 		throw org.apache.commons.math.MathRuntimeException.createIlleg[...]
---analyzing modificationPoint position: 511
Templates availables120
Attempts Base Ingredients  1 total 120
vars from patch []
location: Array2DRowRealMatrix.java121
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int nRows = d.length ` -topatch--> `final int nCols = this.getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 121, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int nRows = d.length ` -topatch--> `final int nCols = this.getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 62, #gens: 540, #ops: 1, parent:61] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 62, errors: [Array2DRowRealMatrix.java:442: error: illegal start of expression
	 * {@inheritDoc }
	 ^, Array2DRowRealMatrix.java:442: error: illegal start of expression
	 * {@inheritDoc }
	   ^, Array2DRowRealMatrix.java:442: error: illegal start of type
	 * {@inheritDoc }
	                ^, Array2DRowRealMatrix.java:442: error: ';' expected
	 * {@inheritDoc }
	                 ^, Array2DRowRealMatrix.java:443: error: illegal start of expression
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	  ^, Array2DRowRealMatrix.java:443: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	   ^, Array2DRowRealMatrix.java:443: error: not a statement
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	          ^, Array2DRowRealMatrix.java:443: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                   ^, Array2DRowRealMatrix.java:443: error: illegal start of expression
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	^, Array2DRowRealMatrix.java:443: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	          ^, Array2DRowRealMatrix.java:443: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	                                                         ^, Array2DRowRealMatrix.java:443: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	                                                                                                           ^, Array2DRowRealMatrix.java:443: error: not a statement
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	                                                                                                                             ^, Array2DRowRealMatrix.java:443: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	                                                                                                                                                      ^, Array2DRowRealMatrix.java:451: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	^, Array2DRowRealMatrix.java:451: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                   ^, Array2DRowRealMatrix.java:451: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                               ^, Array2DRowRealMatrix.java:451: error: not a statement
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                                                 ^, Array2DRowRealMatrix.java:451: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                                                                          ^, Array2DRowRealMatrix.java:452: error: illegal start of expression
	 * {@inheritDoc }
	 ^, Array2DRowRealMatrix.java:452: error: illegal start of expression
	 * {@inheritDoc }
	   ^, Array2DRowRealMatrix.java:452: error: illegal start of type
	 * {@inheritDoc }
	                ^, Array2DRowRealMatrix.java:452: error: ';' expected
	 * {@inheritDoc }
	                 ^, Array2DRowRealMatrix.java:453: error: illegal start of expression
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	  ^, Array2DRowRealMatrix.java:453: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	   ^, Array2DRowRealMatrix.java:453: error: not a statement
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	          ^, Array2DRowRealMatrix.java:453: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                   ^, Array2DRowRealMatrix.java:453: error: illegal start of expression
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	^, Array2DRowRealMatrix.java:453: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	          ^, Array2DRowRealMatrix.java:453: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	                                                         ^, Array2DRowRealMatrix.java:453: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	                                                                                                           ^, Array2DRowRealMatrix.java:453: error: not a statement
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	                                                                                                                             ^, Array2DRowRealMatrix.java:453: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	                                                                                                                                                      ^, Array2DRowRealMatrix.java:461: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	^, Array2DRowRealMatrix.java:461: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                   ^, Array2DRowRealMatrix.java:461: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                               ^, Array2DRowRealMatrix.java:461: error: not a statement
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                                                 ^, Array2DRowRealMatrix.java:461: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                                                                          ^, Array2DRowRealMatrix.java:462: error: illegal start of expression
	 * {@inheritDoc }
	 ^, Array2DRowRealMatrix.java:462: error: illegal start of expression
	 * {@inheritDoc }
	   ^, Array2DRowRealMatrix.java:462: error: illegal start of type
	 * {@inheritDoc }
	                ^, Array2DRowRealMatrix.java:462: error: ';' expected
	 * {@inheritDoc }
	                 ^, Array2DRowRealMatrix.java:463: error: illegal start of expression
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	  ^, Array2DRowRealMatrix.java:463: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	   ^, Array2DRowRealMatrix.java:463: error: not a statement
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	          ^, Array2DRowRealMatrix.java:463: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                   ^, Array2DRowRealMatrix.java:463: error: illegal start of expression
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	^, Array2DRowRealMatrix.java:463: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	      ^, Array2DRowRealMatrix.java:463: error: illegal start of expression
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	             ^, Array2DRowRealMatrix.java:463: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	              ^, Array2DRowRealMatrix.java:463: error: illegal start of expression
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	               ^, Array2DRowRealMatrix.java:463: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	                ^, Array2DRowRealMatrix.java:463: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	                           ^, Array2DRowRealMatrix.java:469: error: illegal start of expression
	 */ 	public double[][] getDataRef() { 		return data;} 	/**
	    	^, Array2DRowRealMatrix.java:469: error: ';' expected
	 */ 	public double[][] getDataRef() { 		return data;} 	/**
	    	                            ^, Array2DRowRealMatrix.java:471: error: ';' expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
	    	                    	                        ^, Array2DRowRealMatrix.java:471: error: <identifier> expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
	    	                    	                                                    ^, Array2DRowRealMatrix.java:471: error: <identifier> expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
	    	                    	                                                                   ^, Array2DRowRealMatrix.java:471: error: ';' expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
	    	                    	                                                                                    ^, Array2DRowRealMatrix.java:471: error: not a statement
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
	    	                    	                                                                                                                           ^, Array2DRowRealMatrix.java:471: error: ';' expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
	    	                    	                                                                                                                                                ^, Array2DRowRealMatrix.java:473: error: ';' expected
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			return data[row][column];} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                      ^, Array2DRowRealMatrix.java:473: error: <identifier> expected
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			return data[row][column];} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                     ^, Array2DRowRealMatrix.java:473: error: ';' expected
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			return data[row][column];} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                      ^, Array2DRowRealMatrix.java:473: error: not a statement
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			return data[row][column];} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                             ^, Array2DRowRealMatrix.java:473: error: ';' expected
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			return data[row][column];} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                                  ^, Array2DRowRealMatrix.java:475: error: ';' expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] = value;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                    ^, Array2DRowRealMatrix.java:475: error: <identifier> expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] = value;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                   ^, Array2DRowRealMatrix.java:475: error: <identifier> expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] = value;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                     ^, Array2DRowRealMatrix.java:475: error: ';' expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] = value;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                        ^, Array2DRowRealMatrix.java:475: error: not a statement
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] = value;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                               ^, Array2DRowRealMatrix.java:475: error: ';' expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] = value;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                                                    ^, Array2DRowRealMatrix.java:477: error: ';' expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] += increment;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                      ^, Array2DRowRealMatrix.java:477: error: <identifier> expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] += increment;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                     ^, Array2DRowRealMatrix.java:477: error: <identifier> expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] += increment;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                       ^, Array2DRowRealMatrix.java:477: error: ';' expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] += increment;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                              ^, Array2DRowRealMatrix.java:477: error: not a statement
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] += increment;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                                     ^, Array2DRowRealMatrix.java:477: error: ';' expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] += increment;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                                                          ^, Array2DRowRealMatrix.java:479: error: ';' expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] *= factor;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                         ^, Array2DRowRealMatrix.java:479: error: <identifier> expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] *= factor;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                        ^, Array2DRowRealMatrix.java:479: error: <identifier> expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] *= factor;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                          ^, Array2DRowRealMatrix.java:479: error: ';' expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] *= factor;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                              ^, Array2DRowRealMatrix.java:479: error: not a statement
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] *= factor;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                                     ^, Array2DRowRealMatrix.java:479: error: ';' expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] *= factor;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                                                          ^, Array2DRowRealMatrix.java:481: error: ';' expected
	 */ 	@java.lang.Override 	public int getRowDimension() { 		return data == null ? 0 : data.length;} 	/**
	    	                    	                          ^, Array2DRowRealMatrix.java:483: error: ';' expected
	 */ 	@java.lang.Override 	public int getColumnDimension() { 		return (data == null) || (data[0] == null) ? 0 : data[0].length;} 	/**
	    	                    	                             ^, Array2DRowRealMatrix.java:485: error: ';' expected
	 */ 	@java.lang.Override 	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = this.getRowDimension(); 		final int nCols = this.getColumnDimension(); 		if (v.length != nCols) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);} 		final double[] out = new double[nRows]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			double sum = 0; 			for (int i = 0; i < nCols; i++) { 				sum += dataRow[i] * v[i];} 			out[row] = sum;} 		return out;} 	/**
	    	                    	                       ^, Array2DRowRealMatrix.java:485: error: ';' expected
	 */ 	@java.lang.Override 	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = this.getRowDimension(); 		final int nCols = this.getColumnDimension(); 		if (v.length != nCols) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);} 		final double[] out = new double[nRows]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			double sum = 0; 			for (int i = 0; i < nCols; i++) { 				sum += dataRow[i] * v[i];} 			out[row] = sum;} 		return out;} 	/**
	    	                    	                                        ^, Array2DRowRealMatrix.java:485: error: not a statement
	 */ 	@java.lang.Override 	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = this.getRowDimension(); 		final int nCols = this.getColumnDimension(); 		if (v.length != nCols) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);} 		final double[] out = new double[nRows]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			double sum = 0; 			for (int i = 0; i < nCols; i++) { 				sum += dataRow[i] * v[i];} 			out[row] = sum;} 		return out;} 	/**
	    	                    	                                                          ^, Array2DRowRealMatrix.java:485: error: ';' expected
	 */ 	@java.lang.Override 	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = this.getRowDimension(); 		final int nCols = this.getColumnDimension(); 		if (v.length != nCols) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);} 		final double[] out = new double[nRows]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			double sum = 0; 			for (int i = 0; i < nCols; i++) { 				sum += dataRow[i] * v[i];} 			out[row] = sum;} 		return out;} 	/**
	    	                    	                                                                                   ^, Array2DRowRealMatrix.java:487: error: ';' expected
	 */ 	@java.lang.Override 	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = getRowDimension(); 		final int nCols = getColumnDimension(); 		if (v.length != nRows) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);} 		final double[] out = new double[nCols]; 		for (int col = 0; col < nCols; ++col) { 			double sum = 0; 			for (int i = 0; i < nRows; ++i) { 				sum += data[i][col] * v[i];} 			out[col] = sum;} 		return out;} 	/**
	    	                    	                           ^, Array2DRowRealMatrix.java:487: error: ';' expected
	 */ 	@java.lang.Override 	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = getRowDimension(); 		final int nCols = getColumnDimension(); 		if (v.length != nRows) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);} 		final double[] out = new double[nCols]; 		for (int col = 0; col < nCols; ++col) { 			double sum = 0; 			for (int i = 0; i < nRows; ++i) { 				sum += data[i][col] * v[i];} 			out[col] = sum;} 		return out;} 	/**
	    	                    	                                            ^, Array2DRowRealMatrix.java:487: error: not a statement
	 */ 	@java.lang.Override 	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = getRowDimension(); 		final int nCols = getColumnDimension(); 		if (v.length != nRows) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);} 		final double[] out = new double[nCols]; 		for (int col = 0; col < nCols; ++col) { 			double sum = 0; 			for (int i = 0; i < nRows; ++i) { 				sum += data[i][col] * v[i];} 			out[col] = sum;} 		return out;} 	/**
	    	                    	                                                              ^, Array2DRowRealMatrix.java:487: error: ';' expected
	 */ 	@java.lang.Override 	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = getRowDimension(); 		final int nCols = getColumnDimension(); 		if (v.length != nRows) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);} 		final double[] out = new double[nCols]; 		for (int col = 0; col < nCols; ++col) { 			double sum = 0; 			for (int i = 0; i < nRows; ++i) { 				sum += data[i][col] * v[i];} 			out[col] = sum;} 		return out;} 	/**
	    	                    	                                                                                       ^, Array2DRowRealMatrix.java:489: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException { 		final int rows = getRowDimension(); 		final int columns = getColumnDimension(); 		visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); 		for (int i = 0; i < rows; ++i) { 			final double[] rowI = data[i]; 			for (int j = 0; j < columns; ++j) { 				rowI[j] = visitor.visit(i, j, rowI[j]);}} 		return visitor.end();} 	/**
	    	                    	                            ^, Array2DRowRealMatrix.java:489: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException { 		final int rows = getRowDimension(); 		final int columns = getColumnDimension(); 		visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); 		for (int i = 0; i < rows; ++i) { 			final double[] rowI = data[i]; 			for (int j = 0; j < columns; ++j) { 				rowI[j] = visitor.visit(i, j, rowI[j]);}} 		return visitor.end();} 	/**
	    	                    	                                                                                                   ^, Array2DRowRealMatrix.java:489: error: not a statement
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException { 		final int rows = getRowDimension(); 		final int columns = getColumnDimension(); 		visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); 		for (int i = 0; i < rows; ++i) { 			final double[] rowI = data[i]; 			for (int j = 0; j < columns; ++j) { 				rowI[j] = visitor.visit(i, j, rowI[j]);}} 		return visitor.end();} 	/**
	    	                    	                                                                                                                                          ^, Array2DRowRealMatrix.java:489: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException { 		final int rows = getRowDimension(); 		final int columns = getColumnDimension(); 		visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); 		for (int i = 0; i < rows; ++i) { 			final double[] rowI = data[i]; 			for (int j = 0; j < columns; ++j) { 				rowI[j] = visitor.visit(i, j, rowI[j]);}} 		return visitor.end();} 	/**
	    	                    	                                                                                                                                                                 ^, Array2DRowRealMatrix.java:491: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException { 		final int rows = getRowDimension(); 		final int columns = getColumnDimension(); 		visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); 		for (int i = 0; i < rows; ++i) { 			final double[] rowI = data[i]; 			for (int j = 0; j < columns; ++j) { 				visitor.visit(i, j, rowI[j]);}}
	    	                    	                            ^, Array2DRowRealMatrix.java:491: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException { 		final int rows = getRowDimension(); 		final int columns = getColumnDimension(); 		visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); 		for (int i = 0; i < rows; ++i) { 			final double[] rowI = data[i]; 			for (int j = 0; j < columns; ++j) { 				visitor.visit(i, j, rowI[j]);}}
	    	                    	                                                                                                     ^]
Ingredient counter is Zero
---Undoing: gnrtn(31): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int nRows = d.length ` -topatch--> `final int nCols = this.getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (61(f=1.0), 62(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (61(f=1.0), )
----------Running generation: 32, population size: 1

***** Generation 32 : 0
**Parent Variant: [Variant id: 63, #gens: 539, #ops: 0, parent:-]

--Child created id: 64
--Creating new operations for variant [Variant id: 64, #gens: 539, #ops: 0, parent:63]
---analyzing modificationPoint position: 199
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  final int maxIter =  2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot[...]
---analyzing modificationPoint position: 310
---modifPoint 1 not mutation generated in  // cases 2 and 3. final double gap2 = (dMin2 - a2) - (dMin2 * 0.25)
---analyzing modificationPoint position: 274
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  d *= tmp
---analyzing modificationPoint position: 347
location: EigenDecompositionImpl.java1715
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `d[i] = di ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 64, #gens: 538, #ops: 1, parent:63] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 64
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-64/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 18] ,[]
-Valid?: |false|8|18|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(32): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `d[i] = di ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (63(f=1.0), 64(f=8.0), )
Selected to next generation: IDs2--> (63(f=1.0), )
----------Running generation: 33, population size: 1

***** Generation 33 : 0
**Parent Variant: [Variant id: 65, #gens: 539, #ops: 0, parent:-]

--Child created id: 66
--Creating new operations for variant [Variant id: 66, #gens: 539, #ops: 0, parent:65]
---analyzing modificationPoint position: 161
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  for (boolean deflating = true; deflating;) {  	if (start >= deflatedEnd) { 		// the array has been c[...]
---analyzing modificationPoint position: 491
---modifPoint 1 not mutation generated in  return out
---analyzing modificationPoint position: 375
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  double si = -lambda
---analyzing modificationPoint position: 97
---modifPoint 3 not mutation generated in  final double s = secondary[i]
---analyzing modificationPoint position: 392
Templates availables42
Attempts Base Ingredients  1 total 42
---modifPoint 4 not mutation generated in  for (int i = nM1 - 1; i >= 0; --i) { 	final double di = d[i]; 	final double li = l[i]; 	final double[...]
---analyzing modificationPoint position: 538
location: AbstractRealMatrix.java56
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (rowDimension <= 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentEx[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 66, #gens: 538, #ops: 1, parent:65] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 66
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-66/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(33): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (rowDimension <= 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentEx[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (65(f=1.0), 66(f=1.0), )
Selected to next generation: IDs2--> (65(f=1.0), )
----------Running generation: 34, population size: 1

***** Generation 34 : 0
**Parent Variant: [Variant id: 67, #gens: 539, #ops: 0, parent:-]

--Child created id: 68
--Creating new operations for variant [Variant id: 68, #gens: 539, #ops: 0, parent:67]
---analyzing modificationPoint position: 86
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 0 not mutation generated in  if (s <= t) { 	s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t)))); } els[...]
---analyzing modificationPoint position: 430
Templates availables281
Attempts Base Ingredients  1 total 281
---modifPoint 1 not mutation generated in  return subtract(((org.apache.commons.math.linear.ArrayRealVector) (v)))
---analyzing modificationPoint position: 17
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 2 not mutation generated in  work[i + k] = work[j - k]
---analyzing modificationPoint position: 486
Templates availables216
Attempts Base Ingredients  1 total 216
---modifPoint 3 not mutation generated in  final int nCols = getColumnDimension()
---analyzing modificationPoint position: 230
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  return count
---analyzing modificationPoint position: 4
location: EigenDecompositionImpl.java957
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[i] = -0.0 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 68, #gens: 538, #ops: 1, parent:67] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 68
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-68/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(34): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[i] = -0.0 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (67(f=1.0), 68(f=1.0), )
Selected to next generation: IDs2--> (67(f=1.0), )
----------Running generation: 35, population size: 1

***** Generation 35 : 0
**Parent Variant: [Variant id: 69, #gens: 539, #ops: 0, parent:-]

--Child created id: 70
--Creating new operations for variant [Variant id: 70, #gens: 539, #ops: 0, parent:69]
---analyzing modificationPoint position: 534
---modifPoint 0 not mutation generated in  return data == null ? 0 : data.length
---analyzing modificationPoint position: 208
location: EigenDecompositionImpl.java1188
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (countEigenValues(middle, index, n) >= 1) { 	right = middle; } else { 	left = middle; } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 70, #gens: 538, #ops: 1, parent:69] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 70
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-70/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 2, was successful: false, cases executed: 18] ,[]
-Valid?: |false|2|18|[]|, fitness 2.0
Ingredient counter is Zero
---Undoing: gnrtn(35): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (countEigenValues(middle, index, n) >= 1) { 	right = middle; } else { 	left = middle; } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (69(f=1.0), 70(f=2.0), )
Selected to next generation: IDs2--> (69(f=1.0), )
----------Running generation: 36, population size: 1

***** Generation 36 : 0
**Parent Variant: [Variant id: 71, #gens: 539, #ops: 0, parent:-]

--Child created id: 72
--Creating new operations for variant [Variant id: 72, #gens: 539, #ops: 0, parent:71]
---analyzing modificationPoint position: 431
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  final int m = main.length
---analyzing modificationPoint position: 228
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  if (ratio <= 0) { 	++count; }
---analyzing modificationPoint position: 301
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  final double cnst2 = 1.01
---analyzing modificationPoint position: 242
location: EigenDecompositionImpl.java1276
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = d ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 72, #gens: 538, #ops: 1, parent:71] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 72
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-72/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
-Killed id: pid->74298
The Process that runs JUnit test cases did not terminate within waitTime of 10 seconds
Killed the Process that runs JUnit test cases 74298
**The validation 1 have not finished well**
-Valid?: null, fitness 1.7976931348623157E308
Ingredient counter is Zero
---Undoing: gnrtn(36): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = d ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (71(f=1.0), 72(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (71(f=1.0), )
----------Running generation: 37, population size: 1

***** Generation 37 : 0
**Parent Variant: [Variant id: 73, #gens: 539, #ops: 0, parent:-]

--Child created id: 74
--Creating new operations for variant [Variant id: 74, #gens: 539, #ops: 0, parent:73]
---analyzing modificationPoint position: 142
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  pingPong = 0
---analyzing modificationPoint position: 334
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  n2 += z * z
---analyzing modificationPoint position: 12
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dMin, org.apache.commons.math.util.MathUtils.SAFE_MIN, qMax, work, l, dMin2, pingPong, start, deflatedEnd, end, loop, dMin1, tau, org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE, sigma, dN1, dN, tType, org.apache.commons.math.util.MathUtils.EPSILON]
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: org.apache.commons.math.util.MathUtils.SAFE_MIN spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: qMax spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: l spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: dMin2 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: start spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: deflatedEnd spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: end spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: loop spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: dMin1 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: tau spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: sigma spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: dN1 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: dN spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: tType spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: org.apache.commons.math.util.MathUtils.EPSILON spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1063
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = -0.0 ` -topatch--> `if ((dMin < 0) ||  ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(wo[...]` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1063, pointed element: CtIfImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = -0.0 ` -topatch--> `if ((dMin < 0) ||  ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(wo[...]` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 74, #gens: 540, #ops: 1, parent:73] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 74, errors: [EigenDecompositionImpl.java:1135: error: illegal start of expression
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array
	    	^, EigenDecompositionImpl.java:1135: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array
	    	                               ^, EigenDecompositionImpl.java:1135: error: <identifier> expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array
	    	                                            ^, EigenDecompositionImpl.java:1135: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array
	    	                                                           ^, EigenDecompositionImpl.java:1158: error: illegal start of expression
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	^, EigenDecompositionImpl.java:1158: error: ';' expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                 ^, EigenDecompositionImpl.java:1158: error: <identifier> expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                                  ^, EigenDecompositionImpl.java:1158: error: ';' expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                                              ^, EigenDecompositionImpl.java:1234: error: illegal start of expression
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	^, EigenDecompositionImpl.java:1234: error: ';' expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                            ^, EigenDecompositionImpl.java:1234: error: <identifier> expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                            ^, EigenDecompositionImpl.java:1234: error: <identifier> expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                                             ^, EigenDecompositionImpl.java:1234: error: ';' expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                                                         ^, EigenDecompositionImpl.java:1257: error: illegal start of expression
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	^, EigenDecompositionImpl.java:1257: error: illegal start of expression
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	        ^, EigenDecompositionImpl.java:1257: error: ';' expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                              ^, EigenDecompositionImpl.java:1257: error: <identifier> expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                   ^, EigenDecompositionImpl.java:1257: error: <identifier> expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                                    ^, EigenDecompositionImpl.java:1257: error: ';' expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                                                ^, EigenDecompositionImpl.java:1275: error: illegal start of expression
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	^, EigenDecompositionImpl.java:1275: error: illegal start of expression
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	        ^, EigenDecompositionImpl.java:1275: error: ';' expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                 ^, EigenDecompositionImpl.java:1275: error: <identifier> expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                  ^, EigenDecompositionImpl.java:1275: error: ';' expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                                ^, EigenDecompositionImpl.java:1332: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	^, EigenDecompositionImpl.java:1332: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	        ^, EigenDecompositionImpl.java:1332: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                ^, EigenDecompositionImpl.java:1332: error: <identifier> expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                 ^, EigenDecompositionImpl.java:1332: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                               ^, EigenDecompositionImpl.java:1435: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	^, EigenDecompositionImpl.java:1435: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	        ^, EigenDecompositionImpl.java:1435: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                  ^, EigenDecompositionImpl.java:1435: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                                   ^, EigenDecompositionImpl.java:1435: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                                                  ^, EigenDecompositionImpl.java:1435: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                                                                     ^, EigenDecompositionImpl.java:1681: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	^, EigenDecompositionImpl.java:1681: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	        ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                        ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                                           ^, EigenDecompositionImpl.java:1699: error: illegal start of expression
	private void findEigenVectors() {
	^, EigenDecompositionImpl.java:1699: error: illegal start of expression
	private void findEigenVectors() {
	        ^, EigenDecompositionImpl.java:1699: error: ';' expected
	private void findEigenVectors() {
	                             ^, EigenDecompositionImpl.java:1737: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	^, EigenDecompositionImpl.java:1737: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                      ^, EigenDecompositionImpl.java:1737: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                               ^, EigenDecompositionImpl.java:1737: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1737: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1799: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1799: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^, EigenDecompositionImpl.java:1799: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                  ^, EigenDecompositionImpl.java:1799: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                    ^, EigenDecompositionImpl.java:1799: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                      ^, EigenDecompositionImpl.java:1799: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                                          ^, EigenDecompositionImpl.java:1827: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	^, EigenDecompositionImpl.java:1827: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	        ^, EigenDecompositionImpl.java:1827: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                   ^, EigenDecompositionImpl.java:1827: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                     ^, EigenDecompositionImpl.java:1827: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                       ^, EigenDecompositionImpl.java:1827: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                                           ^, EigenDecompositionImpl.java:1844: error: reached end of file while parsing
}
 ^]
Ingredient counter is Zero
---Undoing: gnrtn(37): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = -0.0 ` -topatch--> `if ((dMin < 0) ||  ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(wo[...]` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (73(f=1.0), 74(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (73(f=1.0), )
----------Running generation: 38, population size: 1

***** Generation 38 : 0
**Parent Variant: [Variant id: 75, #gens: 539, #ops: 0, parent:-]

--Child created id: 76
--Creating new operations for variant [Variant id: 76, #gens: 539, #ops: 0, parent:75]
---analyzing modificationPoint position: 5
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  work[j] = d
---analyzing modificationPoint position: 465
location: ArrayRealVector.java285
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < data.length; i++) { 	out[i] = data[i] - v[i]; } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 76, #gens: 538, #ops: 1, parent:75] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 76
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-76/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(38): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < data.length; i++) { 	out[i] = data[i] - v[i]; } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (75(f=1.0), 76(f=1.0), )
Selected to next generation: IDs2--> (75(f=1.0), )
----------Running generation: 39, population size: 1

***** Generation 39 : 0
**Parent Variant: [Variant id: 77, #gens: 539, #ops: 0, parent:-]

--Child created id: 78
--Creating new operations for variant [Variant id: 78, #gens: 539, #ops: 0, parent:77]
---analyzing modificationPoint position: 359
location: EigenDecompositionImpl.java1754
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `sixI += 6 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 78, #gens: 538, #ops: 1, parent:77] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 78
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-78/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 18] ,[]
-Valid?: |false|3|18|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(39): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `sixI += 6 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (77(f=1.0), 78(f=3.0), )
Selected to next generation: IDs2--> (77(f=1.0), )
----------Running generation: 40, population size: 1

***** Generation 40 : 0
**Parent Variant: [Variant id: 79, #gens: 539, #ops: 0, parent:-]

--Child created id: 80
--Creating new operations for variant [Variant id: 80, #gens: 539, #ops: 0, parent:79]
---analyzing modificationPoint position: 142
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  pingPong = 0
---analyzing modificationPoint position: 232
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  work[0] = java.lang.Math.abs(di)
---analyzing modificationPoint position: 368
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1768
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `z = 1 ` -topatch--> `// matrix is already diagonal return` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1768, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `z = 1 ` -topatch--> `// matrix is already diagonal return` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 80, #gens: 540, #ops: 1, parent:79] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 80, errors: [EigenDecompositionImpl.java:1769: error: incompatible types: missing return value
		return; 		z = 1;
		^]
Ingredient counter is Zero
---Undoing: gnrtn(40): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `z = 1 ` -topatch--> `// matrix is already diagonal return` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (79(f=1.0), 80(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (79(f=1.0), )
----------Running generation: 41, population size: 1

***** Generation 41 : 0
**Parent Variant: [Variant id: 81, #gens: 539, #ops: 0, parent:-]

--Child created id: 82
--Creating new operations for variant [Variant id: 82, #gens: 539, #ops: 0, parent:81]
---analyzing modificationPoint position: 133
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java881
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[(4 * n0) - 2] = offDiagMin ` -topatch--> `break` (spoon.support.reflect.code.CtBreakImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 881, pointed element: CtBreakImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[(4 * n0) - 2] = offDiagMin ` -topatch--> `break` (spoon.support.reflect.code.CtBreakImpl) 

--Summary Creation: for variant [Variant id: 82, #gens: 540, #ops: 1, parent:81] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 82, errors: [EigenDecompositionImpl.java:885: error: unreachable statement
			dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax)));
			^]
Ingredient counter is Zero
---Undoing: gnrtn(41): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[(4 * n0) - 2] = offDiagMin ` -topatch--> `break` (spoon.support.reflect.code.CtBreakImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (81(f=1.0), 82(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (81(f=1.0), )
----------Running generation: 42, population size: 1

***** Generation 42 : 0
**Parent Variant: [Variant id: 83, #gens: 539, #ops: 0, parent:-]

--Child created id: 84
--Creating new operations for variant [Variant id: 84, #gens: 539, #ops: 0, parent:83]
---analyzing modificationPoint position: 358
location: EigenDecompositionImpl.java1750
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (absG < minG) { 	r = i; 	minG = absG; } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 84, #gens: 538, #ops: 1, parent:83] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 84
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-84/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 7, was successful: false, cases executed: 18] ,[]
-Valid?: |false|7|18|[]|, fitness 7.0
Ingredient counter is Zero
---Undoing: gnrtn(42): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (absG < minG) { 	r = i; 	minG = absG; } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (83(f=1.0), 84(f=7.0), )
Selected to next generation: IDs2--> (83(f=1.0), )
----------Running generation: 43, population size: 1

***** Generation 43 : 0
**Parent Variant: [Variant id: 85, #gens: 539, #ops: 0, parent:-]

--Child created id: 86
--Creating new operations for variant [Variant id: 86, #gens: 539, #ops: 0, parent:85]
---analyzing modificationPoint position: 133
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  work[(4 * n0) - 2] = offDiagMin
---analyzing modificationPoint position: 342
location: EigenDecompositionImpl.java1710
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 1; i < m; ++i) { 	final double eiM1 = secondary[i - 1]; 	final double ratio = eiM1 / di[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 86, #gens: 538, #ops: 1, parent:85] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 86
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-86/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 18] ,[]
-Valid?: |false|8|18|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(43): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 1; i < m; ++i) { 	final double eiM1 = secondary[i - 1]; 	final double ratio = eiM1 / di[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (85(f=1.0), 86(f=8.0), )
Selected to next generation: IDs2--> (85(f=1.0), )
----------Running generation: 44, population size: 1

***** Generation 44 : 0
**Parent Variant: [Variant id: 87, #gens: 539, #ops: 0, parent:-]

--Child created id: 88
--Creating new operations for variant [Variant id: 88, #gens: 539, #ops: 0, parent:87]
---analyzing modificationPoint position: 484
Templates availables16
Attempts Base Ingredients  1 total 16
---modifPoint 0 not mutation generated in  return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false)
---analyzing modificationPoint position: 298
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 1 not mutation generated in  work[j4 + 2] = dN
---analyzing modificationPoint position: 533
---modifPoint 2 not mutation generated in  return (data == null) || (data[0] == null) ? 0 : data[0].length
---analyzing modificationPoint position: 413
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  work[upperStart + i] = upper
---analyzing modificationPoint position: 132
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [cachedV]
--> var from patch: cachedV spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java879
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]) ` -topatch--> `// return the cached matrix return cachedV` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 879, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]) ` -topatch--> `// return the cached matrix return cachedV` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 88, #gens: 540, #ops: 1, parent:87] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child does NOT compile: 88, errors: [EigenDecompositionImpl.java:881: error: incompatible types: unexpected return value
				return cachedV;}
				       ^]
Ingredient counter is Zero
---Undoing: gnrtn(44): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]) ` -topatch--> `// return the cached matrix return cachedV` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (87(f=1.0), 88(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (87(f=1.0), )
----------Running generation: 45, population size: 1

***** Generation 45 : 0
**Parent Variant: [Variant id: 89, #gens: 539, #ops: 0, parent:-]

--Child created id: 90
--Creating new operations for variant [Variant id: 90, #gens: 539, #ops: 0, parent:89]
---analyzing modificationPoint position: 71
Templates availables281
Attempts Base Ingredients  1 total 281
---modifPoint 0 not mutation generated in  double sum = 0
---analyzing modificationPoint position: 23
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [secondary, transformer]
--> var from patch: secondary spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: transformer spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1386
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = dN1 ` -topatch--> `secondary = transformer.getSecondaryDiagonalRef()` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1386, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = dN1 ` -topatch--> `secondary = transformer.getSecondaryDiagonalRef()` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 90, #gens: 540, #ops: 1, parent:89] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 90
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-90/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(45): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = dN1 ` -topatch--> `secondary = transformer.getSecondaryDiagonalRef()` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (89(f=1.0), 90(f=1.0), )
Selected to next generation: IDs2--> (89(f=1.0), )
----------Running generation: 46, population size: 1

***** Generation 46 : 0
**Parent Variant: [Variant id: 91, #gens: 539, #ops: 0, parent:-]

--Child created id: 92
--Creating new operations for variant [Variant id: 92, #gens: 539, #ops: 0, parent:91]
---analyzing modificationPoint position: 297
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [d, work, j4]
--> var from patch: d spoon.support.reflect.code.CtVariableWriteImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: j4 spoon.support.reflect.code.CtVariableReadImpl
location: EigenDecompositionImpl.java1417
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = java.lang.Math.min(dMin, dN) ` -topatch--> `d *= work[j4 + 2] / work[j4 - 3]` (spoon.support.reflect.code.CtOperatorAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1417, pointed element: CtOperatorAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = java.lang.Math.min(dMin, dN) ` -topatch--> `d *= work[j4 + 2] / work[j4 - 3]` (spoon.support.reflect.code.CtOperatorAssignmentImpl) 

--Summary Creation: for variant [Variant id: 92, #gens: 540, #ops: 1, parent:91] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 92
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-92/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(46): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = java.lang.Math.min(dMin, dN) ` -topatch--> `d *= work[j4 + 2] / work[j4 - 3]` (spoon.support.reflect.code.CtOperatorAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (91(f=1.0), 92(f=1.0), )
Selected to next generation: IDs2--> (91(f=1.0), )
----------Running generation: 47, population size: 1

***** Generation 47 : 0
**Parent Variant: [Variant id: 93, #gens: 539, #ops: 0, parent:-]

--Child created id: 94
--Creating new operations for variant [Variant id: 94, #gens: 539, #ops: 0, parent:93]
---analyzing modificationPoint position: 514
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  if (nCols == 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException[...]
---analyzing modificationPoint position: 205
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  if ((range < absoluteTolerance) ||  (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.[...]
---analyzing modificationPoint position: 94
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 2 not mutation generated in  transformer = null
---analyzing modificationPoint position: 262
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [this.secondary]
--> var from patch: this.secondary spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1317
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 + 2] = dN ` -topatch--> `this.secondary = secondary.clone()` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1317, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 + 2] = dN ` -topatch--> `this.secondary = secondary.clone()` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 94, #gens: 539, #ops: 1, parent:93] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 94
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-94/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 10, was successful: false, cases executed: 18] ,[]
-Valid?: |false|10|18|[]|, fitness 10.0
Ingredient counter is Zero
---Undoing: gnrtn(47): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 + 2] = dN ` -topatch--> `this.secondary = secondary.clone()` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (93(f=1.0), 94(f=10.0), )
Selected to next generation: IDs2--> (93(f=1.0), )
----------Running generation: 48, population size: 1

***** Generation 48 : 0
**Parent Variant: [Variant id: 95, #gens: 539, #ops: 0, parent:-]

--Child created id: 96
--Creating new operations for variant [Variant id: 96, #gens: 539, #ops: 0, parent:95]
---analyzing modificationPoint position: 237
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di)
---analyzing modificationPoint position: 103
Templates availables156
Attempts Base Ingredients  1 total 156
vars from patch [dMin]
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java829
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int fourI = 4 * i ` -topatch--> `double s = 0.25 * dMin` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 829, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int fourI = 4 * i ` -topatch--> `double s = 0.25 * dMin` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 96, #gens: 539, #ops: 1, parent:95] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 96, errors: [EigenDecompositionImpl.java:1480: error: illegal start of expression
	 * Perform two iterations with Li's tests for initial splits.
	 ^, EigenDecompositionImpl.java:1480: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	          ^, EigenDecompositionImpl.java:1480: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                         ^, EigenDecompositionImpl.java:1480: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1480: error: not a statement
	 * Perform two iterations with Li's tests for initial splits.
	                                    ^, EigenDecompositionImpl.java:1480: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                         ^, EigenDecompositionImpl.java:1480: error: '(' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                             ^, EigenDecompositionImpl.java:1480: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                                            ^, EigenDecompositionImpl.java:1482: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1482: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1483: error: ';' expected
	 * 		number of rows of the matrix to process
	   		      ^, EigenDecompositionImpl.java:1483: error: not a statement
	 * 		number of rows of the matrix to process
	   		       ^, EigenDecompositionImpl.java:1483: error: ')' expected
	 * 		number of rows of the matrix to process
	   		         ^, EigenDecompositionImpl.java:1483: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                 ^, EigenDecompositionImpl.java:1483: error: variable declaration not allowed here
	 * 		number of rows of the matrix to process
	   		               ^, EigenDecompositionImpl.java:1483: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                            ^, EigenDecompositionImpl.java:1483: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                                       ^, EigenDecompositionImpl.java:1484: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	^, EigenDecompositionImpl.java:1484: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	        ^, EigenDecompositionImpl.java:1484: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                          ^, EigenDecompositionImpl.java:1484: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1485: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1485: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1485: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1485: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1485: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1485: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1485: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1486: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^, EigenDecompositionImpl.java:1486: error: not a statement
	 * <p>This implementation is based on Beresford N. Parlett
	 ^, EigenDecompositionImpl.java:1486: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                            ^, EigenDecompositionImpl.java:1486: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                     ^, EigenDecompositionImpl.java:1486: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                                 ^, EigenDecompositionImpl.java:1487: error: not a statement
	 * and Osni A. Marques paper <a
	 ^, EigenDecompositionImpl.java:1487: error: ';' expected
	 * and Osni A. Marques paper <a
	      ^, EigenDecompositionImpl.java:1487: error: ';' expected
	 * and Osni A. Marques paper <a
	             ^, EigenDecompositionImpl.java:1487: error: ';' expected
	 * and Osni A. Marques paper <a
	                            ^, EigenDecompositionImpl.java:1488: error: > expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	 ^, EigenDecompositionImpl.java:1488: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	  ^, EigenDecompositionImpl.java:1488: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	       ^, EigenDecompositionImpl.java:1488: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	        ^, EigenDecompositionImpl.java:1488: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                           ^, EigenDecompositionImpl.java:1488: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                              ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                    ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                             ^, EigenDecompositionImpl.java:1489: error: ')' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                 ^, EigenDecompositionImpl.java:1489: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                      ^, EigenDecompositionImpl.java:1489: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                        ^, EigenDecompositionImpl.java:1489: error: not a statement
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                          ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                               ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                                      ^, EigenDecompositionImpl.java:1490: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                       ^, EigenDecompositionImpl.java:1490: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                      ^, EigenDecompositionImpl.java:1490: error: illegal start of type
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                        ^, EigenDecompositionImpl.java:1490: error: illegal start of expression
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                         ^, EigenDecompositionImpl.java:1491: error: illegal start of expression
	 *
	 ^, EigenDecompositionImpl.java:1492: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1492: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1490: error: not a statement
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                          ^, EigenDecompositionImpl.java:1493: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1494: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1495: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1495: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1496: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1496: error: not a statement
	 * @return new end (maybe deflated)
	 ^, EigenDecompositionImpl.java:1496: error: ';' expected
	 * @return new end (maybe deflated)
	              ^, EigenDecompositionImpl.java:1496: error: -> expected
	 * @return new end (maybe deflated)
	                                   ^, EigenDecompositionImpl.java:1497: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	 ^, EigenDecompositionImpl.java:1497: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	^, EigenDecompositionImpl.java:1496: error: not a statement
	 * @return new end (maybe deflated)
	                   ^, EigenDecompositionImpl.java:1497: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                    ^, EigenDecompositionImpl.java:1497: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                     ^, EigenDecompositionImpl.java:1497: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                                   ^, EigenDecompositionImpl.java:1504: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1504: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1504: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1504: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1504: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1506: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1506: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1507: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1507: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1507: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1507: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1508: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1509: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1509: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1509: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1509: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1509: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1509: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1509: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1509: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1510: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1510: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1510: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1510: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1510: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1510: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1510: error: ';' expected
	 * 		only every other element)
	   		                        ^]
Ingredient counter is Zero
---Undoing: gnrtn(48): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int fourI = 4 * i ` -topatch--> `double s = 0.25 * dMin` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (95(f=1.0), 96(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (95(f=1.0), )
----------Running generation: 49, population size: 1

***** Generation 49 : 0
**Parent Variant: [Variant id: 97, #gens: 539, #ops: 0, parent:-]

--Child created id: 98
--Creating new operations for variant [Variant id: 98, #gens: 539, #ops: 0, parent:97]
---analyzing modificationPoint position: 535
Templates availables216
Attempts Base Ingredients  1 total 216
vars from patch []
location: AbstractRealMatrix.java44
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `lu = null ` -topatch--> `java.lang.String fullClassName = getClass().getName()` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.AbstractRealMatrix line: 44, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `lu = null ` -topatch--> `java.lang.String fullClassName = getClass().getName()` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 98, #gens: 540, #ops: 1, parent:97] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 98, errors: [AbstractRealMatrix.java:1011: error: illegal start of expression
	 * {@inheritDoc }
	 ^, AbstractRealMatrix.java:1011: error: illegal start of expression
	 * {@inheritDoc }
	   ^, AbstractRealMatrix.java:1011: error: illegal start of type
	 * {@inheritDoc }
	                ^, AbstractRealMatrix.java:1011: error: ';' expected
	 * {@inheritDoc }
	                 ^, AbstractRealMatrix.java:1012: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));}} 		return out;} 	/**
	  ^, AbstractRealMatrix.java:1012: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));}} 		return out;} 	/**
	   ^, AbstractRealMatrix.java:1012: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));}} 		return out;} 	/**
	    	                                                         ^, AbstractRealMatrix.java:1012: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));}} 		return out;} 	/**
	    	                                                                                                           ^, AbstractRealMatrix.java:1012: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));}} 		return out;} 	/**
	    	                                                                                                                             ^, AbstractRealMatrix.java:1012: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));}} 		return out;} 	/**
	    	                                                                                                                                                      ^, AbstractRealMatrix.java:1013: error: illegal start of expression
	 * {@inheritDoc }
	 ^, AbstractRealMatrix.java:1013: error: illegal start of expression
	 * {@inheritDoc }
	   ^, AbstractRealMatrix.java:1013: error: illegal start of type
	 * {@inheritDoc }
	                ^, AbstractRealMatrix.java:1013: error: ';' expected
	 * {@inheritDoc }
	                 ^, AbstractRealMatrix.java:1014: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) { 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) + d);}} 		return out;} 	/**
	  ^, AbstractRealMatrix.java:1014: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) { 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) + d);}} 		return out;} 	/**
	   ^, AbstractRealMatrix.java:1014: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) { 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) + d);}} 		return out;} 	/**
	    	                                                          ^, AbstractRealMatrix.java:1014: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) { 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) + d);}} 		return out;} 	/**
	    	                                                                         ^, AbstractRealMatrix.java:1016: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) { 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) * d);}} 		return out;} 	/**
	    	^, AbstractRealMatrix.java:1016: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) { 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) * d);}} 		return out;} 	/**
	    	                                                               ^, AbstractRealMatrix.java:1016: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) { 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount); 		for (int row = 0; row < rowCount; ++row) { 			for (int col = 0; col < columnCount; ++col) { 				out.setEntry(row, col, getEntry(row, col) * d);}} 		return out;} 	/**
	    	                                                                              ^, AbstractRealMatrix.java:1018: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols); 		for (int row = 0; row < nRows; ++row) { 			for (int col = 0; col < nCols; ++col) { 				double sum = 0; 				for (int i = 0; i < nSum; ++i) { 					sum += getEntry(row, i) * m.getEntry(i, col);} 				out.setEntry(row, col, sum);}} 		return out;} 	/**
	    	^, AbstractRealMatrix.java:1018: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols); 		for (int row = 0; row < nRows; ++row) { 			for (int col = 0; col < nCols; ++col) { 				double sum = 0; 				for (int i = 0; i < nSum; ++i) { 					sum += getEntry(row, i) * m.getEntry(i, col);} 				out.setEntry(row, col, sum);}} 		return out;} 	/**
	    	                                                         ^, AbstractRealMatrix.java:1018: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols); 		for (int row = 0; row < nRows; ++row) { 			for (int col = 0; col < nCols; ++col) { 				double sum = 0; 				for (int i = 0; i < nSum; ++i) { 					sum += getEntry(row, i) * m.getEntry(i, col);} 				out.setEntry(row, col, sum);}} 		return out;} 	/**
	    	                                                                                                           ^, AbstractRealMatrix.java:1018: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols); 		for (int row = 0; row < nRows; ++row) { 			for (int col = 0; col < nCols; ++col) { 				double sum = 0; 				for (int i = 0; i < nSum; ++i) { 					sum += getEntry(row, i) * m.getEntry(i, col);} 				out.setEntry(row, col, sum);}} 		return out;} 	/**
	    	                                                                                                                             ^, AbstractRealMatrix.java:1018: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols); 		for (int row = 0; row < nRows; ++row) { 			for (int col = 0; col < nCols; ++col) { 				double sum = 0; 				for (int i = 0; i < nSum; ++i) { 					sum += getEntry(row, i) * m.getEntry(i, col);} 				out.setEntry(row, col, sum);}} 		return out;} 	/**
	    	                                                                                                                                                      ^, AbstractRealMatrix.java:1019: error: illegal start of expression
	 * {@inheritDoc }
	 ^, AbstractRealMatrix.java:1019: error: illegal start of expression
	 * {@inheritDoc }
	   ^, AbstractRealMatrix.java:1019: error: illegal start of type
	 * {@inheritDoc }
	                ^, AbstractRealMatrix.java:1019: error: ';' expected
	 * {@inheritDoc }
	                 ^, AbstractRealMatrix.java:1020: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		return m.multiply(this);} 	/**
	  ^, AbstractRealMatrix.java:1020: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		return m.multiply(this);} 	/**
	   ^, AbstractRealMatrix.java:1020: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		return m.multiply(this);} 	/**
	    	                                                            ^, AbstractRealMatrix.java:1020: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		return m.multiply(this);} 	/**
	    	                                                                                                              ^, AbstractRealMatrix.java:1020: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		return m.multiply(this);} 	/**
	    	                                                                                                                                ^, AbstractRealMatrix.java:1020: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		return m.multiply(this);} 	/**
	    	                                                                                                                                                         ^, AbstractRealMatrix.java:1022: error: illegal start of expression
	 */ 	public double[][] getData() { 		final double[][] data = new double[getRowDimension()][getColumnDimension()]; 		for (int i = 0; i < data.length; ++i) { 			final double[] dataI = data[i]; 			for (int j = 0; j < dataI.length; ++j) { 				dataI[j] = getEntry(i, j);}} 		return data;} 	/**
	    	^, AbstractRealMatrix.java:1022: error: ';' expected
	 */ 	public double[][] getData() { 		final double[][] data = new double[getRowDimension()][getColumnDimension()]; 		for (int i = 0; i < data.length; ++i) { 			final double[] dataI = data[i]; 			for (int j = 0; j < dataI.length; ++j) { 				dataI[j] = getEntry(i, j);}} 		return data;} 	/**
	    	                         ^, AbstractRealMatrix.java:1024: error: illegal start of expression
	 */ 	public double getNorm() { 		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() { 			/**
	    	^, AbstractRealMatrix.java:1024: error: ';' expected
	 */ 	public double getNorm() { 		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() { 			/**
	    	                     ^, AbstractRealMatrix.java:1038: error: illegal start of expression
	 */ 	public double getFrobeniusNorm() { 		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() { 			/**
	    	^, AbstractRealMatrix.java:1038: error: ';' expected
	 */ 	public double getFrobeniusNorm() { 		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() { 			/**
	    	                              ^, AbstractRealMatrix.java:1048: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException { 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix((endRow - startRow) + 1, (endColumn - startColumn) + 1); 		for (int i = startRow; i <= endRow; ++i) { 			for (int j = startColumn; j <= endColumn; ++j) { 				subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));}} 		return subMatrix;} 	/**
	    	^, AbstractRealMatrix.java:1048: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException { 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix((endRow - startRow) + 1, (endColumn - startColumn) + 1); 		for (int i = startRow; i <= endRow; ++i) { 			for (int j = startColumn; j <= endColumn; ++j) { 				subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));}} 		return subMatrix;} 	/**
	    	                                                             ^, AbstractRealMatrix.java:1048: error: <identifier> expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException { 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix((endRow - startRow) + 1, (endColumn - startColumn) + 1); 		for (int i = startRow; i <= endRow; ++i) { 			for (int j = startColumn; j <= endColumn; ++j) { 				subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));}} 		return subMatrix;} 	/**
	    	                                                                                 ^, AbstractRealMatrix.java:1048: error: <identifier> expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException { 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix((endRow - startRow) + 1, (endColumn - startColumn) + 1); 		for (int i = startRow; i <= endRow; ++i) { 			for (int j = startColumn; j <= endColumn; ++j) { 				subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));}} 		return subMatrix;} 	/**
	    	                                                                                                   ^, AbstractRealMatrix.java:1048: error: <identifier> expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException { 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix((endRow - startRow) + 1, (endColumn - startColumn) + 1); 		for (int i = startRow; i <= endRow; ++i) { 			for (int j = startColumn; j <= endColumn; ++j) { 				subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));}} 		return subMatrix;} 	/**
	    	                                                                                                                          ^, AbstractRealMatrix.java:1048: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException { 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix((endRow - startRow) + 1, (endColumn - startColumn) + 1); 		for (int i = startRow; i <= endRow; ++i) { 			for (int j = startColumn; j <= endColumn; ++j) { 				subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));}} 		return subMatrix;} 	/**
	    	                                                                                                                                              ^, AbstractRealMatrix.java:1048: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException { 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix((endRow - startRow) + 1, (endColumn - startColumn) + 1); 		for (int i = startRow; i <= endRow; ++i) { 			for (int j = startColumn; j <= endColumn; ++j) { 				subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));}} 		return subMatrix;} 	/**
	    	                                                                                                                                                                                     ^, AbstractRealMatrix.java:1048: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException { 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix((endRow - startRow) + 1, (endColumn - startColumn) + 1); 		for (int i = startRow; i <= endRow; ++i) { 			for (int j = startColumn; j <= endColumn; ++j) { 				subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));}} 		return subMatrix;} 	/**
	    	                                                                                                                                                                                                          ^, AbstractRealMatrix.java:1050: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns); 		// copy entries 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length); 		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() { 			/**
	    	^, AbstractRealMatrix.java:1050: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns); 		// copy entries 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length); 		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() { 			/**
	    	                                                             ^, AbstractRealMatrix.java:1050: error: <identifier> expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns); 		// copy entries 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length); 		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() { 			/**
	    	                                                                                       ^, AbstractRealMatrix.java:1050: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns); 		// copy entries 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length); 		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() { 			/**
	    	                                                                                                                   ^, AbstractRealMatrix.java:1050: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns); 		// copy entries 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length); 		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() { 			/**
	    	                                                                                                                                                          ^, AbstractRealMatrix.java:1050: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns); 		// copy entries 		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length); 		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() { 			/**
	    	                                                                                                                                                                               ^, AbstractRealMatrix.java:1051: error: illegal start of expression
			 * {@inheritDoc }
			 ^, AbstractRealMatrix.java:1051: error: illegal start of expression
			 * {@inheritDoc }
			   ^, AbstractRealMatrix.java:1051: error: illegal start of type
			 * {@inheritDoc }
			                ^, AbstractRealMatrix.java:1051: error: ';' expected
			 * {@inheritDoc }
			                 ^, AbstractRealMatrix.java:1052: error: illegal start of expression
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			  ^, AbstractRealMatrix.java:1052: error: ';' expected
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			   ^, AbstractRealMatrix.java:1052: error: not a statement
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			    			          ^, AbstractRealMatrix.java:1052: error: ';' expected
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			    			                   ^, AbstractRealMatrix.java:1052: error: illegal start of expression
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			    			                    			^, AbstractRealMatrix.java:1052: error: ';' expected
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			    			                    			      ^, AbstractRealMatrix.java:1052: error: illegal start of expression
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			    			                    			                    ^, AbstractRealMatrix.java:1052: error: ';' expected
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			    			                    			                         ^, AbstractRealMatrix.java:1052: error: not a statement
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			    			                    			                              ^, AbstractRealMatrix.java:1052: error: ';' expected
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			    			                    			                                 ^, AbstractRealMatrix.java:1052: error: <identifier> expected
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			    			                    			                                                    ^, AbstractRealMatrix.java:1052: error: ';' expected
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			    			                    			                                                                       ^, AbstractRealMatrix.java:1052: error: illegal start of expression
			 */ 			@java.lang.Override 			public double visit(final int row, final int column, final double value) { 				return getEntry(selectedRows[row], selectedColumns[column]);}}); 		return subMatrix;} 	/**
			    			                    			                                                                           				                                                              ^, AbstractRealMatrix.java:1054: error: illegal start of expression
	 */ 	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws org.apache.commons.math.linear.MatrixIndexException, java.lang.IllegalArgumentException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final int rowsCount = (endRow + 1) - startRow; 		final int columnsCount = (endColumn + 1) - startColumn; 		if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);} 		// copy entries 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
	    	^, AbstractRealMatrix.java:1054: error: illegal start of expression
	 */ 	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws org.apache.commons.math.linear.MatrixIndexException, java.lang.IllegalArgumentException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final int rowsCount = (endRow + 1) - startRow; 		final int columnsCount = (endColumn + 1) - startColumn; 		if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);} 		// copy entries 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
	    	       ^, AbstractRealMatrix.java:1054: error: ';' expected
	 */ 	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws org.apache.commons.math.linear.MatrixIndexException, java.lang.IllegalArgumentException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final int rowsCount = (endRow + 1) - startRow; 		final int columnsCount = (endColumn + 1) - startColumn; 		if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);} 		// copy entries 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
	    	                         ^, AbstractRealMatrix.java:1054: error: <identifier> expected
	 */ 	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws org.apache.commons.math.linear.MatrixIndexException, java.lang.IllegalArgumentException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final int rowsCount = (endRow + 1) - startRow; 		final int columnsCount = (endColumn + 1) - startColumn; 		if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);} 		// copy entries 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
	    	                                             ^, AbstractRealMatrix.java:1054: error: <identifier> expected
	 */ 	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws org.apache.commons.math.linear.MatrixIndexException, java.lang.IllegalArgumentException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final int rowsCount = (endRow + 1) - startRow; 		final int columnsCount = (endColumn + 1) - startColumn; 		if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);} 		// copy entries 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
	    	                                                               ^, AbstractRealMatrix.java:1054: error: <identifier> expected
	 */ 	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws org.apache.commons.math.linear.MatrixIndexException, java.lang.IllegalArgumentException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final int rowsCount = (endRow + 1) - startRow; 		final int columnsCount = (endColumn + 1) - startColumn; 		if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);} 		// copy entries 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
	    	                                                                                      ^, AbstractRealMatrix.java:1054: error: <identifier> expected
	 */ 	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws org.apache.commons.math.linear.MatrixIndexException, java.lang.IllegalArgumentException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final int rowsCount = (endRow + 1) - startRow; 		final int columnsCount = (endColumn + 1) - startColumn; 		if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);} 		// copy entries 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
	    	                                                                                                           ^, AbstractRealMatrix.java:1054: error: ';' expected
	 */ 	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws org.apache.commons.math.linear.MatrixIndexException, java.lang.IllegalArgumentException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final int rowsCount = (endRow + 1) - startRow; 		final int columnsCount = (endColumn + 1) - startColumn; 		if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);} 		// copy entries 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
	    	                                                                                                                                        ^, AbstractRealMatrix.java:1054: error: not a statement
	 */ 	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws org.apache.commons.math.linear.MatrixIndexException, java.lang.IllegalArgumentException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final int rowsCount = (endRow + 1) - startRow; 		final int columnsCount = (endColumn + 1) - startColumn; 		if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);} 		// copy entries 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
	    	                                                                                                                                                                               ^, AbstractRealMatrix.java:1054: error: ';' expected
	 */ 	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws org.apache.commons.math.linear.MatrixIndexException, java.lang.IllegalArgumentException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final int rowsCount = (endRow + 1) - startRow; 		final int columnsCount = (endColumn + 1) - startColumn; 		if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);} 		// copy entries 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
	    	                                                                                                                                                                                                    ^, AbstractRealMatrix.java:1054: error: not a statement
	 */ 	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws org.apache.commons.math.linear.MatrixIndexException, java.lang.IllegalArgumentException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final int rowsCount = (endRow + 1) - startRow; 		final int columnsCount = (endColumn + 1) - startColumn; 		if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);} 		// copy entries 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
	    	                                                                                                                                                                                                               ^, AbstractRealMatrix.java:1054: error: ';' expected
	 */ 	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws org.apache.commons.math.linear.MatrixIndexException, java.lang.IllegalArgumentException { 		// safety checks 		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); 		final int rowsCount = (endRow + 1) - startRow; 		final int columnsCount = (endColumn + 1) - startColumn; 		if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);} 		// copy entries 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
	    	                                                                                                                                                                                                                                        ^, AbstractRealMatrix.java:1055: error: illegal start of expression
			 * Initial row index.
			 ^, AbstractRealMatrix.java:1055: error: ';' expected
			 * Initial row index.
			          ^, AbstractRealMatrix.java:1055: error: ';' expected
			 * Initial row index.
			                    ^, AbstractRealMatrix.java:1056: error: illegal start of expression
			 */ 			private int startRow; 			/**
			    			^, AbstractRealMatrix.java:1058: error: illegal start of expression
			 */ 			private int startColumn; 			/**
			    			^, AbstractRealMatrix.java:1060: error: ';' expected
			 */ 			@java.lang.Override 			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) { 				this.startRow = startRow; 				this.startColumn = startColumn;} 			/**
			    			                    			                 ^, AbstractRealMatrix.java:1060: error: <identifier> expected
			 */ 			@java.lang.Override 			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) { 				this.startRow = startRow; 				this.startColumn = startColumn;} 			/**
			    			                    			                                 ^, AbstractRealMatrix.java:1060: error: <identifier> expected
			 */ 			@java.lang.Override 			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) { 				this.startRow = startRow; 				this.startColumn = startColumn;} 			/**
			    			                    			                                                    ^, AbstractRealMatrix.java:1060: error: <identifier> expected
			 */ 			@java.lang.Override 			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) { 				this.startRow = startRow; 				this.startColumn = startColumn;} 			/**
			    			                    			                                                                        ^, AbstractRealMatrix.java:1060: error: <identifier> expected
			 */ 			@java.lang.Override 			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) { 				this.startRow = startRow; 				this.startColumn = startColumn;} 			/**
			    			                    			                                                                                          ^, AbstractRealMatrix.java:1060: error: <identifier> expected
			 */ 			@java.lang.Override 			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) { 				this.startRow = startRow; 				this.startColumn = startColumn;} 			/**
			    			                    			                                                                                                                 ^, AbstractRealMatrix.java:1060: error: ';' expected
			 */ 			@java.lang.Override 			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) { 				this.startRow = startRow; 				this.startColumn = startColumn;} 			/**
			    			                    			                                                                                                                                     ^, AbstractRealMatrix.java:1062: error: ';' expected
			 */ 			@java.lang.Override 			public void visit(final int row, final int column, final double value) { 				destination[row - startRow][column - startColumn] = value;}}, startRow, endRow, startColumn, endColumn);} 	/**
			    			                    			                 ^, AbstractRealMatrix.java:1062: error: <identifier> expected
			 */ 			@java.lang.Override 			public void visit(final int row, final int column, final double value) { 				destination[row - startRow][column - startColumn] = value;}}, startRow, endRow, startColumn, endColumn);} 	/**
			    			                    			                                ^, AbstractRealMatrix.java:1062: error: <identifier> expected
			 */ 			@java.lang.Override 			public void visit(final int row, final int column, final double value) { 				destination[row - startRow][column - startColumn] = value;}}, startRow, endRow, startColumn, endColumn);} 	/**
			    			                    			                                                  ^]
Ingredient counter is Zero
---Undoing: gnrtn(49): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `lu = null ` -topatch--> `java.lang.String fullClassName = getClass().getName()` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (97(f=1.0), 98(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (97(f=1.0), )
----------Running generation: 50, population size: 1

***** Generation 50 : 0
**Parent Variant: [Variant id: 99, #gens: 539, #ops: 0, parent:-]

--Child created id: 100
--Creating new operations for variant [Variant id: 100, #gens: 539, #ops: 0, parent:99]
---analyzing modificationPoint position: 209
location: EigenDecompositionImpl.java1189
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `right = middle ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 100, #gens: 538, #ops: 1, parent:99] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 100
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-100/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 2, was successful: false, cases executed: 18] ,[]
-Valid?: |false|2|18|[]|, fitness 2.0
Ingredient counter is Zero
---Undoing: gnrtn(50): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `right = middle ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (99(f=1.0), 100(f=2.0), )
Selected to next generation: IDs2--> (99(f=1.0), )
----------Running generation: 51, population size: 1

***** Generation 51 : 0
**Parent Variant: [Variant id: 101, #gens: 539, #ops: 0, parent:-]

--Child created id: 102
--Creating new operations for variant [Variant id: 102, #gens: 539, #ops: 0, parent:101]
---analyzing modificationPoint position: 77
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 0 not mutation generated in  if (dMin == dN) { 	gam = dN; 	a2 = 0.0; 	if (work[nn - 5] > work[nn - 7]) { 		return; 	} 	b2 = work[[...]
---analyzing modificationPoint position: 106
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java834
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if (sumOffDiag == 0) { 	// matrix is already diagonal 	return; } ` -topatch--> `int np` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 834, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if (sumOffDiag == 0) { 	// matrix is already diagonal 	return; } ` -topatch--> `int np` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 102, #gens: 540, #ops: 1, parent:101] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 102, errors: [EigenDecompositionImpl.java:1481: error: illegal start of expression
	 * Perform two iterations with Li's tests for initial splits.
	 ^, EigenDecompositionImpl.java:1481: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	          ^, EigenDecompositionImpl.java:1481: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                         ^, EigenDecompositionImpl.java:1481: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1481: error: not a statement
	 * Perform two iterations with Li's tests for initial splits.
	                                    ^, EigenDecompositionImpl.java:1481: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                         ^, EigenDecompositionImpl.java:1481: error: '(' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                             ^, EigenDecompositionImpl.java:1481: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                                            ^, EigenDecompositionImpl.java:1483: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1483: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1484: error: ';' expected
	 * 		number of rows of the matrix to process
	   		      ^, EigenDecompositionImpl.java:1484: error: not a statement
	 * 		number of rows of the matrix to process
	   		       ^, EigenDecompositionImpl.java:1484: error: ')' expected
	 * 		number of rows of the matrix to process
	   		         ^, EigenDecompositionImpl.java:1484: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                 ^, EigenDecompositionImpl.java:1484: error: variable declaration not allowed here
	 * 		number of rows of the matrix to process
	   		               ^, EigenDecompositionImpl.java:1484: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                            ^, EigenDecompositionImpl.java:1484: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                                       ^, EigenDecompositionImpl.java:1485: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	^, EigenDecompositionImpl.java:1485: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	        ^, EigenDecompositionImpl.java:1485: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                          ^, EigenDecompositionImpl.java:1485: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1486: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1486: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1486: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1486: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1486: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1486: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1486: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1487: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^, EigenDecompositionImpl.java:1487: error: not a statement
	 * <p>This implementation is based on Beresford N. Parlett
	 ^, EigenDecompositionImpl.java:1487: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                            ^, EigenDecompositionImpl.java:1487: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                     ^, EigenDecompositionImpl.java:1487: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                                 ^, EigenDecompositionImpl.java:1488: error: not a statement
	 * and Osni A. Marques paper <a
	 ^, EigenDecompositionImpl.java:1488: error: ';' expected
	 * and Osni A. Marques paper <a
	      ^, EigenDecompositionImpl.java:1488: error: ';' expected
	 * and Osni A. Marques paper <a
	             ^, EigenDecompositionImpl.java:1488: error: ';' expected
	 * and Osni A. Marques paper <a
	                            ^, EigenDecompositionImpl.java:1489: error: > expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	 ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	  ^, EigenDecompositionImpl.java:1489: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	       ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	        ^, EigenDecompositionImpl.java:1489: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                           ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                              ^, EigenDecompositionImpl.java:1490: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                    ^, EigenDecompositionImpl.java:1490: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                             ^, EigenDecompositionImpl.java:1490: error: ')' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                 ^, EigenDecompositionImpl.java:1490: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                      ^, EigenDecompositionImpl.java:1490: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                        ^, EigenDecompositionImpl.java:1490: error: not a statement
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                          ^, EigenDecompositionImpl.java:1490: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                               ^, EigenDecompositionImpl.java:1490: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                                      ^, EigenDecompositionImpl.java:1491: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                       ^, EigenDecompositionImpl.java:1491: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                      ^, EigenDecompositionImpl.java:1491: error: illegal start of type
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                        ^, EigenDecompositionImpl.java:1491: error: illegal start of expression
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                         ^, EigenDecompositionImpl.java:1492: error: illegal start of expression
	 *
	 ^, EigenDecompositionImpl.java:1493: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1493: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1491: error: not a statement
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                          ^, EigenDecompositionImpl.java:1494: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1495: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1496: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1496: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1497: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1497: error: not a statement
	 * @return new end (maybe deflated)
	 ^, EigenDecompositionImpl.java:1497: error: ';' expected
	 * @return new end (maybe deflated)
	              ^, EigenDecompositionImpl.java:1497: error: -> expected
	 * @return new end (maybe deflated)
	                                   ^, EigenDecompositionImpl.java:1498: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	 ^, EigenDecompositionImpl.java:1498: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	^, EigenDecompositionImpl.java:1497: error: not a statement
	 * @return new end (maybe deflated)
	                   ^, EigenDecompositionImpl.java:1498: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                    ^, EigenDecompositionImpl.java:1498: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                     ^, EigenDecompositionImpl.java:1498: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                                   ^, EigenDecompositionImpl.java:1505: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1505: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1505: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1505: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1505: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1507: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1507: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1508: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1508: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1508: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1508: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1509: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1510: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1510: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1510: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1510: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1510: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1510: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1510: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1510: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1511: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1511: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1511: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1511: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1511: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1511: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1511: error: ';' expected
	 * 		only every other element)
	   		                        ^]
Ingredient counter is Zero
---Undoing: gnrtn(51): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if (sumOffDiag == 0) { 	// matrix is already diagonal 	return; } ` -topatch--> `int np` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (101(f=1.0), 102(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (101(f=1.0), )
----------Running generation: 52, population size: 1

***** Generation 52 : 0
**Parent Variant: [Variant id: 103, #gens: 539, #ops: 0, parent:-]

--Child created id: 104
--Creating new operations for variant [Variant id: 104, #gens: 539, #ops: 0, parent:103]
---analyzing modificationPoint position: 146
location: EigenDecompositionImpl.java943
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 	work[[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 104, #gens: 538, #ops: 1, parent:103] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 104
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-104/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(52): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 	work[[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (103(f=1.0), 104(f=1.0), )
Selected to next generation: IDs2--> (103(f=1.0), )
----------Running generation: 53, population size: 1

***** Generation 53 : 0
**Parent Variant: [Variant id: 105, #gens: 539, #ops: 0, parent:-]

--Child created id: 106
--Creating new operations for variant [Variant id: 106, #gens: 539, #ops: 0, parent:105]
---analyzing modificationPoint position: 372
Templates availables26
Attempts Base Ingredients  1 total 26
---modifPoint 0 not mutation generated in  eigenvector[i] *= inv
---analyzing modificationPoint position: 469
location: ArrayRealVector.java1287
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (data.length != n) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentExc[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 106, #gens: 538, #ops: 1, parent:105] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 106
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-106/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(53): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (data.length != n) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentExc[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (105(f=1.0), 106(f=1.0), )
Selected to next generation: IDs2--> (105(f=1.0), )
----------Running generation: 54, population size: 1

***** Generation 54 : 0
**Parent Variant: [Variant id: 107, #gens: 539, #ops: 0, parent:-]

--Child created id: 108
--Creating new operations for variant [Variant id: 108, #gens: 539, #ops: 0, parent:107]
---analyzing modificationPoint position: 203
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [this.secondary]
--> var from patch: this.secondary spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1178
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < maxIter; ++i) {  	final double range = right - left; 	if ((range < absoluteToler[...] ` -topatch--> `this.secondary = secondary.clone()` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1178, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < maxIter; ++i) {  	final double range = right - left; 	if ((range < absoluteToler[...] ` -topatch--> `this.secondary = secondary.clone()` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 108, #gens: 540, #ops: 1, parent:107] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 108
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-108/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(54): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < maxIter; ++i) {  	final double range = right - left; 	if ((range < absoluteToler[...] ` -topatch--> `this.secondary = secondary.clone()` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (107(f=1.0), 108(f=1.0), )
Selected to next generation: IDs2--> (107(f=1.0), )
----------Running generation: 55, population size: 1

***** Generation 55 : 0
**Parent Variant: [Variant id: 109, #gens: 539, #ops: 0, parent:-]

--Child created id: 110
--Creating new operations for variant [Variant id: 110, #gens: 539, #ops: 0, parent:109]
---analyzing modificationPoint position: 500
---modifPoint 0 not mutation generated in  return 0
---analyzing modificationPoint position: 74
---modifPoint 1 not mutation generated in  return java.lang.Math.sqrt(sum)
---analyzing modificationPoint position: 93
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 2 not mutation generated in  this.secondary = secondary.clone()
---analyzing modificationPoint position: 323
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 3 not mutation generated in  sigma = t
---analyzing modificationPoint position: 232
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 4 not mutation generated in  work[0] = java.lang.Math.abs(di)
---analyzing modificationPoint position: 119
location: EigenDecompositionImpl.java860
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// retrieve shift that was temporarily stored as a negative off-diagonal element sigma = (n0 == n) ?[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 110, #gens: 538, #ops: 1, parent:109] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 110
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-110/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 2, was successful: false, cases executed: 18] ,[]
-Valid?: |false|2|18|[]|, fitness 2.0
Ingredient counter is Zero
---Undoing: gnrtn(55): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// retrieve shift that was temporarily stored as a negative off-diagonal element sigma = (n0 == n) ?[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (109(f=1.0), 110(f=2.0), )
Selected to next generation: IDs2--> (109(f=1.0), )
----------Running generation: 56, population size: 1

***** Generation 56 : 0
**Parent Variant: [Variant id: 111, #gens: 539, #ops: 0, parent:-]

--Child created id: 112
--Creating new operations for variant [Variant id: 112, #gens: 539, #ops: 0, parent:111]
---analyzing modificationPoint position: 288
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 0 not mutation generated in  dMin1 = dMin
---analyzing modificationPoint position: 485
---modifPoint 1 not mutation generated in  final int nRows = getRowDimension()
---analyzing modificationPoint position: 239
location: EigenDecompositionImpl.java1262
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[fourI] = java.lang.Math.abs(di) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 112, #gens: 538, #ops: 1, parent:111] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 112
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-112/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 18] ,[]
-Valid?: |false|9|18|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(56): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[fourI] = java.lang.Math.abs(di) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (111(f=1.0), 112(f=9.0), )
Selected to next generation: IDs2--> (111(f=1.0), )
----------Running generation: 57, population size: 1

***** Generation 57 : 0
**Parent Variant: [Variant id: 113, #gens: 539, #ops: 0, parent:-]

--Child created id: 114
--Creating new operations for variant [Variant id: 114, #gens: 539, #ops: 0, parent:113]
---analyzing modificationPoint position: 508
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  if (d[r].length != nCols) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumen[...]
---analyzing modificationPoint position: 460
Templates availables42
Attempts Base Ingredients  1 total 42
---modifPoint 1 not mutation generated in  for (int i = 0; i < secondary.length; ++i) { 	final double absDPrevious = absDCurrent; 	absDCurrent [...]
---analyzing modificationPoint position: 72
Templates availables281
Attempts Base Ingredients  1 total 281
---modifPoint 2 not mutation generated in  for (double a : data) { 	sum += a * a; }
---analyzing modificationPoint position: 274
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  d *= tmp
---analyzing modificationPoint position: 401
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  sixI -= 6
---analyzing modificationPoint position: 507
Templates availables83
Attempts Base Ingredients  1 total 83
---modifPoint 5 not mutation generated in  data = (copyArray) ? d.clone() : d
---analyzing modificationPoint position: 448
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 6 not mutation generated in  // find realEigenvalues in each block realEigenvalues = new double[main.length]
---analyzing modificationPoint position: 361
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 7 not mutation generated in  double n2 = 1
---analyzing modificationPoint position: 439
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dMin1]
--> var from patch: dMin1 spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java597
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double dCurrent = main[m - 1] ` -topatch--> `dMin1 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 597, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double dCurrent = main[m - 1] ` -topatch--> `dMin1 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 114, #gens: 540, #ops: 1, parent:113] gen mutated: 1 , gen not mut: 8, gen not applied  0
-The child does NOT compile: 114, errors: [EigenDecompositionImpl.java:854: error: <identifier> expected
					if (chooseLeft) { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda + work[4 * i];}} else { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda - work[4 * i];}}} 			begin = end;} 		// sort the realEigenvalues in decreasing order 		java.util.Arrays.sort(realEigenvalues); 		int j = realEigenvalues.length - 1; 		for (int i = 0; i < j; ++i) { 			final double tmp = realEigenvalues[i]; 			realEigenvalues[i] = realEigenvalues[j]; 			realEigenvalues[j] = tmp; 			--j;}} 	/**
					                  						                              							                                                            						                              							                                                      			     ^, EigenDecompositionImpl.java:855: error: class, interface, or enum expected
	 * Compute splitting points.
	 ^, EigenDecompositionImpl.java:857: error: <identifier> expected
	 * @return list of indices after matrix can be split
	    ^, EigenDecompositionImpl.java:857: error: class, interface, or enum expected
	 * @return list of indices after matrix can be split
	           ^, EigenDecompositionImpl.java:858: error: class, interface, or enum expected
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	                                                            		      ^, EigenDecompositionImpl.java:859: error: class, interface, or enum expected
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:862: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:864: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                    ^, EigenDecompositionImpl.java:864: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                                 		                                     ^, EigenDecompositionImpl.java:872: error: class, interface, or enum expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                     ^, EigenDecompositionImpl.java:876: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:878: error: class, interface, or enum expected
	 * @exception InvalidMatrixException
	              ^, EigenDecompositionImpl.java:880: error: class, interface, or enum expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                     ^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                       ^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		      ^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		      ^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		      ^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		      ^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			      ^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			       ^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		                                ^, EigenDecompositionImpl.java:894: error: class, interface, or enum expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                       ^, EigenDecompositionImpl.java:895: error: class, interface, or enum expected
			return;} 		// initial checks for splits (see Parlett & Marques section 3.3) 		flipIfWarranted(n, 2); 		// two iterations with Li's test for initial splits 		initialSplits(n); 		// initialize parameters used by goodStep 		tType = 0; 		dMin1 = 0; 		dMin2 = 0; 		dN = 0; 		dN1 = 0; 		dN2 = 0; 		tau = 0; 		// process split segments 		int i0 = 0; 		int n0 = n; 		while (n0 > 0) { 			// retrieve shift that was temporarily stored as a negative off-diagonal element 			sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2]; 			sigmaLow = 0; 			// find start of a new split segment to process 			double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6]; 			double offDiagMax = 0; 			double diagMax = work[(4 * n0) - 4]; 			double diagMin = diagMax; 			i0 = 0; 			for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { 				if (work[i + 2] <= 0) { 					i0 = 1 + (i / 4); 					break;} 				if (diagMin >= (4 * offDiagMax)) { 					diagMin = java.lang.Math.min(diagMin, work[i + 4]); 					offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);} 				diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]); 				offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);} 			work[(4 * n0) - 2] = offDiagMin; 			// lower bound of Gershgorin disk 			dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax))); 			pingPong = 0; 			int maxIter = 30 * (n0 - i0); 			for (int k = 0; i0 < n0; ++k) { 				if (k >= maxIter) { 					throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));} 				// perform one step 				n0 = goodStep(i0, n0);
			       ^, EigenDecompositionImpl.java:900: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && 
				^, EigenDecompositionImpl.java:904: error: class, interface, or enum expected
					diagMax = work[4 * i0];
					^, EigenDecompositionImpl.java:905: error: class, interface, or enum expected
					offDiagMin = work[(4 * i0) + 2];
					^, EigenDecompositionImpl.java:906: error: class, interface, or enum expected
					double previousEMin = work[(4 * i0) + 3];
					^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					                     ^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					                                          ^, EigenDecompositionImpl.java:912: error: class, interface, or enum expected
							split = i / 4;
							^, EigenDecompositionImpl.java:913: error: class, interface, or enum expected
							diagMax = 0;
							^, EigenDecompositionImpl.java:914: error: class, interface, or enum expected
							offDiagMin = work[i + 6];
							^, EigenDecompositionImpl.java:915: error: class, interface, or enum expected
							previousEMin = work[i + 7];
							^, EigenDecompositionImpl.java:916: error: class, interface, or enum expected
						} else {
						^, EigenDecompositionImpl.java:918: error: class, interface, or enum expected
							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);
							^, EigenDecompositionImpl.java:919: error: class, interface, or enum expected
							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);
							^, EigenDecompositionImpl.java:920: error: class, interface, or enum expected
						}
						^, EigenDecompositionImpl.java:923: error: class, interface, or enum expected
					work[(4 * n0) - 1] = previousEMin;
					^, EigenDecompositionImpl.java:924: error: class, interface, or enum expected
					i0 = split + 1;
					^, EigenDecompositionImpl.java:925: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:937: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) {
	    	                                 ^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		                ^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		                       ^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			                                       ^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			                                               ^, EigenDecompositionImpl.java:946: error: class, interface, or enum expected
					d = work[i];
					^, EigenDecompositionImpl.java:947: error: class, interface, or enum expected
				} else {
				^, EigenDecompositionImpl.java:949: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			                           ^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			                                              ^, EigenDecompositionImpl.java:955: error: class, interface, or enum expected
				final int j = (i - (2 * pingPong)) - 1;
				      ^, EigenDecompositionImpl.java:956: error: class, interface, or enum expected
				work[j] = d + work[i];
				^, EigenDecompositionImpl.java:957: error: class, interface, or enum expected
				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {
				^, EigenDecompositionImpl.java:959: error: class, interface, or enum expected
					work[j] = d;
					^, EigenDecompositionImpl.java:960: error: class, interface, or enum expected
					work[j + 2] = 0.0;
					^, EigenDecompositionImpl.java:961: error: class, interface, or enum expected
					d = work[i + 2];
					^, EigenDecompositionImpl.java:962: error: class, interface, or enum expected
				} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && 
				^, EigenDecompositionImpl.java:964: error: class, interface, or enum expected
					final double tmp = work[i + 2] / work[j];
					      ^, EigenDecompositionImpl.java:965: error: class, interface, or enum expected
					work[j + 2] = work[i] * tmp;
					^, EigenDecompositionImpl.java:966: error: class, interface, or enum expected
					d *= tmp;
					^, EigenDecompositionImpl.java:967: error: class, interface, or enum expected
				} else {
				^, EigenDecompositionImpl.java:969: error: class, interface, or enum expected
					d *= work[i + 2] / work[j];
					^, EigenDecompositionImpl.java:970: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:975: error: class, interface, or enum expected
			pingPong = 1 - pingPong;
			^, EigenDecompositionImpl.java:977: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:994: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0;
	    	                           ^, EigenDecompositionImpl.java:994: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0;
	    	                                            ^, EigenDecompositionImpl.java:997: error: class, interface, or enum expected
		int deflatedEnd = end;
		^, EigenDecompositionImpl.java:998: error: class, interface, or enum expected
		for (boolean deflating = true; deflating;) {
		^, EigenDecompositionImpl.java:998: error: class, interface, or enum expected
		for (boolean deflating = true; deflating;) {
		                               ^, EigenDecompositionImpl.java:998: error: class, interface, or enum expected
		for (boolean deflating = true; deflating;) {
		                                         ^, EigenDecompositionImpl.java:1003: error: class, interface, or enum expected
			}
			^, EigenDecompositionImpl.java:1005: error: class, interface, or enum expected
			final int k = ((4 * deflatedEnd) + pingPong) - 1;
			      ^, EigenDecompositionImpl.java:1007: error: class, interface, or enum expected
			if ((start == (deflatedEnd - 1)) || 
			^, EigenDecompositionImpl.java:1014: error: class, interface, or enum expected
				deflatedEnd -= 1;
				^, EigenDecompositionImpl.java:1016: error: class, interface, or enum expected
			} else if (((start == (deflatedEnd - 2)) || 
			^, EigenDecompositionImpl.java:1022: error: class, interface, or enum expected
					final double tmp = work[k - 3];
					      ^, EigenDecompositionImpl.java:1023: error: class, interface, or enum expected
					work[k - 3] = work[k - 7];
					^, EigenDecompositionImpl.java:1024: error: class, interface, or enum expected
					work[k - 7] = tmp;
					^, EigenDecompositionImpl.java:1025: error: class, interface, or enum expected
				}
				^]
Ingredient counter is Zero
---Undoing: gnrtn(57): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double dCurrent = main[m - 1] ` -topatch--> `dMin1 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (113(f=1.0), 114(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (113(f=1.0), )
----------Running generation: 58, population size: 1

***** Generation 58 : 0
**Parent Variant: [Variant id: 115, #gens: 539, #ops: 0, parent:-]

--Child created id: 116
--Creating new operations for variant [Variant id: 116, #gens: 539, #ops: 0, parent:115]
---analyzing modificationPoint position: 471
Templates availables120
Attempts Base Ingredients  1 total 120
vars from patch [((org.apache.commons.math.linear.Array2DRowRealMatrix) (m))]
--> var from patch: ((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)) spoon.support.reflect.code.CtVariableReadImpl
location: Array2DRowRealMatrix.java271
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtInvocationImpl) `// safety check org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m) ` -topatch--> `return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)))` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 271, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtInvocationImpl) `// safety check org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m) ` -topatch--> `return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)))` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 116, #gens: 540, #ops: 1, parent:115] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 116, errors: [Array2DRowRealMatrix.java:272: error: unreachable statement
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		^]
Ingredient counter is Zero
---Undoing: gnrtn(58): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtInvocationImpl) `// safety check org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m) ` -topatch--> `return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)))` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (115(f=1.0), 116(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (115(f=1.0), )
----------Running generation: 59, population size: 1

***** Generation 59 : 0
**Parent Variant: [Variant id: 117, #gens: 539, #ops: 0, parent:-]

--Child created id: 118
--Creating new operations for variant [Variant id: 118, #gens: 539, #ops: 0, parent:117]
---analyzing modificationPoint position: 180
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // step 4a: dqds for (boolean loop = true; loop;) {  	// perform one dqds step with the chosen shift[...]
---analyzing modificationPoint position: 528
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 1 not mutation generated in  data = new double[subMatrix.length][nCols]
---analyzing modificationPoint position: 78
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1503
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// approximate contribution to norm squared from i < nn-1. a2 = a2 + b2 ` -topatch--> `// cases 7 and 8. tType = -7` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1503, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// approximate contribution to norm squared from i < nn-1. a2 = a2 + b2 ` -topatch--> `// cases 7 and 8. tType = -7` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 118, #gens: 539, #ops: 1, parent:117] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 118, errors: [EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						     ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						          ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							    ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							^
  symbol:   variable b1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							     ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							     ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							     ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							          ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                               ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                   ^
  symbol:   variable b1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                          ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                          ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						             ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					    ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					                  						       ^
  symbol:   variable gam
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					                  						                                      ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					                  						                                                   ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 3) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					                  						                                                                						      ^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1615: error: cannot find symbol
						tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));
						                         ^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1617: error: cannot find symbol
						tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));
						                         ^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl]
Ingredient counter is Zero
---Undoing: gnrtn(59): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// approximate contribution to norm squared from i < nn-1. a2 = a2 + b2 ` -topatch--> `// cases 7 and 8. tType = -7` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (117(f=1.0), 118(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (117(f=1.0), )
----------Running generation: 60, population size: 1

***** Generation 60 : 0
**Parent Variant: [Variant id: 119, #gens: 539, #ops: 0, parent:-]

--Child created id: 120
--Creating new operations for variant [Variant id: 120, #gens: 539, #ops: 0, parent:119]
---analyzing modificationPoint position: 197
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 0 not mutation generated in  final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON)
---analyzing modificationPoint position: 454
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  begin = end
---analyzing modificationPoint position: 490
Templates availables1
Attempts Base Ingredients  1 total 1
vars from patch [out, column, row, value]
--> var from patch: out spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: column spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: row spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: value spoon.support.reflect.code.CtVariableReadImpl
location: AbstractRealMatrix.java611
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `out.setEntry(column, row, value) ` -topatch--> `out.setEntry(column, row, value)` (spoon.support.reflect.code.CtInvocationImpl) 
---MP=org.apache.commons.math.linear.AbstractRealMatrix line: 611, pointed element: CtInvocationImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `out.setEntry(column, row, value) ` -topatch--> `out.setEntry(column, row, value)` (spoon.support.reflect.code.CtInvocationImpl) 

--Summary Creation: for variant [Variant id: 120, #gens: 539, #ops: 1, parent:119] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 120
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-120/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(60): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `out.setEntry(column, row, value) ` -topatch--> `out.setEntry(column, row, value)` (spoon.support.reflect.code.CtInvocationImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (119(f=1.0), 120(f=1.0), )
Selected to next generation: IDs2--> (119(f=1.0), )
----------Running generation: 61, population size: 1

***** Generation 61 : 0
**Parent Variant: [Variant id: 121, #gens: 539, #ops: 0, parent:-]

--Child created id: 122
--Creating new operations for variant [Variant id: 122, #gens: 539, #ops: 0, parent:121]
---analyzing modificationPoint position: 99
location: EigenDecompositionImpl.java204
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `this.splitTolerance = splitTolerance ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 122, #gens: 538, #ops: 1, parent:121] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 122
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-122/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(61): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `this.splitTolerance = splitTolerance ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (121(f=1.0), 122(f=1.0), )
Selected to next generation: IDs2--> (121(f=1.0), )
----------Running generation: 62, population size: 1

***** Generation 62 : 0
**Parent Variant: [Variant id: 123, #gens: 539, #ops: 0, parent:-]

--Child created id: 124
--Creating new operations for variant [Variant id: 124, #gens: 539, #ops: 0, parent:123]
---analyzing modificationPoint position: 308
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  double a2 = work[nn - 7] + work[nn - 5]
---analyzing modificationPoint position: 99
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 1 not mutation generated in  this.splitTolerance = splitTolerance
---analyzing modificationPoint position: 436
---modifPoint 2 not mutation generated in  double eMax = 0
---analyzing modificationPoint position: 465
Templates availables281
Attempts Base Ingredients  1 total 281
---modifPoint 3 not mutation generated in  for (int i = 0; i < data.length; i++) { 	out[i] = data[i] - v[i]; }
---analyzing modificationPoint position: 267
Templates availables78
Attempts Base Ingredients  1 total 78
vars from patch [dMin, tau, tType]
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1335
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 		work[j4 - 2][...] ` -topatch--> `// a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...]` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1335, pointed element: CtIfImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 		work[j4 - 2][...] ` -topatch--> `// a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...]` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 124, #gens: 539, #ops: 1, parent:123] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child does NOT compile: 124, errors: [EigenDecompositionImpl.java:1445: error: illegal start of expression
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	 ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	          ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                    ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                 ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                             ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                    ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                                        ^, EigenDecompositionImpl.java:1446: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	      ^, EigenDecompositionImpl.java:1446: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                            ^, EigenDecompositionImpl.java:1446: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                          ^, EigenDecompositionImpl.java:1446: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                 ^, EigenDecompositionImpl.java:1446: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                ^, EigenDecompositionImpl.java:1446: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                         ^, EigenDecompositionImpl.java:1446: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                           ^, EigenDecompositionImpl.java:1448: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1448: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1449: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1449: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1450: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1451: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1451: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1452: error: illegal start of expression
	 * @param deflated
	   ^, EigenDecompositionImpl.java:1453: error: not a statement
	 * 		number of realEigenvalues just deflated
	 ^, EigenDecompositionImpl.java:1453: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		      ^, EigenDecompositionImpl.java:1453: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                         ^, EigenDecompositionImpl.java:1453: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                                       ^, EigenDecompositionImpl.java:1454: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	^, EigenDecompositionImpl.java:1454: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	        ^, EigenDecompositionImpl.java:1454: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                  ^, EigenDecompositionImpl.java:1454: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                   ^, EigenDecompositionImpl.java:1454: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                  ^, EigenDecompositionImpl.java:1454: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                                     ^, EigenDecompositionImpl.java:1681: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	^, EigenDecompositionImpl.java:1681: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	        ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                        ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                                           ^, EigenDecompositionImpl.java:1699: error: illegal start of expression
	private void findEigenVectors() {
	^, EigenDecompositionImpl.java:1699: error: illegal start of expression
	private void findEigenVectors() {
	        ^, EigenDecompositionImpl.java:1699: error: ';' expected
	private void findEigenVectors() {
	                             ^, EigenDecompositionImpl.java:1737: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	^, EigenDecompositionImpl.java:1737: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                      ^, EigenDecompositionImpl.java:1737: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                               ^, EigenDecompositionImpl.java:1737: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1737: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1799: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1799: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^, EigenDecompositionImpl.java:1799: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                  ^, EigenDecompositionImpl.java:1799: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                    ^, EigenDecompositionImpl.java:1799: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                      ^, EigenDecompositionImpl.java:1799: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                                          ^, EigenDecompositionImpl.java:1827: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	^, EigenDecompositionImpl.java:1827: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	        ^, EigenDecompositionImpl.java:1827: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                   ^, EigenDecompositionImpl.java:1827: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                     ^, EigenDecompositionImpl.java:1827: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                       ^, EigenDecompositionImpl.java:1827: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                                           ^, EigenDecompositionImpl.java:1844: error: reached end of file while parsing
}
 ^]
Ingredient counter is Zero
---Undoing: gnrtn(62): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 		work[j4 - 2][...] ` -topatch--> `// a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...]` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (123(f=1.0), 124(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (123(f=1.0), )
----------Running generation: 63, population size: 1

***** Generation 63 : 0
**Parent Variant: [Variant id: 125, #gens: 539, #ops: 0, parent:-]

--Child created id: 126
--Creating new operations for variant [Variant id: 126, #gens: 539, #ops: 0, parent:125]
---analyzing modificationPoint position: 459
---modifPoint 0 not mutation generated in  // splitting preserving relative accuracy double absDCurrent = java.lang.Math.abs(main[0])
---analyzing modificationPoint position: 70
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  realEigenvalues[begin + i] = lambda - work[4 * i]
---analyzing modificationPoint position: 268
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 	work[j4 - 2] = d + work[j4 - 1]; 	i[...]
---analyzing modificationPoint position: 427
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  // compute the Gershgorin circles computeGershgorinCircles()
---analyzing modificationPoint position: 77
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  if (dMin == dN) { 	gam = dN; 	a2 = 0.0; 	if (work[nn - 5] > work[nn - 7]) { 		return; 	} 	b2 = work[[...]
---analyzing modificationPoint position: 205
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 5 not mutation generated in  if ((range < absoluteTolerance) ||  (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.[...]
---analyzing modificationPoint position: 364
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 6 not mutation generated in  for (int i = r - 1; i >= 0; --i) { 	z *= -work[(6 * i) + 2]; 	eigenvector[i] = z; 	n2 += z * z; }
---analyzing modificationPoint position: 523
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 7 not mutation generated in  if (column > 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalStateException( 	[...]
---analyzing modificationPoint position: 51
---modifPoint 8 not mutation generated in  return new org.apache.commons.math.linear.ArrayRealVector(this, true)
---analyzing modificationPoint position: 393
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 9 not mutation generated in  final double di = d[i]
---analyzing modificationPoint position: 367
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 10 not mutation generated in  n2 += z * z
---analyzing modificationPoint position: 104
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 11 not mutation generated in  final double ei = work[fourI + 2]
---analyzing modificationPoint position: 38
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 12 not mutation generated in  // early failure. Divide by 4. tau *= 0.25
---analyzing modificationPoint position: 47
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [nn, pingPong]
--> var from patch: nn spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1541
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1)) ` -topatch--> `// compute contribution to norm squared from i > nn-2. final int np = nn - (2 * pingPong)` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1541, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1)) ` -topatch--> `// compute contribution to norm squared from i > nn-2. final int np = nn - (2 * pingPong)` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 126, #gens: 540, #ops: 1, parent:125] gen mutated: 1 , gen not mut: 13, gen not applied  0
-The child compiles: id 126
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-126/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(63): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1)) ` -topatch--> `// compute contribution to norm squared from i > nn-2. final int np = nn - (2 * pingPong)` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (125(f=1.0), 126(f=1.0), )
Selected to next generation: IDs2--> (125(f=1.0), )
----------Running generation: 64, population size: 1

***** Generation 64 : 0
**Parent Variant: [Variant id: 127, #gens: 539, #ops: 0, parent:-]

--Child created id: 128
--Creating new operations for variant [Variant id: 128, #gens: 539, #ops: 0, parent:127]
---analyzing modificationPoint position: 100
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java205
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtInvocationImpl) `decompose() ` -topatch--> `double offDiagMax = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 205, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtInvocationImpl) `decompose() ` -topatch--> `double offDiagMax = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 128, #gens: 540, #ops: 1, parent:127] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 128, errors: [EigenDecompositionImpl.java:878: error: illegal start of expression
	 * {@inheritDoc }
	 ^, EigenDecompositionImpl.java:878: error: illegal start of expression
	 * {@inheritDoc }
	   ^, EigenDecompositionImpl.java:878: error: illegal start of type
	 * {@inheritDoc }
	                ^, EigenDecompositionImpl.java:878: error: ';' expected
	 * {@inheritDoc }
	                 ^, EigenDecompositionImpl.java:879: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	  ^, EigenDecompositionImpl.java:879: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	   ^, EigenDecompositionImpl.java:879: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                     ^, EigenDecompositionImpl.java:879: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                             ^, EigenDecompositionImpl.java:879: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                                                    ^, EigenDecompositionImpl.java:882: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	^, EigenDecompositionImpl.java:882: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	                                                     ^, EigenDecompositionImpl.java:882: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	                                                                                             ^, EigenDecompositionImpl.java:882: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	                                                                                                                    ^, EigenDecompositionImpl.java:883: error: illegal start of expression
	 * {@inheritDoc }
	 ^, EigenDecompositionImpl.java:883: error: illegal start of expression
	 * {@inheritDoc }
	   ^, EigenDecompositionImpl.java:883: error: illegal start of type
	 * {@inheritDoc }
	                ^, EigenDecompositionImpl.java:883: error: ';' expected
	 * {@inheritDoc }
	                 ^, EigenDecompositionImpl.java:884: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	  ^, EigenDecompositionImpl.java:884: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	   ^, EigenDecompositionImpl.java:884: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                      ^, EigenDecompositionImpl.java:884: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                              ^, EigenDecompositionImpl.java:884: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                                                     ^, EigenDecompositionImpl.java:887: error: illegal start of expression
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	^, EigenDecompositionImpl.java:887: error: ';' expected
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	                                  ^, EigenDecompositionImpl.java:887: error: not a statement
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	                                                                          ^, EigenDecompositionImpl.java:887: error: ';' expected
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	                                                                                                 ^, EigenDecompositionImpl.java:889: error: illegal start of expression
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	^, EigenDecompositionImpl.java:889: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                               ^, EigenDecompositionImpl.java:889: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                           ^, EigenDecompositionImpl.java:889: error: not a statement
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                  ^, EigenDecompositionImpl.java:889: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                                         ^, EigenDecompositionImpl.java:889: error: not a statement
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                                                    ^, EigenDecompositionImpl.java:889: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                                                                                   ^, EigenDecompositionImpl.java:891: error: illegal start of expression
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	^, EigenDecompositionImpl.java:891: error: ';' expected
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	                                  ^, EigenDecompositionImpl.java:891: error: not a statement
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	                                                                          ^, EigenDecompositionImpl.java:891: error: ';' expected
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	                                                                                                 ^, EigenDecompositionImpl.java:893: error: illegal start of expression
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	^, EigenDecompositionImpl.java:893: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                               ^, EigenDecompositionImpl.java:893: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                           ^, EigenDecompositionImpl.java:893: error: not a statement
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                  ^, EigenDecompositionImpl.java:893: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                                         ^, EigenDecompositionImpl.java:893: error: not a statement
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                                                    ^, EigenDecompositionImpl.java:893: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                                                                                   ^, EigenDecompositionImpl.java:895: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	^, EigenDecompositionImpl.java:895: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                               ^, EigenDecompositionImpl.java:895: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:895: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                  ^, EigenDecompositionImpl.java:895: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                                         ^, EigenDecompositionImpl.java:895: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                                                    ^, EigenDecompositionImpl.java:895: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                                                                                   ^, EigenDecompositionImpl.java:899: error: illegal start of expression
	 */ 	public double getDeterminant() { 		double determinant = 1; 		for (double lambda : realEigenvalues) { 			determinant *= lambda;} 		return determinant;} 	/**
	    	^, EigenDecompositionImpl.java:899: error: ';' expected
	 */ 	public double getDeterminant() { 		double determinant = 1; 		for (double lambda : realEigenvalues) { 			determinant *= lambda;} 		return determinant;} 	/**
	    	                            ^, EigenDecompositionImpl.java:901: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.DecompositionSolver getSolver() { 		if (eigenvectors == null) { 			findEigenVectors();} 		return new org.apache.commons.math.linear.EigenDecompositionImpl.Solver(realEigenvalues, imagEigenvalues, eigenvectors);} 	/**
	    	^, EigenDecompositionImpl.java:901: error: ';' expected
	 */ 	public org.apache.commons.math.linear.DecompositionSolver getSolver() { 		if (eigenvectors == null) { 			findEigenVectors();} 		return new org.apache.commons.math.linear.EigenDecompositionImpl.Solver(realEigenvalues, imagEigenvalues, eigenvectors);} 	/**
	    	                                                                   ^, EigenDecompositionImpl.java:903: error: illegal start of expression
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	^, EigenDecompositionImpl.java:903: error: illegal start of expression
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	        ^, EigenDecompositionImpl.java:903: error: ';' expected
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	              ^, EigenDecompositionImpl.java:903: error: not a statement
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                     ^, EigenDecompositionImpl.java:903: error: ';' expected
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                           ^, EigenDecompositionImpl.java:903: error: not a statement
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                                                                     ^, EigenDecompositionImpl.java:903: error: ';' expected
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                                                                                         ^, EigenDecompositionImpl.java:905: error: illegal start of expression
		 */ 		private double[] realEigenvalues; 		/**
		    		^, EigenDecompositionImpl.java:907: error: illegal start of expression
		 */ 		private double[] imagEigenvalues; 		/**
		    		^, EigenDecompositionImpl.java:909: error: illegal start of expression
		 */ 		private final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors; 		/**
		    		^, EigenDecompositionImpl.java:918: error: illegal start of expression
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		^, EigenDecompositionImpl.java:918: error: illegal start of expression
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		               ^, EigenDecompositionImpl.java:918: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                    ^, EigenDecompositionImpl.java:918: error: illegal start of expression
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                           ^, EigenDecompositionImpl.java:918: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                            ^, EigenDecompositionImpl.java:918: error: not a statement
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                              ^, EigenDecompositionImpl.java:918: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                                             ^, EigenDecompositionImpl.java:918: error: <identifier> expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                                                                              ^, EigenDecompositionImpl.java:918: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                                                                                                                                                  ^, EigenDecompositionImpl.java:930: error: illegal start of expression
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		^, EigenDecompositionImpl.java:930: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                     ^, EigenDecompositionImpl.java:930: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                      ^, EigenDecompositionImpl.java:930: error: not a statement
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                        ^, EigenDecompositionImpl.java:930: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                                                 ^, EigenDecompositionImpl.java:930: error: not a statement
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                                                                                 ^, EigenDecompositionImpl.java:930: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                                                                                                        ^, EigenDecompositionImpl.java:942: error: illegal start of expression
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		^, EigenDecompositionImpl.java:942: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                      ^, EigenDecompositionImpl.java:942: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                        ^, EigenDecompositionImpl.java:942: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                          ^, EigenDecompositionImpl.java:942: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                                                   ^, EigenDecompositionImpl.java:942: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                                                                                   ^, EigenDecompositionImpl.java:942: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                                                                                                          ^, EigenDecompositionImpl.java:954: error: illegal start of expression
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		^, EigenDecompositionImpl.java:954: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                      ^, EigenDecompositionImpl.java:954: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                        ^, EigenDecompositionImpl.java:954: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                          ^, EigenDecompositionImpl.java:954: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                                                   ^, EigenDecompositionImpl.java:954: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                                                                                   ^, EigenDecompositionImpl.java:954: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                                                                                                          ^, EigenDecompositionImpl.java:958: error: illegal start of expression
		 */ 		public boolean isNonSingular() { 			for (int i = 0; i < realEigenvalues.length; ++i) { 				if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) { 					return false;}} 			return true;} 		/**
		    		^, EigenDecompositionImpl.java:958: error: ';' expected
		 */ 		public boolean isNonSingular() { 			for (int i = 0; i < realEigenvalues.length; ++i) { 				if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) { 					return false;}} 			return true;} 		/**
		    		                            ^, EigenDecompositionImpl.java:964: error: illegal start of expression
		 */ 		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			final double[][] invData = new double[m][m]; 			for (int i = 0; i < m; ++i) { 				final double[] invI = invData[i]; 				for (int j = 0; j < m; ++j) { 					double invIJ = 0; 					for (int k = 0; k < m; ++k) { 						final double[] vK = eigenvectors[k].getDataRef(); 						invIJ += (vK[i] * vK[j]) / realEigenvalues[k];} 					invI[j] = invIJ;}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);}} 	/**
		    		^, EigenDecompositionImpl.java:964: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			final double[][] invData = new double[m][m]; 			for (int i = 0; i < m; ++i) { 				final double[] invI = invData[i]; 				for (int j = 0; j < m; ++j) { 					double invIJ = 0; 					for (int k = 0; k < m; ++k) { 						final double[] vK = eigenvectors[k].getDataRef(); 						invIJ += (vK[i] * vK[j]) / realEigenvalues[k];} 					invI[j] = invIJ;}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);}} 	/**
		    		                                                           ^, EigenDecompositionImpl.java:964: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			final double[][] invData = new double[m][m]; 			for (int i = 0; i < m; ++i) { 				final double[] invI = invData[i]; 				for (int j = 0; j < m; ++j) { 					double invIJ = 0; 					for (int k = 0; k < m; ++k) { 						final double[] vK = eigenvectors[k].getDataRef(); 						invIJ += (vK[i] * vK[j]) / realEigenvalues[k];} 					invI[j] = invIJ;}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);}} 	/**
		    		                                                                                                   ^]
Ingredient counter is Zero
---Undoing: gnrtn(64): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtInvocationImpl) `decompose() ` -topatch--> `double offDiagMax = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (127(f=1.0), 128(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (127(f=1.0), )
----------Running generation: 65, population size: 1

***** Generation 65 : 0
**Parent Variant: [Variant id: 129, #gens: 539, #ops: 0, parent:-]

--Child created id: 130
--Creating new operations for variant [Variant id: 130, #gens: 539, #ops: 0, parent:129]
---analyzing modificationPoint position: 124
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tau, dMin1]
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dMin1 spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java867
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double diagMin = diagMax ` -topatch--> `tau = 0.5 * dMin1` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 867, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double diagMin = diagMax ` -topatch--> `tau = 0.5 * dMin1` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 130, #gens: 540, #ops: 1, parent:129] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 130, errors: [EigenDecompositionImpl.java:1627: error: illegal start of expression
	 * Perform two iterations with Li's tests for initial splits.
	 ^, EigenDecompositionImpl.java:1627: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	          ^, EigenDecompositionImpl.java:1627: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                         ^, EigenDecompositionImpl.java:1627: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1627: error: not a statement
	 * Perform two iterations with Li's tests for initial splits.
	                                    ^, EigenDecompositionImpl.java:1627: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                         ^, EigenDecompositionImpl.java:1627: error: '(' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                             ^, EigenDecompositionImpl.java:1627: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                                            ^, EigenDecompositionImpl.java:1629: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1629: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1630: error: ';' expected
	 * 		number of rows of the matrix to process
	   		      ^, EigenDecompositionImpl.java:1630: error: not a statement
	 * 		number of rows of the matrix to process
	   		       ^, EigenDecompositionImpl.java:1630: error: ')' expected
	 * 		number of rows of the matrix to process
	   		         ^, EigenDecompositionImpl.java:1630: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                 ^, EigenDecompositionImpl.java:1630: error: variable declaration not allowed here
	 * 		number of rows of the matrix to process
	   		               ^, EigenDecompositionImpl.java:1630: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                            ^, EigenDecompositionImpl.java:1630: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                                       ^, EigenDecompositionImpl.java:1631: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	^, EigenDecompositionImpl.java:1631: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	        ^, EigenDecompositionImpl.java:1631: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                          ^, EigenDecompositionImpl.java:1631: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1632: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1632: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1632: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1632: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1632: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1632: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1632: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1633: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^, EigenDecompositionImpl.java:1633: error: not a statement
	 * <p>This implementation is based on Beresford N. Parlett
	 ^, EigenDecompositionImpl.java:1633: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                            ^, EigenDecompositionImpl.java:1633: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                     ^, EigenDecompositionImpl.java:1633: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                                 ^, EigenDecompositionImpl.java:1634: error: not a statement
	 * and Osni A. Marques paper <a
	 ^, EigenDecompositionImpl.java:1634: error: ';' expected
	 * and Osni A. Marques paper <a
	      ^, EigenDecompositionImpl.java:1634: error: ';' expected
	 * and Osni A. Marques paper <a
	             ^, EigenDecompositionImpl.java:1634: error: ';' expected
	 * and Osni A. Marques paper <a
	                            ^, EigenDecompositionImpl.java:1635: error: > expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	 ^, EigenDecompositionImpl.java:1635: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	  ^, EigenDecompositionImpl.java:1635: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	       ^, EigenDecompositionImpl.java:1635: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	        ^, EigenDecompositionImpl.java:1635: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                           ^, EigenDecompositionImpl.java:1635: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                              ^, EigenDecompositionImpl.java:1636: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                    ^, EigenDecompositionImpl.java:1636: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                             ^, EigenDecompositionImpl.java:1636: error: ')' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                 ^, EigenDecompositionImpl.java:1636: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                      ^, EigenDecompositionImpl.java:1636: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                        ^, EigenDecompositionImpl.java:1636: error: not a statement
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                          ^, EigenDecompositionImpl.java:1636: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                               ^, EigenDecompositionImpl.java:1636: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                                      ^, EigenDecompositionImpl.java:1637: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                       ^, EigenDecompositionImpl.java:1637: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                      ^, EigenDecompositionImpl.java:1637: error: illegal start of type
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                        ^, EigenDecompositionImpl.java:1637: error: illegal start of expression
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                         ^, EigenDecompositionImpl.java:1638: error: illegal start of expression
	 *
	 ^, EigenDecompositionImpl.java:1639: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1639: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1637: error: not a statement
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                          ^, EigenDecompositionImpl.java:1640: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1641: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1642: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1642: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1643: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1643: error: not a statement
	 * @return new end (maybe deflated)
	 ^, EigenDecompositionImpl.java:1643: error: ';' expected
	 * @return new end (maybe deflated)
	              ^, EigenDecompositionImpl.java:1643: error: -> expected
	 * @return new end (maybe deflated)
	                                   ^, EigenDecompositionImpl.java:1644: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	 ^, EigenDecompositionImpl.java:1644: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	^, EigenDecompositionImpl.java:1643: error: not a statement
	 * @return new end (maybe deflated)
	                   ^, EigenDecompositionImpl.java:1644: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                    ^, EigenDecompositionImpl.java:1644: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                     ^, EigenDecompositionImpl.java:1644: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                                   ^, EigenDecompositionImpl.java:1651: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1651: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1651: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1651: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1651: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1653: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1653: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1654: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1654: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1654: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1654: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1655: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1656: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1656: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1656: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1656: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1656: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1656: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1656: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1656: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1657: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1657: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1657: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1657: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1657: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1657: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1657: error: ';' expected
	 * 		only every other element)
	   		                        ^]
Ingredient counter is Zero
---Undoing: gnrtn(65): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double diagMin = diagMax ` -topatch--> `tau = 0.5 * dMin1` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (129(f=1.0), 130(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (129(f=1.0), )
----------Running generation: 66, population size: 1

***** Generation 66 : 0
**Parent Variant: [Variant id: 131, #gens: 539, #ops: 0, parent:-]

--Child created id: 132
--Creating new operations for variant [Variant id: 132, #gens: 539, #ops: 0, parent:131]
---analyzing modificationPoint position: 210
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  left = middle
---analyzing modificationPoint position: 489
Templates availables37
Attempts Base Ingredients  1 total 37
---modifPoint 1 not mutation generated in  walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {  	/**[...]
---analyzing modificationPoint position: 473
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 2 not mutation generated in  final int nCols = m.getColumnDimension()
---analyzing modificationPoint position: 225
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1232
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int count = (ratio > 0) ? 0 : 1 ` -topatch--> `// cases 7 and 8. tType = -7` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1232, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int count = (ratio > 0) ? 0 : 1 ` -topatch--> `// cases 7 and 8. tType = -7` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 132, #gens: 540, #ops: 1, parent:131] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child does NOT compile: 132, errors: [EigenDecompositionImpl.java:1614: error: illegal start of expression
	 * Perform a dqd step.
	 ^, EigenDecompositionImpl.java:1614: error: ';' expected
	 * Perform a dqd step.
	          ^, EigenDecompositionImpl.java:1614: error: ';' expected
	 * Perform a dqd step.
	                ^, EigenDecompositionImpl.java:1614: error: <identifier> expected
	 * Perform a dqd step.
	                      ^, EigenDecompositionImpl.java:1615: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	      ^, EigenDecompositionImpl.java:1615: error: not a statement
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	 ^, EigenDecompositionImpl.java:1615: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                            ^, EigenDecompositionImpl.java:1615: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                          ^, EigenDecompositionImpl.java:1615: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                 ^, EigenDecompositionImpl.java:1615: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                ^, EigenDecompositionImpl.java:1615: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                         ^, EigenDecompositionImpl.java:1615: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                           ^, EigenDecompositionImpl.java:1617: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1617: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1618: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1618: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1619: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1620: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1620: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1621: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	  ^, EigenDecompositionImpl.java:1621: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	^, EigenDecompositionImpl.java:1621: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	        ^, EigenDecompositionImpl.java:1621: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                ^, EigenDecompositionImpl.java:1621: error: <identifier> expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                 ^, EigenDecompositionImpl.java:1621: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                               ^, EigenDecompositionImpl.java:1622: error: illegal start of expression
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	 ^, EigenDecompositionImpl.java:1622: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	          ^, EigenDecompositionImpl.java:1622: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                    ^, EigenDecompositionImpl.java:1622: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                 ^, EigenDecompositionImpl.java:1622: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                             ^, EigenDecompositionImpl.java:1622: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                    ^, EigenDecompositionImpl.java:1622: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                                        ^, EigenDecompositionImpl.java:1623: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	      ^, EigenDecompositionImpl.java:1623: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                            ^, EigenDecompositionImpl.java:1623: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                          ^, EigenDecompositionImpl.java:1623: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                 ^, EigenDecompositionImpl.java:1623: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                ^, EigenDecompositionImpl.java:1623: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                         ^, EigenDecompositionImpl.java:1623: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                           ^, EigenDecompositionImpl.java:1625: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1625: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1626: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1626: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1627: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1628: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1628: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1629: error: illegal start of expression
	 * @param deflated
	   ^, EigenDecompositionImpl.java:1630: error: not a statement
	 * 		number of realEigenvalues just deflated
	 ^, EigenDecompositionImpl.java:1630: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		      ^, EigenDecompositionImpl.java:1630: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                         ^, EigenDecompositionImpl.java:1630: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                                       ^, EigenDecompositionImpl.java:1631: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	^, EigenDecompositionImpl.java:1631: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	        ^, EigenDecompositionImpl.java:1631: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                  ^, EigenDecompositionImpl.java:1631: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                   ^, EigenDecompositionImpl.java:1631: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                  ^, EigenDecompositionImpl.java:1631: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                                     ^, EigenDecompositionImpl.java:1669: error: orphaned default
			default : 				// case 12, more than two realEigenvalues deflated. no information.
			^, EigenDecompositionImpl.java:1681: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	^, EigenDecompositionImpl.java:1681: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	        ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                        ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                                           ^, EigenDecompositionImpl.java:1699: error: illegal start of expression
	private void findEigenVectors() {
	^, EigenDecompositionImpl.java:1699: error: illegal start of expression
	private void findEigenVectors() {
	        ^, EigenDecompositionImpl.java:1699: error: ';' expected
	private void findEigenVectors() {
	                             ^, EigenDecompositionImpl.java:1737: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	^, EigenDecompositionImpl.java:1737: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                      ^, EigenDecompositionImpl.java:1737: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                               ^, EigenDecompositionImpl.java:1737: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1737: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1799: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1799: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^, EigenDecompositionImpl.java:1799: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                  ^, EigenDecompositionImpl.java:1799: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                    ^, EigenDecompositionImpl.java:1799: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                      ^, EigenDecompositionImpl.java:1799: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                                          ^, EigenDecompositionImpl.java:1827: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	^, EigenDecompositionImpl.java:1827: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	        ^, EigenDecompositionImpl.java:1827: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                   ^, EigenDecompositionImpl.java:1827: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                     ^, EigenDecompositionImpl.java:1827: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                       ^, EigenDecompositionImpl.java:1827: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                                           ^, EigenDecompositionImpl.java:1844: error: reached end of file while parsing
}
 ^]
Ingredient counter is Zero
---Undoing: gnrtn(66): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int count = (ratio > 0) ? 0 : 1 ` -topatch--> `// cases 7 and 8. tType = -7` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (131(f=1.0), 132(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (131(f=1.0), )
----------Running generation: 67, population size: 1

***** Generation 67 : 0
**Parent Variant: [Variant id: 133, #gens: 539, #ops: 0, parent:-]

--Child created id: 134
--Creating new operations for variant [Variant id: 134, #gens: 539, #ops: 0, parent:133]
---analyzing modificationPoint position: 58
location: EigenDecompositionImpl.java1491
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (work[np - 4] > work[np - 2]) { 	return; } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 134, #gens: 538, #ops: 1, parent:133] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 134
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-134/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(67): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (work[np - 4] > work[np - 2]) { 	return; } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (133(f=1.0), 134(f=1.0), )
Selected to next generation: IDs2--> (133(f=1.0), )
----------Running generation: 68, population size: 1

***** Generation 68 : 0
**Parent Variant: [Variant id: 135, #gens: 539, #ops: 0, parent:-]

--Child created id: 136
--Creating new operations for variant [Variant id: 136, #gens: 539, #ops: 0, parent:135]
---analyzing modificationPoint position: 172
location: EigenDecompositionImpl.java1039
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[(4 * deflatedEnd) - 4] = sigma + work[k - 3] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 136, #gens: 538, #ops: 1, parent:135] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 136
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-136/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 18] ,[]
-Valid?: |false|9|18|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(68): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[(4 * deflatedEnd) - 4] = sigma + work[k - 3] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (135(f=1.0), 136(f=9.0), )
Selected to next generation: IDs2--> (135(f=1.0), )
----------Running generation: 69, population size: 1

***** Generation 69 : 0
**Parent Variant: [Variant id: 137, #gens: 539, #ops: 0, parent:-]

--Child created id: 138
--Creating new operations for variant [Variant id: 138, #gens: 539, #ops: 0, parent:137]
---analyzing modificationPoint position: 434
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  lowerSpectra = java.lang.Double.POSITIVE_INFINITY
---analyzing modificationPoint position: 467
---modifPoint 1 not mutation generated in  return new org.apache.commons.math.linear.ArrayRealVector(out)
---analyzing modificationPoint position: 248
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tType, g]
--> var from patch: tType spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: g spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1301
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = dMin ` -topatch--> `if (tType == (-18)) { 	g = 0.25 * 0.333; } else { 	g = 0.25; }` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1301, pointed element: CtIfImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = dMin ` -topatch--> `if (tType == (-18)) { 	g = 0.25 * 0.333; } else { 	g = 0.25; }` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 138, #gens: 540, #ops: 1, parent:137] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 138, errors: [EigenDecompositionImpl.java:1589: error: illegal start of expression
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	 ^, EigenDecompositionImpl.java:1589: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	          ^, EigenDecompositionImpl.java:1589: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                    ^, EigenDecompositionImpl.java:1589: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                 ^, EigenDecompositionImpl.java:1589: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                             ^, EigenDecompositionImpl.java:1589: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                    ^, EigenDecompositionImpl.java:1589: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                                        ^, EigenDecompositionImpl.java:1590: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	      ^, EigenDecompositionImpl.java:1590: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                            ^, EigenDecompositionImpl.java:1590: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                          ^, EigenDecompositionImpl.java:1590: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                 ^, EigenDecompositionImpl.java:1590: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                ^, EigenDecompositionImpl.java:1590: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                         ^, EigenDecompositionImpl.java:1590: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                           ^, EigenDecompositionImpl.java:1592: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1592: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1593: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1593: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1594: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1595: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1595: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1596: error: illegal start of expression
	 * @param deflated
	   ^, EigenDecompositionImpl.java:1597: error: not a statement
	 * 		number of realEigenvalues just deflated
	 ^, EigenDecompositionImpl.java:1597: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		      ^, EigenDecompositionImpl.java:1597: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                         ^, EigenDecompositionImpl.java:1597: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                                       ^, EigenDecompositionImpl.java:1598: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	^, EigenDecompositionImpl.java:1598: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	        ^, EigenDecompositionImpl.java:1598: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                  ^, EigenDecompositionImpl.java:1598: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                   ^, EigenDecompositionImpl.java:1598: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                  ^, EigenDecompositionImpl.java:1598: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                                     ^, EigenDecompositionImpl.java:1620: error: 'else' without 'if'
				} else {
				  ^, EigenDecompositionImpl.java:1631: error: orphaned case
			case 2 : 				// two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.
			^, EigenDecompositionImpl.java:1681: error: class, interface, or enum expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	        ^, EigenDecompositionImpl.java:1681: error: class, interface, or enum expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                               ^, EigenDecompositionImpl.java:1686: error: class, interface, or enum expected
			final double t = sigma + sigmaLow;
			      ^, EigenDecompositionImpl.java:1687: error: class, interface, or enum expected
			sigmaLow -= t - sigma;
			^, EigenDecompositionImpl.java:1688: error: class, interface, or enum expected
			sigma = t;
			^, EigenDecompositionImpl.java:1689: error: class, interface, or enum expected
		} else {
		^, EigenDecompositionImpl.java:1690: error: class, interface, or enum expected
			final double t = sigma + shift;
			      ^, EigenDecompositionImpl.java:1691: error: class, interface, or enum expected
			sigmaLow += sigma - (t - shift);
			^, EigenDecompositionImpl.java:1692: error: class, interface, or enum expected
			sigma = t;
			^, EigenDecompositionImpl.java:1693: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:1701: error: class, interface, or enum expected
		final int m = main.length;
		      ^, EigenDecompositionImpl.java:1702: error: class, interface, or enum expected
		eigenvectors = new org.apache.commons.math.linear.ArrayRealVector[m];
		^, EigenDecompositionImpl.java:1705: error: class, interface, or enum expected
		final double[] d = new double[m];
		      ^, EigenDecompositionImpl.java:1706: error: class, interface, or enum expected
		final double[] l = new double[m - 1];
		      ^, EigenDecompositionImpl.java:1708: error: class, interface, or enum expected
		final double mu = ((realEigenvalues[m - 1] <= 0) && (realEigenvalues[0] > 0)) ? 0.5 - realEigenvalues[m - 1] : 0;
		      ^, EigenDecompositionImpl.java:1709: error: class, interface, or enum expected
		double di = main[0] + mu;
		^, EigenDecompositionImpl.java:1710: error: class, interface, or enum expected
		d[0] = di;
		^, EigenDecompositionImpl.java:1711: error: class, interface, or enum expected
		for (int i = 1; i < m; ++i) {
		^, EigenDecompositionImpl.java:1711: error: class, interface, or enum expected
		for (int i = 1; i < m; ++i) {
		                ^, EigenDecompositionImpl.java:1711: error: class, interface, or enum expected
		for (int i = 1; i < m; ++i) {
		                       ^, EigenDecompositionImpl.java:1712: error: class, interface, or enum expected
			final double eiM1 = secondary[i - 1];
			      ^, EigenDecompositionImpl.java:1713: error: class, interface, or enum expected
			final double ratio = eiM1 / di;
			      ^, EigenDecompositionImpl.java:1714: error: class, interface, or enum expected
			di = (main[i] - (eiM1 * ratio)) + mu;
			^, EigenDecompositionImpl.java:1715: error: class, interface, or enum expected
			l[i - 1] = ratio;
			^, EigenDecompositionImpl.java:1716: error: class, interface, or enum expected
			d[i] = di;
			^, EigenDecompositionImpl.java:1717: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:1720: error: class, interface, or enum expected
		for (int i = 0; i < m; ++i) {
		                ^, EigenDecompositionImpl.java:1720: error: class, interface, or enum expected
		for (int i = 0; i < m; ++i) {
		                       ^, EigenDecompositionImpl.java:1722: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:1737: error: class, interface, or enum expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                             ^, EigenDecompositionImpl.java:1737: error: class, interface, or enum expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                      ^, EigenDecompositionImpl.java:1737: error: class, interface, or enum expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                        ^, EigenDecompositionImpl.java:1740: error: class, interface, or enum expected
		final int m = main.length;
		      ^, EigenDecompositionImpl.java:1741: error: class, interface, or enum expected
		stationaryQuotientDifferenceWithShift(d, l, eigenvalue);
		^, EigenDecompositionImpl.java:1742: error: class, interface, or enum expected
		progressiveQuotientDifferenceWithShift(d, l, eigenvalue);
		^, EigenDecompositionImpl.java:1746: error: class, interface, or enum expected
		int r = m - 1;
		^, EigenDecompositionImpl.java:1747: error: class, interface, or enum expected
		double minG = java.lang.Math.abs((work[6 * r] + work[(6 * r) + 3]) + eigenvalue);
		^, EigenDecompositionImpl.java:1748: error: class, interface, or enum expected
		int sixI = 0;
		^, EigenDecompositionImpl.java:1749: error: class, interface, or enum expected
		for (int i = 0; i < (m - 1); ++i) {
		^, EigenDecompositionImpl.java:1749: error: class, interface, or enum expected
		for (int i = 0; i < (m - 1); ++i) {
		                ^, EigenDecompositionImpl.java:1749: error: class, interface, or enum expected
		for (int i = 0; i < (m - 1); ++i) {
		                             ^, EigenDecompositionImpl.java:1750: error: class, interface, or enum expected
			final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10]));
			      ^, EigenDecompositionImpl.java:1751: error: class, interface, or enum expected
			if (absG < minG) {
			^, EigenDecompositionImpl.java:1753: error: class, interface, or enum expected
				minG = absG;
				^, EigenDecompositionImpl.java:1754: error: class, interface, or enum expected
			}
			^, EigenDecompositionImpl.java:1756: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:1761: error: class, interface, or enum expected
		double n2 = 1;
		^, EigenDecompositionImpl.java:1762: error: class, interface, or enum expected
		eigenvector[r] = 1;
		^, EigenDecompositionImpl.java:1763: error: class, interface, or enum expected
		double z = 1;
		^, EigenDecompositionImpl.java:1764: error: class, interface, or enum expected
		for (int i = r - 1; i >= 0; --i) {
		^, EigenDecompositionImpl.java:1764: error: class, interface, or enum expected
		for (int i = r - 1; i >= 0; --i) {
		                    ^, EigenDecompositionImpl.java:1764: error: class, interface, or enum expected
		for (int i = r - 1; i >= 0; --i) {
		                            ^, EigenDecompositionImpl.java:1766: error: class, interface, or enum expected
			eigenvector[i] = z;
			^, EigenDecompositionImpl.java:1767: error: class, interface, or enum expected
			n2 += z * z;
			^, EigenDecompositionImpl.java:1768: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:1770: error: class, interface, or enum expected
		for (int i = r + 1; i < m; ++i) {
		^, EigenDecompositionImpl.java:1770: error: class, interface, or enum expected
		for (int i = r + 1; i < m; ++i) {
		                    ^, EigenDecompositionImpl.java:1770: error: class, interface, or enum expected
		for (int i = r + 1; i < m; ++i) {
		                           ^, EigenDecompositionImpl.java:1772: error: class, interface, or enum expected
			eigenvector[i] = z;
			^, EigenDecompositionImpl.java:1773: error: class, interface, or enum expected
			n2 += z * z;
			^, EigenDecompositionImpl.java:1774: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:1777: error: class, interface, or enum expected
		final double inv = 1.0 / java.lang.Math.sqrt(n2);
		      ^, EigenDecompositionImpl.java:1778: error: class, interface, or enum expected
		for (int i = 0; i < m; ++i) {
		^, EigenDecompositionImpl.java:1778: error: class, interface, or enum expected
		for (int i = 0; i < m; ++i) {
		                ^, EigenDecompositionImpl.java:1778: error: class, interface, or enum expected
		for (int i = 0; i < m; ++i) {
		                       ^, EigenDecompositionImpl.java:1780: error: class, interface, or enum expected
		}
		^]
Ingredient counter is Zero
---Undoing: gnrtn(69): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = dMin ` -topatch--> `if (tType == (-18)) { 	g = 0.25 * 0.333; } else { 	g = 0.25; }` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (137(f=1.0), 138(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (137(f=1.0), )
----------Running generation: 70, population size: 1

***** Generation 70 : 0
**Parent Variant: [Variant id: 139, #gens: 539, #ops: 0, parent:-]

--Child created id: 140
--Creating new operations for variant [Variant id: 140, #gens: 539, #ops: 0, parent:139]
---analyzing modificationPoint position: 91
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 	work[j4 - 3] = d + work[j4]; 	if (w[...]
---analyzing modificationPoint position: 279
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  int j4 = ((4 * (end - 2)) - pingPong) - 1
---analyzing modificationPoint position: 516
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 2 not mutation generated in  data = d
---analyzing modificationPoint position: 238
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  di = (main[index + i] - lambda) - (eiM1 * ratio)
---analyzing modificationPoint position: 170
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 4 not mutation generated in  if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3]))[...]
---analyzing modificationPoint position: 318
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 5 not mutation generated in  final double t = sigma + sigmaLow
---analyzing modificationPoint position: 457
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 6 not mutation generated in  for (int i = 0; i < j; ++i) { 	final double tmp = realEigenvalues[i]; 	realEigenvalues[i] = realEige[...]
---analyzing modificationPoint position: 431
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 7 not mutation generated in  final int m = main.length
---analyzing modificationPoint position: 143
Templates availables42
Attempts Base Ingredients  1 total 42
---modifPoint 8 not mutation generated in  for (int k = 0; k < 2; ++k) {  	// apply Li's reverse test 	double d = work[(4 * (n - 1)) + pingPong[...]
---analyzing modificationPoint position: 482
Templates availables5
Attempts Base Ingredients  1 total 5
---modifPoint 9 not mutation generated in  sum += dataRow[i] * m.data[i][col]
---analyzing modificationPoint position: 264
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 10 not mutation generated in  eMin = work[((4 * start) + pingPong) + 4]
---analyzing modificationPoint position: 521
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 11 not mutation generated in  if (data == null) { 	if (row > 0) { 		throw org.apache.commons.math.MathRuntimeException.createIlleg[...]
---analyzing modificationPoint position: 415
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java679
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double tmp = realEigenvalues[i] ` -topatch--> `final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>()` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 679, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double tmp = realEigenvalues[i] ` -topatch--> `final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>()` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 140, #gens: 540, #ops: 1, parent:139] gen mutated: 1 , gen not mut: 12, gen not applied  0
-The child does NOT compile: 140, errors: [EigenDecompositionImpl.java:709: error: <identifier> expected
		list.add(secondary.length + 1);
		        ^, EigenDecompositionImpl.java:709: error: <identifier> expected
		list.add(secondary.length + 1);
		                         ^, EigenDecompositionImpl.java:709: error: ';' expected
		list.add(secondary.length + 1);
		                           ^, EigenDecompositionImpl.java:709: error: illegal start of type
		list.add(secondary.length + 1);
		                             ^, EigenDecompositionImpl.java:709: error: <identifier> expected
		list.add(secondary.length + 1);
		                              ^, EigenDecompositionImpl.java:709: error: ';' expected
		list.add(secondary.length + 1);
		                               ^, EigenDecompositionImpl.java:710: error: <identifier> expected
		return list;
		           ^, EigenDecompositionImpl.java:720: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];
	    	        ^, EigenDecompositionImpl.java:720: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];
	    	                                    ^, EigenDecompositionImpl.java:721: error: class, interface, or enum expected
	}
	^, EigenDecompositionImpl.java:731: error: class, interface, or enum expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException {
	    	                                     ^, EigenDecompositionImpl.java:734: error: class, interface, or enum expected
		final double q0 = main[index];
		      ^, EigenDecompositionImpl.java:735: error: class, interface, or enum expected
		final double q1 = main[index + 1];
		      ^, EigenDecompositionImpl.java:736: error: class, interface, or enum expected
		final double e12 = squaredSecondary[index];
		      ^, EigenDecompositionImpl.java:738: error: class, interface, or enum expected
		final double s = q0 + q1;
		      ^, EigenDecompositionImpl.java:739: error: class, interface, or enum expected
		final double p = (q0 * q1) - e12;
		      ^, EigenDecompositionImpl.java:740: error: class, interface, or enum expected
		final double delta = (s * s) - (4 * p);
		      ^, EigenDecompositionImpl.java:741: error: class, interface, or enum expected
		if (delta < 0) {
		^, EigenDecompositionImpl.java:743: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:745: error: class, interface, or enum expected
		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta));
		      ^, EigenDecompositionImpl.java:746: error: class, interface, or enum expected
		realEigenvalues[index] = largestRoot;
		^, EigenDecompositionImpl.java:747: error: class, interface, or enum expected
		realEigenvalues[index + 1] = p / largestRoot;
		^, EigenDecompositionImpl.java:749: error: class, interface, or enum expected
	}
	^, EigenDecompositionImpl.java:759: error: class, interface, or enum expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException {
	    	                                     ^, EigenDecompositionImpl.java:762: error: class, interface, or enum expected
		final double q0 = main[index];
		      ^, EigenDecompositionImpl.java:763: error: class, interface, or enum expected
		final double q1 = main[index + 1];
		      ^, EigenDecompositionImpl.java:764: error: class, interface, or enum expected
		final double q2 = main[index + 2];
		      ^, EigenDecompositionImpl.java:765: error: class, interface, or enum expected
		final double e12 = squaredSecondary[index];
		      ^, EigenDecompositionImpl.java:766: error: class, interface, or enum expected
		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1];
		      ^, EigenDecompositionImpl.java:769: error: class, interface, or enum expected
		final double b = -((q0 + q1) + q2);
		      ^, EigenDecompositionImpl.java:770: error: class, interface, or enum expected
		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12;
		      ^, EigenDecompositionImpl.java:771: error: class, interface, or enum expected
		final double d = (q2 * e12) - (q0 * q1q2Me22);
		      ^, EigenDecompositionImpl.java:774: error: class, interface, or enum expected
		final double b2 = b * b;
		      ^, EigenDecompositionImpl.java:775: error: class, interface, or enum expected
		final double q = ((3 * c) - b2) / 9;
		      ^, EigenDecompositionImpl.java:776: error: class, interface, or enum expected
		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54;
		      ^, EigenDecompositionImpl.java:777: error: class, interface, or enum expected
		final double delta = ((q * q) * q) + (r * r);
		      ^, EigenDecompositionImpl.java:778: error: class, interface, or enum expected
		if (delta >= 0) {
		^, EigenDecompositionImpl.java:783: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:784: error: class, interface, or enum expected
		final double sqrtMq = java.lang.Math.sqrt(-q);
		      ^, EigenDecompositionImpl.java:785: error: class, interface, or enum expected
		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq));
		      ^, EigenDecompositionImpl.java:786: error: class, interface, or enum expected
		final double alpha = 2 * sqrtMq;
		      ^, EigenDecompositionImpl.java:787: error: class, interface, or enum expected
		final double beta = b / 3;
		      ^, EigenDecompositionImpl.java:789: error: class, interface, or enum expected
		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta;
		^, EigenDecompositionImpl.java:790: error: class, interface, or enum expected
		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta;
		^, EigenDecompositionImpl.java:791: error: class, interface, or enum expected
		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta;
		^, EigenDecompositionImpl.java:792: error: class, interface, or enum expected
		if (z0 < z1) {
		^, EigenDecompositionImpl.java:793: error: class, interface, or enum expected
			final double t = z0;
			      ^, EigenDecompositionImpl.java:794: error: class, interface, or enum expected
			z0 = z1;
			^, EigenDecompositionImpl.java:795: error: class, interface, or enum expected
			z1 = t;
			^, EigenDecompositionImpl.java:796: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:798: error: class, interface, or enum expected
			final double t = z1;
			      ^, EigenDecompositionImpl.java:799: error: class, interface, or enum expected
			z1 = z2;
			^, EigenDecompositionImpl.java:800: error: class, interface, or enum expected
			z2 = t;
			^, EigenDecompositionImpl.java:801: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:803: error: class, interface, or enum expected
			final double t = z0;
			      ^, EigenDecompositionImpl.java:804: error: class, interface, or enum expected
			z0 = z1;
			^, EigenDecompositionImpl.java:805: error: class, interface, or enum expected
			z1 = t;
			^, EigenDecompositionImpl.java:806: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:808: error: class, interface, or enum expected
		realEigenvalues[index + 1] = z1;
		^, EigenDecompositionImpl.java:809: error: class, interface, or enum expected
		realEigenvalues[index + 2] = z2;
		^, EigenDecompositionImpl.java:811: error: class, interface, or enum expected
	}
	^, EigenDecompositionImpl.java:826: error: class, interface, or enum expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException {
	    	                                       ^, EigenDecompositionImpl.java:829: error: class, interface, or enum expected
		for (int i = 0; i < (n - 1); ++i) {
		^, EigenDecompositionImpl.java:829: error: class, interface, or enum expected
		for (int i = 0; i < (n - 1); ++i) {
		                ^, EigenDecompositionImpl.java:829: error: class, interface, or enum expected
		for (int i = 0; i < (n - 1); ++i) {
		                             ^, EigenDecompositionImpl.java:830: error: class, interface, or enum expected
			final int fourI = 4 * i;
			      ^, EigenDecompositionImpl.java:831: error: class, interface, or enum expected
			final double ei = work[fourI + 2];
			      ^, EigenDecompositionImpl.java:832: error: class, interface, or enum expected
			sumOffDiag += ei;
			^, EigenDecompositionImpl.java:833: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:838: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:844: error: class, interface, or enum expected
		initialSplits(n);
		^, EigenDecompositionImpl.java:847: error: class, interface, or enum expected
		tType = 0;
		^, EigenDecompositionImpl.java:848: error: class, interface, or enum expected
		dMin1 = 0;
		^, EigenDecompositionImpl.java:849: error: class, interface, or enum expected
		dMin2 = 0;
		^, EigenDecompositionImpl.java:850: error: class, interface, or enum expected
		dN = 0;
		^, EigenDecompositionImpl.java:851: error: class, interface, or enum expected
		dN1 = 0;
		^, EigenDecompositionImpl.java:852: error: class, interface, or enum expected
		dN2 = 0;
		^, EigenDecompositionImpl.java:853: error: class, interface, or enum expected
		tau = 0;
		^, EigenDecompositionImpl.java:856: error: class, interface, or enum expected
		int i0 = 0;
		^, EigenDecompositionImpl.java:857: error: class, interface, or enum expected
		int n0 = n;
		^, EigenDecompositionImpl.java:858: error: class, interface, or enum expected
		while (n0 > 0) {
		^, EigenDecompositionImpl.java:862: error: class, interface, or enum expected
			sigmaLow = 0;
			^, EigenDecompositionImpl.java:865: error: class, interface, or enum expected
			double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6];
			^, EigenDecompositionImpl.java:866: error: class, interface, or enum expected
			double offDiagMax = 0;
			^, EigenDecompositionImpl.java:867: error: class, interface, or enum expected
			double diagMax = work[(4 * n0) - 4];
			^, EigenDecompositionImpl.java:868: error: class, interface, or enum expected
			double diagMin = diagMax;
			^, EigenDecompositionImpl.java:869: error: class, interface, or enum expected
			i0 = 0;
			^, EigenDecompositionImpl.java:870: error: class, interface, or enum expected
			for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {
			^, EigenDecompositionImpl.java:870: error: class, interface, or enum expected
			for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {
			                           ^, EigenDecompositionImpl.java:870: error: class, interface, or enum expected
			for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {
			                                   ^, EigenDecompositionImpl.java:873: error: class, interface, or enum expected
					break;
					^, EigenDecompositionImpl.java:874: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:877: error: class, interface, or enum expected
					offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);
					^, EigenDecompositionImpl.java:878: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:880: error: class, interface, or enum expected
				offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);
				^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			}
			^, EigenDecompositionImpl.java:885: error: class, interface, or enum expected
			dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax)));
			^, EigenDecompositionImpl.java:887: error: class, interface, or enum expected
			pingPong = 0;
			^, EigenDecompositionImpl.java:888: error: class, interface, or enum expected
			int maxIter = 30 * (n0 - i0);
			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			for (int k = 0; i0 < n0; ++k) {
			^]
Ingredient counter is Zero
---Undoing: gnrtn(70): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double tmp = realEigenvalues[i] ` -topatch--> `final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>()` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (139(f=1.0), 140(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (139(f=1.0), )
----------Running generation: 71, population size: 1

***** Generation 71 : 0
**Parent Variant: [Variant id: 141, #gens: 539, #ops: 0, parent:-]

--Child created id: 142
--Creating new operations for variant [Variant id: 142, #gens: 539, #ops: 0, parent:141]
---analyzing modificationPoint position: 24
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  eMin = 0.0
---analyzing modificationPoint position: 279
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  int j4 = ((4 * (end - 2)) - pingPong) - 1
---analyzing modificationPoint position: 104
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  final double ei = work[fourI + 2]
---analyzing modificationPoint position: 343
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1711
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double eiM1 = secondary[i - 1] ` -topatch--> `// check decomposed matrix data range double sumOffDiag = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1711, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double eiM1 = secondary[i - 1] ` -topatch--> `// check decomposed matrix data range double sumOffDiag = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 142, #gens: 540, #ops: 1, parent:141] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 142
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-142/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(71): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double eiM1 = secondary[i - 1] ` -topatch--> `// check decomposed matrix data range double sumOffDiag = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (141(f=1.0), 142(f=1.0), )
Selected to next generation: IDs2--> (141(f=1.0), )
----------Running generation: 72, population size: 1

***** Generation 72 : 0
**Parent Variant: [Variant id: 143, #gens: 539, #ops: 0, parent:-]

--Child created id: 144
--Creating new operations for variant [Variant id: 144, #gens: 539, #ops: 0, parent:143]
---analyzing modificationPoint position: 357
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10]))
---analyzing modificationPoint position: 29
location: EigenDecompositionImpl.java1414
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 144, #gens: 538, #ops: 1, parent:143] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 144
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-144/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(72): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (143(f=1.0), 144(f=1.0), )
Selected to next generation: IDs2--> (143(f=1.0), )
----------Running generation: 73, population size: 1

***** Generation 73 : 0
**Parent Variant: [Variant id: 145, #gens: 539, #ops: 0, parent:-]

--Child created id: 146
--Creating new operations for variant [Variant id: 146, #gens: 539, #ops: 0, parent:145]
---analyzing modificationPoint position: 484
Templates availables16
Attempts Base Ingredients  1 total 16
vars from patch []
location: Array2DRowRealMatrix.java289
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false) ` -topatch--> `return copyOut()` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 289, pointed element: CtReturnImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false) ` -topatch--> `return copyOut()` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 146, #gens: 539, #ops: 1, parent:145] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 146, errors: [Array2DRowRealMatrix.java:297: error: incompatible types: double[][] cannot be converted to org.apache.commons.math.linear.Array2DRowRealMatrix
		return copyOut();} 	/**
		              ^]
Ingredient counter is Zero
---Undoing: gnrtn(73): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false) ` -topatch--> `return copyOut()` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (145(f=1.0), 146(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (145(f=1.0), )
----------Running generation: 74, population size: 1

***** Generation 74 : 0
**Parent Variant: [Variant id: 147, #gens: 539, #ops: 0, parent:-]

--Child created id: 148
--Creating new operations for variant [Variant id: 148, #gens: 539, #ops: 0, parent:147]
---analyzing modificationPoint position: 0
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  i0 = 1 + (i / 4)
---analyzing modificationPoint position: 24
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [dN1]
--> var from patch: dN1 spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1387
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `eMin = 0.0 ` -topatch--> `dN1 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1387, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `eMin = 0.0 ` -topatch--> `dN1 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 148, #gens: 539, #ops: 1, parent:147] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 148
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-148/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(74): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `eMin = 0.0 ` -topatch--> `dN1 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (147(f=1.0), 148(f=1.0), )
Selected to next generation: IDs2--> (147(f=1.0), )
----------Running generation: 75, population size: 1

***** Generation 75 : 0
**Parent Variant: [Variant id: 149, #gens: 539, #ops: 0, parent:-]

--Child created id: 150
--Creating new operations for variant [Variant id: 150, #gens: 539, #ops: 0, parent:149]
---analyzing modificationPoint position: 161
location: EigenDecompositionImpl.java997
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (boolean deflating = true; deflating;) {  	if (start >= deflatedEnd) { 		// the array has been c[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 150, #gens: 538, #ops: 1, parent:149] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 150
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-150/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 10, was successful: false, cases executed: 18] ,[]
-Valid?: |false|10|18|[]|, fitness 10.0
Ingredient counter is Zero
---Undoing: gnrtn(75): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (boolean deflating = true; deflating;) {  	if (start >= deflatedEnd) { 		// the array has been c[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (149(f=1.0), 150(f=10.0), )
Selected to next generation: IDs2--> (149(f=1.0), )
----------Running generation: 76, population size: 1

***** Generation 76 : 0
**Parent Variant: [Variant id: 151, #gens: 539, #ops: 0, parent:-]

--Child created id: 152
--Creating new operations for variant [Variant id: 152, #gens: 539, #ops: 0, parent:151]
---analyzing modificationPoint position: 276
location: EigenDecompositionImpl.java1353
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `eMin = java.lang.Math.min(eMin, work[j4]) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 152, #gens: 538, #ops: 1, parent:151] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 152
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-152/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(76): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `eMin = java.lang.Math.min(eMin, work[j4]) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (151(f=1.0), 152(f=1.0), )
Selected to next generation: IDs2--> (151(f=1.0), )
----------Running generation: 77, population size: 1

***** Generation 77 : 0
**Parent Variant: [Variant id: 153, #gens: 539, #ops: 0, parent:-]

--Child created id: 154
--Creating new operations for variant [Variant id: 154, #gens: 539, #ops: 0, parent:153]
---analyzing modificationPoint position: 335
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  final int m = main.length
---analyzing modificationPoint position: 136
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  int maxIter = 30 * (n0 - i0)
---analyzing modificationPoint position: 107
location: EigenDecompositionImpl.java840
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `// initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 154, #gens: 538, #ops: 1, parent:153] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 154
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-154/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: true, failTest= 0, was successful: true, cases executed: 18] ,[]
-Test Failing is passing, Executing regression
Executing process: (timeout765secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-154/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.stat.data.LotteryTest  org.apache.commons.math.linear.FieldMatrixImplTest  org.apache.commons.math.ode.sampling.StepNormalizerTest  org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest  org.apache.commons.math.geometry.RotationOrderTest  org.apache.commons.math.analysis.solvers.NewtonSolverTest  org.apache.commons.math.estimation.EstimatedParameterTest  org.apache.commons.math.linear.CholeskyDecompositionImplTest  org.apache.commons.math.linear.Array2DRowRealMatrixTest  org.apache.commons.math.linear.SparseRealMatrixTest  org.apache.commons.math.util.OpenIntToFieldTest  org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest  org.apache.commons.math.optimization.fitting.PolynomialFitterTest  org.apache.commons.math.linear.ArrayRealVectorTest  org.apache.commons.math.distribution.HypergeometricDistributionTest  org.apache.commons.math.random.RandomAdaptorTest  org.apache.commons.math.ode.FirstOrderConverterTest  org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest  org.apache.commons.math.stat.inference.TestUtilsTest  org.apache.commons.math.stat.data.LewTest  org.apache.commons.math.distribution.GammaDistributionTest  org.apache.commons.math.stat.descriptive.rank.MedianTest  org.apache.commons.math.distribution.ZipfDistributionTest  org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest  org.apache.commons.math.stat.CertifiedDataTest  org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest  org.apache.commons.math.complex.FrenchComplexFormatTest  org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest  org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest  org.apache.commons.math.DuplicateSampleAbscissaExceptionTest  org.apache.commons.math.estimation.MinpackTest  org.apache.commons.math.genetics.FixedGenerationCountTest  org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest  org.apache.commons.math.fraction.BigFractionFormatTest  org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest  org.apache.commons.math.random.RandomDataTest  org.apache.commons.math.distribution.FDistributionTest  org.apache.commons.math.FunctionEvaluationExceptionTest  org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest  org.apache.commons.math.stat.inference.TTestFactoryTest  org.apache.commons.math.stat.descriptive.moment.SkewnessTest  org.apache.commons.math.special.GammaTest  org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest  org.apache.commons.math.analysis.integration.RombergIntegratorTest  org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest  org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest  org.apache.commons.math.stat.descriptive.SummaryStatisticsTest  org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest  org.apache.commons.math.stat.descriptive.moment.FirstMomentTest  org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest  org.apache.commons.math.complex.ComplexTest  org.apache.commons.math.distribution.BetaDistributionTest  org.apache.commons.math.special.ErfTest  org.apache.commons.math.special.BetaTest  org.apache.commons.math.ode.nonstiff.GillIntegratorTest  org.apache.commons.math.random.EmpiricalDistributionTest  org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest  org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest  org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest  org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest  org.apache.commons.math.random.AbstractRandomGeneratorTest  org.apache.commons.math.fraction.BigFractionFieldTest  org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest  org.apache.commons.math.genetics.GeneticAlgorithmTestBinary  org.apache.commons.math.linear.BiDiagonalTransformerTest  org.apache.commons.math.util.DefaultTransformerTest  org.apache.commons.math.linear.LUDecompositionImplTest  org.apache.commons.math.random.ValueServerTest  org.apache.commons.math.stat.descriptive.moment.MeanTest  org.apache.commons.math.util.BigRealFieldTest  org.apache.commons.math.linear.QRDecompositionImplTest  org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest  org.apache.commons.math.stat.descriptive.moment.VarianceTest  org.apache.commons.math.genetics.OnePointCrossoverTest  org.apache.commons.math.stat.ranking.NaturalRankingTest  org.apache.commons.math.optimization.linear.SimplexSolverTest  org.apache.commons.math.stat.descriptive.moment.FourthMomentTest  org.apache.commons.math.linear.BlockRealMatrixTest  org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest  org.apache.commons.math.random.MersenneTwisterTest  org.apache.commons.math.genetics.RandomKeyTest  org.apache.commons.math.stat.descriptive.summary.ProductTest  org.apache.commons.math.fraction.FractionTest  org.apache.commons.math.util.OpenIntToDoubleHashMapTest  org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest  org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest  org.apache.commons.math.genetics.ChromosomeTest  org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest  org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest  org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest  org.apache.commons.math.geometry.Vector3DTest  org.apache.commons.math.stat.descriptive.rank.MinTest  org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest  org.apache.commons.math.linear.FieldLUDecompositionImplTest  org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest  org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest  org.apache.commons.math.transform.FastHadamardTransformerTest  org.apache.commons.math.optimization.fitting.HarmonicFitterTest  org.apache.commons.math.stat.correlation.PearsonsCorrelationTest  org.apache.commons.math.random.GaussianRandomGeneratorTest  org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest  org.apache.commons.math.linear.FrenchRealVectorFormatTest  org.apache.commons.math.fraction.BigFractionTest  org.apache.commons.math.util.ContinuedFractionTest  org.apache.commons.math.util.TransformerMapTest  org.apache.commons.math.analysis.solvers.BisectionSolverTest  org.apache.commons.math.genetics.BinaryChromosomeTest  org.apache.commons.math.linear.BlockFieldMatrixTest  org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest  org.apache.commons.math.linear.SingularValueDecompositionImplTest  org.apache.commons.math.distribution.TDistributionTest  org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest  org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest  org.apache.commons.math.linear.InvalidMatrixExceptionTest  org.apache.commons.math.distribution.BinomialDistributionTest  org.apache.commons.math.linear.EigenSolverTest  org.apache.commons.math.stat.inference.TTestTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest  org.apache.commons.math.random.UniformRandomGeneratorTest  org.apache.commons.math.stat.descriptive.rank.PercentileTest  org.apache.commons.math.analysis.solvers.RiddersSolverTest  org.apache.commons.math.linear.ArrayFieldVectorTest  org.apache.commons.math.ode.ContinuousOutputModelTest  org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest  org.apache.commons.math.optimization.linear.SimplexTableauTest  org.apache.commons.math.ConvergenceExceptionTest  org.apache.commons.math.util.ResizableDoubleArrayTest  org.apache.commons.math.complex.ComplexFormatTest  org.apache.commons.math.linear.RealMatrixImplTest  org.apache.commons.math.stat.descriptive.summary.SumTest  org.apache.commons.math.linear.SparseFieldVectorTest  org.apache.commons.math.genetics.ElitisticListPopulationTest  org.apache.commons.math.stat.descriptive.summary.SumSqTest  org.apache.commons.math.linear.SparseRealVectorTest  org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest  org.apache.commons.math.linear.EigenDecompositionImplTest  org.apache.commons.math.analysis.integration.SimpsonIntegratorTest  org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest  org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest  org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations  org.apache.commons.math.stat.descriptive.moment.KurtosisTest  org.apache.commons.math.transform.FastFourierTransformerTest  org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest  org.apache.commons.math.distribution.NormalDistributionTest  org.apache.commons.math.distribution.PoissonDistributionTest  org.apache.commons.math.geometry.Vector3DFormatTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest  org.apache.commons.math.genetics.TournamentSelectionTest  org.apache.commons.math.optimization.general.MinpackTest  org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest  org.apache.commons.math.analysis.solvers.BrentSolverTest  org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest  org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest  org.apache.commons.math.estimation.WeightedMeasurementTest  org.apache.commons.math.stat.inference.ChiSquareTestTest  org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest  org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest  org.apache.commons.math.linear.MatrixIndexExceptionTest  org.apache.commons.math.genetics.BinaryMutationTest  org.apache.commons.math.fraction.FractionFormatTest  org.apache.commons.math.distribution.PascalDistributionTest  org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest  org.apache.commons.math.util.MathUtilsTest  org.apache.commons.math.complex.ComplexUtilsTest  org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest  org.apache.commons.math.optimization.direct.MultiDirectionalTest  org.apache.commons.math.genetics.FitnessCachingTest  org.apache.commons.math.linear.BigMatrixImplTest  org.apache.commons.math.stat.inference.ChiSquareFactoryTest  org.apache.commons.math.fraction.FractionFieldTest  org.apache.commons.math.stat.descriptive.InteractionTest  org.apache.commons.math.stat.correlation.CovarianceTest  org.apache.commons.math.optimization.univariate.BrentMinimizerTest  org.apache.commons.math.linear.QRSolverTest  org.apache.commons.math.linear.RealVectorFormatTest  org.apache.commons.math.analysis.solvers.LaguerreSolverTest  org.apache.commons.math.linear.CholeskySolverTest  org.apache.commons.math.distribution.WeibullDistributionTest  org.apache.commons.math.stat.StatUtilsTest  org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest  org.apache.commons.math.analysis.solvers.MullerSolverTest  org.apache.commons.math.linear.TriDiagonalTransformerTest  org.apache.commons.math.distribution.ChiSquareDistributionTest  org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest  org.apache.commons.math.transform.FastSineTransformerTest  org.apache.commons.math.stat.inference.OneWayAnovaTest  org.apache.commons.math.transform.FastCosineTransformerTest  org.apache.commons.math.ArgumentOutsideDomainExceptionTest  org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest  org.apache.commons.math.ode.nonstiff.EulerIntegratorTest  org.apache.commons.math.stat.descriptive.rank.MaxTest  org.apache.commons.math.complex.ComplexFieldTest  org.apache.commons.math.stat.descriptive.ListUnivariateImplTest  org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest  org.apache.commons.math.MaxIterationsExceededExceptionTest  org.apache.commons.math.linear.MatrixUtilsTest  org.apache.commons.math.optimization.direct.NelderMeadTest  org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest  org.apache.commons.math.geometry.RotationTest  org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest  org.apache.commons.math.linear.SingularValueSolverTest  org.apache.commons.math.genetics.RandomKeyMutationTest  org.apache.commons.math.util.BigRealTest  org.apache.commons.math.distribution.ExponentialDistributionTest  org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest  org.apache.commons.math.geometry.FrenchVector3DFormatTest  org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest  org.apache.commons.math.stat.regression.SimpleRegressionTest  org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest  org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest  org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest  org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest  org.apache.commons.math.linear.LUSolverTest  org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest  org.apache.commons.math.MathConfigurationExceptionTest  org.apache.commons.math.estimation.GaussNewtonEstimatorTest  org.apache.commons.math.genetics.ListPopulationTest  org.apache.commons.math.MathExceptionTest  org.apache.commons.math.distribution.CauchyDistributionTest  org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest  org.apache.commons.math.linear.SparseFieldMatrixTest  org.apache.commons.math.stat.descriptive.summary.SumLogTest  org.apache.commons.math.stat.FrequencyTest  org.apache.commons.math.stat.descriptive.moment.SecondMomentTest
Analyzing output from process
TR: Success: true, failTest= 0, was successful: true, cases executed: 2104] ,[]
-Valid?: |true|0|2104|[]|, fitness 0.0
-Found Solution, child variant #154
Ingredient counter is Zero

Attempts to find patch Id 154: 0, successful 0, failing 0

-Saving child on disk variant #154 at /Users/marekmazur/astor/./output_astor/AstorMain-math-80//src//variant-154

-Saving child on disk variant #154 at /Users/marekmazur/astor/./output_astor/AstorMain-math-80//src//variant-154_f
---Undoing: gnrtn(77): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `// initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2) ` -topatch--> `-` (null) 
/Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/default_f/org/apache/commons/math/linear/EigenDecompositionImpl.java
/Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/variant-154_f/org/apache/commons/math/linear/EigenDecompositionImpl.java
diff command : diff -w -b  --label=/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java --label=/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java /Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/default_f/org/apache/commons/math/linear/EigenDecompositionImpl.java /Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/variant-154_f/org/apache/commons/math/linear/EigenDecompositionImpl.java --unified=0
/Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/default/org/apache/commons/math/linear/EigenDecompositionImpl.java
/Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/variant-154/org/apache/commons/math/linear/EigenDecompositionImpl.java
diff command : diff -w -b  --label=/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java --label=/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java /Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/default/org/apache/commons/math/linear/EigenDecompositionImpl.java /Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/variant-154/org/apache/commons/math/linear/EigenDecompositionImpl.java --unified=0
Generation 1
Generation 2
Generation 3
Generation 4
Generation 5
Generation 6
Generation 7
Generation 8
Generation 9
Generation 10
Generation 11
Generation 12
Generation 13
Generation 14
Generation 15
Generation 16
Generation 17
Generation 18
Generation 19
Generation 20
Generation 21
Generation 22
Generation 23
Generation 24
Generation 25
Generation 26
Generation 27
Generation 28
Generation 29
Generation 30
Generation 31
Generation 32
Generation 33
Generation 34
Generation 35
Generation 36
Generation 37
Generation 38
Generation 39
Generation 40
Generation 41
Generation 42
Generation 43
Generation 44
Generation 45
Generation 46
Generation 47
Generation 48
Generation 49
Generation 50
Generation 51
Generation 52
Generation 53
Generation 54
Generation 55
Generation 56
Generation 57
Generation 58
Generation 59
Generation 60
Generation 61
Generation 62
Generation 63
Generation 64
Generation 65
Generation 66
Generation 67
Generation 68
Generation 69
Generation 70
Generation 71
Generation 72
Generation 73
Generation 74
Generation 75
Generation 76
Generation 77
Storing ing JSON at ./diffSolutions/patchinfo_154.json
./diffSolutions/patchinfo_154.json:
{"VARIANT_ID":"154","VALIDATION":"|true|0|2104|[]|","patchhunks":[{"LOCATION":"org.apache.commons.math.linear.EigenDecompositionImpl","PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/defects4j\\\/math-80\\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","INGREDIENT_SCOPE":"-","ORIGINAL_CODE":"\\\/\\\/ initial checks for splits (see Parlett & Marques section 3.3)\\nflipIfWarranted(n, 2)","BUGGY_CODE_TYPE":"CtInvocationImpl|CtBlockImpl","OPERATOR":"RemoveOp","MODIFIED_FILE_PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-80\\\/\\\/src\\\/\\\/variant-154\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","LINE":"840","SUSPICIOUNESS":"0,992","MP_RANKING":"107"}],"TIME":"81","GENERATION":"77","FOLDER_SOLUTION_CODE":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-80\\\/\\\/src\\\/\\\/variant-154","PATCH_DIFF_ORIG":"--- \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n+++ \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n@@ -839,2 +839,2 @@\\n-\\t\\t\\\/\\\/ initial checks for splits (see Parlett & Marques section 3.3)\\n-\\t\\tflipIfWarranted(n, 2);\\n+\\n+\\n\\n"}
Saving patch info at ./diffSolutions/patchinfo_154.json
Storing ing JSON at /Users/marekmazur/astor/./diffSolutions/patch_82043_154.diff
/Users/marekmazur/astor/./diffSolutions/patch_82043_154.diff:
{"VARIANT_ID":"154","VALIDATION":"|true|0|2104|[]|","patchhunks":[{"LOCATION":"org.apache.commons.math.linear.EigenDecompositionImpl","PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/defects4j\\\/math-80\\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","INGREDIENT_SCOPE":"-","ORIGINAL_CODE":"\\\/\\\/ initial checks for splits (see Parlett & Marques section 3.3)\\nflipIfWarranted(n, 2)","BUGGY_CODE_TYPE":"CtInvocationImpl|CtBlockImpl","OPERATOR":"RemoveOp","MODIFIED_FILE_PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-80\\\/\\\/src\\\/\\\/variant-154\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","LINE":"840","SUSPICIOUNESS":"0,992","MP_RANKING":"107"}],"TIME":"81","GENERATION":"77","FOLDER_SOLUTION_CODE":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-80\\\/\\\/src\\\/\\\/variant-154","PATCH_DIFF_ORIG":"--- \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n+++ \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n@@ -839,2 +839,2 @@\\n-\\t\\t\\\/\\\/ initial checks for splits (see Parlett & Marques section 3.3)\\n-\\t\\tflipIfWarranted(n, 2);\\n+\\n+\\n\\n"}
Saving patch diff at /Users/marekmazur/astor/./diffSolutions/patch_82043_154.diff
End analysis generation - Solutions found:--> (154(SOLUTION)(f=0.0), )
Variants to next generation from: 2-->IDs: (154(f=0.0)[SOL], 153(f=1.0), )
Selected to next generation: IDs2--> (153(f=1.0), )
Max Solution found 1
Time Repair Loop (s): 82.046
generationsexecuted: 77
----SUMMARY_EXECUTION---
End Repair Search: Found solution
Solution stored at: /Users/marekmazur/astor/./output_astor/AstorMain-math-80//src/
Number solutions:1
f (sol): 0.0, [Variant id: 154 (SOL) , #gens: 538, #ops: 1, parent:153]
All variants:
f 1.0, [Variant id: 155, #gens: 539, #ops: 0, parent:-]
Number suspicious:1

 --SOLUTIONS DESCRIPTION--

 ----
ProgramVariant 154
 
time(sec)= 81
operation: RemoveOp
location= org.apache.commons.math.linear.EigenDecompositionImpl
line= 840
lineSuspiciousness= 0,992
lineSuspiciousness= 107
original statement= // initial checks for splits (see Parlett & Marques section 3.3)
flipIfWarranted(n, 2)
buggy kind= CtInvocationImpl|CtBlockImpl
fixed statement= 
generation= 77
ingredientScope= -
validation=|true|0|2104|[]|
diffpatch=--- /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
+++ /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
@@ -840,2 +839,0 @@
-		// initial checks for splits (see Parlett & Marques section 3.3)
-		flipIfWarranted(n, 2);


diffpatchoriginal=--- /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
+++ /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
@@ -839,2 +839,2 @@
-		// initial checks for splits (see Parlett & Marques section 3.3)
-		flipIfWarranted(n, 2);
+
+



Astor Output:

General stats:
EXECUTION_IDENTIFIER=
TOTAL_TIME=82.046
NR_GENERATIONS=77
NR_RIGHT_COMPILATIONS=47
NR_FAILLING_COMPILATIONS=30
NR_ERRONEOUS_VARIANCES=null
NR_FAILING_VALIDATION_PROCESS=null
OUTPUT_STATUS=STOP_BY_PATCH_FOUND
FAULT_LOCALIZATION=flacoco

Patch stats:

Patch 1
VARIANT_ID=154
TIME=81
VALIDATION=|true|0|2104|[]|
GENERATION=77
FOLDER_SOLUTION_CODE=/Users/marekmazur/astor/./output_astor/AstorMain-math-80//src//variant-154
--Patch Hunk #1
OPERATOR=RemoveOp

LOCATION=org.apache.commons.math.linear.EigenDecompositionImpl

PATH=/Users/marekmazur/astor/defects4j/math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java

MODIFIED_FILE_PATH=/Users/marekmazur/astor/./output_astor/AstorMain-math-80//src//variant-154/org/apache/commons/math/linear/EigenDecompositionImpl.java

LINE=840

SUSPICIOUNESS=0,992

MP_RANKING=107

ORIGINAL_CODE=// initial checks for splits (see Parlett & Marques section 3.3)
flipIfWarranted(n, 2)

BUGGY_CODE_TYPE=CtInvocationImpl|CtBlockImpl

PATCH_HUNK_CODE=null

PATCH_HUNK_TYPE=null

INGREDIENT_SCOPE=-

INGREDIENT_PARENT=null

PATCH_DIFF_ORIG=--- /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
+++ /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
@@ -839,2 +839,2 @@
-		// initial checks for splits (see Parlett & Marques section 3.3)
-		flipIfWarranted(n, 2);
+
+



Storing ing JSON at /Users/marekmazur/astor/./output_astor/AstorMain-math-80//astor_output.json
astor_output:
{"general":{"NR_RIGHT_COMPILATIONS":47,"NR_ERRONEOUS_VARIANCES":null,"EXECUTION_IDENTIFIER":"","FAULT_LOCALIZATION":"flacoco","OUTPUT_STATUS":"STOP_BY_PATCH_FOUND","NR_FAILLING_COMPILATIONS":30,"NR_GENERATIONS":77,"TOTAL_TIME":82.046,"NR_FAILING_VALIDATION_PROCESS":null},"patches":[{"VARIANT_ID":"154","VALIDATION":"|true|0|2104|[]|","patchhunks":[{"LOCATION":"org.apache.commons.math.linear.EigenDecompositionImpl","PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/defects4j\\\/math-80\\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","INGREDIENT_SCOPE":"-","ORIGINAL_CODE":"\\\/\\\/ initial checks for splits (see Parlett & Marques section 3.3)\\nflipIfWarranted(n, 2)","BUGGY_CODE_TYPE":"CtInvocationImpl|CtBlockImpl","OPERATOR":"RemoveOp","MODIFIED_FILE_PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-80\\\/\\\/src\\\/\\\/variant-154\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","LINE":"840","SUSPICIOUNESS":"0,992","MP_RANKING":"107"}],"TIME":"81","GENERATION":"77","FOLDER_SOLUTION_CODE":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-80\\\/\\\/src\\\/\\\/variant-154","PATCH_DIFF_ORIG":"--- \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n+++ \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n@@ -839,2 +839,2 @@\\n-\\t\\t\\\/\\\/ initial checks for splits (see Parlett & Marques section 3.3)\\n-\\t\\tflipIfWarranted(n, 2);\\n+\\n+\\n\\n"}]}
Time Total(s): 294.469
