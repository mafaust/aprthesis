[0] INFO ProjectConfiguration - Version of the JVM used: 1.8.0_202
[1] INFO main - Java version of the JDK used to run tests: 1.8.0_202
[1] INFO main - The compliance of the JVM is:  8
[2] INFO main - command line arguments: [-location  /Users/marekmazur/astor/defects4j/math-80  -mode  jgenprog  -package  org.apache.commons  -jvm4testexecution  /Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin  -failing  org.apache.commons.math.linear.EigenDecompositionImplTest  -srcjavafolder  /src/java/  -srctestfolder  /src/test/  -binjavafolder  /target/classes/  -bintestfolder  /target/test-classes/  -stopfirst  true  -dependencies  /Users/marekmazur/astor/examples/libs/junit-4.4.jar  -maxgen  1000000  -seed  10  -maxtime  60  -scope  local  -stopfirst  true  -flthreshold  0  -population  1  -faultlocalization  flacoco]
[5] INFO AstorMain - Running Astor on a JDK at /Users/marekmazur/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/jre
Source folders: [/Users/marekmazur/astor/defects4j/math-80/src/main/java]
Source Test folders: [/Users/marekmazur/astor/defects4j/math-80/src/test]
---- Creating spoon model
Creating model,  Code location from working folder: /Users/marekmazur/astor/defects4j/math-80/src/main/java
building model: /Users/marekmazur/astor/defects4j/math-80/src/main/java, compliance level: 8
Classpath (Dependencies) for building SpoonModel: [/Users/marekmazur/astor/examples/libs/junit-4.4.jar]
Spoon Model built from location: /Users/marekmazur/astor/defects4j/math-80/src/main/java
Number of CtTypes created: 393
Running chosen test detection strategy: CLASSLOADER
Test retrieved from classes: 225
Running Flacoco...
Running spectrum-based fault localization...
FlacocoConfig{workspace='/Users/marekmazur/astor/.', projectPath='/Users/marekmazur/astor/defects4j/math-80', srcJavaDir=[/Users/marekmazur/astor/defects4j/math-80/src/main/java], srcTestDir=[/Users/marekmazur/astor/defects4j/math-80/src/test], binJavaDir=[/Users/marekmazur/astor/defects4j/math-80/target/classes], binTestDir=[/Users/marekmazur/astor/defects4j/math-80/target/test-classes], classpath='/Users/marekmazur/astor/examples/libs/junit-4.4.jar', customJUnitClasspath='null', customJacocoClasspath='null', mavenHome='/Users/marekmazur/.m2/repository/', coverTests=false, testRunnerVerbose=false, testRunnerTimeoutInMs=3600000, testRunnerJVMArgs='null', threshold=0.0, includeZeros=false, complianceLevel=8, testDetectionStrategy=CLASSLOADER, ignoredTests=[], jUnit4Tests=[org.apache.commons.math.linear.SparseRealMatrixTest#testSerial, org.apache.commons.math.util.MathUtilsTest#testL2DistanceInt, org.apache.commons.math.linear.QRSolverTest#testOverdetermined, org.apache.commons.math.linear.SingularValueSolverTest#testSolveSingularityErrors, org.apache.commons.math.fraction.BigFractionTest#testPow, org.apache.commons.math.linear.BigMatrixImplTest#testSubMatrix, org.apache.commons.math.geometry.RotationTest#testCompose, org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testParameters, org.apache.commons.math.linear.RealMatrixImplTest#testAdd, org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowFieldMatrix, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testDimensions, org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.ode.FirstOrderConverterTest#testSmallStep, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithSplit, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNonDefaultSetting, org.apache.commons.math.stat.StatUtilsTest#testStats, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testSwissFertility, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeReal, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFitting, org.apache.commons.math.stat.regression.SimpleRegressionTest#testCorr, org.apache.commons.math.linear.BiDiagonalTransformerTest#testDimensions, org.apache.commons.math.util.MathUtilsTest#testNextAfterSpecialCases, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testPerfectFit, org.apache.commons.math.distribution.TDistributionTest#testConsistency, org.apache.commons.math.stat.inference.TTestTest#testOneSampleT, org.apache.commons.math.random.RandomAdaptorTest#testConfig, org.apache.commons.math.complex.ComplexTest#testConstructor, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testIllConditioned, org.apache.commons.math.complex.ComplexTest#testMultiplyNaN, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testConsistency, org.apache.commons.math.util.MathUtilsTest#testSubAndCheckLong, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowMatrix, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testGetValues, org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArguments, org.apache.commons.math.distribution.WeibullDistributionTest#testSampling, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSanityChecks, org.apache.commons.math.linear.BlockRealMatrixTest#testCopyFunctions, org.apache.commons.math.linear.LUSolverTest#testSolveDimensionErrors, org.apache.commons.math.linear.BigMatrixImplTest#testPlusMinus, org.apache.commons.math.distribution.CauchyDistributionTest#testIllegalArguments, org.apache.commons.math.random.ValueServerTest#testReplay, org.apache.commons.math.util.MathUtilsTest#testSignInt, org.apache.commons.math.distribution.GammaDistributionTest#testCumulativeProbabilities, org.apache.commons.math.linear.BlockFieldMatrixTest#testAddFail, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnLarge, org.apache.commons.math.fraction.FractionTest#testDoubleValue, org.apache.commons.math.linear.SparseFieldVectorTest#testMapFunctions, org.apache.commons.math.distribution.HypergeometricDistributionTest#testIllegalArguments, org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#checkClone, org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestNegative, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testIncrementation, org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewNewtonSolverValid, org.apache.commons.math.complex.ComplexTest#testGetArgumentNaN, org.apache.commons.math.geometry.Vector3DTest#testAdd, org.apache.commons.math.transform.FastSineTransformerTest#testSinFunction, org.apache.commons.math.stat.FrequencyTest#testSerial, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowMatrix, org.apache.commons.math.linear.LUDecompositionImplTest#testDimensions, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPlusMinus, org.apache.commons.math.special.BetaTest#testLogBetaPositiveZero, org.apache.commons.math.fraction.BigFractionFieldTest#testSerial, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testString, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerial, org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructor, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPermutation, org.apache.commons.math.linear.EigenSolverTest#testSolve, org.apache.commons.math.complex.ComplexTest#testTan, org.apache.commons.math.distribution.PoissonDistributionTest#testDensities, org.apache.commons.math.util.BigRealTest#testConstructor, org.apache.commons.math.linear.BigMatrixImplTest#testIsSingular, org.apache.commons.math.MaxIterationsExceededExceptionTest#testSimpleConstructor, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateSin, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonEqualCounts, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testMinStep, org.apache.commons.math.linear.SingularValueSolverTest#testSolveDimensionErrors, org.apache.commons.math.special.BetaTest#testLogBetaNanPositive, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testDeprecated, org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSimplistic, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTrivial, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEvaluation, org.apache.commons.math.util.MathUtilsTest#testPermutedArrayHash, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowLarge, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentEquations, org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#derivativesConsistency, org.apache.commons.math.linear.SparseRealMatrixTest#testTranspose, org.apache.commons.math.geometry.Vector3DTest#testNorm, org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumn, org.apache.commons.math.complex.ComplexTest#testCosNaN, org.apache.commons.math.linear.BigMatrixImplTest#testPremultiplyVector, org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testSinFunction, org.apache.commons.math.linear.CholeskySolverTest#testDeterminant, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataThatIsNotSquare, org.apache.commons.math.genetics.RandomKeyTest#testIsSame, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotSymmetricMatrixException, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testEqualsAndHashCode, org.apache.commons.math.random.RandomDataTest#testNextUniform, org.apache.commons.math.fraction.FractionTest#testCompareTo, org.apache.commons.math.linear.RealMatrixImplTest#testSetRow, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEvaluation, org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnVector, org.apache.commons.math.linear.FieldMatrixImplTest#testSetSubMatrix, org.apache.commons.math.stat.CertifiedDataTest#testSummaryStatistics, org.apache.commons.math.util.BigRealTest#testCompareTo, org.apache.commons.math.stat.descriptive.rank.MinTest#testConsistency, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonUnEqualCounts, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFittingBadInit, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsErrors, org.apache.commons.math.linear.RealMatrixImplTest#testToString, org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearFullRank, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexTest#testDivideInfinite, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNonInversible, org.apache.commons.math.fraction.FractionTest#testDoubleConstructor, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFittingBadInit, org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#serialization, org.apache.commons.math.genetics.RandomKeyMutationTest#testMutate, org.apache.commons.math.optimization.linear.SimplexSolverTest#testEpsilon, org.apache.commons.math.linear.RealMatrixImplTest#testGetRowVector, org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#serialization, org.apache.commons.math.estimation.WeightedMeasurementTest#testTheory, org.apache.commons.math.complex.ComplexTest#testSubtractNaN, org.apache.commons.math.random.RandomAdaptorTest#testNextPoisson, org.apache.commons.math.stat.descriptive.moment.MeanTest#testIncrementation, org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquare, org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedConsistency, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testNonSquare, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testInconsistentEquations, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleNoDecimals, org.apache.commons.math.complex.ComplexTest#testSqrtRealZero, org.apache.commons.math.linear.RealMatrixImplTest#testDimensions, org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproperNegative, org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testSinFunction, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveBadParameters, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testN0andN1Conditions, org.apache.commons.math.complex.ComplexFormatTest#testGetImaginaryFormat, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSetQuantile, org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryNegative, org.apache.commons.math.stat.FrequencyTest#testAddNonComparable, org.apache.commons.math.linear.BlockRealMatrixTest#testPlusMinus, org.apache.commons.math.linear.BigMatrixImplTest#testConstructors, org.apache.commons.math.complex.ComplexTest#testSinhNaN, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerial, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSerial, org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnVector, org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowVector, org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleTTest, org.apache.commons.math.fraction.BigFractionTest#testDoubleValue, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testWindowSize, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testQRColumnsPermutation, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testCopy, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerialization, org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvalues, org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate1, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testGetSummary, org.apache.commons.math.linear.BlockFieldMatrixTest#testPlusMinus, org.apache.commons.math.complex.FrenchComplexFormatTest#testPositiveInfinity, org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate0, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowLarge, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersSimple, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetFromEmpty, org.apache.commons.math.special.BetaTest#testRegularizedBetaNegativePositivePositive, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumn, org.apache.commons.math.stat.descriptive.summary.SumTest#testSerialization, org.apache.commons.math.linear.EigenDecompositionImplTest#testTridiagonal, org.apache.commons.math.linear.SparseFieldVectorTest#testBasicFunctions, org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.linear.SparseRealMatrixTest#testMath209, org.apache.commons.math.distribution.HypergeometricDistributionTest#testCumulativeProbabilities, org.apache.commons.math.linear.FieldMatrixImplTest#testGetVectors, org.apache.commons.math.geometry.RotationTest#testAngles, org.apache.commons.math.linear.BigMatrixImplTest#testEqualsAndHashCode, org.apache.commons.math.analysis.solvers.BrentSolverTest#testQuinticZero, org.apache.commons.math.optimization.linear.SimplexSolverTest#testSolutionWithNegativeDecisionVariable, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testMultiplication, org.apache.commons.math.distribution.ChiSquareDistributionTest#testDfAccessors, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLaguerrePolynomials, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnMatrix, org.apache.commons.math.ode.ContinuousOutputModelTest#testRandomAccess, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterInjection, org.apache.commons.math.genetics.RandomKeyTest#testIdentityPermutation, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testCovarianceConsistency, org.apache.commons.math.distribution.BetaDistributionTest#testDensity, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testIncreasingTolerance, org.apache.commons.math.fraction.BigFractionFormatTest#testParseBig, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testSanityChecks, org.apache.commons.math.linear.SparseRealMatrixTest#testSetSubMatrix, org.apache.commons.math.linear.QRSolverTest#testSolveRankErrors, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testShuffledStatistics, org.apache.commons.math.geometry.Vector3DTest#testDistanceSq, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterInjection, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumn, org.apache.commons.math.linear.EigenDecompositionImplTest#testMathpbx02, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHermiteDifferentials, org.apache.commons.math.distribution.NormalDistributionTest#testGetMean, org.apache.commons.math.genetics.RandomKeyTest#testComparatorPermutation, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIntegratorControls, org.apache.commons.math.stat.regression.SimpleRegressionTest#testSSENonNegative, org.apache.commons.math.linear.RealMatrixImplTest#testGetEntry, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSerialization, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension1, org.apache.commons.math.optimization.linear.SimplexSolverTest#testTrivialModel, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension2, org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#testDerivativesConsistency, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMatricesValues, org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeY, org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeZ, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFitting, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension3, org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnVector, org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeX, org.apache.commons.math.fraction.FractionFormatTest#testParseProperInvalidMinus, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSeparator, org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne2, org.apache.commons.math.genetics.GeneticAlgorithmTestBinary#test, org.apache.commons.math.complex.ComplexTest#testTanhCritical, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateDegenerate, org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne1, org.apache.commons.math.geometry.Vector3DTest#testSubtract, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testIllegalArguments, org.apache.commons.math.complex.ComplexFormatTest#testNegativeImaginary, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIncreasingTolerance, org.apache.commons.math.random.RandomAdaptorTest#testNextSample, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetFunctionValueAccuracy, org.apache.commons.math.linear.SparseRealMatrixTest#testTrace, org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnBigMatrix, org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumn, org.apache.commons.math.linear.ArrayFieldVectorTest#testMapFunctions, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTwoSets, org.apache.commons.math.stat.descriptive.rank.MaxTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.moment.MeanTest#testEvaluation, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testMomentSmallSamples, org.apache.commons.math.linear.BlockFieldMatrixTest#testDimensions, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEqualsAndHashCode, org.apache.commons.math.fraction.FractionFieldTest#testSerial, org.apache.commons.math.linear.SparseRealVectorTest#testMisc, org.apache.commons.math.special.GammaTest#testLogGammaPositive, org.apache.commons.math.stat.StatUtilsTest#testProduct, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterIllegalState, org.apache.commons.math.complex.ComplexTest#testCosInf, org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownAlmostLinear, org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest#testRosenbrock, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.estimation.MinpackTest#testMinpackBrownAlmostLinear, org.apache.commons.math.genetics.BinaryChromosomeTest#testInvalidConstructor, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testMomentSmallSamples, org.apache.commons.math.geometry.Vector3DTest#testNormalize, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction2, org.apache.commons.math.genetics.RandomKeyTest#testEqualRepr, org.apache.commons.math.complex.FrenchComplexFormatTest#testStaticFormatComplex, org.apache.commons.math.stat.correlation.CovarianceTest#testConstant, org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaTest, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutOnExisting, org.apache.commons.math.complex.ComplexFormatTest#testParseZeroReal, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParsePositiveInfinity, org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testExpm1Function, org.apache.commons.math.geometry.Vector3DFormatTest#testParsePositiveInfinity, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDimensionCheck, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimensions, org.apache.commons.math.geometry.Vector3DTest#testAngular, org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacity, org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testSinFunction, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testIllConditioned, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArguments, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testVariableSteps, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerial, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketSin, org.apache.commons.math.util.MathUtilsTest#testGcd, org.apache.commons.math.distribution.GammaDistributionTest#testValues, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeBoth, org.apache.commons.math.linear.FieldMatrixImplTest#testEqualsAndHashCode, org.apache.commons.math.linear.BigMatrixImplTest#testMultiply2, org.apache.commons.math.genetics.FitnessCachingTest#testFitnessCaching, org.apache.commons.math.random.RandomAdaptorTest#testNextUniform, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiplyVector, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeZ, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSample, org.apache.commons.math.distribution.WeibullDistributionTest#testConsistency, org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoSuccesses, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeX, org.apache.commons.math.stat.FrequencyTest#testAdd, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeY, org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeImaginary, org.apache.commons.math.distribution.BetaDistributionTest#testCumulative, org.apache.commons.math.random.RandomDataTest#testNextPoisson, org.apache.commons.math.distribution.ChiSquareDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290LEQ, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetMatrixLarge, org.apache.commons.math.distribution.HypergeometricDistributionTest#testLargeValues, org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexInf, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#backward, org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testQuinticMin, org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate1, org.apache.commons.math.special.BetaTest#testLogBetaNegativePositive, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testOneSet, org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate0, org.apache.commons.math.distribution.CauchyDistributionTest#testScale, org.apache.commons.math.util.MathUtilsTest#testSubAndCheck, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testNaNContracts, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testToString, org.apache.commons.math.fraction.BigFractionTest#testNegate, org.apache.commons.math.complex.ComplexTest#testExpInf, org.apache.commons.math.stat.regression.SimpleRegressionTest#testNorris, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroImaginary, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseIgnoredWhitespace, org.apache.commons.math.genetics.RandomKeyTest#testDecode, org.apache.commons.math.optimization.general.MinpackTest#testMinpackChebyquad, org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigMatrix, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConstant, org.apache.commons.math.analysis.integration.RombergIntegratorTest#testSinFunction, org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareIndependence, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testCopy, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBadParameters, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowVector, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testProductAndGeometricMean, org.apache.commons.math.genetics.FixedGenerationCountTest#testIsSatisfied, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGet, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveZeroPositive, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstChebyshevPolynomials, org.apache.commons.math.linear.RealMatrixImplTest#testTrace, org.apache.commons.math.optimization.direct.NelderMeadTest#testMinimizeMaximize, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopyConsistency, org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testInconsistentEquations, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testVariableSteps, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testConstructorSingleFormat, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testStepSize, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSpecialValues, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testIncrementation, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testNaN, org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSuffix, org.apache.commons.math.linear.QRSolverTest#testSolve, org.apache.commons.math.util.OpenIntToFieldTest#testGetAbsent, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testExamples, org.apache.commons.math.util.TransformerMapTest#testTransformers, org.apache.commons.math.util.OpenIntToFieldTest#testIterator, org.apache.commons.math.complex.ComplexFormatTest#testNegativeInfinity, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testConstants, org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply2, org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_fourthRoot, org.apache.commons.math.distribution.ZipfDistributionTest#testCumulativeProbabilities, org.apache.commons.math.special.GammaTest#testDigammaSmallArgs, org.apache.commons.math.linear.BlockRealMatrixTest#testGetVectors, org.apache.commons.math.stat.regression.SimpleRegressionTest#testInference, org.apache.commons.math.stat.descriptive.rank.PercentileTest#test5, org.apache.commons.math.linear.ArrayRealVectorTest#testMisc, org.apache.commons.math.distribution.WeibullDistributionTest#testIllegalArguments, org.apache.commons.math.optimization.direct.NelderMeadTest#testRosenbrock, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetEntry, org.apache.commons.math.stat.regression.SimpleRegressionTest#testClear, org.apache.commons.math.linear.SparseFieldMatrixTest#testAddFail, org.apache.commons.math.special.BetaTest#testRegularizedBetaZeroPositivePositive, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEvaluation, org.apache.commons.math.optimization.linear.SimplexSolverTest#testInfeasibleSolution, org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testQuinticFunction, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testSetterInjection, org.apache.commons.math.random.MersenneTwisterTest#testNextIntNeg, org.apache.commons.math.complex.ComplexTest#testEqualsTrue, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerial, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDecreasingSteps, org.apache.commons.math.complex.ComplexTest#testEqualsNull, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerialization, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply2, org.apache.commons.math.linear.SparseFieldMatrixTest#testSubMatrix, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArgumentCause, org.apache.commons.math.util.BigRealFieldTest#testOne, org.apache.commons.math.complex.ComplexTest#testScalarMultiply, org.apache.commons.math.linear.RealMatrixImplTest#testGetRow, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopy, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromSingle, org.apache.commons.math.util.TransformerMapTest#testClear, org.apache.commons.math.complex.ComplexTest#testSqrtPolar, org.apache.commons.math.random.ValueServerTest#testFill, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testWeightedConsistency, org.apache.commons.math.fraction.BigFractionFormatTest#testFormatZero, org.apache.commons.math.distribution.ChiSquareDistributionTest#testSmallDf, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNan, org.apache.commons.math.util.MathUtilsTest#testL1DistanceInt, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.stat.descriptive.summary.ProductTest#testSpecialValues, org.apache.commons.math.distribution.NormalDistributionTest#testMath280, org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareLargeTestStatistic, org.apache.commons.math.linear.EigenDecompositionImplTest#testDistinctEigenvalues, org.apache.commons.math.fraction.FractionFormatTest#testDoubleFormat, org.apache.commons.math.linear.BlockFieldMatrixTest#testSerial, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testDimensionCheck, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumn, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBigStep, org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testSerial, org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMath226, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLong, org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowVector, org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowMatrix, org.apache.commons.math.genetics.ElitisticListPopulationTest#testNextGeneration, org.apache.commons.math.analysis.integration.RombergIntegratorTest#testParameters, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureHex, org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexNaN, org.apache.commons.math.linear.RealVectorFormatTest#testParseZeroX, org.apache.commons.math.ConvergenceExceptionTest#testConstructor, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#checklone, org.apache.commons.math.estimation.MinpackTest#testMinpackHelicalValley, org.apache.commons.math.genetics.ListPopulationTest#testGetFittestChromosome, org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSeparator, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testLongly, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testMomentSmallSamples, org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowBigMatrix, org.apache.commons.math.linear.LUDecompositionImplTest#testLLowerTriangular, org.apache.commons.math.distribution.BinomialDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.util.MathUtilsTest#testLInfDistanceInt, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowVector, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNoDependency, org.apache.commons.math.linear.BiDiagonalTransformerTest#testUOrthogonal, org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiply, org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowRealMatrix, org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated2, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseManyComponents, org.apache.commons.math.special.GammaTest#testRegularizedGammaPositivePositive, org.apache.commons.math.util.TransformerMapTest#testPutTransformer, org.apache.commons.math.optimization.linear.SimplexSolverTest#testDegeneracy, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeAll, org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testQuinticFunction, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testDimension, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFittingBadInit, org.apache.commons.math.optimization.linear.SimplexTableauTest#testDropPhase1Objective, org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatObject, org.apache.commons.math.fraction.BigFractionFormatTest#testWholeFormat, org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testStepSize, org.apache.commons.math.util.MathUtilsTest#testNormalizeAngle, org.apache.commons.math.MathExceptionTest#testConstructorCause, org.apache.commons.math.complex.ComplexTest#testAbsNaN, org.apache.commons.math.stat.descriptive.rank.MinTest#testWeightedConsistency, org.apache.commons.math.util.MathUtilsTest#testIndicatorInt, org.apache.commons.math.linear.BlockRealMatrixTest#testAdd, org.apache.commons.math.linear.RealMatrixImplTest#testScalarAdd, org.apache.commons.math.special.GammaTest#testLogGammaZero, org.apache.commons.math.stat.StatUtilsTest#testPercentile, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareLargeTestStatistic, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopyConsistency, org.apache.commons.math.linear.RealMatrixImplTest#testOperate, org.apache.commons.math.stat.descriptive.rank.MaxTest#testMomentSmallSamples, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenPrefix, org.apache.commons.math.stat.correlation.CovarianceTest#testLongly, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTrivial, org.apache.commons.math.ode.ContinuousOutputModelTest#testErrorConditions, org.apache.commons.math.complex.ComplexFormatTest#testZeroImaginary, org.apache.commons.math.fraction.BigFractionFormatTest#testParseInteger, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testWeightedConsistency, org.apache.commons.math.random.MersenneTwisterTest#testNexBytes, org.apache.commons.math.complex.ComplexUtilsTest#testPolar2Complex, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testPercentileSetter, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testUnstableDerivative, org.apache.commons.math.complex.ComplexTest#testMath221, org.apache.commons.math.complex.ComplexTest#testSqrt1z, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnDistortedSine, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopy, org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowMatrix, org.apache.commons.math.geometry.RotationTest#testQuaternion, org.apache.commons.math.linear.ArrayFieldVectorTest#testDataInOut, org.apache.commons.math.random.RandomAdaptorTest#testNextPermutation, org.apache.commons.math.linear.RealMatrixImplTest#testMultiply, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testRedundantEquations, org.apache.commons.math.linear.QRDecompositionImplTest#testHTrapezoidal, org.apache.commons.math.linear.RealVectorFormatTest#testParseNan, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNoRoot, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testDimensions, org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.analysis.integration.RombergIntegratorTest#testQuinticFunction, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testN0andN1Conditions, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseZeroX, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterIllegalState, org.apache.commons.math.linear.QRDecompositionImplTest#testQOrthogonal, org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testMismatch, org.apache.commons.math.fraction.FractionFormatTest#testFormatZero, org.apache.commons.math.distribution.GammaDistributionTest#testConsistency, org.apache.commons.math.distribution.WeibullDistributionTest#testSetBeta, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDimensionCheck, org.apache.commons.math.linear.BiDiagonalTransformerTest#testMatricesValues, org.apache.commons.math.stat.data.LotteryTest#testCertifiedValues, org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testFixedState, org.apache.commons.math.fraction.BigFractionTest#testGetReducedFraction, org.apache.commons.math.linear.RealMatrixImplTest#testAddFail, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testSmallLastStep, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.util.TransformerMapTest#testContainsClass, org.apache.commons.math.linear.BlockFieldMatrixTest#testSeveralBlocks, org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFat, org.apache.commons.math.geometry.RotationTest#testMatrix, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerialization, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopy, org.apache.commons.math.stat.descriptive.summary.ProductTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.linear.SparseFieldMatrixTest#testCopyFunctions, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetAbsoluteAccuracy, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopyConsistency, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextHex, org.apache.commons.math.linear.BiDiagonalTransformerTest#testVOrthogonal, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMinimization, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testConsistency, org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHeterscedastic, org.apache.commons.math.geometry.Vector3DFormatTest#testParseIgnoredWhitespace, org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnMatrix, org.apache.commons.math.linear.RealVectorFormatTest#testNonDefaultSetting, org.apache.commons.math.fraction.FractionFieldTest#testZero, org.apache.commons.math.util.MathUtilsTest#test0Choose0, org.apache.commons.math.util.DefaultTransformerTest#testTransformString, org.apache.commons.math.distribution.NormalDistributionTest#testSetMean, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testCopy, org.apache.commons.math.linear.EigenDecompositionImplTest#testRepeatedEigenvalue, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerial, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerialization, org.apache.commons.math.stat.descriptive.rank.MinTest#testIncrementation, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testIncrementation, org.apache.commons.math.genetics.ChromosomeTest#testFindSameChromosome, org.apache.commons.math.linear.BlockFieldMatrixTest#testOperatePremultiplyLarge, org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimals, org.apache.commons.math.stat.descriptive.rank.MaxTest#testSpecialValues, org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiply, org.apache.commons.math.geometry.Vector3DFormatTest#testNan, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressandVariance, org.apache.commons.math.complex.ComplexTest#testConjugate, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testIncrementation, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevDifferentials, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNan, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsNoConvergence, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetEntry, org.apache.commons.math.distribution.WeibullDistributionTest#testAlpha, org.apache.commons.math.linear.BigMatrixImplTest#testTranspose, org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedUlps, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetRelativeAccuracy, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracySin, org.apache.commons.math.complex.FrenchComplexFormatTest#testNan, org.apache.commons.math.linear.ArrayRealVectorTest#testBasicFunctions, org.apache.commons.math.distribution.BinomialDistributionTest#testDensities, org.apache.commons.math.random.ValueServerTest#testEmptyDigestFile, org.apache.commons.math.fraction.BigFractionTest#testDivide, org.apache.commons.math.linear.BlockRealMatrixTest#testCopySubMatrix, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testConsistency, org.apache.commons.math.random.RandomAdaptorTest#testNextInt, org.apache.commons.math.complex.ComplexFormatTest#testParseZeroImaginary, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNullIntervalCheck, org.apache.commons.math.special.GammaTest#testTrigamma, org.apache.commons.math.fraction.BigFractionTest#testSerial, org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHeterscedastic, org.apache.commons.math.complex.ComplexTest#testDivideReal, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAdd, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testWeightedConsistency, org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply, org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testParameters, org.apache.commons.math.linear.MatrixUtilsTest#testCreateIdentityMatrix, org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove2, org.apache.commons.math.linear.FieldMatrixImplTest#testCopyFunctions, org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalid, org.apache.commons.math.distribution.NormalDistributionTest#testQuantiles, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testIncreasingTolerance, org.apache.commons.math.special.GammaTest#testDigammaLargeArgs, org.apache.commons.math.linear.ArrayRealVectorTest#testPredicates, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testVOrthogonal, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBackward, org.apache.commons.math.distribution.NormalDistributionTest#testCumulativeProbabilities, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRandom, org.apache.commons.math.linear.ArrayFieldVectorTest#testConstructors, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testRemoval, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetMaximalIterationCount, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testWalk, org.apache.commons.math.complex.ComplexTest#testDivideNaN, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnTwoPoints, org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testNoError, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnVector, org.apache.commons.math.fraction.FractionFormatTest#testParseProper, org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testSerialization, org.apache.commons.math.geometry.Vector3DTest#testScalarProduct, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArgumentsCause, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowMatrix, org.apache.commons.math.transform.FastCosineTransformerTest#testSinFunction, org.apache.commons.math.stat.descriptive.summary.SumTest#testEqualsAndHashCode, org.apache.commons.math.linear.RealMatrixImplTest#testTranspose, org.apache.commons.math.geometry.RotationTest#testVectorOnePair, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testIncreasingTolerance, org.apache.commons.math.linear.TriDiagonalTransformerTest#testQOrthogonal, org.apache.commons.math.special.BetaTest#testLogBetaPositiveNan, org.apache.commons.math.special.BetaTest#testLogBetaPositiveNegative, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testWrongDerivative, org.apache.commons.math.linear.SparseRealMatrixTest#testSubMatrix, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testQuinticFunction, org.apache.commons.math.distribution.PoissonDistributionTest#testNormalApproximateProbability, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMaximalTiesMinimum, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testMomentSmallSamples, org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#serialization, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationInside, org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleT, org.apache.commons.math.complex.ComplexTest#testNegateNaN, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNonDefaultSetting, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetVectors, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testStats, org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopy, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTranspose, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetEntry, org.apache.commons.math.linear.BigMatrixImplTest#testPremultiply, org.apache.commons.math.optimization.linear.SimplexTableauTest#testSerial, org.apache.commons.math.stat.descriptive.rank.MinTest#testMomentSmallSamples, org.apache.commons.math.fraction.BigFractionFormatTest#testDenominatorFormat, org.apache.commons.math.linear.BlockRealMatrixTest#testDimensions, org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#serialization, org.apache.commons.math.complex.ComplexTest#testSinNaN, org.apache.commons.math.complex.ComplexTest#testScalarMultiplyInf, org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testParaboloid2D, org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testEqualsAndHashCode, org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues2, org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues1, org.apache.commons.math.stat.descriptive.rank.MaxTest#testIncrementation, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentSizes, org.apache.commons.math.linear.RealVectorFormatTest#testNan, org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiplyVector, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwissFertility, org.apache.commons.math.genetics.RandomKeyTest#testConstructor2, org.apache.commons.math.genetics.RandomKeyTest#testConstructor1, org.apache.commons.math.util.BigRealTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexTest#testLogZero, org.apache.commons.math.util.ResizableDoubleArrayTest#testMinMax, org.apache.commons.math.linear.LUDecompositionImplTest#testUUpperTriangular, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNonInversible, org.apache.commons.math.random.RandomDataTest#testNextLongExtremeValues, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerialization, org.apache.commons.math.linear.TriDiagonalTransformerTest#testNonSquare, org.apache.commons.math.complex.ComplexTest#testCosh, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopyConsistency, org.apache.commons.math.linear.ArrayFieldVectorTest#testSerial, org.apache.commons.math.estimation.MinpackTest#testMinpackLinearFullRank, org.apache.commons.math.geometry.Vector3DFormatTest#testPositiveInfinity, org.apache.commons.math.stat.descriptive.rank.MinTest#testNaNs, org.apache.commons.math.stat.descriptive.summary.SumTest#testCopy, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testKepler, org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfect, org.apache.commons.math.linear.RealVectorFormatTest#testParseManyComponents, org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuinticFunction, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEqualsAndHashCode, org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply2, org.apache.commons.math.linear.ArrayFieldVectorTest#testBasicFunctions, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEqualsAndHashCode, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnLarge, org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeImaginary, org.apache.commons.math.linear.BlockFieldMatrixTest#testAdd, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNonDefaultSetting, org.apache.commons.math.fraction.BigFractionTest#testSubtract, org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnVector, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testConsistency, org.apache.commons.math.distribution.ChiSquareDistributionTest#testConsistency, org.apache.commons.math.fraction.FractionFormatTest#testParse, org.apache.commons.math.linear.FieldMatrixImplTest#testGetRow, org.apache.commons.math.linear.RealMatrixImplTest#testSetRowMatrix, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMaxIterations, org.apache.commons.math.linear.BigMatrixImplTest#testNorm, org.apache.commons.math.distribution.GammaDistributionTest#testDensity, org.apache.commons.math.fraction.BigFractionTest#testDigitLimitConstructor, org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnMatrix, org.apache.commons.math.linear.MatrixUtilsTest#testBigFractionConverter, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeInfinity, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#test20090720, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testIllConditioned, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTwoSets, org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testLinearFunction2D, org.apache.commons.math.linear.ArrayRealVectorTest#testSerial, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopyConsistency, org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGet, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMath199, org.apache.commons.math.linear.BlockFieldMatrixTest#testTrace, org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testStats, org.apache.commons.math.complex.ComplexFormatTest#testFormatObject, org.apache.commons.math.stat.descriptive.summary.SumTest#testCopyConsistency, org.apache.commons.math.transform.FastFourierTransformerTest#testSinFunction, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#serialization, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testContainsKey, org.apache.commons.math.complex.ComplexFormatTest#testSetRealFormatNull, org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantUnsolvable, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonBadCounts, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#backward, org.apache.commons.math.analysis.solvers.NewtonSolverTest#testSinZero, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testSmallStep, org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnMatrix, org.apache.commons.math.linear.FieldMatrixImplTest#testToString, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testKepler, org.apache.commons.math.linear.BlockRealMatrixTest#testWalk, org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated, org.apache.commons.math.linear.BlockFieldMatrixTest#testOperateLarge, org.apache.commons.math.stat.descriptive.rank.MinTest#testEvaluation, org.apache.commons.math.optimization.general.MinpackTest#testMinpackBox3Dimensional, org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeImaginary, org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnMatrix, org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArgumentsCause, org.apache.commons.math.linear.BlockRealMatrixTest#testOperateLarge, org.apache.commons.math.geometry.Vector3DTest#testDistanceInf, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBigStep, org.apache.commons.math.linear.BlockFieldMatrixTest#testTranspose, org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiplyVector, org.apache.commons.math.fraction.BigFractionTest#testGoldenRatio, org.apache.commons.math.linear.ArrayRealVectorTest#testDataInOut, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEvaluation, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEvaluation, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMaxIterations, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnOnePoint, org.apache.commons.math.ode.sampling.StepNormalizerTest#testBoundaries, org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiply, org.apache.commons.math.geometry.Vector3DTest#testAngularSeparation, org.apache.commons.math.random.RandomAdaptorTest#testNextSecureInt, org.apache.commons.math.linear.BigMatrixImplTest#testInverse, org.apache.commons.math.linear.SparseRealMatrixTest#testToString, org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testBackward, org.apache.commons.math.util.DefaultTransformerTest#testTransformDouble, org.apache.commons.math.MathExceptionTest#testSerialization, org.apache.commons.math.util.MathUtilsTest#testCosh, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterInjection, org.apache.commons.math.optimization.linear.SimplexTableauTest#testTableauWithNoArtificialVars, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetSubMatrix, org.apache.commons.math.util.MathUtilsTest#testScalb, org.apache.commons.math.genetics.BinaryChromosomeTest#testRandomConstructor, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeZ, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquare, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeY, org.apache.commons.math.estimation.EstimatedParameterTest#testEstimate, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeX, org.apache.commons.math.optimization.general.MinpackTest#testMinpackPowellSingular, org.apache.commons.math.util.OpenIntToFieldTest#testContainsKey, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testDeprecated, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testUUpperTriangular, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testConsistency, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopy, org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_thirdRoot, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNan, org.apache.commons.math.linear.BigMatrixImplTest#testToString, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath272, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleNoDecimals, org.apache.commons.math.stat.inference.TTestTest#testOneSampleTTest, org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSeparator, org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testSerialization, org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeReal, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMinimizeMaximize, org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply, org.apache.commons.math.stat.descriptive.summary.ProductTest#testConsistency, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnStraightLine, org.apache.commons.math.complex.ComplexTest#testSinh, org.apache.commons.math.random.RandomAdaptorTest#testNextExponential, org.apache.commons.math.linear.LUSolverTest#testDeterminant, org.apache.commons.math.stat.StatUtilsTest#testArrayIndexConditions, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testNaN, org.apache.commons.math.estimation.WeightedMeasurementTest#testConstruction, org.apache.commons.math.linear.SparseFieldMatrixTest#testMath209, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testVariableSteps, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testToString, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testGetSummary, org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedConsistency, org.apache.commons.math.util.MathUtilsTest#testNormalizeArray, org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath288, org.apache.commons.math.linear.EigenDecompositionImplTest#testDiagonal, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath286, org.apache.commons.math.analysis.solvers.BrentSolverTest#testInitialGuess, org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnRealMatrix, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testDimensionCheck, org.apache.commons.math.fraction.BigFractionFormatTest#testFormat, org.apache.commons.math.util.MathUtilsTest#testSignByte, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFitting, org.apache.commons.math.ode.ContinuousOutputModelTest#testBoundaries, org.apache.commons.math.complex.ComplexFormatTest#testPaseNegativeInfinity, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNan, org.apache.commons.math.random.RandomAdaptorTest#testNextSecureLong, org.apache.commons.math.distribution.PascalDistributionTest#testCumulativeProbabilities, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSpecialValues, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConsistency, org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopy, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeInfinity, org.apache.commons.math.stat.StatUtilsTest#testN0andN1Conditions, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath293, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopySubMatrix, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseZeroX, org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#derivativesConsistency, org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.linear.FieldMatrixImplTest#testOperate, org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testConstructor, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testOperate, org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWith0ExpectedSize, org.apache.commons.math.special.ErfTest#testErf3291, org.apache.commons.math.complex.ComplexTest#testHashCode, org.apache.commons.math.linear.EigenDecompositionImplTest#testMath308, org.apache.commons.math.linear.SparseRealMatrixTest#testNorm, org.apache.commons.math.linear.ArrayRealVectorTest#testConstructors, org.apache.commons.math.linear.EigenSolverTest#testSolveDimensionErrors, org.apache.commons.math.complex.ComplexTest#testAddNaN, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testFrobeniusNorm, org.apache.commons.math.linear.SparseFieldMatrixTest#testPlusMinus, org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne2, org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimals, org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnMatrix, org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testDistance, org.apache.commons.math.linear.BlockRealMatrixTest#testTrace, org.apache.commons.math.linear.QRDecompositionImplTest#testRUpperTriangular, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowVector, org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne1, org.apache.commons.math.linear.BlockFieldMatrixTest#testCopySubMatrix, org.apache.commons.math.linear.BlockRealMatrixTest#testOperatePremultiplyLarge, org.apache.commons.math.complex.ComplexTest#testConjugateNaN, org.apache.commons.math.linear.FieldMatrixImplTest#testMath209, org.apache.commons.math.stat.inference.TTestTest#testSmallSamples, org.apache.commons.math.linear.RealMatrixImplTest#testSetSubMatrix, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreRows, org.apache.commons.math.linear.BigMatrixImplTest#testMath209, org.apache.commons.math.distribution.ChiSquareDistributionTest#testDensity, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTwoSets, org.apache.commons.math.complex.FrenchComplexFormatTest#testConstructorSingleFormat, org.apache.commons.math.linear.BlockFieldMatrixTest#testScalarAdd, org.apache.commons.math.complex.ComplexTest#testCos, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSuffix, org.apache.commons.math.special.BetaTest#testRegularizedBetaNanPositivePositive, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testMinStep, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuintic, org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#checklone, org.apache.commons.math.linear.BlockFieldMatrixTest#testCopyFunctions, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextIntExtremeValues, org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testSinMin, org.apache.commons.math.random.RandomDataTest#testConfig, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedVariance, org.apache.commons.math.complex.ComplexTest#testAsinInf, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testNorm, org.apache.commons.math.distribution.PoissonDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNISTExample, org.apache.commons.math.complex.ComplexTest#testAtanNaN, org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbability2, org.apache.commons.math.complex.ComplexTest#testAcosInf, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testKepler, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testInsufficientBandwidth, org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterEmpty, org.apache.commons.math.complex.ComplexTest#testDivideImaginary, org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuadraticFunction, org.apache.commons.math.linear.BlockFieldMatrixTest#testExamples, org.apache.commons.math.distribution.HypergeometricDistributionTest#testMoreLargeValues, org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedMean, org.apache.commons.math.complex.ComplexTest#testPow, org.apache.commons.math.linear.RealVectorFormatTest#testFormatObject, org.apache.commons.math.distribution.FDistributionTest#testDfAccessors, org.apache.commons.math.util.MathUtilsTest#testArrayEquals, org.apache.commons.math.stat.descriptive.moment.MeanTest#testEqualsAndHashCode, org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownDennis, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRow, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesMaximum, org.apache.commons.math.stat.correlation.CovarianceTest#testSwissFertility, org.apache.commons.math.random.RandomDataTest#testNextSecureInt, org.apache.commons.math.geometry.Vector3DTest#testOrthogonal, org.apache.commons.math.geometry.Vector3DTest#testDistance, org.apache.commons.math.distribution.WeibullDistributionTest#testCumulativeProbabilities, org.apache.commons.math.distribution.CauchyDistributionTest#testSetScale, org.apache.commons.math.stat.FrequencyTest#testEmptyTable, org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxIterations, org.apache.commons.math.linear.RealMatrixImplTest#testMultiply2, org.apache.commons.math.special.BetaTest#testLogBetaZeroPositive, org.apache.commons.math.fraction.BigFractionFormatTest#testFormatNegative, org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientLarge, org.apache.commons.math.random.RandomAdaptorTest#testNextIntExtremeValues, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testWindowSize, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesAverage, org.apache.commons.math.stat.descriptive.rank.MinTest#testCopyConsistency, org.apache.commons.math.complex.ComplexFormatTest#testConstructorSingleFormat, org.apache.commons.math.linear.LUDecompositionImplTest#testNonSquare, org.apache.commons.math.fraction.FractionFormatTest#testWholeFormat, org.apache.commons.math.distribution.PascalDistributionTest#testFloatingPointArguments, org.apache.commons.math.stat.StatUtilsTest#testVariance, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testNaNContracts, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNegative, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerialization, org.apache.commons.math.geometry.Vector3DTest#testConstructors, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testWeightedConsistency, org.apache.commons.math.util.MathUtilsTest#testIndicatorLong, org.apache.commons.math.stat.descriptive.rank.MaxTest#testNaNs, org.apache.commons.math.util.TransformerMapTest#testRemoveTransformer, org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimals, org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldMatrix, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testNaNContracts, org.apache.commons.math.linear.BlockRealMatrixTest#testSerial, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeX, org.apache.commons.math.linear.BiDiagonalTransformerTest#testUpperOrLower, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeY, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeZ, org.apache.commons.math.distribution.ExponentialDistributionTest#testIllegalArguments, org.apache.commons.math.random.MersenneTwisterTest#testDouble, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersSimple, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testStepSize, org.apache.commons.math.MaxIterationsExceededExceptionTest#testComplexConstructor, org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHeterscedastic, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testUnstableDerivative, org.apache.commons.math.stat.FrequencyTest#testPcts, org.apache.commons.math.geometry.Vector3DTest#testAngle, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testMomentSmallSamples, org.apache.commons.math.random.MersenneTwisterTest#testGaussian, org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction2, org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBrentSolverValid, org.apache.commons.math.fraction.FractionFormatTest#testLongFormat, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSerialization, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testStats, org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testProductAndGeometricMean, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextGaussian, org.apache.commons.math.linear.BigMatrixImplTest#testLUDecomposition, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerial, org.apache.commons.math.random.ValueServerTest#testProperties, org.apache.commons.math.linear.RealMatrixImplTest#testEqualsAndHashCode, org.apache.commons.math.geometry.Vector3DTest#testNorm1, org.apache.commons.math.complex.ComplexTest#testAtanInf, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowVector, org.apache.commons.math.special.ErfTest#testErf2807, org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testArrayIsReference, org.apache.commons.math.random.AbstractRandomGeneratorTest#testConfig, org.apache.commons.math.random.MersenneTwisterTest#testNexBoolean, org.apache.commons.math.linear.BigMatrixImplTest#testOperate, org.apache.commons.math.util.TransformerMapTest#testClasses, org.apache.commons.math.linear.SparseRealVectorTest#testMapFunctions, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testCovarianceConsistency, org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilities, org.apache.commons.math.complex.ComplexTest#testSqrt1zNaN, org.apache.commons.math.stat.correlation.CovarianceTest#testConsistency, org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.util.MathUtilsTest#testSignShort, org.apache.commons.math.stat.descriptive.summary.SumTest#testSerial, org.apache.commons.math.special.ErfTest#testErf1960, org.apache.commons.math.util.MathUtilsTest#testHash, org.apache.commons.math.linear.RealVectorFormatTest#testSimpleNoDecimals, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, org.apache.commons.math.fraction.FractionTest#testReciprocal, org.apache.commons.math.linear.BlockRealMatrixTest#testNorm, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEvaluation, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testMomentSmallSamples, org.apache.commons.math.linear.ArrayFieldVectorTest#testMisc, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testDimensions, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testIncrementation, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testWeightedConsistency, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testInconsistentEquations, org.apache.commons.math.fraction.BigFractionTest#testConstructor, org.apache.commons.math.complex.ComplexTest#testGetArgumentInf, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testStats, org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest#dimension2, org.apache.commons.math.stat.FrequencyTest#testIntegerValues, org.apache.commons.math.linear.SparseRealMatrixTest#testPlusMinus, org.apache.commons.math.linear.QRSolverTest#testSolveDimensionErrors, org.apache.commons.math.estimation.EstimatedParameterTest#testConstruction, org.apache.commons.math.genetics.BinaryMutationTest#testMutate, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.linear.BigMatrixImplTest#testGetRowMatrix, org.apache.commons.math.fraction.FractionTest#testIntValue, org.apache.commons.math.util.OpenIntToFieldTest#testRemoveAbsent, org.apache.commons.math.complex.ComplexTest#testAcosNaN, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerial, org.apache.commons.math.complex.ComplexTest#testAddInfinite, org.apache.commons.math.stat.descriptive.rank.MinTest#testSpecialValues, org.apache.commons.math.linear.SparseRealMatrixTest#testGetVectors, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testDimension, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testQRColumnsPermutation, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNonInversible, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testToString, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetSubMatrix, org.apache.commons.math.distribution.FDistributionTest#testLargeDegreesOfFreedom, org.apache.commons.math.random.MersenneTwisterTest#testNextInt, org.apache.commons.math.linear.FieldMatrixImplTest#testWalk, org.apache.commons.math.complex.ComplexTest#testLog, org.apache.commons.math.distribution.CauchyDistributionTest#testCumulativeProbabilities, org.apache.commons.math.complex.ComplexTest#testScalarMultiplyNaN, org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiplyVector, org.apache.commons.math.linear.MatrixUtilsTest#testCreateRealMatrix, org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.linear.BlockRealMatrixTest#testExamples, org.apache.commons.math.genetics.BinaryChromosomeTest#testIsSame, org.apache.commons.math.linear.RealVectorFormatTest#testParseNonDefaultSetting, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testEvaluation, org.apache.commons.math.fraction.FractionFieldTest#testOne, org.apache.commons.math.linear.BlockRealMatrixTest#testAddFail, org.apache.commons.math.estimation.MinpackTest#testMinpackKowalikOsborne, org.apache.commons.math.MathExceptionTest#testConstructorPatternArgumentsCause, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureLong, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTrivial, org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedSum, org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testNoReset, org.apache.commons.math.fraction.BigFractionTest#testBigDecimalValue, org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRootMatrix, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevBounds, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopy, org.apache.commons.math.util.MathUtilsTest#testMulAndCheckLong, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConstant, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniform, org.apache.commons.math.complex.ComplexFormatTest#testParsePositiveInfinity, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseIgnoredWhitespace, org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumn, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testRedundantEquations, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareIndependence, org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacityAndExpansionFactor, org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuadraticFunction, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMath209, org.apache.commons.math.linear.RealMatrixImplTest#testPremultiply, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testCopy, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNullEmpty, org.apache.commons.math.complex.ComplexTest#testEqualsSame, org.apache.commons.math.random.EmpiricalDistributionTest#testNext, org.apache.commons.math.util.MathUtilsTest#testRoundDouble, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnMatrix, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSerialization, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withWeights, org.apache.commons.math.DuplicateSampleAbscissaExceptionTest#testConstructor, org.apache.commons.math.complex.ComplexTest#testMultiplyNaNInf, org.apache.commons.math.linear.FieldMatrixImplTest#testPlusMinus, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNull, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinear, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopy, org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerial, org.apache.commons.math.complex.ComplexFormatTest#testGetRealFormat, org.apache.commons.math.random.RandomAdaptorTest#testNextPoissonConsistency, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testNullIntervalCheck, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testPercentile, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateSpecialValues, org.apache.commons.math.util.ResizableDoubleArrayTest#testGetValues, org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnMatrix, org.apache.commons.math.fraction.BigFractionFormatTest#testParseNegative, org.apache.commons.math.complex.ComplexFormatTest#testParseDifferentImaginaryChar, org.apache.commons.math.linear.CholeskySolverTest#testSolve, org.apache.commons.math.fraction.FractionTest#testToString, org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullURL, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonUnEqualCounts, org.apache.commons.math.random.RandomDataTest#testNextExponential, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290GEQ, org.apache.commons.math.linear.BlockRealMatrixTest#testFrobeniusNorm, org.apache.commons.math.fraction.BigFractionTest#testEpsilonLimitConstructor, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregationConsistency, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimals, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnVectorLarge, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testShuffledStatistics, org.apache.commons.math.util.MathUtilsTest#testRoundFloat, org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientFail, org.apache.commons.math.distribution.NormalDistributionTest#testSetStandardDeviation, org.apache.commons.math.stat.descriptive.summary.ProductTest#testMomentSmallSamples, org.apache.commons.math.complex.ComplexTest#testLogInf, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testShuffledStatistics, org.apache.commons.math.util.ResizableDoubleArrayTest#testSubstitute, org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testParameters, org.apache.commons.math.linear.RealMatrixImplTest#testPlusMinus, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregate, org.apache.commons.math.estimation.MinpackTest#testMinpackPowellSingular, org.apache.commons.math.complex.ComplexTest#testCoshNaN, org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testSinMin, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoisson, org.apache.commons.math.ode.FirstOrderConverterTest#testBigStep, org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiply, org.apache.commons.math.linear.LUSolverTest#testSolve, org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testCentroid, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEqualsAndHashCode, org.apache.commons.math.linear.InvalidMatrixExceptionTest#testConstructorMessage, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoissonConsistency, org.apache.commons.math.distribution.NormalDistributionTest#testIllegalArguments, org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBisectionSolverValid, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testIllConditioned, org.apache.commons.math.transform.FastCosineTransformerTest#testParameters, org.apache.commons.math.linear.QRDecompositionImplTest#testAEqualQR, org.apache.commons.math.fraction.BigFractionFormatTest#testNumeratorFormat, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testEvents, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnMatrixLarge, org.apache.commons.math.complex.FrenchComplexFormatTest#testSetRealFormatNull, org.apache.commons.math.special.GammaTest#testLogGammaNegative, org.apache.commons.math.transform.FastFourierTransformerTest#testAdHocData, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withoutWeights, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeAll, org.apache.commons.math.linear.BigMatrixImplTest#testCopyFunctions, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLegendrePolynomials, org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiplyVector, org.apache.commons.math.fraction.BigFractionTest#testReciprocal, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowVectorLarge, org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilityExtremes, org.apache.commons.math.random.RandomAdaptorTest#testNextSecureHex, org.apache.commons.math.random.UniformRandomGeneratorTest#testMeanAndStandardDeviation, org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testMismatch, org.apache.commons.math.linear.SparseRealVectorTest#testBasicFunctions, org.apache.commons.math.distribution.PascalDistributionTest#testIllegalArguments, org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testParameters, org.apache.commons.math.linear.RealVectorFormatTest#testPositiveInfinity, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLLowerTriangular, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testCopy, org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#serialization, org.apache.commons.math.estimation.EstimatedParameterTest#testBound, org.apache.commons.math.transform.FastHadamardTransformerTest#test8Points, org.apache.commons.math.stat.ranking.NaturalRankingTest#testDefault, org.apache.commons.math.util.ResizableDoubleArrayTest#testConstructors, org.apache.commons.math.transform.FastSineTransformerTest#testAdHocData, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddNullYSampleData, org.apache.commons.math.linear.BigMatrixImplTest#testGetVectors, org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAbsentOnExisting, org.apache.commons.math.complex.ComplexFormatTest#testPositiveInfinity, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testControlParameters, org.apache.commons.math.genetics.TournamentSelectionTest#testSelect, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testPopulation, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregation, org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilities, org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowMatrix, org.apache.commons.math.distribution.TDistributionTest#testIllegalArguments, org.apache.commons.math.complex.FrenchComplexFormatTest#testForgottenImaginaryCharacter, org.apache.commons.math.fraction.FractionFormatTest#testFormat, org.apache.commons.math.analysis.solvers.BrentSolverTest#testRootEndpoints, org.apache.commons.math.optimization.general.MinpackTest#testMinpackWatson, org.apache.commons.math.fraction.BigFractionTest#testDoubleConstructor, org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryFormatNull, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#polynomial, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNoDependency, org.apache.commons.math.optimization.linear.SimplexSolverTest#testModelWithNoArtificialVars, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopyFunctions, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testSingular, org.apache.commons.math.linear.FieldMatrixImplTest#testCopySubMatrix, org.apache.commons.math.complex.ComplexTest#testEqualsImaginaryDifference, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testEqualsAndHashCode, org.apache.commons.math.optimization.general.MinpackTest#testMinpackFreudensteinRoth, org.apache.commons.math.fraction.FractionTest#testDivide, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveSingle, org.apache.commons.math.complex.ComplexTest#testAbs, org.apache.commons.math.linear.ArrayRealVectorTest#testMapFunctions, org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.random.RandomAdaptorTest#testAdaptor, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNonSquare, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testCircleFitting, org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares3, org.apache.commons.math.distribution.ExponentialDistributionTest#testMeanAccessors, org.apache.commons.math.complex.ComplexTest#testGetArgument, org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares1, org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares2, org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnMatrix, org.apache.commons.math.random.RandomDataTest#testNextInt, org.apache.commons.math.stat.inference.TestUtilsTest#testSmallSamples, org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullDoubleArray, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testDecreasingSteps, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testToString, org.apache.commons.math.linear.BlockRealMatrixTest#testMath209, org.apache.commons.math.estimation.MinpackTest#testMinpackBox3Dimensional, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowMatrix, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply, org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilityExtremes, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSerialization, org.apache.commons.math.complex.ComplexTest#testDivideNaNInf, org.apache.commons.math.linear.FieldMatrixImplTest#testExamples, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRow, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSmallStep, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithoutSplit, org.apache.commons.math.distribution.ZipfDistributionTest#testIllegalArguments, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetSubMatrix, org.apache.commons.math.complex.ComplexTest#testSqrtNaN, org.apache.commons.math.distribution.NormalDistributionTest#testGetStandardDeviation, org.apache.commons.math.linear.MatrixIndexExceptionTest#testConstructorMessage, org.apache.commons.math.distribution.HypergeometricDistributionTest#testDensities, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDecreasingSteps, org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testParameters, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareIndependence, org.apache.commons.math.fraction.BigFractionTest#testConstructorDouble, org.apache.commons.math.stat.descriptive.rank.MaxTest#testConsistency, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsRemovedTiesSequential, org.apache.commons.math.fraction.FractionFormatTest#testNumeratorFormat, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues1, org.apache.commons.math.util.OpenIntToFieldTest#testPutAbsentOnExisting, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues2, org.apache.commons.math.linear.BigMatrixImplTest#testDeterminant, org.apache.commons.math.complex.ComplexTest#testEqualsClass, org.apache.commons.math.fraction.BigFractionTest#testEqualsAndHashCode, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollision2, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testStepSize, org.apache.commons.math.complex.ComplexTest#testCoshInf, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreColumns, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiple, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetAbsoluteAccuracy, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testSetterInjection, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSingleton, org.apache.commons.math.fraction.BigFractionFormatTest#testLongFormat, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#notEnoughData, org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilityAgaintStackOverflow, org.apache.commons.math.stat.inference.TestUtilsTest#testOneWayAnovaUtils, org.apache.commons.math.optimization.direct.NelderMeadTest#testPowell, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testIllConditioned, org.apache.commons.math.geometry.Vector3DFormatTest#testParseZeroX, org.apache.commons.math.util.MathUtilsTest#testL2DistanceDouble, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testLongly, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testHighPercentile, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testMinStep, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveSin, org.apache.commons.math.util.MathUtilsTest#testNextAfter, org.apache.commons.math.linear.LUDecompositionImplTest#testSingular, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testGetValues, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonEqualCounts, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveFromEmpty, org.apache.commons.math.geometry.Vector3DTest#testCoordinates, org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollisions, org.apache.commons.math.complex.ComplexTest#testAsinNaN, org.apache.commons.math.util.MathUtilsTest#testIndicatorDouble, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTwoSets, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLongExtremeValues, org.apache.commons.math.random.RandomDataTest#testNextSecureLong, org.apache.commons.math.linear.SparseFieldMatrixTest#testScalarAdd, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateResiduals, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testOneSet, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDecreasingSteps, org.apache.commons.math.stat.descriptive.summary.SumTest#testMomentSmallSamples, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBackward, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testNaN, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.linear.MatrixUtilsTest#testFractionConverter, org.apache.commons.math.util.BigRealFieldTest#testSerial, org.apache.commons.math.random.RandomAdaptorTest#testNextLong, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testWeightedConsistency, org.apache.commons.math.stat.descriptive.rank.MinTest#testEqualsAndHashCode, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPAEqualLU, org.apache.commons.math.distribution.PoissonDistributionTest#testMean, org.apache.commons.math.distribution.PoissonDistributionTest#testIllegalArguments, org.apache.commons.math.stat.descriptive.rank.MedianTest#testCopy, org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.analysis.solvers.BrentSolverTest#testSinZero, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNonInversible, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testProductAndGeometricMean, org.apache.commons.math.util.ResizableDoubleArrayTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexTest#testAdd, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareLargeTestStatistic, org.apache.commons.math.special.GammaTest#testRegularizedGammaNegativePositive, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBigStep, org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#checkClone, org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuinticFunction, org.apache.commons.math.complex.ComplexTest#testSqrtInf, org.apache.commons.math.distribution.NormalDistributionTest#testConsistency, org.apache.commons.math.complex.ComplexTest#testAbsInfinite, org.apache.commons.math.complex.ComplexFieldTest#testZero, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataWithSampleSizeMismatch, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#exceedMaxEvaluations, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testStdErrorConsistency, org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproper, org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWithExpectedSize, org.apache.commons.math.random.MersenneTwisterTest#testFloat, org.apache.commons.math.stat.descriptive.rank.MaxTest#testEvaluation, org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_realPartZero, org.apache.commons.math.complex.ComplexTest#testEqualsNaN, org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryZero, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopyConsistency, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEvaluation, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextFloat, org.apache.commons.math.stat.inference.TTestTest#testPaired, org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testImpossibleSerialization, org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroImaginary, org.apache.commons.math.linear.QRDecompositionImplTest#testDimensions, org.apache.commons.math.distribution.GammaDistributionTest#testParameterAccessors, org.apache.commons.math.random.ValueServerTest#testNextDigestFail, org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperInvalidMinus, org.apache.commons.math.complex.ComplexFormatTest#testNegativeBoth, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testMomentSmallSamples, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEqualsAndHashCode, org.apache.commons.math.linear.SparseRealVectorTest#testDataInOut, org.apache.commons.math.random.RandomAdaptorTest#testNextUniformExclusiveEndpoints, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBackward, org.apache.commons.math.complex.FrenchComplexFormatTest#testParsePositiveInfinity, org.apache.commons.math.stat.StatUtilsTest#testMax, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopyConsistency, org.apache.commons.math.optimization.linear.SimplexSolverTest#testRestrictVariablesToNonNegative, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerialization, org.apache.commons.math.stat.correlation.CovarianceTest#testInsufficientData, org.apache.commons.math.optimization.linear.SimplexTableauTest#testInitialization, org.apache.commons.math.linear.EigenSolverTest#testNonInvertible, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveXY, org.apache.commons.math.linear.RealMatrixImplTest#testGetRowMatrix, org.apache.commons.math.ode.ContinuousOutputModelTest#testModelsMerging, org.apache.commons.math.stat.FrequencyTest#testToString, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testEqualsAndHashCode, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNonDefaultSetting, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testStats, org.apache.commons.math.complex.ComplexTest#testPowInf, org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testValues, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#noReset, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testRedundantEquations, org.apache.commons.math.stat.descriptive.summary.ProductTest#testEvaluation, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth1, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth2, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.transform.FastCosineTransformerTest#testAdHocData, org.apache.commons.math.distribution.ChiSquareDistributionTest#testIllegalArguments, org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterNull, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testIncrementation, org.apache.commons.math.complex.ComplexTest#testTanh, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testConsistency, org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerial, org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerialization, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testIncrementation, org.apache.commons.math.linear.RealMatrixImplTest#testGetColumn, org.apache.commons.math.linear.RealMatrixImplTest#testMath209, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#serialization, org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMax, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testN0andN1Conditions, org.apache.commons.math.util.OpenIntToFieldTest#testRemove2, org.apache.commons.math.complex.ComplexTest#testSqrtRealNegative, org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArguments, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testUOrthogonal, org.apache.commons.math.linear.BiDiagonalTransformerTest#testBBiDiagonal, org.apache.commons.math.linear.BigMatrixImplTest#testGetColumnMatrix, org.apache.commons.math.complex.ComplexTest#testpowNull, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBigStep, org.apache.commons.math.stat.descriptive.summary.SumTest#testSpecialValues, org.apache.commons.math.linear.BlockRealMatrixTest#testScalarAdd, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSerialization, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEqualsAndHashCode, org.apache.commons.math.fraction.FractionTest#testConstructor, org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetMatrixLarge, org.apache.commons.math.linear.EigenDecompositionImplTest#testVOrthogonal, org.apache.commons.math.distribution.PoissonDistributionTest#testDegenerateInverseCumulativeProbability, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#polynomial, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSinZero, org.apache.commons.math.fraction.FractionTest#testGetReducedFraction, org.apache.commons.math.distribution.FDistributionTest#testConsistency, org.apache.commons.math.analysis.solvers.BrentSolverTest#testDeprecated, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues2, org.apache.commons.math.fraction.FractionFormatTest#testParseInteger, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testStaticFormatRealVectorImpl, org.apache.commons.math.estimation.MinpackTest#testMinpackMeyer, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues1, org.apache.commons.math.random.RandomAdaptorTest#testNextGaussian, org.apache.commons.math.util.BigRealTest#testDoubleValue, org.apache.commons.math.linear.FieldMatrixImplTest#testSerial, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNanPositive, org.apache.commons.math.linear.FieldMatrixImplTest#testDimensions, org.apache.commons.math.linear.RealMatrixImplTest#testGetSubMatrix, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetMaximalIterationCount, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterInjection, org.apache.commons.math.linear.TriDiagonalTransformerTest#testTTriDiagonal, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testRedundantEquations, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracyNull, org.apache.commons.math.complex.ComplexTest#testConstructorNaN, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersSimple, org.apache.commons.math.stat.descriptive.summary.SumTest#testConsistency, org.apache.commons.math.fraction.BigFractionFieldTest#testZero, org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigIdentityMatrix, org.apache.commons.math.linear.SparseRealVectorTest#testPredicates, org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testLinearFunction, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositivePositive, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testStepSize, org.apache.commons.math.linear.SparseFieldMatrixTest#testOperate, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopyConsistency, org.apache.commons.math.linear.BlockRealMatrixTest#testSetRow, org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest#testMeanAndCorrelation, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testConcurrentModification, org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopyConsistency, org.apache.commons.math.linear.SparseFieldMatrixTest#testTranspose, org.apache.commons.math.optimization.general.MinpackTest#testMinpackRosenbrok, org.apache.commons.math.util.MathUtilsTest#testSignFloat, org.apache.commons.math.util.MathUtilsTest#testSignDouble, org.apache.commons.math.fraction.FractionFormatTest#testParseInvalid, org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowVector, org.apache.commons.math.geometry.RotationTest#testVectorTwoPairs, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetVectors, org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#serialization, org.apache.commons.math.distribution.NormalDistributionTest#testExtremeValues, org.apache.commons.math.linear.LUSolverTest#testThreshold, org.apache.commons.math.geometry.RotationOrderTest#testName, org.apache.commons.math.util.MathUtilsTest#testIndicatorShort, org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanCumulativeProbability, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTrivial, org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollisions, org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeInfinity, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testMinStep, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testConsistency, org.apache.commons.math.complex.ComplexFormatTest#testStaticFormatComplex, org.apache.commons.math.linear.TriDiagonalTransformerTest#testAEqualQTQt, org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerialization, org.apache.commons.math.util.MathUtilsTest#testSinh, org.apache.commons.math.complex.FrenchComplexFormatTest#testGetImaginaryFormat, org.apache.commons.math.distribution.GammaDistributionTest#testIllegalArguments, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testKepler, org.apache.commons.math.linear.BlockFieldMatrixTest#testEqualsAndHashCode, org.apache.commons.math.linear.SparseRealMatrixTest#testAddFail, org.apache.commons.math.linear.BlockRealMatrixTest#testSetSubMatrix, org.apache.commons.math.complex.ComplexTest#testTanNaN, org.apache.commons.math.genetics.RandomKeyTest#testInducedPermutation, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTrace, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnVectorLarge, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSeparator, org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaPValue, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#dimensionCheck, org.apache.commons.math.ConvergenceExceptionTest#testConstructorCause, org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnMatrix, org.apache.commons.math.estimation.MinpackTest#testMinpackRosenbrok, org.apache.commons.math.fraction.BigFractionTest#testAdd, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testNaNContracts, org.apache.commons.math.random.RandomDataTest#testNextSample, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroReal, org.apache.commons.math.linear.RealVectorFormatTest#testParseIgnoredWhitespace, org.apache.commons.math.distribution.PoissonDistributionTest#testFloatingPointArguments, org.apache.commons.math.linear.EigenDecompositionImplTest#testZeroDivide, org.apache.commons.math.linear.CholeskySolverTest#testSolveDimensionErrors, org.apache.commons.math.linear.EigenDecompositionImplTest#testBigMatrix, org.apache.commons.math.linear.QRSolverTest#testRank, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddXSampleData, org.apache.commons.math.linear.EigenDecompositionImplTest#testAEqualVDVt, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSubMatrix, org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.geometry.RotationTest#testSingularities, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerialization, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullCovarianceData, org.apache.commons.math.fraction.BigFractionFormatTest#testDoubleFormat, org.apache.commons.math.util.MathUtilsTest#testFactorialFail, org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply2, org.apache.commons.math.linear.TriDiagonalTransformerTest#testQTOrthogonal, org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSimplistic, org.apache.commons.math.fraction.BigFractionTest#testAbs, org.apache.commons.math.linear.SparseFieldMatrixTest#testAdd, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testParameters, org.apache.commons.math.linear.RealMatrixImplTest#testCopySubMatrix, org.apache.commons.math.distribution.WeibullDistributionTest#testSetAlpha, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLaguerreDifferentials, org.apache.commons.math.complex.ComplexFieldTest#testOne, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, org.apache.commons.math.linear.RealMatrixImplTest#testSetRowVector, org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedConsistency, org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testTrivial, org.apache.commons.math.linear.BigMatrixImplTest#testTrace, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSuffix, org.apache.commons.math.linear.FieldMatrixImplTest#testGetEntry, org.apache.commons.math.linear.SparseRealMatrixTest#testExamples, org.apache.commons.math.distribution.NormalDistributionTest#testDensity, org.apache.commons.math.geometry.Vector3DTest#testNormInf, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSerial, org.apache.commons.math.random.MersenneTwisterTest#testMakotoNishimura, org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantSolvable, org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowMatrix, org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply, org.apache.commons.math.complex.ComplexTest#testLogNaN, org.apache.commons.math.distribution.ZipfDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative, org.apache.commons.math.transform.FastHadamardTransformerTest#testNoIntInverse, org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterEmpty, org.apache.commons.math.random.EmpiricalDistributionTest#testBinIndexOverflow, org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor, org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaFValue, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testSwissFertility, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBackward, org.apache.commons.math.util.MathUtilsTest#testFactorial, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterIllegalState, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testStats, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLegendreDifferentials, org.apache.commons.math.linear.SparseFieldVectorTest#testMisc, org.apache.commons.math.linear.BlockRealMatrixTest#testGetEntry, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopyConsistency, org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentSizes, org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMin, org.apache.commons.math.random.RandomDataTest#testNextUniformExclusiveEndpoints, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.optimization.general.MinpackTest#testMinpackJennrichSampson, org.apache.commons.math.distribution.ChiSquareDistributionTest#testSampling, org.apache.commons.math.distribution.PascalDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateTwoSegment, org.apache.commons.math.linear.RealMatrixImplTest#testSetColumn, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedConsistency, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testBoundParameters, org.apache.commons.math.linear.RealMatrixImplTest#testGetVectors, org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTwoSets, org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilitySpecial, org.apache.commons.math.estimation.MinpackTest#testMinpackFreudensteinRoth, org.apache.commons.math.MathExceptionTest#testConstructor, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEqualsAndHashCode, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateResiduals, org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.random.RandomDataTest#testNextLong, org.apache.commons.math.util.MathUtilsTest#testIndicatorByte, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testAEqualLLT, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testIncrementation, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testKepler, org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollision2, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testDimensionCheck, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testDeprecated, org.apache.commons.math.geometry.RotationTest#testComposeInverse, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testMinStep, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWithExpectedSize, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNan, org.apache.commons.math.estimation.MinpackTest#testMinpackBrownDennis, org.apache.commons.math.linear.LUSolverTest#testSingular, org.apache.commons.math.stat.descriptive.InteractionTest#testInteraction, org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testBasicStats, org.apache.commons.math.stat.descriptive.summary.SumTest#testEvaluation, org.apache.commons.math.util.MathUtilsTest#testAddAndCheckLong, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopy, org.apache.commons.math.analysis.solvers.MullerSolverTest#testParameters, org.apache.commons.math.random.RandomDataTest#testNextSecureHex, org.apache.commons.math.random.RandomAdaptorTest#testNextHex, org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatNumber, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testToString, org.apache.commons.math.MathConfigurationExceptionTest#testConstructor, org.apache.commons.math.util.BigRealFieldTest#testZero, org.apache.commons.math.linear.QRDecompositionImplTest#testMatricesValues, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.rank.MaxTest#testWeightedConsistency, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeBoth, org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply2, org.apache.commons.math.fraction.BigFractionTest#testMultiply, org.apache.commons.math.util.ResizableDoubleArrayTest#testDiscard, org.apache.commons.math.util.ResizableDoubleArrayTest#testAdd1000, org.apache.commons.math.distribution.TDistributionTest#testSmallDf, org.apache.commons.math.distribution.HypergeometricDistributionTest#testFloatingPointArguments, org.apache.commons.math.linear.RealMatrixImplTest#testWalk, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniformExclusiveEndpoints, org.apache.commons.math.special.GammaTest#testRegularizedGammaZeroPositive, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testWeightedConsistency, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSkewAndKurtosis, org.apache.commons.math.MathExceptionTest#testConstructorPatternArguments, org.apache.commons.math.util.TransformerMapTest#testSerial, org.apache.commons.math.linear.RealMatrixImplTest#testCopyFunctions, org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnFieldMatrix, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.fraction.FractionTest#testIntegerOverflow, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testConsistency, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testPopulation, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers, org.apache.commons.math.distribution.BinomialDistributionTest#testFloatingPointArguments, org.apache.commons.math.linear.SparseRealMatrixTest#testDimensions, org.apache.commons.math.complex.ComplexTest#testSinInf, org.apache.commons.math.special.GammaTest#testRegularizedGammaNanPositive, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParsePositiveInfinity, org.apache.commons.math.linear.RealVectorFormatTest#testForgottenPrefix, org.apache.commons.math.complex.ComplexFormatTest#testNegativeReal, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testFunctionEvaluationExceptions, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketEndpointRoot, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNoDependency, org.apache.commons.math.complex.ComplexFormatTest#testParseNan, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerialization, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testPositiveInfinity, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWith0ExpectedSize, org.apache.commons.math.stat.descriptive.rank.MedianTest#testEvaluation, org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArgumentsCause, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentEquations, org.apache.commons.math.util.TransformerMapTest#testContainsTransformer, org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues5, org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues3, org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestPositive, org.apache.commons.math.linear.SparseRealMatrixTest#testOperate, org.apache.commons.math.linear.FieldMatrixImplTest#testGetSubMatrix, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testControlParameters, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeInfinity, org.apache.commons.math.complex.ComplexTest#testAsin, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeInfinity, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowVectorLarge, org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalidDenominator, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, org.apache.commons.math.util.ResizableDoubleArrayTest#testSetElementArbitraryExpansion, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testLinear, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testWeightedConsistency, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testHat, org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_NAN_Inf, org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveZero, org.apache.commons.math.linear.FieldMatrixImplTest#testTranspose, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsAndInfs, org.apache.commons.math.geometry.RotationTest#testAxisAngle, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetRelativeAccuracy, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstHermitePolynomials, org.apache.commons.math.stat.inference.TTestFactoryTest#testPaired, org.apache.commons.math.geometry.RotationTest#testRevert, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerial, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFitting, org.apache.commons.math.optimization.linear.SimplexSolverTest#testLargeModel, org.apache.commons.math.geometry.Vector3DTest#testVectorialProducts, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerial, org.apache.commons.math.genetics.OnePointCrossoverTest#testCrossover, org.apache.commons.math.util.OpenIntToFieldTest#testRemove, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMath283, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowMatrixLarge, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#exceedMaxEvaluations, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing1, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testConditionNumber, org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testParameters, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing2, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testStaticFormatVector3D, org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureInt, org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnVector, org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations#test, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testRedundantEquations, org.apache.commons.math.linear.LUSolverTest#testSolveSingularityErrors, org.apache.commons.math.analysis.solvers.NewtonSolverTest#testDeprecated, org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testLinearFunction, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonBadCounts, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testPercentileSetter, org.apache.commons.math.util.MathUtilsTest#testCoshNaN, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseDifferentImaginaryChar, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testPositiveInfinity, org.apache.commons.math.complex.ComplexTest#testPowNaNExponent, org.apache.commons.math.stat.StatUtilsTest#testSumLog, org.apache.commons.math.complex.ComplexFormatTest#testDifferentImaginaryChar, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testBackward, org.apache.commons.math.linear.BlockFieldMatrixTest#testMath209, org.apache.commons.math.transform.FastSineTransformerTest#testParameters, org.apache.commons.math.util.DefaultTransformerTest#testTransformNull, org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testNoOptimum, org.apache.commons.math.linear.BigMatrixImplTest#testAdd, org.apache.commons.math.complex.ComplexTest#testPowZero, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testOneSet, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsFixedTiesRandom, org.apache.commons.math.fraction.BigFractionFormatTest#testParseProper, org.apache.commons.math.optimization.linear.SimplexSolverTest#testSingleVariableAndConstraint, org.apache.commons.math.geometry.Vector3DTest#testDistance1, org.apache.commons.math.linear.RealMatrixImplTest#testFrobeniusNorm, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNegativePositive, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareZeroCount, org.apache.commons.math.linear.RealMatrixImplTest#testPremultiplyVector, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationAtBounds, org.apache.commons.math.stat.descriptive.rank.MinTest#testCopy, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeY, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeZ, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNan, org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSerial, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeX, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromEmpty, org.apache.commons.math.optimization.general.MinpackTest#testMinpackMeyer, org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleTTest, org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimals, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNonInversible, org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.fraction.FractionTest#testFloatValue, org.apache.commons.math.complex.ComplexTest#testDivide, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetAbsent, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testOneSet, org.apache.commons.math.random.MersenneTwisterTest#testNextIntN, org.apache.commons.math.complex.ComplexTest#testSubtract, org.apache.commons.math.linear.LUDecompositionImplTest#testPPermutation, org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoFailures, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRow, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testKepler, org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testUnsorted, org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest#testCircleFitting, org.apache.commons.math.fraction.FractionTest#testMultiply, org.apache.commons.math.estimation.WeightedMeasurementTest#testIgnored, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopyConsistency, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiply, org.apache.commons.math.fraction.BigFractionTest#testFloatValue, org.apache.commons.math.distribution.FDistributionTest#testSmallDegreesOfFreedom, org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testExpm1Function, org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopyConsistency, org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function2, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimals, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testIncreasingTolerance, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testMinStep, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testKepler, org.apache.commons.math.complex.ComplexTest#testAtan, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testIncrementation, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuadraticFunction, org.apache.commons.math.distribution.TDistributionTest#testDfAccessors, org.apache.commons.math.distribution.CauchyDistributionTest#testConsistency, org.apache.commons.math.special.BetaTest#testLogBetaPositivePositive, org.apache.commons.math.util.OpenIntToFieldTest#testPutOnExisting, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testProductAndGeometricMean, org.apache.commons.math.estimation.MinpackTest#testMinpackBard, org.apache.commons.math.random.MersenneTwisterTest#testNextLong, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLTTransposed, org.apache.commons.math.linear.TriDiagonalTransformerTest#testNoAccessBelowDiagonal, org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRank, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testAEqualUSVt, org.apache.commons.math.stat.descriptive.moment.MeanTest#testConsistency, org.apache.commons.math.stat.descriptive.rank.MinTest#testSerial, org.apache.commons.math.transform.FastFourierTransformerTest#test2DData, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateThreeSegment, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextInt, org.apache.commons.math.linear.SparseRealMatrixTest#testEqualsAndHashCode, org.apache.commons.math.linear.RealMatrixImplTest#testSerial, org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testSkewAndKurtosis, org.apache.commons.math.stat.StatUtilsTest#testMean, org.apache.commons.math.linear.SingularValueSolverTest#testConditionNumber, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopy, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFittingBadInit, org.apache.commons.math.fraction.FractionFormatTest#testParseNegative, org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerial, org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiplyVector, org.apache.commons.math.util.ResizableDoubleArrayTest#testMutators, org.apache.commons.math.linear.SparseFieldMatrixTest#testEqualsAndHashCode, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRow, org.apache.commons.math.util.ContinuedFractionTest#testGoldenRatio, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testEvents, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testParameters, org.apache.commons.math.stat.StatUtilsTest#testDifferenceStats, org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testInitialGuess, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testSmallStep, org.apache.commons.math.complex.ComplexTest#testSin, org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateFullSample, org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHomoscedastic, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMath199, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextExponential, org.apache.commons.math.linear.RealMatrixImplTest#testExamples, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerialization, org.apache.commons.math.complex.ComplexTest#testExpNaN, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testSmallStep, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowMatrix, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetFunctionValueAccuracy, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testAddition, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerial, org.apache.commons.math.fraction.BigFractionTest#testIntValue, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHighDegreeLegendre, org.apache.commons.math.optimization.fitting.HarmonicFitterTest#test1PercentError, org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedProduct, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEqualsAndHashCode, org.apache.commons.math.estimation.MinpackTest#testMinpackJennrichSampson, org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowVector, org.apache.commons.math.util.BigRealTest#testBigDecimalValue, org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleNoDecimals, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#serialization, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testQRColumnsPermutation, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testMomentSmallSamples, org.apache.commons.math.linear.EigenSolverTest#testInvertible, org.apache.commons.math.linear.BlockRealMatrixTest#testTranspose, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNoDenseOutput, org.apache.commons.math.distribution.BinomialDistributionTest#testIllegalArguments, org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullFile, org.apache.commons.math.util.MathUtilsTest#testPow, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnVector, org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopyConsistency, org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testN0andN1Conditions, org.apache.commons.math.distribution.ChiSquareDistributionTest#testCumulativeProbabilities, org.apache.commons.math.distribution.HypergeometricDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testSinFunction, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenPrefix, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testRemoval, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testScalarAdd, org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHomoscedastic, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNoDependency, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEvaluation, org.apache.commons.math.distribution.ExponentialDistributionTest#testDensity, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnMatrixLarge, org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexIllegalModulus, org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterNull, org.apache.commons.math.linear.RealVectorFormatTest#testParseNoComponents, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnVector, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testInsufficientData, org.apache.commons.math.estimation.MinpackTest#testMinpackWatson, org.apache.commons.math.linear.SparseRealMatrixTest#testCopyFunctions, org.apache.commons.math.geometry.RotationTest#testIdentity, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testLongly, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testColumnsPermutation, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testDimensions, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArguments, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopy, org.apache.commons.math.random.ValueServerTest#testNextDigest, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArgumentsCause, org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFine, org.apache.commons.math.random.RandomDataTest#testNextGaussian, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testIterator, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuadratic, org.apache.commons.math.distribution.GammaDistributionTest#testProbabilities, org.apache.commons.math.linear.RealMatrixImplTest#testNorm, org.apache.commons.math.stat.inference.TestUtilsTest#testPaired, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTrivial, org.apache.commons.math.MathExceptionTest#testPrintStackTrace, org.apache.commons.math.util.OpenIntToFieldTest#testConcurrentModification, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperNegative, org.apache.commons.math.complex.ComplexFormatTest#testNan, org.apache.commons.math.random.RandomDataTest#testNextPermutation, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenPrefix, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testEmptyData, org.apache.commons.math.linear.BlockFieldMatrixTest#testWalk, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testQuinticZero, org.apache.commons.math.complex.ComplexTest#testEqualsRealDifference, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultipleToEmpty, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressandVariance, org.apache.commons.math.util.MathUtilsTest#testAddAndCheck, org.apache.commons.math.special.ErfTest#testErf2576, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullYSampleData, org.apache.commons.math.stat.descriptive.summary.ProductTest#testIncrementation, org.apache.commons.math.linear.BigMatrixImplTest#testSetSubMatrix, org.apache.commons.math.geometry.Vector3DFormatTest#testNonDefaultSetting, org.apache.commons.math.distribution.CauchyDistributionTest#testMedian, org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnVector, org.apache.commons.math.linear.BigMatrixImplTest#testScalarAdd, org.apache.commons.math.util.MathUtilsTest#testCompareTo, org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply2, org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#serialization, org.apache.commons.math.random.RandomAdaptorTest#testNextLongExtremeValues, org.apache.commons.math.util.MathUtilsTest#testArrayHash, org.apache.commons.math.distribution.BinomialDistributionTest#testCumulativeProbabilities, org.apache.commons.math.distribution.WeibullDistributionTest#testBeta, org.apache.commons.math.util.MathUtilsTest#testLcm, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#dimensionCheck, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBackward, org.apache.commons.math.util.MathUtilsTest#testIndicatorFloat, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testNaN, org.apache.commons.math.linear.BlockRealMatrixTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testWeightedConsistency, org.apache.commons.math.random.EmpiricalDistributionTest#testLoad, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveZero, org.apache.commons.math.linear.SparseFieldMatrixTest#testExamples, org.apache.commons.math.complex.FrenchComplexFormatTest#testDifferentImaginaryChar, org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroReal, org.apache.commons.math.complex.ComplexTest#testTanInf, org.apache.commons.math.complex.ComplexFormatTest#testForgottenImaginaryCharacter, org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSuffix, org.apache.commons.math.complex.ComplexTest#testSerial, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetVectors, org.apache.commons.math.ode.FirstOrderConverterTest#testDoubleDimension, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexTest#testTanhInf, org.apache.commons.math.stat.FrequencyTest#testCounts, org.apache.commons.math.linear.SparseFieldVectorTest#testPredicates, org.apache.commons.math.linear.BigMatrixImplTest#testSolve, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParameters, org.apache.commons.math.geometry.Vector3DFormatTest#testConstructorSingleFormat, org.apache.commons.math.util.ResizableDoubleArrayTest#testSetNumberOfElements, org.apache.commons.math.optimization.general.MinpackTest#testMinpackKowalikOsborne, org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvectors, org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanInverseCumulativeProbability, org.apache.commons.math.linear.SparseRealMatrixTest#testAdd, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConsistency, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testMomentSmallSamples, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnMatrix, org.apache.commons.math.fraction.BigFractionFormatTest#testParse, org.apache.commons.math.fraction.BigFractionTest#testCompareTo, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopy, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerialization, org.apache.commons.math.complex.ComplexTest#testTanhNaN, org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testUnstableDerivative, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEvaluation, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testN0andN1Conditions, org.apache.commons.math.util.MathUtilsTest#testSubAndCheckErrorMessage, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopy, org.apache.commons.math.fraction.FractionTest#testAbs, org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#derivativesConsistency, org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testMinEndpoints, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEvaluation, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testIncrementation, org.apache.commons.math.stat.descriptive.rank.MinTest#testSerialization, org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative, org.apache.commons.math.util.MathUtilsTest#testEquals, org.apache.commons.math.random.EmpiricalDistributionTest#testNexFail, org.apache.commons.math.complex.ComplexFormatTest#testFormatNumber, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testHadamard, org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDecreasingSteps, org.apache.commons.math.stat.descriptive.moment.MeanTest#testSmallSamples, org.apache.commons.math.util.DefaultTransformerTest#testTransformBigDecimal, org.apache.commons.math.linear.BigMatrixImplTest#testDimensions, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterIllegalState, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testColumnsPermutation, org.apache.commons.math.optimization.direct.NelderMeadTest#testFunctionEvaluationExceptions, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumn, org.apache.commons.math.complex.FrenchComplexFormatTest#testGetRealFormat, org.apache.commons.math.complex.ComplexTest#testSqrtRealPositive, org.apache.commons.math.linear.BlockFieldMatrixTest#testToString, org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiply, org.apache.commons.math.linear.BigMatrixImplTest#testAddFail, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiplePastEmpty, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSpecialValues, org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply, org.apache.commons.math.util.MathUtilsTest#testLog, org.apache.commons.math.transform.FastFourierTransformerTest#testParameters, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testFormatObject, org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowVector, org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNan, org.apache.commons.math.util.MathUtilsTest#testSignLong, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testUnequalSizeArguments, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testWeightedConsistency, org.apache.commons.math.complex.ComplexTest#testMultiply, org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleNoDecimals, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testMomentSmallSamples, org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testBasicStats, org.apache.commons.math.random.GaussianRandomGeneratorTest#testMeanAndStandardDeviation, org.apache.commons.math.util.OpenIntToFieldTest#testRemoveFromEmpty, org.apache.commons.math.util.MathUtilsTest#testMulAndCheck, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testIncreasingTolerance, org.apache.commons.math.stat.StatUtilsTest#testGeometricMean, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEvents, org.apache.commons.math.fraction.FractionTest#testAdd, org.apache.commons.math.complex.ComplexTest#testNegate, org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSerial, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowVector, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testConsistency, org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficient, org.apache.commons.math.linear.FieldMatrixImplTest#testSetRow, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testConsistency, org.apache.commons.math.complex.ComplexTest#testSinhInf, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDimensionCheck, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testOneSet, org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction2, org.apache.commons.math.distribution.ExponentialDistributionTest#testConsistency, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeZ, org.apache.commons.math.complex.ComplexFormatTest#testZeroReal, org.apache.commons.math.linear.SparseFieldMatrixTest#testTrace, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testLLowerTriangular, org.apache.commons.math.linear.FieldMatrixImplTest#testAddFail, org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testSmallError, org.apache.commons.math.distribution.ZipfDistributionTest#testFloatingPointArguments, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopyConsistency, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeX, org.apache.commons.math.linear.BlockRealMatrixTest#testGetRow, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeY, org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPPermutation, org.apache.commons.math.stat.descriptive.summary.SumTest#testIncrementation, org.apache.commons.math.util.MathUtilsTest#testL1DistanceDouble, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testRosenbrock, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testConsistency, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#test20090720, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testLinearFunction, org.apache.commons.math.optimization.linear.SimplexSolverTest#testUnboundedSolution, org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewSecantSolverValid, org.apache.commons.math.distribution.FDistributionTest#testIllegalArguments, org.apache.commons.math.stat.StatUtilsTest#testSumSq, org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryFormatNull, org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testNoError, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testN0andN1Conditions, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testShuffledStatistics, org.apache.commons.math.complex.ComplexTest#testAcos, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveAbsent, org.apache.commons.math.ode.FirstOrderConverterTest#testDecreasingSteps, org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeReal, org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleT, org.apache.commons.math.ode.sampling.StepNormalizerTest#testBeforeEnd, org.apache.commons.math.util.DefaultTransformerTest#testSerial, org.apache.commons.math.random.RandomDataTest#testNextPoissonConsistency, org.apache.commons.math.linear.SparseRealVectorTest#testConstructors, org.apache.commons.math.util.DefaultTransformerTest#testTransformInteger, org.apache.commons.math.stat.descriptive.rank.MedianTest#testWeightedConsistency, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNoDependency, org.apache.commons.math.complex.ComplexTest#testConjugateInfiinite, org.apache.commons.math.util.OpenIntToFieldTest#testCopy, org.apache.commons.math.optimization.linear.SimplexSolverTest#testSimplexSolver, org.apache.commons.math.linear.RealVectorFormatTest#testStaticFormatRealVectorImpl, org.apache.commons.math.linear.BigMatrixImplTest#testMultiply, org.apache.commons.math.fraction.FractionFormatTest#testParseInvalidDenominator, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnVector, org.apache.commons.math.linear.SparseFieldMatrixTest#testDimensions, org.apache.commons.math.util.ResizableDoubleArrayTest#testAddElementRolling, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBigStep, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testIncrementation, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddXSampleData, org.apache.commons.math.linear.BlockRealMatrixTest#testSeveralBlocks, org.apache.commons.math.distribution.PascalDistributionTest#testDensities, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeAll, org.apache.commons.math.complex.FrenchComplexFormatTest#testPaseNegativeInfinity, org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#testDerivativesConsistency, org.apache.commons.math.linear.BlockRealMatrixTest#testToString, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArray, org.apache.commons.math.linear.RealVectorFormatTest#testNegativeX, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDimensionCheck, org.apache.commons.math.complex.ComplexTest#testTanCritical, org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnVector, org.apache.commons.math.complex.ComplexFormatTest#testSimpleNoDecimals, org.apache.commons.math.linear.RealVectorFormatTest#testNegativeZ, org.apache.commons.math.geometry.RotationTest#testApplyInverseTo, org.apache.commons.math.linear.RealVectorFormatTest#testNegativeY, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeZ, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNan, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersSimple, org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMeanAndCovariance, org.apache.commons.math.complex.ComplexTest#testExp, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testEvents, org.apache.commons.math.stat.StatUtilsTest#testMin, org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumn, org.apache.commons.math.util.OpenIntToFieldTest#testGetFromEmpty, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeX, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeY, org.apache.commons.math.stat.inference.TTestFactoryTest#testSmallSamples, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareZeroCount, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParameters, org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnVector, org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNegative, org.apache.commons.math.MathConfigurationExceptionTest#testConstructorCause, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testQuinticFunction, org.apache.commons.math.fraction.FractionTest#testConstructorDouble, org.apache.commons.math.transform.FastHadamardTransformerTest#test4Points, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSpecialValues, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEvaluation, org.apache.commons.math.util.DefaultTransformerTest#testTransformObject, org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareZeroCount, org.apache.commons.math.fraction.FractionTest#testSubtract, org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove, org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowMatrix, org.apache.commons.math.geometry.Vector3DFormatTest#testStaticFormatVector3D, org.apache.commons.math.complex.ComplexTest#testPowNaNBase, org.apache.commons.math.linear.LUDecompositionImplTest#testPAEqualLU, org.apache.commons.math.genetics.RandomKeyTest#testRandomPermutation, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAddFail, org.apache.commons.math.linear.SparseRealVectorTest#testSerial, org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfectNegative, org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilities, org.apache.commons.math.complex.ComplexTest#testDivideZero, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwiss, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testBackward, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testFormatObject, org.apache.commons.math.genetics.ChromosomeTest#testCompareTo, org.apache.commons.math.special.GammaTest#testLogGammaNan, org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply, org.apache.commons.math.linear.FieldMatrixImplTest#testScalarAdd, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testMomentSmallSamples, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNoComponents, org.apache.commons.math.util.MathUtilsTest#testSinhNaN, org.apache.commons.math.random.RandomDataTest#testNextHex, org.apache.commons.math.analysis.solvers.BrentSolverTest#testBadEndpoints, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testWeightedConsistency, org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldIdentityMatrix, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextBoolean, org.apache.commons.math.fraction.BigFractionTest#testLongValue, org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHomoscedastic, org.apache.commons.math.distribution.HypergeometricDistributionTest#testPopulationSize, org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testSinFunction, org.apache.commons.math.random.EmpiricalDistributionTest#testGetBinUpperBounds, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquare, org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeBoth, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testCopy, org.apache.commons.math.linear.BlockRealMatrixTest#testOperate, org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopy, org.apache.commons.math.linear.FieldMatrixImplTest#testAdd, org.apache.commons.math.random.ValueServerTest#testModes, org.apache.commons.math.fraction.FractionTest#testSerial, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testfirstDerivativeComparison, org.apache.commons.math.stat.regression.SimpleRegressionTest#testNaNs, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerial, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersSimple, org.apache.commons.math.linear.RealVectorFormatTest#testParsePositiveInfinity, org.apache.commons.math.fraction.FractionTest#testLongValue, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testExpm1Function, org.apache.commons.math.random.RandomDataTest#testNextIntExtremeValues, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testInsufficientData, org.apache.commons.math.ArgumentOutsideDomainExceptionTest#testConstructor, org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.fraction.BigFractionFieldTest#testOne, org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilities, org.apache.commons.math.transform.FastHadamardTransformerTest#test3Points, org.apache.commons.math.optimization.general.MinpackTest#testMinpackHelicalValley, org.apache.commons.math.linear.SparseRealMatrixTest#testScalarAdd, org.apache.commons.math.geometry.Vector3DFormatTest#testFormatObject, org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedDelta, org.apache.commons.math.stat.data.LewTest#testCertifiedValues, org.apache.commons.math.analysis.solvers.NewtonSolverTest#testQuinticZero, org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testPowell, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingBandwidthIncreasesSmoothness, org.apache.commons.math.linear.FieldMatrixImplTest#testTrace, org.apache.commons.math.fraction.FractionFormatTest#testDenominatorFormat, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal3, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal4, org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxEvaluations, org.apache.commons.math.linear.RealVectorFormatTest#testConstructorSingleFormat, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal5, org.apache.commons.math.linear.SparseRealMatrixTest#testGetEntry, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal6, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testStdErrorConsistency, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal1, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal2, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNonDefaultSetting, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnMatrix, org.apache.commons.math.stat.CertifiedDataTest#testDescriptiveStatistics, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testSmallStep, org.apache.commons.math.linear.QRSolverTest#testUnderdetermined, org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testExactIntegration, org.apache.commons.math.linear.SparseFieldMatrixTest#testSetSubMatrix, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerialization, org.apache.commons.math.distribution.ZipfDistributionTest#testDensities, org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1, org.apache.commons.math.linear.SingularValueSolverTest#testSolve, org.apache.commons.math.fraction.FractionTest#testGoldenRatio, org.apache.commons.math.linear.BiDiagonalTransformerTest#testAEqualUSVt, org.apache.commons.math.random.EmpiricalDistributionTest#testSerialization, org.apache.commons.math.stat.descriptive.moment.MeanTest#testMomentSmallSamples, org.apache.commons.math.complex.ComplexFieldTest#testSerial, org.apache.commons.math.random.EmpiricalDistributionTest#testDoubleLoad, org.apache.commons.math.util.MathUtilsTest#testLInfDistanceDouble, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testConstructorSingleFormat, org.apache.commons.math.optimization.general.MinpackTest#testMinpackBard, org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testSinFunction, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSubtraction, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeAll, org.apache.commons.math.special.ErfTest#testErf0, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayArgumentCause, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testBackward, org.apache.commons.math.fraction.FractionTest#testNegate, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSubMatrix, org.apache.commons.math.estimation.MinpackTest#testMinpackChebyquad, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowMatrixLarge, org.apache.commons.math.linear.BlockFieldMatrixTest#testOperate, org.apache.commons.math.random.ValueServerTest#testEmptyReplayFile], jUnit5Tests=[], jacocoIncludes=[org.apache.commons.*], jacocoExcludes=[java.*], family=SPECTRUM_BASED, spectrumFormula=OP2, computeSpoonResults=false}
Computing tests from config.
Running TestContext{testMethods=[[Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL2DistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testOverdetermined, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolveSingularityErrors, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testCompose, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowFieldMatrix, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithSplit, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeReal, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testCorr, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNextAfterSpecialCases, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testPerfectFit, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testConfig, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiplyNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheckLong, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSampling, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSanityChecks, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testReplay, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignInt, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnLarge, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#checkClone, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewNewtonSolverValid, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgumentNaN, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAdd, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveZero, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTan, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testIsSingular, [Manual]TestMethod=org.apache.commons.math.MaxIterationsExceededExceptionTest#testSimpleConstructor, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateSin, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonEqualCounts, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaNanPositive, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSimplistic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testPermutedArrayHash, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowLarge, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNorm, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosNaN, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataThatIsNotSquare, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testIsSame, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotSymmetricMatrixException, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.CertifiedDataTest#testSummaryStatistics, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonUnEqualCounts, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsErrors, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearFullRank, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideInfinite, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDoubleConstructor, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyMutationTest#testMutate, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testEpsilon, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testTheory, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSubtractNaN, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealZero, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproperNegative, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveBadParameters, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testGetImaginaryFormat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSetQuantile, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryNegative, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testAddNonComparable, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinhNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testWindowSize, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvalues, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate1, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testGetSummary, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate0, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowLarge, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetFromEmpty, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaNegativePositivePositive, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testTridiagonal, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testAngles, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSolutionWithNegativeDecisionVariable, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testMultiplication, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLaguerrePolynomials, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testRandomAccess, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testIdentityPermutation, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testCovarianceConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.BetaDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseBig, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testSanityChecks, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolveRankErrors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistanceSq, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testMathpbx02, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHermiteDifferentials, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testGetMean, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testComparatorPermutation, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIntegratorControls, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testSSENonNegative, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension1, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testTrivialModel, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#testDerivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension3, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProperInvalidMinus, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne2, [Manual]TestMethod=org.apache.commons.math.genetics.GeneticAlgorithmTestBinary#test, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhCritical, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateDegenerate, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne1, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetFunctionValueAccuracy, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaPositive, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testProduct, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosInf, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownAlmostLinear, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBrownAlmostLinear, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testInvalidConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNormalize, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction2, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testEqualRepr, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testStaticFormatComplex, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testConstant, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaTest, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutOnExisting, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseZeroReal, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngular, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacity, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketSin, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testGcd, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testValues, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeBoth, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.genetics.FitnessCachingTest#testFitnessCaching, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoSuccesses, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.distribution.BetaDistributionTest#testCumulative, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290LEQ, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetMatrixLarge, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testLargeValues, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#backward, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testQuinticMin, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate1, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaNegativePositive, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate0, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testScale, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheck, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testNegate, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExpInf, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testNorris, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroImaginary, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testDecode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackChebyquad, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigMatrix, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConstant, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBadParameters, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.genetics.FixedGenerationCountTest#testIsSatisfied, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGet, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveZeroPositive, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstChebyshevPolynomials, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMinimizeMaximize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testNaN, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testGetAbsent, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testTransformers, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testIterator, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testConstants, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_fourthRoot, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testDigammaSmallArgs, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testInference, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#test5, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testClear, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaZeroPositivePositive, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testInfeasibleSolution, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextIntNeg, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsTrue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsNull, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArgumentCause, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiply, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromSingle, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testClear, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtPolar, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testFill, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatZero, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testSmallDf, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL1DistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testMath280, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDistinctEigenvalues, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testDoubleFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMath226, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.genetics.ElitisticListPopulationTest#testNextGeneration, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexNaN, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#checklone, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackHelicalValley, [Manual]TestMethod=org.apache.commons.math.genetics.ListPopulationTest#testGetFittestChromosome, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testLongly, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLInfDistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testUOrthogonal, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowRealMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseManyComponents, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositivePositive, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testPutTransformer, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testDegeneracy, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testDimension, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testDropPhase1Objective, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testWholeFormat, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNormalizeAngle, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbsNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaZero, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testPercentile, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testLongly, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testErrorConditions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testZeroImaginary, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInteger, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNexBytes, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2Complex, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testPercentileSetter, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMath221, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrt1z, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnDistortedSine, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testQuaternion, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testHTrapezoidal, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNoRoot, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testQOrthogonal, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testMismatch, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatZero, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSetBeta, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.stat.data.LotteryTest#testCertifiedValues, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testFixedState, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testGetReducedFraction, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testSmallLastStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testContainsClass, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSeveralBlocks, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFat, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetAbsoluteAccuracy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMinimization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#test0Choose0, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformString, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testSetMean, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testRepeatedEigenvalue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.genetics.ChromosomeTest#testFindSameChromosome, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperatePremultiplyLarge, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressandVariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevDifferentials, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsNoConvergence, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testAlpha, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedUlps, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetRelativeAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracySin, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testEmptyDigestFile, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDivide, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseZeroImaginary, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNullIntervalCheck, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testTrigamma, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideReal, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove2, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalid, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testQuantiles, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testDigammaLargeArgs, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRandom, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testRemoval, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetMaximalIterationCount, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideNaN, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnTwoPoints, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testNoError, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProper, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testScalarProduct, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testVectorOnePair, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testQOrthogonal, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveNan, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveNegative, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testWrongDerivative, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testNormalApproximateProbability, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMaximalTiesMinimum, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationInside, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNegateNaN, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testDenominatorFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinNaN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiplyInf, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testParaboloid2D, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentSizes, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testConstructor2, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testConstructor1, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogZero, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testMinMax, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testUUpperTriangular, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearFullRank, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testCopy, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfect, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseManyComponents, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParse, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testNorm, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDigitLimitConstructor, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testBigFractionConverter, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#test20090720, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testLinearFunction2D, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGet, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMath199, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testStats, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testContainsKey, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetRealFormatNull, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantUnsolvable, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonBadCounts, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#backward, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperateLarge, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBox3Dimensional, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperateLarge, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistanceInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnOnePoint, [Manual]TestMethod=org.apache.commons.math.ode.sampling.StepNormalizerTest#testBoundaries, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngularSeparation, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testInverse, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformDouble, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCosh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testTableauWithNoArtificialVars, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testScalb, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testRandomConstructor, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testEstimate, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackPowellSingular, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testContainsKey, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testUUpperTriangular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_thirdRoot, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath272, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeReal, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMinimizeMaximize, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnStraightLine, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinh, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testArrayIndexConditions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testNaN, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testConstruction, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testGetSummary, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNormalizeArray, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath288, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDiagonal, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath286, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testInitialGuess, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnRealMatrix, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignByte, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testBoundaries, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testPaseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath293, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWith0ExpectedSize, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf3291, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testHashCode, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testMath308, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAddNaN, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne2, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testDistance, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testRUpperTriangular, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne1, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperatePremultiplyLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugateNaN, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreRows, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCos, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaNanPositivePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuintic, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#checklone, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testSinMin, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testConfig, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedVariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsinInf, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNISTExample, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtanNaN, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbability2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcosInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testInsufficientBandwidth, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterEmpty, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideImaginary, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testMoreLargeValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedMean, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testArrayEquals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownDennis, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesMaximum, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testOrthogonal, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistance, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testSetScale, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testEmptyTable, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaZeroPositive, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatNegative, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientLarge, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testWindowSize, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesAverage, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testWholeFormat, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testVariance, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testRemoveTransformer, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testUpperOrLower, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testDouble, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.MaxIterationsExceededExceptionTest#testComplexConstructor, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testPcts, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngle, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testGaussian, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction2, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBrentSolverValid, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testLongFormat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testLUDecomposition, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testProperties, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNorm1, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtanInf, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf2807, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testArrayIsReference, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testConfig, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNexBoolean, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testClasses, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testCovarianceConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrt1zNaN, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignShort, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSerial, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf1960, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testHash, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testReciprocal, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgumentInf, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest#dimension2, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testIntegerValues, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testConstruction, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryMutationTest#testMutate, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testIntValue, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemoveAbsent, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcosNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerial, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAddInfinite, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testDimension, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testLargeDegreesOfFreedom, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLog, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiplyNaN, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRealMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testIsSame, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackKowalikOsborne, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedSum, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testNoReset, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testBigDecimalValue, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRootMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevBounds, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testMulAndCheckLong, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConstant, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacityAndExpansionFactor, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNullEmpty, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsSame, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testNext, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testRoundDouble, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withWeights, [Manual]TestMethod=org.apache.commons.math.DuplicateSampleAbscissaExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiplyNaNInf, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNull, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinear, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerial, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testGetRealFormat, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testNullIntervalCheck, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testPercentile, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateSpecialValues, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseNegative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testToString, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullURL, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonUnEqualCounts, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290GEQ, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testEpsilonLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregationConsistency, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnVectorLarge, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testRoundFloat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientFail, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testSetStandardDeviation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogInf, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSubstitute, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregate, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackPowellSingular, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCoshNaN, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testSinMin, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testCentroid, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.InvalidMatrixExceptionTest#testConstructorMessage, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBisectionSolverValid, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testAEqualQR, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testNumeratorFormat, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnMatrixLarge, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetRealFormatNull, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaNegative, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withoutWeights, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLegendrePolynomials, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testReciprocal, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowVectorLarge, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.random.UniformRandomGeneratorTest#testMeanAndStandardDeviation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testMismatch, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testCopy, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testBound, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test8Points, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testDefault, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddNullYSampleData, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAbsentOnExisting, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testControlParameters, [Manual]TestMethod=org.apache.commons.math.genetics.TournamentSelectionTest#testSelect, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testPopulation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregation, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testForgottenImaginaryCharacter, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormat, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testRootEndpoints, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackWatson, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDoubleConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryFormatNull, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#polynomial, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testModelWithNoArtificialVars, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testSingular, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsImaginaryDifference, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackFreudensteinRoth, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDivide, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveSingle, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbs, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testAdaptor, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares3, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testMeanAccessors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgument, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares1, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares2, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullDoubleArray, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBox3Dimensional, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideNaNInf, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testExamples, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithoutSplit, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtNaN, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testGetStandardDeviation, [Manual]TestMethod=org.apache.commons.math.linear.MatrixIndexExceptionTest#testConstructorMessage, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testConstructorDouble, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsRemovedTiesSequential, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testNumeratorFormat, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAbsentOnExisting, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsClass, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollision2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCoshInf, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreColumns, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiple, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetAbsoluteAccuracy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSingleton, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testLongFormat, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#notEnoughData, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilityAgaintStackOverflow, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneWayAnovaUtils, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testPowell, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL2DistanceDouble, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testLongly, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testHighPercentile, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveSin, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNextAfter, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testSingular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonEqualCounts, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveFromEmpty, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testCoordinates, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollisions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsinNaN, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorDouble, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateResiduals, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testNaN, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testFractionConverter, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPAEqualLU, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testMean, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testCopy, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaNegativePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#checkClone, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtInf, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbsInfinite, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataWithSampleSizeMismatch, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#exceedMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testStdErrorConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproper, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWithExpectedSize, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testFloat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_realPartZero, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsNaN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryZero, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextFloat, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testPaired, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testImpossibleSerialization, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroImaginary, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testParameterAccessors, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testNextDigestFail, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperInvalidMinus, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeBoth, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMax, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testRestrictVariablesToNonNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testInitialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testNonInvertible, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveXY, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testModelsMerging, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testToString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowInf, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testValues, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#noReset, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth1, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterNull, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMax, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemove2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealNegative, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testUOrthogonal, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testBBiDiagonal, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testpowNull, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetMatrixLarge, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testDegenerateInverseCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#polynomial, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testGetReducedFraction, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInteger, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testStaticFormatRealVectorImpl, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackMeyer, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSerial, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNanPositive, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetMaximalIterationCount, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testTTriDiagonal, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracyNull, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConstructorNaN, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositivePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest#testMeanAndCorrelation, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testConcurrentModification, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackRosenbrok, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignFloat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignDouble, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInvalid, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testVectorTwoPairs, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testExtremeValues, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testThreshold, [Manual]TestMethod=org.apache.commons.math.geometry.RotationOrderTest#testName, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorShort, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollisions, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testStaticFormatComplex, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testAEqualQTQt, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSinh, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testGetImaginaryFormat, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanNaN, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testInducedPermutation, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnVectorLarge, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaPValue, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#dimensionCheck, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackRosenbrok, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroReal, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testZeroDivide, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testRank, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddXSampleData, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testAEqualVDVt, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testSingularities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullCovarianceData, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testDoubleFormat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testFactorialFail, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testQTOrthogonal, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSimplistic, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testAbs, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSetAlpha, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLaguerreDifferentials, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNormInf, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testMakotoNishimura, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantSolvable, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogNaN, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#testNoIntInverse, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterEmpty, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testBinIndexOverflow, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaFValue, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testFactorial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLegendreDifferentials, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentSizes, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMin, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackJennrichSampson, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testSampling, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateTwoSegment, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testBoundParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilitySpecial, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackFreudensteinRoth, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateResiduals, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorByte, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testAEqualLLT, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollision2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testComposeInverse, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWithExpectedSize, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBrownDennis, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSingular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.InteractionTest#testInteraction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testBasicStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testAddAndCheckLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatNumber, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeBoth, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testDiscard, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testAdd1000, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testSmallDf, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testWalk, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaZeroPositive, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSkewAndKurtosis, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnFieldMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testIntegerOverflow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testPopulation, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinInf, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaNanPositive, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeReal, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testFunctionEvaluationExceptions, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketEndpointRoot, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWith0ExpectedSize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testContainsTransformer, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues5, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues3, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestPositive, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testControlParameters, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsin, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowVectorLarge, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalidDenominator, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSetElementArbitraryExpansion, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testLinear, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testHat, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_NAN_Inf, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveZero, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsAndInfs, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testAxisAngle, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetRelativeAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstHermitePolynomials, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testPaired, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testRevert, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerial, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testLargeModel, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testVectorialProducts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.genetics.OnePointCrossoverTest#testCrossover, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemove, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMath283, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowMatrixLarge, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#exceedMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing1, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testConditionNumber, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testParameters, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing2, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testStaticFormatVector3D, [Manual]TestMethod=org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations#test, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolveSingularityErrors, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonBadCounts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testPercentileSetter, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCoshNaN, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowNaNExponent, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testSumLog, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformNull, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testNoOptimum, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowZero, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsFixedTiesRandom, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProper, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSingleVariableAndConstraint, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistance1, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNegativePositive, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationAtBounds, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testCopy, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromEmpty, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackMeyer, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testFloatValue, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivide, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetAbsent, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextIntN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testPPermutation, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoFailures, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testUnsorted, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testIgnored, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testFloatValue, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testSmallDegreesOfFreedom, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositivePositive, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutOnExisting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBard, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLTTransposed, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testNoAccessBelowDiagonal, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRank, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testAEqualUSVt, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSerial, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#test2DData, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateThreeSegment, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testSkewAndKurtosis, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMean, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testConditionNumber, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopy, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testMutators, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.util.ContinuedFractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testDifferenceStats, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testInitialGuess, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSin, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateFullSample, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMath199, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testExamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExpNaN, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetFunctionValueAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testAddition, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testIntValue, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHighDegreeLegendre, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#test1PercentError, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedProduct, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackJennrichSampson, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testBigDecimalValue, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testInvertible, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNoDenseOutput, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullFile, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testRemoval, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnMatrixLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexIllegalModulus, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterNull, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNoComponents, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackWatson, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testIdentity, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testLongly, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopy, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testNextDigest, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFine, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testIterator, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuadratic, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testNorm, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testPaired, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testPrintStackTrace, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testConcurrentModification, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperNegative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testEmptyData, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsRealDifference, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultipleToEmpty, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressandVariance, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testAddAndCheck, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf2576, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullYSampleData, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testMedian, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testArrayHash, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testBeta, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLcm, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#dimensionCheck, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorFloat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testNaN, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoad, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveZero, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroReal, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanInf, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testForgottenImaginaryCharacter, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testDoubleDimension, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhInf, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testCounts, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSolve, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParameters, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSetNumberOfElements, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackKowalikOsborne, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvectors, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanInverseCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParse, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhNaN, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheckErrorMessage, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopy, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testAbs, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testMinEndpoints, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEquals, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testNexFail, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testFormatNumber, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testHadamard, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformBigDecimal, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testFunctionEvaluationExceptions, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testGetRealFormat, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealPositive, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiplePastEmpty, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLog, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNan, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignLong, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testUnequalSizeArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testBasicStats, [Manual]TestMethod=org.apache.commons.math.random.GaussianRandomGeneratorTest#testMeanAndStandardDeviation, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemoveFromEmpty, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testMulAndCheck, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testGeometricMean, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNegate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficient, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinhInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction2, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testZeroReal, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testSmallError, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL1DistanceDouble, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#test20090720, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testUnboundedSolution, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewSecantSolverValid, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testSumSq, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryFormatNull, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testNoError, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcos, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveAbsent, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeReal, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.ode.sampling.StepNormalizerTest#testBeforeEnd, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformInteger, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugateInfiinite, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testCopy, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSimplexSolver, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testStaticFormatRealVectorImpl, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInvalidDenominator, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testAddElementRolling, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddXSampleData, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSeveralBlocks, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testPaseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#testDerivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArray, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanCritical, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testApplyInverseTo, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNan, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMeanAndCovariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExp, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMin, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testGetFromEmpty, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParameters, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNegative, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testConstructorDouble, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test4Points, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformObject, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testStaticFormatVector3D, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowNaNBase, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testPAEqualLU, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testRandomPermutation, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfectNegative, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideZero, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwiss, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.genetics.ChromosomeTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaNan, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNoComponents, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSinhNaN, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testBadEndpoints, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextBoolean, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testLongValue, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testPopulationSize, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGetBinUpperBounds, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeBoth, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testModes, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testfirstDerivativeComparison, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testLongValue, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.ArgumentOutsideDomainExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test3Points, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackHelicalValley, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedDelta, [Manual]TestMethod=org.apache.commons.math.stat.data.LewTest#testCertifiedValues, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testPowell, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingBandwidthIncreasesSmoothness, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testDenominatorFormat, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal3, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal4, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal5, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal6, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testStdErrorConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal1, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal2, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.CertifiedDataTest#testDescriptiveStatistics, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testUnderdetermined, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testExactIntegration, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testAEqualUSVt, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testDoubleLoad, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLInfDistanceDouble, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBard, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSubtraction, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf0, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayArgumentCause, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testNegate, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackChebyquad, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowMatrixLarge, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testEmptyReplayFile], testFrameworkStrategy=fr.spoonlabs.flacoco.core.coverage.framework.JUnit4Strategy@2c1b9e4b}
Running TestContext{testMethods=[[Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL2DistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testOverdetermined, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolveSingularityErrors, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testCompose, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowFieldMatrix, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithSplit, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeReal, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testCorr, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNextAfterSpecialCases, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testPerfectFit, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testConfig, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiplyNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheckLong, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSampling, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSanityChecks, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testReplay, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignInt, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnLarge, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#checkClone, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewNewtonSolverValid, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgumentNaN, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAdd, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveZero, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTan, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testIsSingular, [Manual]TestMethod=org.apache.commons.math.MaxIterationsExceededExceptionTest#testSimpleConstructor, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateSin, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonEqualCounts, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaNanPositive, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSimplistic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testPermutedArrayHash, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowLarge, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNorm, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosNaN, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataThatIsNotSquare, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testIsSame, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotSymmetricMatrixException, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.CertifiedDataTest#testSummaryStatistics, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonUnEqualCounts, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsErrors, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearFullRank, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideInfinite, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDoubleConstructor, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyMutationTest#testMutate, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testEpsilon, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testTheory, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSubtractNaN, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealZero, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproperNegative, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveBadParameters, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testGetImaginaryFormat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSetQuantile, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryNegative, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testAddNonComparable, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinhNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testWindowSize, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvalues, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate1, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testGetSummary, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate0, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowLarge, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetFromEmpty, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaNegativePositivePositive, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testTridiagonal, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testAngles, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSolutionWithNegativeDecisionVariable, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testMultiplication, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLaguerrePolynomials, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testRandomAccess, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testIdentityPermutation, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testCovarianceConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.BetaDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseBig, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testSanityChecks, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolveRankErrors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistanceSq, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testMathpbx02, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHermiteDifferentials, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testGetMean, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testComparatorPermutation, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIntegratorControls, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testSSENonNegative, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension1, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testTrivialModel, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#testDerivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension3, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProperInvalidMinus, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne2, [Manual]TestMethod=org.apache.commons.math.genetics.GeneticAlgorithmTestBinary#test, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhCritical, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateDegenerate, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne1, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetFunctionValueAccuracy, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaPositive, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testProduct, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosInf, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownAlmostLinear, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBrownAlmostLinear, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testInvalidConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNormalize, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction2, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testEqualRepr, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testStaticFormatComplex, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testConstant, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaTest, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutOnExisting, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseZeroReal, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngular, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacity, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketSin, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testGcd, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testValues, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeBoth, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.genetics.FitnessCachingTest#testFitnessCaching, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoSuccesses, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.distribution.BetaDistributionTest#testCumulative, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290LEQ, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetMatrixLarge, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testLargeValues, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#backward, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testQuinticMin, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate1, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaNegativePositive, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate0, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testScale, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheck, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testNegate, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExpInf, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testNorris, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroImaginary, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testDecode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackChebyquad, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigMatrix, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConstant, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBadParameters, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.genetics.FixedGenerationCountTest#testIsSatisfied, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGet, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveZeroPositive, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstChebyshevPolynomials, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMinimizeMaximize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testNaN, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testGetAbsent, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testTransformers, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testIterator, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testConstants, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_fourthRoot, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testDigammaSmallArgs, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testInference, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#test5, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testClear, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaZeroPositivePositive, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testInfeasibleSolution, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextIntNeg, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsTrue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsNull, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArgumentCause, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiply, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromSingle, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testClear, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtPolar, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testFill, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatZero, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testSmallDf, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL1DistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testMath280, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDistinctEigenvalues, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testDoubleFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMath226, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.genetics.ElitisticListPopulationTest#testNextGeneration, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexNaN, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#checklone, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackHelicalValley, [Manual]TestMethod=org.apache.commons.math.genetics.ListPopulationTest#testGetFittestChromosome, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testLongly, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLInfDistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testUOrthogonal, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowRealMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseManyComponents, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositivePositive, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testPutTransformer, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testDegeneracy, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testDimension, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testDropPhase1Objective, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testWholeFormat, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNormalizeAngle, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbsNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaZero, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testPercentile, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testLongly, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testErrorConditions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testZeroImaginary, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInteger, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNexBytes, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2Complex, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testPercentileSetter, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMath221, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrt1z, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnDistortedSine, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testQuaternion, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testHTrapezoidal, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNoRoot, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testQOrthogonal, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testMismatch, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatZero, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSetBeta, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.stat.data.LotteryTest#testCertifiedValues, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testFixedState, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testGetReducedFraction, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testSmallLastStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testContainsClass, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSeveralBlocks, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFat, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetAbsoluteAccuracy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMinimization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#test0Choose0, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformString, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testSetMean, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testRepeatedEigenvalue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.genetics.ChromosomeTest#testFindSameChromosome, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperatePremultiplyLarge, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressandVariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevDifferentials, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsNoConvergence, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testAlpha, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedUlps, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetRelativeAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracySin, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testEmptyDigestFile, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDivide, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseZeroImaginary, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNullIntervalCheck, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testTrigamma, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideReal, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove2, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalid, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testQuantiles, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testDigammaLargeArgs, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRandom, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testRemoval, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetMaximalIterationCount, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideNaN, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnTwoPoints, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testNoError, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProper, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testScalarProduct, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testVectorOnePair, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testQOrthogonal, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveNan, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveNegative, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testWrongDerivative, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testNormalApproximateProbability, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMaximalTiesMinimum, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationInside, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNegateNaN, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testDenominatorFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinNaN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiplyInf, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testParaboloid2D, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentSizes, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testConstructor2, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testConstructor1, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogZero, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testMinMax, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testUUpperTriangular, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearFullRank, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testCopy, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfect, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseManyComponents, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParse, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testNorm, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDigitLimitConstructor, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testBigFractionConverter, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#test20090720, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testLinearFunction2D, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGet, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMath199, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testStats, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testContainsKey, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetRealFormatNull, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantUnsolvable, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonBadCounts, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#backward, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperateLarge, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBox3Dimensional, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperateLarge, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistanceInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnOnePoint, [Manual]TestMethod=org.apache.commons.math.ode.sampling.StepNormalizerTest#testBoundaries, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngularSeparation, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testInverse, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformDouble, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCosh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testTableauWithNoArtificialVars, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testScalb, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testRandomConstructor, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testEstimate, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackPowellSingular, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testContainsKey, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testUUpperTriangular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_thirdRoot, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath272, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeReal, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMinimizeMaximize, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnStraightLine, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinh, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testArrayIndexConditions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testNaN, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testConstruction, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testGetSummary, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNormalizeArray, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath288, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDiagonal, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath286, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testInitialGuess, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnRealMatrix, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignByte, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testBoundaries, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testPaseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath293, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWith0ExpectedSize, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf3291, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testHashCode, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testMath308, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAddNaN, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne2, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testDistance, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testRUpperTriangular, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne1, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperatePremultiplyLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugateNaN, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreRows, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCos, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaNanPositivePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuintic, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#checklone, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testSinMin, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testConfig, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedVariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsinInf, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNISTExample, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtanNaN, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbability2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcosInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testInsufficientBandwidth, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterEmpty, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideImaginary, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testMoreLargeValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedMean, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testArrayEquals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownDennis, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesMaximum, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testOrthogonal, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistance, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testSetScale, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testEmptyTable, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaZeroPositive, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatNegative, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientLarge, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testWindowSize, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesAverage, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testWholeFormat, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testVariance, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testRemoveTransformer, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testUpperOrLower, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testDouble, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.MaxIterationsExceededExceptionTest#testComplexConstructor, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testPcts, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngle, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testGaussian, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction2, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBrentSolverValid, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testLongFormat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testLUDecomposition, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testProperties, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNorm1, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtanInf, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf2807, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testArrayIsReference, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testConfig, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNexBoolean, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testClasses, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testCovarianceConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrt1zNaN, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignShort, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSerial, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf1960, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testHash, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testReciprocal, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgumentInf, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest#dimension2, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testIntegerValues, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testConstruction, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryMutationTest#testMutate, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testIntValue, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemoveAbsent, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcosNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerial, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAddInfinite, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testDimension, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testLargeDegreesOfFreedom, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLog, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiplyNaN, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRealMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testIsSame, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackKowalikOsborne, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedSum, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testNoReset, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testBigDecimalValue, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRootMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevBounds, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testMulAndCheckLong, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConstant, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacityAndExpansionFactor, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNullEmpty, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsSame, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testNext, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testRoundDouble, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withWeights, [Manual]TestMethod=org.apache.commons.math.DuplicateSampleAbscissaExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiplyNaNInf, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNull, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinear, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerial, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testGetRealFormat, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testNullIntervalCheck, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testPercentile, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateSpecialValues, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseNegative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testToString, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullURL, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonUnEqualCounts, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290GEQ, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testEpsilonLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregationConsistency, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnVectorLarge, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testRoundFloat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientFail, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testSetStandardDeviation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogInf, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSubstitute, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregate, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackPowellSingular, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCoshNaN, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testSinMin, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testCentroid, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.InvalidMatrixExceptionTest#testConstructorMessage, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBisectionSolverValid, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testAEqualQR, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testNumeratorFormat, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnMatrixLarge, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetRealFormatNull, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaNegative, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withoutWeights, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLegendrePolynomials, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testReciprocal, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowVectorLarge, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.random.UniformRandomGeneratorTest#testMeanAndStandardDeviation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testMismatch, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testCopy, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testBound, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test8Points, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testDefault, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddNullYSampleData, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAbsentOnExisting, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testControlParameters, [Manual]TestMethod=org.apache.commons.math.genetics.TournamentSelectionTest#testSelect, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testPopulation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregation, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testForgottenImaginaryCharacter, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormat, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testRootEndpoints, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackWatson, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDoubleConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryFormatNull, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#polynomial, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testModelWithNoArtificialVars, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testSingular, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsImaginaryDifference, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackFreudensteinRoth, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDivide, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveSingle, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbs, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testAdaptor, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares3, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testMeanAccessors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgument, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares1, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares2, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullDoubleArray, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBox3Dimensional, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideNaNInf, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testExamples, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithoutSplit, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtNaN, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testGetStandardDeviation, [Manual]TestMethod=org.apache.commons.math.linear.MatrixIndexExceptionTest#testConstructorMessage, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testConstructorDouble, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsRemovedTiesSequential, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testNumeratorFormat, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAbsentOnExisting, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsClass, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollision2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCoshInf, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreColumns, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiple, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetAbsoluteAccuracy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSingleton, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testLongFormat, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#notEnoughData, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilityAgaintStackOverflow, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneWayAnovaUtils, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testPowell, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL2DistanceDouble, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testLongly, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testHighPercentile, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveSin, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNextAfter, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testSingular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonEqualCounts, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveFromEmpty, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testCoordinates, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollisions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsinNaN, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorDouble, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateResiduals, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testNaN, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testFractionConverter, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPAEqualLU, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testMean, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testCopy, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaNegativePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#checkClone, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtInf, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbsInfinite, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataWithSampleSizeMismatch, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#exceedMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testStdErrorConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproper, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWithExpectedSize, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testFloat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_realPartZero, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsNaN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryZero, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextFloat, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testPaired, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testImpossibleSerialization, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroImaginary, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testParameterAccessors, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testNextDigestFail, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperInvalidMinus, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeBoth, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMax, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testRestrictVariablesToNonNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testInitialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testNonInvertible, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveXY, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testModelsMerging, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testToString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowInf, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testValues, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#noReset, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth1, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterNull, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMax, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemove2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealNegative, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testUOrthogonal, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testBBiDiagonal, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testpowNull, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetMatrixLarge, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testDegenerateInverseCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#polynomial, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testGetReducedFraction, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInteger, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testStaticFormatRealVectorImpl, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackMeyer, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSerial, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNanPositive, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetMaximalIterationCount, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testTTriDiagonal, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracyNull, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConstructorNaN, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositivePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest#testMeanAndCorrelation, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testConcurrentModification, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackRosenbrok, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignFloat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignDouble, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInvalid, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testVectorTwoPairs, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testExtremeValues, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testThreshold, [Manual]TestMethod=org.apache.commons.math.geometry.RotationOrderTest#testName, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorShort, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollisions, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testStaticFormatComplex, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testAEqualQTQt, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSinh, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testGetImaginaryFormat, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanNaN, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testInducedPermutation, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnVectorLarge, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaPValue, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#dimensionCheck, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackRosenbrok, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroReal, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testZeroDivide, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testRank, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddXSampleData, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testAEqualVDVt, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testSingularities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullCovarianceData, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testDoubleFormat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testFactorialFail, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testQTOrthogonal, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSimplistic, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testAbs, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSetAlpha, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLaguerreDifferentials, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNormInf, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testMakotoNishimura, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantSolvable, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogNaN, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#testNoIntInverse, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterEmpty, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testBinIndexOverflow, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaFValue, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testFactorial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLegendreDifferentials, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentSizes, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMin, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackJennrichSampson, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testSampling, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateTwoSegment, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testBoundParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilitySpecial, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackFreudensteinRoth, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateResiduals, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorByte, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testAEqualLLT, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollision2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testComposeInverse, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWithExpectedSize, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBrownDennis, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSingular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.InteractionTest#testInteraction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testBasicStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testAddAndCheckLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatNumber, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeBoth, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testDiscard, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testAdd1000, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testSmallDf, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testWalk, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaZeroPositive, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSkewAndKurtosis, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnFieldMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testIntegerOverflow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testPopulation, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinInf, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaNanPositive, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeReal, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testFunctionEvaluationExceptions, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketEndpointRoot, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWith0ExpectedSize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testContainsTransformer, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues5, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues3, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestPositive, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testControlParameters, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsin, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowVectorLarge, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalidDenominator, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSetElementArbitraryExpansion, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testLinear, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testHat, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_NAN_Inf, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveZero, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsAndInfs, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testAxisAngle, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetRelativeAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstHermitePolynomials, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testPaired, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testRevert, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerial, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testLargeModel, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testVectorialProducts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.genetics.OnePointCrossoverTest#testCrossover, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemove, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMath283, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowMatrixLarge, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#exceedMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing1, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testConditionNumber, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testParameters, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing2, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testStaticFormatVector3D, [Manual]TestMethod=org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations#test, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolveSingularityErrors, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonBadCounts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testPercentileSetter, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCoshNaN, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowNaNExponent, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testSumLog, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformNull, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testNoOptimum, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowZero, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsFixedTiesRandom, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProper, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSingleVariableAndConstraint, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistance1, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNegativePositive, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationAtBounds, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testCopy, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromEmpty, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackMeyer, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testFloatValue, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivide, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetAbsent, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextIntN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testPPermutation, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoFailures, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testUnsorted, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testIgnored, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testFloatValue, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testSmallDegreesOfFreedom, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositivePositive, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutOnExisting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBard, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLTTransposed, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testNoAccessBelowDiagonal, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRank, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testAEqualUSVt, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSerial, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#test2DData, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateThreeSegment, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testSkewAndKurtosis, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMean, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testConditionNumber, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopy, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testMutators, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.util.ContinuedFractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testDifferenceStats, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testInitialGuess, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSin, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateFullSample, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMath199, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testExamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExpNaN, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetFunctionValueAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testAddition, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testIntValue, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHighDegreeLegendre, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#test1PercentError, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedProduct, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackJennrichSampson, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testBigDecimalValue, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testInvertible, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNoDenseOutput, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullFile, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testRemoval, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnMatrixLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexIllegalModulus, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterNull, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNoComponents, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackWatson, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testIdentity, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testLongly, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopy, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testNextDigest, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFine, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testIterator, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuadratic, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testNorm, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testPaired, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testPrintStackTrace, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testConcurrentModification, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperNegative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testEmptyData, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsRealDifference, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultipleToEmpty, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressandVariance, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testAddAndCheck, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf2576, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullYSampleData, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testMedian, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testArrayHash, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testBeta, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLcm, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#dimensionCheck, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorFloat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testNaN, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoad, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveZero, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroReal, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanInf, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testForgottenImaginaryCharacter, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testDoubleDimension, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhInf, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testCounts, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSolve, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParameters, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSetNumberOfElements, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackKowalikOsborne, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvectors, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanInverseCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParse, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhNaN, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheckErrorMessage, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopy, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testAbs, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testMinEndpoints, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEquals, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testNexFail, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testFormatNumber, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testHadamard, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformBigDecimal, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testFunctionEvaluationExceptions, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testGetRealFormat, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealPositive, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiplePastEmpty, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLog, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNan, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignLong, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testUnequalSizeArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testBasicStats, [Manual]TestMethod=org.apache.commons.math.random.GaussianRandomGeneratorTest#testMeanAndStandardDeviation, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemoveFromEmpty, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testMulAndCheck, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testGeometricMean, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNegate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficient, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinhInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction2, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testZeroReal, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testSmallError, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL1DistanceDouble, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#test20090720, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testUnboundedSolution, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewSecantSolverValid, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testSumSq, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryFormatNull, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testNoError, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcos, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveAbsent, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeReal, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.ode.sampling.StepNormalizerTest#testBeforeEnd, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformInteger, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugateInfiinite, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testCopy, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSimplexSolver, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testStaticFormatRealVectorImpl, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInvalidDenominator, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testAddElementRolling, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddXSampleData, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSeveralBlocks, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testPaseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#testDerivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArray, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanCritical, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testApplyInverseTo, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNan, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMeanAndCovariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExp, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMin, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testGetFromEmpty, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParameters, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNegative, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testConstructorDouble, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test4Points, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformObject, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testStaticFormatVector3D, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowNaNBase, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testPAEqualLU, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testRandomPermutation, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfectNegative, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideZero, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwiss, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.genetics.ChromosomeTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaNan, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNoComponents, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSinhNaN, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testBadEndpoints, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextBoolean, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testLongValue, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testPopulationSize, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGetBinUpperBounds, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeBoth, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testModes, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testfirstDerivativeComparison, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testLongValue, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.ArgumentOutsideDomainExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test3Points, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackHelicalValley, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedDelta, [Manual]TestMethod=org.apache.commons.math.stat.data.LewTest#testCertifiedValues, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testPowell, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingBandwidthIncreasesSmoothness, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testDenominatorFormat, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal3, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal4, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal5, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal6, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testStdErrorConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal1, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal2, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.CertifiedDataTest#testDescriptiveStatistics, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testUnderdetermined, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testExactIntegration, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testAEqualUSVt, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testDoubleLoad, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLInfDistanceDouble, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBard, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSubtraction, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf0, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayArgumentCause, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testNegate, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackChebyquad, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowMatrixLarge, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testEmptyReplayFile], testFrameworkStrategy=fr.spoonlabs.flacoco.core.coverage.framework.JUnit4Strategy@2c1b9e4b}
Path to runner Classes: /Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
Tests found: 2104
Tests executed: 2104
Suspicious: 1 line org.apache.commons.math.linear.EigenDecompositionImpl l: 871, susp 1.0
Suspicious: 2 line org.apache.commons.math.linear.EigenDecompositionImpl l: 872, susp 1.0
Suspicious: 3 line org.apache.commons.math.linear.EigenDecompositionImpl l: 944, susp 1.0
Suspicious: 4 line org.apache.commons.math.linear.EigenDecompositionImpl l: 945, susp 1.0
Suspicious: 5 line org.apache.commons.math.linear.EigenDecompositionImpl l: 957, susp 1.0
Suspicious: 6 line org.apache.commons.math.linear.EigenDecompositionImpl l: 958, susp 1.0
Suspicious: 7 line org.apache.commons.math.linear.EigenDecompositionImpl l: 959, susp 1.0
Suspicious: 8 line org.apache.commons.math.linear.EigenDecompositionImpl l: 960, susp 1.0
Suspicious: 9 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1055, susp 1.0
Suspicious: 10 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1056, susp 1.0
Suspicious: 11 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1057, susp 1.0
Suspicious: 12 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1058, susp 1.0
Suspicious: 13 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1059, susp 1.0
Suspicious: 14 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1060, susp 1.0
Suspicious: 15 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1061, susp 1.0
Suspicious: 16 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1062, susp 1.0
Suspicious: 17 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1063, susp 1.0
Suspicious: 18 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1135, susp 1.0
Suspicious: 19 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1136, susp 1.0
Suspicious: 20 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1137, susp 1.0
Suspicious: 21 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1138, susp 1.0
Suspicious: 22 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1139, susp 1.0
Suspicious: 23 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1140, susp 1.0
Suspicious: 24 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1142, susp 1.0
Suspicious: 25 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1144, susp 1.0
Suspicious: 26 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1384, susp 1.0
Suspicious: 27 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1385, susp 1.0
Suspicious: 28 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1386, susp 1.0
Suspicious: 29 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1387, susp 1.0
Suspicious: 30 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1404, susp 1.0
Suspicious: 31 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1405, susp 1.0
Suspicious: 32 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1406, susp 1.0
Suspicious: 33 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1407, susp 1.0
Suspicious: 34 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1414, susp 1.0
Suspicious: 35 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1415, susp 1.0
Suspicious: 36 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1090, susp 0.9995235826584088
Suspicious: 37 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1091, susp 0.9995235826584088
Suspicious: 38 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1092, susp 0.9995235826584088
Suspicious: 39 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1093, susp 0.9995235826584088
Suspicious: 40 line org.apache.commons.math.linear.EigenDecompositionImpl l: 336, susp 0.9990471653168176
Suspicious: 41 line org.apache.commons.math.linear.EigenDecompositionImpl l: 337, susp 0.9990471653168176
Suspicious: 42 line org.apache.commons.math.linear.EigenDecompositionImpl l: 339, susp 0.9990471653168176
Suspicious: 43 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1088, susp 0.9985707479752263
Suspicious: 44 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1105, susp 0.9985707479752263
Suspicious: 45 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1106, susp 0.9985707479752263
Suspicious: 46 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1530, susp 0.9985707479752263
Suspicious: 47 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1531, susp 0.9985707479752263
Suspicious: 48 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1534, susp 0.9985707479752263
Suspicious: 49 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1535, susp 0.9985707479752263
Suspicious: 50 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1536, susp 0.9985707479752263
Suspicious: 51 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1537, susp 0.9985707479752263
Suspicious: 52 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1538, susp 0.9985707479752263
Suspicious: 53 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1541, susp 0.9985707479752263
Suspicious: 54 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1544, susp 0.9985707479752263
Suspicious: 55 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1564, susp 0.9985707479752263
Suspicious: 56 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1565, susp 0.9985707479752263
Suspicious: 57 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1570, susp 0.9985707479752263
Suspicious: 58 line org.apache.commons.math.linear.ArrayRealVector l: 225, susp 0.9976179132920439
Suspicious: 59 line org.apache.commons.math.linear.ArrayRealVector l: 870, susp 0.9976179132920439
Suspicious: 60 line org.apache.commons.math.linear.ArrayRealVector l: 175, susp 0.9971414959504526
Suspicious: 61 line org.apache.commons.math.linear.ArrayRealVector l: 176, susp 0.9971414959504526
Suspicious: 62 line org.apache.commons.math.linear.ArrayRealVector l: 177, susp 0.9971414959504526
Suspicious: 63 line org.apache.commons.math.linear.ArrayRealVector l: 900, susp 0.9971414959504526
Suspicious: 64 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1488, susp 0.9961886612672701
Suspicious: 65 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1489, susp 0.9961886612672701
Suspicious: 66 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1490, susp 0.9961886612672701
Suspicious: 67 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1491, susp 0.9961886612672701
Suspicious: 68 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1494, susp 0.9961886612672701
Suspicious: 69 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1495, susp 0.9961886612672701
Suspicious: 70 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1498, susp 0.9961886612672701
Suspicious: 71 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1499, susp 0.9961886612672701
Suspicious: 72 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1085, susp 0.9957122439256789
Suspicious: 73 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1094, susp 0.9957122439256789
Suspicious: 74 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1096, susp 0.9957122439256789
Suspicious: 75 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1099, susp 0.9957122439256789
Suspicious: 76 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1101, susp 0.9957122439256789
Suspicious: 77 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1102, susp 0.9957122439256789
Suspicious: 78 line org.apache.commons.math.linear.EigenDecompositionImpl l: 666, susp 0.9952358265840877
Suspicious: 79 line org.apache.commons.math.linear.EigenDecompositionImpl l: 667, susp 0.9952358265840877
Suspicious: 80 line org.apache.commons.math.linear.ArrayRealVector l: 905, susp 0.9952358265840877
Suspicious: 81 line org.apache.commons.math.linear.ArrayRealVector l: 906, susp 0.9952358265840877
Suspicious: 82 line org.apache.commons.math.linear.ArrayRealVector l: 907, susp 0.9952358265840877
Suspicious: 83 line org.apache.commons.math.linear.ArrayRealVector l: 909, susp 0.9952358265840877
Suspicious: 84 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1475, susp 0.9952358265840877
Suspicious: 85 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1476, susp 0.9952358265840877
Suspicious: 86 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1479, susp 0.9952358265840877
Suspicious: 87 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1503, susp 0.9952358265840877
Suspicious: 88 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1504, susp 0.9952358265840877
Suspicious: 89 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1518, susp 0.9952358265840877
Suspicious: 90 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1521, susp 0.9952358265840877
Suspicious: 91 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1522, susp 0.9952358265840877
Suspicious: 92 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1524, susp 0.9952358265840877
Suspicious: 93 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1027, susp 0.9928537398761315
Suspicious: 94 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1028, susp 0.9928537398761315
Suspicious: 95 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1029, susp 0.9928537398761315
Suspicious: 96 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1030, susp 0.9928537398761315
Suspicious: 97 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1034, susp 0.9928537398761315
Suspicious: 98 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1035, susp 0.9928537398761315
Suspicious: 99 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1036, susp 0.9928537398761315
Suspicious: 100 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1356, susp 0.9928537398761315
Suspicious: 101 line org.apache.commons.math.linear.EigenDecompositionImpl l: 191, susp 0.9923773225345403
Suspicious: 102 line org.apache.commons.math.linear.EigenDecompositionImpl l: 193, susp 0.9923773225345403
Suspicious: 103 line org.apache.commons.math.linear.EigenDecompositionImpl l: 194, susp 0.9923773225345403
Suspicious: 104 line org.apache.commons.math.linear.EigenDecompositionImpl l: 195, susp 0.9923773225345403
Suspicious: 105 line org.apache.commons.math.linear.EigenDecompositionImpl l: 198, susp 0.9923773225345403
Suspicious: 106 line org.apache.commons.math.linear.EigenDecompositionImpl l: 199, susp 0.9923773225345403
Suspicious: 107 line org.apache.commons.math.linear.EigenDecompositionImpl l: 200, susp 0.9923773225345403
Suspicious: 108 line org.apache.commons.math.linear.EigenDecompositionImpl l: 201, susp 0.9923773225345403
Suspicious: 109 line org.apache.commons.math.linear.EigenDecompositionImpl l: 204, susp 0.9923773225345403
Suspicious: 110 line org.apache.commons.math.linear.EigenDecompositionImpl l: 205, susp 0.9923773225345403
Suspicious: 111 line org.apache.commons.math.linear.EigenDecompositionImpl l: 207, susp 0.9923773225345403
Suspicious: 112 line org.apache.commons.math.linear.EigenDecompositionImpl l: 644, susp 0.9923773225345403
Suspicious: 113 line org.apache.commons.math.linear.EigenDecompositionImpl l: 645, susp 0.9923773225345403
Suspicious: 114 line org.apache.commons.math.linear.EigenDecompositionImpl l: 646, susp 0.9923773225345403
Suspicious: 115 line org.apache.commons.math.linear.EigenDecompositionImpl l: 647, susp 0.9923773225345403
Suspicious: 116 line org.apache.commons.math.linear.EigenDecompositionImpl l: 648, susp 0.9923773225345403
Suspicious: 117 line org.apache.commons.math.linear.EigenDecompositionImpl l: 649, susp 0.9923773225345403
Suspicious: 118 line org.apache.commons.math.linear.EigenDecompositionImpl l: 650, susp 0.9923773225345403
Suspicious: 119 line org.apache.commons.math.linear.EigenDecompositionImpl l: 652, susp 0.9923773225345403
Suspicious: 120 line org.apache.commons.math.linear.EigenDecompositionImpl l: 655, susp 0.9923773225345403
Suspicious: 121 line org.apache.commons.math.linear.EigenDecompositionImpl l: 658, susp 0.9923773225345403
Suspicious: 122 line org.apache.commons.math.linear.EigenDecompositionImpl l: 661, susp 0.9923773225345403
Suspicious: 123 line org.apache.commons.math.linear.EigenDecompositionImpl l: 827, susp 0.9923773225345403
Suspicious: 124 line org.apache.commons.math.linear.EigenDecompositionImpl l: 828, susp 0.9923773225345403
Suspicious: 125 line org.apache.commons.math.linear.EigenDecompositionImpl l: 829, susp 0.9923773225345403
Suspicious: 126 line org.apache.commons.math.linear.EigenDecompositionImpl l: 830, susp 0.9923773225345403
Suspicious: 127 line org.apache.commons.math.linear.EigenDecompositionImpl l: 831, susp 0.9923773225345403
Suspicious: 128 line org.apache.commons.math.linear.EigenDecompositionImpl l: 834, susp 0.9923773225345403
Suspicious: 129 line org.apache.commons.math.linear.EigenDecompositionImpl l: 840, susp 0.9923773225345403
Suspicious: 130 line org.apache.commons.math.linear.EigenDecompositionImpl l: 843, susp 0.9923773225345403
Suspicious: 131 line org.apache.commons.math.linear.EigenDecompositionImpl l: 846, susp 0.9923773225345403
Suspicious: 132 line org.apache.commons.math.linear.EigenDecompositionImpl l: 847, susp 0.9923773225345403
Suspicious: 133 line org.apache.commons.math.linear.EigenDecompositionImpl l: 848, susp 0.9923773225345403
Suspicious: 134 line org.apache.commons.math.linear.EigenDecompositionImpl l: 849, susp 0.9923773225345403
Suspicious: 135 line org.apache.commons.math.linear.EigenDecompositionImpl l: 850, susp 0.9923773225345403
Suspicious: 136 line org.apache.commons.math.linear.EigenDecompositionImpl l: 851, susp 0.9923773225345403
Suspicious: 137 line org.apache.commons.math.linear.EigenDecompositionImpl l: 852, susp 0.9923773225345403
Suspicious: 138 line org.apache.commons.math.linear.EigenDecompositionImpl l: 855, susp 0.9923773225345403
Suspicious: 139 line org.apache.commons.math.linear.EigenDecompositionImpl l: 856, susp 0.9923773225345403
Suspicious: 140 line org.apache.commons.math.linear.EigenDecompositionImpl l: 857, susp 0.9923773225345403
Suspicious: 141 line org.apache.commons.math.linear.EigenDecompositionImpl l: 860, susp 0.9923773225345403
Suspicious: 142 line org.apache.commons.math.linear.EigenDecompositionImpl l: 861, susp 0.9923773225345403
Suspicious: 143 line org.apache.commons.math.linear.EigenDecompositionImpl l: 864, susp 0.9923773225345403
Suspicious: 144 line org.apache.commons.math.linear.EigenDecompositionImpl l: 865, susp 0.9923773225345403
Suspicious: 145 line org.apache.commons.math.linear.EigenDecompositionImpl l: 866, susp 0.9923773225345403
Suspicious: 146 line org.apache.commons.math.linear.EigenDecompositionImpl l: 867, susp 0.9923773225345403
Suspicious: 147 line org.apache.commons.math.linear.EigenDecompositionImpl l: 868, susp 0.9923773225345403
Suspicious: 148 line org.apache.commons.math.linear.EigenDecompositionImpl l: 869, susp 0.9923773225345403
Suspicious: 149 line org.apache.commons.math.linear.EigenDecompositionImpl l: 870, susp 0.9923773225345403
Suspicious: 150 line org.apache.commons.math.linear.EigenDecompositionImpl l: 874, susp 0.9923773225345403
Suspicious: 151 line org.apache.commons.math.linear.EigenDecompositionImpl l: 875, susp 0.9923773225345403
Suspicious: 152 line org.apache.commons.math.linear.EigenDecompositionImpl l: 876, susp 0.9923773225345403
Suspicious: 153 line org.apache.commons.math.linear.EigenDecompositionImpl l: 878, susp 0.9923773225345403
Suspicious: 154 line org.apache.commons.math.linear.EigenDecompositionImpl l: 879, susp 0.9923773225345403
Suspicious: 155 line org.apache.commons.math.linear.EigenDecompositionImpl l: 881, susp 0.9923773225345403
Suspicious: 156 line org.apache.commons.math.linear.EigenDecompositionImpl l: 884, susp 0.9923773225345403
Suspicious: 157 line org.apache.commons.math.linear.EigenDecompositionImpl l: 886, susp 0.9923773225345403
Suspicious: 158 line org.apache.commons.math.linear.EigenDecompositionImpl l: 887, susp 0.9923773225345403
Suspicious: 159 line org.apache.commons.math.linear.EigenDecompositionImpl l: 888, susp 0.9923773225345403
Suspicious: 160 line org.apache.commons.math.linear.EigenDecompositionImpl l: 889, susp 0.9923773225345403
Suspicious: 161 line org.apache.commons.math.linear.EigenDecompositionImpl l: 894, susp 0.9923773225345403
Suspicious: 162 line org.apache.commons.math.linear.EigenDecompositionImpl l: 895, susp 0.9923773225345403
Suspicious: 163 line org.apache.commons.math.linear.EigenDecompositionImpl l: 899, susp 0.9923773225345403
Suspicious: 164 line org.apache.commons.math.linear.EigenDecompositionImpl l: 927, susp 0.9923773225345403
Suspicious: 165 line org.apache.commons.math.linear.EigenDecompositionImpl l: 929, susp 0.9923773225345403
Suspicious: 166 line org.apache.commons.math.linear.EigenDecompositionImpl l: 937, susp 0.9923773225345403
Suspicious: 167 line org.apache.commons.math.linear.EigenDecompositionImpl l: 938, susp 0.9923773225345403
Suspicious: 168 line org.apache.commons.math.linear.EigenDecompositionImpl l: 941, susp 0.9923773225345403
Suspicious: 169 line org.apache.commons.math.linear.EigenDecompositionImpl l: 942, susp 0.9923773225345403
Suspicious: 170 line org.apache.commons.math.linear.EigenDecompositionImpl l: 943, susp 0.9923773225345403
Suspicious: 171 line org.apache.commons.math.linear.EigenDecompositionImpl l: 947, susp 0.9923773225345403
Suspicious: 172 line org.apache.commons.math.linear.EigenDecompositionImpl l: 952, susp 0.9923773225345403
Suspicious: 173 line org.apache.commons.math.linear.EigenDecompositionImpl l: 953, susp 0.9923773225345403
Suspicious: 174 line org.apache.commons.math.linear.EigenDecompositionImpl l: 954, susp 0.9923773225345403
Suspicious: 175 line org.apache.commons.math.linear.EigenDecompositionImpl l: 955, susp 0.9923773225345403
Suspicious: 176 line org.apache.commons.math.linear.EigenDecompositionImpl l: 956, susp 0.9923773225345403
Suspicious: 177 line org.apache.commons.math.linear.EigenDecompositionImpl l: 961, susp 0.9923773225345403
Suspicious: 178 line org.apache.commons.math.linear.EigenDecompositionImpl l: 963, susp 0.9923773225345403
Suspicious: 179 line org.apache.commons.math.linear.EigenDecompositionImpl l: 964, susp 0.9923773225345403
Suspicious: 180 line org.apache.commons.math.linear.EigenDecompositionImpl l: 965, susp 0.9923773225345403
Suspicious: 181 line org.apache.commons.math.linear.EigenDecompositionImpl l: 966, susp 0.9923773225345403
Suspicious: 182 line org.apache.commons.math.linear.EigenDecompositionImpl l: 971, susp 0.9923773225345403
Suspicious: 183 line org.apache.commons.math.linear.EigenDecompositionImpl l: 974, susp 0.9923773225345403
Suspicious: 184 line org.apache.commons.math.linear.EigenDecompositionImpl l: 978, susp 0.9923773225345403
Suspicious: 185 line org.apache.commons.math.linear.EigenDecompositionImpl l: 993, susp 0.9923773225345403
Suspicious: 186 line org.apache.commons.math.linear.EigenDecompositionImpl l: 996, susp 0.9923773225345403
Suspicious: 187 line org.apache.commons.math.linear.EigenDecompositionImpl l: 997, susp 0.9923773225345403
Suspicious: 188 line org.apache.commons.math.linear.EigenDecompositionImpl l: 999, susp 0.9923773225345403
Suspicious: 189 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1001, susp 0.9923773225345403
Suspicious: 190 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1004, susp 0.9923773225345403
Suspicious: 191 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1006, susp 0.9923773225345403
Suspicious: 192 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1012, susp 0.9923773225345403
Suspicious: 193 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1013, susp 0.9923773225345403
Suspicious: 194 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1015, susp 0.9923773225345403
Suspicious: 195 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1020, susp 0.9923773225345403
Suspicious: 196 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1026, susp 0.9923773225345403
Suspicious: 197 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1038, susp 0.9923773225345403
Suspicious: 198 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1039, susp 0.9923773225345403
Suspicious: 199 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1040, susp 0.9923773225345403
Suspicious: 200 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1044, susp 0.9923773225345403
Suspicious: 201 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1048, susp 0.9923773225345403
Suspicious: 202 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1050, susp 0.9923773225345403
Suspicious: 203 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1053, susp 0.9923773225345403
Suspicious: 204 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1054, susp 0.9923773225345403
Suspicious: 205 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1067, susp 0.9923773225345403
Suspicious: 206 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1068, susp 0.9923773225345403
Suspicious: 207 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1069, susp 0.9923773225345403
Suspicious: 208 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1072, susp 0.9923773225345403
Suspicious: 209 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1075, susp 0.9923773225345403
Suspicious: 210 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1078, susp 0.9923773225345403
Suspicious: 211 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1081, susp 0.9923773225345403
Suspicious: 212 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1083, susp 0.9923773225345403
Suspicious: 213 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1084, susp 0.9923773225345403
Suspicious: 214 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1119, susp 0.9923773225345403
Suspicious: 215 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1121, susp 0.9923773225345403
Suspicious: 216 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1133, susp 0.9923773225345403
Suspicious: 217 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1146, susp 0.9923773225345403
Suspicious: 218 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1158, susp 0.9923773225345403
Suspicious: 219 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1159, susp 0.9923773225345403
Suspicious: 220 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1160, susp 0.9923773225345403
Suspicious: 221 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1161, susp 0.9923773225345403
Suspicious: 222 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1162, susp 0.9923773225345403
Suspicious: 223 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1163, susp 0.9923773225345403
Suspicious: 224 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1164, susp 0.9923773225345403
Suspicious: 225 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1168, susp 0.9923773225345403
Suspicious: 226 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1169, susp 0.9923773225345403
Suspicious: 227 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1170, susp 0.9923773225345403
Suspicious: 228 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1171, susp 0.9923773225345403
Suspicious: 229 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1172, susp 0.9923773225345403
Suspicious: 230 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1173, susp 0.9923773225345403
Suspicious: 231 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1176, susp 0.9923773225345403
Suspicious: 232 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1177, susp 0.9923773225345403
Suspicious: 233 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1178, susp 0.9923773225345403
Suspicious: 234 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1180, susp 0.9923773225345403
Suspicious: 235 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1181, susp 0.9923773225345403
Suspicious: 236 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1182, susp 0.9923773225345403
Suspicious: 237 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1184, susp 0.9923773225345403
Suspicious: 238 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1187, susp 0.9923773225345403
Suspicious: 239 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1188, susp 0.9923773225345403
Suspicious: 240 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1189, susp 0.9923773225345403
Suspicious: 241 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1191, susp 0.9923773225345403
Suspicious: 242 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1195, susp 0.9923773225345403
Suspicious: 243 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1198, susp 0.9923773225345403
Suspicious: 244 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1199, susp 0.9923773225345403
Suspicious: 245 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1200, susp 0.9923773225345403
Suspicious: 246 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1202, susp 0.9923773225345403
Suspicious: 247 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1203, susp 0.9923773225345403
Suspicious: 248 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1204, susp 0.9923773225345403
Suspicious: 249 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1206, susp 0.9923773225345403
Suspicious: 250 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1209, susp 0.9923773225345403
Suspicious: 251 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1210, susp 0.9923773225345403
Suspicious: 252 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1211, susp 0.9923773225345403
Suspicious: 253 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1213, susp 0.9923773225345403
Suspicious: 254 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1217, susp 0.9923773225345403
Suspicious: 255 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1219, susp 0.9923773225345403
Suspicious: 256 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1231, susp 0.9923773225345403
Suspicious: 257 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1232, susp 0.9923773225345403
Suspicious: 258 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1233, susp 0.9923773225345403
Suspicious: 259 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1234, susp 0.9923773225345403
Suspicious: 260 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1235, susp 0.9923773225345403
Suspicious: 261 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1236, susp 0.9923773225345403
Suspicious: 262 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1239, susp 0.9923773225345403
Suspicious: 263 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1254, susp 0.9923773225345403
Suspicious: 264 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1255, susp 0.9923773225345403
Suspicious: 265 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1256, susp 0.9923773225345403
Suspicious: 266 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1257, susp 0.9923773225345403
Suspicious: 267 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1258, susp 0.9923773225345403
Suspicious: 268 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1259, susp 0.9923773225345403
Suspicious: 269 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1260, susp 0.9923773225345403
Suspicious: 270 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1261, susp 0.9923773225345403
Suspicious: 271 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1262, susp 0.9923773225345403
Suspicious: 272 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1264, susp 0.9923773225345403
Suspicious: 273 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1274, susp 0.9923773225345403
Suspicious: 274 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1275, susp 0.9923773225345403
Suspicious: 275 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1276, susp 0.9923773225345403
Suspicious: 276 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1277, susp 0.9923773225345403
Suspicious: 277 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1279, susp 0.9923773225345403
Suspicious: 278 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1280, susp 0.9923773225345403
Suspicious: 279 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1289, susp 0.9923773225345403
Suspicious: 280 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1300, susp 0.9923773225345403
Suspicious: 281 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1301, susp 0.9923773225345403
Suspicious: 282 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1302, susp 0.9923773225345403
Suspicious: 283 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1303, susp 0.9923773225345403
Suspicious: 284 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1304, susp 0.9923773225345403
Suspicious: 285 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1305, susp 0.9923773225345403
Suspicious: 286 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1306, susp 0.9923773225345403
Suspicious: 287 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1307, susp 0.9923773225345403
Suspicious: 288 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1309, susp 0.9923773225345403
Suspicious: 289 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1310, susp 0.9923773225345403
Suspicious: 290 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1311, susp 0.9923773225345403
Suspicious: 291 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1312, susp 0.9923773225345403
Suspicious: 292 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1313, susp 0.9923773225345403
Suspicious: 293 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1314, susp 0.9923773225345403
Suspicious: 294 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1315, susp 0.9923773225345403
Suspicious: 295 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1317, susp 0.9923773225345403
Suspicious: 296 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1318, susp 0.9923773225345403
Suspicious: 297 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1320, susp 0.9923773225345403
Suspicious: 298 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1331, susp 0.9923773225345403
Suspicious: 299 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1332, susp 0.9923773225345403
Suspicious: 300 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1333, susp 0.9923773225345403
Suspicious: 301 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1335, susp 0.9923773225345403
Suspicious: 302 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1336, susp 0.9923773225345403
Suspicious: 303 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1337, susp 0.9923773225345403
Suspicious: 304 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1338, susp 0.9923773225345403
Suspicious: 305 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1343, susp 0.9923773225345403
Suspicious: 306 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1345, susp 0.9923773225345403
Suspicious: 307 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1346, susp 0.9923773225345403
Suspicious: 308 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1347, susp 0.9923773225345403
Suspicious: 309 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1348, susp 0.9923773225345403
Suspicious: 310 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1352, susp 0.9923773225345403
Suspicious: 311 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1353, susp 0.9923773225345403
Suspicious: 312 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1378, susp 0.9923773225345403
Suspicious: 313 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1379, susp 0.9923773225345403
Suspicious: 314 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1380, susp 0.9923773225345403
Suspicious: 315 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1381, susp 0.9923773225345403
Suspicious: 316 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1382, susp 0.9923773225345403
Suspicious: 317 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1383, susp 0.9923773225345403
Suspicious: 318 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1388, susp 0.9923773225345403
Suspicious: 319 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1390, susp 0.9923773225345403
Suspicious: 320 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1391, susp 0.9923773225345403
Suspicious: 321 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1392, susp 0.9923773225345403
Suspicious: 322 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1393, susp 0.9923773225345403
Suspicious: 323 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1397, susp 0.9923773225345403
Suspicious: 324 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1399, susp 0.9923773225345403
Suspicious: 325 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1400, susp 0.9923773225345403
Suspicious: 326 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1401, susp 0.9923773225345403
Suspicious: 327 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1402, susp 0.9923773225345403
Suspicious: 328 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1403, susp 0.9923773225345403
Suspicious: 329 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1408, susp 0.9923773225345403
Suspicious: 330 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1410, susp 0.9923773225345403
Suspicious: 331 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1411, susp 0.9923773225345403
Suspicious: 332 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1412, susp 0.9923773225345403
Suspicious: 333 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1413, susp 0.9923773225345403
Suspicious: 334 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1417, susp 0.9923773225345403
Suspicious: 335 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1419, susp 0.9923773225345403
Suspicious: 336 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1420, susp 0.9923773225345403
Suspicious: 337 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1422, susp 0.9923773225345403
Suspicious: 338 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1433, susp 0.9923773225345403
Suspicious: 339 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1434, susp 0.9923773225345403
Suspicious: 340 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1435, susp 0.9923773225345403
Suspicious: 341 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1439, susp 0.9923773225345403
Suspicious: 342 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1445, susp 0.9923773225345403
Suspicious: 343 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1446, susp 0.9923773225345403
Suspicious: 344 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1449, susp 0.9923773225345403
Suspicious: 345 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1451, susp 0.9923773225345403
Suspicious: 346 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1452, susp 0.9923773225345403
Suspicious: 347 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1453, susp 0.9923773225345403
Suspicious: 348 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1455, susp 0.9923773225345403
Suspicious: 349 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1457, susp 0.9923773225345403
Suspicious: 350 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1458, susp 0.9923773225345403
Suspicious: 351 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1459, susp 0.9923773225345403
Suspicious: 352 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1460, susp 0.9923773225345403
Suspicious: 353 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1461, susp 0.9923773225345403
Suspicious: 354 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1473, susp 0.9923773225345403
Suspicious: 355 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1527, susp 0.9923773225345403
Suspicious: 356 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1673, susp 0.9923773225345403
Suspicious: 357 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1683, susp 0.9923773225345403
Suspicious: 358 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1684, susp 0.9923773225345403
Suspicious: 359 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1685, susp 0.9923773225345403
Suspicious: 360 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1686, susp 0.9923773225345403
Suspicious: 361 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1687, susp 0.9923773225345403
Suspicious: 362 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1688, susp 0.9923773225345403
Suspicious: 363 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1689, susp 0.9923773225345403
Suspicious: 364 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1690, susp 0.9923773225345403
Suspicious: 365 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1691, susp 0.9923773225345403
Suspicious: 366 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1693, susp 0.9923773225345403
Suspicious: 367 line org.apache.commons.math.linear.EigenDecompositionImpl l: 312, susp 0.9899952358265841
Suspicious: 368 line org.apache.commons.math.linear.ArrayRealVector l: 884, susp 0.9899952358265841
Suspicious: 369 line org.apache.commons.math.linear.ArrayRealVector l: 885, susp 0.9899952358265841
Suspicious: 370 line org.apache.commons.math.linear.ArrayRealVector l: 886, susp 0.9899952358265841
Suspicious: 371 line org.apache.commons.math.linear.ArrayRealVector l: 887, susp 0.9899952358265841
Suspicious: 372 line org.apache.commons.math.linear.ArrayRealVector l: 889, susp 0.9899952358265841
Suspicious: 373 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1751, susp 0.9899952358265841
Suspicious: 374 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1752, susp 0.9899952358265841
Suspicious: 375 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1770, susp 0.9899952358265841
Suspicious: 376 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1771, susp 0.9899952358265841
Suspicious: 377 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1772, susp 0.9899952358265841
Suspicious: 378 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1700, susp 0.9895188184849929
Suspicious: 379 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1701, susp 0.9895188184849929
Suspicious: 380 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1704, susp 0.9895188184849929
Suspicious: 381 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1705, susp 0.9895188184849929
Suspicious: 382 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1707, susp 0.9895188184849929
Suspicious: 383 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1708, susp 0.9895188184849929
Suspicious: 384 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1709, susp 0.9895188184849929
Suspicious: 385 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1710, susp 0.9895188184849929
Suspicious: 386 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1711, susp 0.9895188184849929
Suspicious: 387 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1712, susp 0.9895188184849929
Suspicious: 388 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1713, susp 0.9895188184849929
Suspicious: 389 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1714, susp 0.9895188184849929
Suspicious: 390 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1715, susp 0.9895188184849929
Suspicious: 391 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1719, susp 0.9895188184849929
Suspicious: 392 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1720, susp 0.9895188184849929
Suspicious: 393 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1723, susp 0.9895188184849929
Suspicious: 394 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1739, susp 0.9895188184849929
Suspicious: 395 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1740, susp 0.9895188184849929
Suspicious: 396 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1741, susp 0.9895188184849929
Suspicious: 397 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1745, susp 0.9895188184849929
Suspicious: 398 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1746, susp 0.9895188184849929
Suspicious: 399 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1747, susp 0.9895188184849929
Suspicious: 400 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1748, susp 0.9895188184849929
Suspicious: 401 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1749, susp 0.9895188184849929
Suspicious: 402 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1750, susp 0.9895188184849929
Suspicious: 403 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1754, susp 0.9895188184849929
Suspicious: 404 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1759, susp 0.9895188184849929
Suspicious: 405 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1760, susp 0.9895188184849929
Suspicious: 406 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1761, susp 0.9895188184849929
Suspicious: 407 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1762, susp 0.9895188184849929
Suspicious: 408 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1763, susp 0.9895188184849929
Suspicious: 409 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1764, susp 0.9895188184849929
Suspicious: 410 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1765, susp 0.9895188184849929
Suspicious: 411 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1766, susp 0.9895188184849929
Suspicious: 412 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1768, susp 0.9895188184849929
Suspicious: 413 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1769, susp 0.9895188184849929
Suspicious: 414 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1776, susp 0.9895188184849929
Suspicious: 415 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1777, susp 0.9895188184849929
Suspicious: 416 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1778, susp 0.9895188184849929
Suspicious: 417 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1781, susp 0.9895188184849929
Suspicious: 418 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1797, susp 0.9895188184849929
Suspicious: 419 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1798, susp 0.9895188184849929
Suspicious: 420 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1799, susp 0.9895188184849929
Suspicious: 421 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1800, susp 0.9895188184849929
Suspicious: 422 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1801, susp 0.9895188184849929
Suspicious: 423 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1802, susp 0.9895188184849929
Suspicious: 424 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1803, susp 0.9895188184849929
Suspicious: 425 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1804, susp 0.9895188184849929
Suspicious: 426 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1805, susp 0.9895188184849929
Suspicious: 427 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1806, susp 0.9895188184849929
Suspicious: 428 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1807, susp 0.9895188184849929
Suspicious: 429 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1808, susp 0.9895188184849929
Suspicious: 430 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1809, susp 0.9895188184849929
Suspicious: 431 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1811, susp 0.9895188184849929
Suspicious: 432 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1812, susp 0.9895188184849929
Suspicious: 433 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1813, susp 0.9895188184849929
Suspicious: 434 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1825, susp 0.9895188184849929
Suspicious: 435 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1826, susp 0.9895188184849929
Suspicious: 436 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1827, susp 0.9895188184849929
Suspicious: 437 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1828, susp 0.9895188184849929
Suspicious: 438 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1829, susp 0.9895188184849929
Suspicious: 439 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1830, susp 0.9895188184849929
Suspicious: 440 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1831, susp 0.9895188184849929
Suspicious: 441 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1832, susp 0.9895188184849929
Suspicious: 442 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1833, susp 0.9895188184849929
Suspicious: 443 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1834, susp 0.9895188184849929
Suspicious: 444 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1835, susp 0.9895188184849929
Suspicious: 445 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1836, susp 0.9895188184849929
Suspicious: 446 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1837, susp 0.9895188184849929
Suspicious: 447 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1839, susp 0.9895188184849929
Suspicious: 448 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1840, susp 0.9895188184849929
Suspicious: 449 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1841, susp 0.9895188184849929
Suspicious: 450 line org.apache.commons.math.linear.EigenDecompositionImpl l: 581, susp 0.9838018103858981
Suspicious: 451 line org.apache.commons.math.linear.EigenDecompositionImpl l: 582, susp 0.9838018103858981
Suspicious: 452 line org.apache.commons.math.linear.EigenDecompositionImpl l: 583, susp 0.9838018103858981
Suspicious: 453 line org.apache.commons.math.linear.EigenDecompositionImpl l: 584, susp 0.9838018103858981
Suspicious: 454 line org.apache.commons.math.linear.EigenDecompositionImpl l: 585, susp 0.9838018103858981
Suspicious: 455 line org.apache.commons.math.linear.EigenDecompositionImpl l: 587, susp 0.9838018103858981
Suspicious: 456 line org.apache.commons.math.linear.EigenDecompositionImpl l: 588, susp 0.9838018103858981
Suspicious: 457 line org.apache.commons.math.linear.EigenDecompositionImpl l: 589, susp 0.9838018103858981
Suspicious: 458 line org.apache.commons.math.linear.EigenDecompositionImpl l: 591, susp 0.9838018103858981
Suspicious: 459 line org.apache.commons.math.linear.EigenDecompositionImpl l: 592, susp 0.9838018103858981
Suspicious: 460 line org.apache.commons.math.linear.EigenDecompositionImpl l: 593, susp 0.9838018103858981
Suspicious: 461 line org.apache.commons.math.linear.EigenDecompositionImpl l: 679, susp 0.9838018103858981
Suspicious: 462 line org.apache.commons.math.linear.EigenDecompositionImpl l: 680, susp 0.9838018103858981
Suspicious: 463 line org.apache.commons.math.linear.EigenDecompositionImpl l: 681, susp 0.9838018103858981
Suspicious: 464 line org.apache.commons.math.linear.EigenDecompositionImpl l: 682, susp 0.9838018103858981
Suspicious: 465 line org.apache.commons.math.linear.EigenDecompositionImpl l: 698, susp 0.9838018103858981
Suspicious: 466 line org.apache.commons.math.linear.EigenDecompositionImpl l: 699, susp 0.9838018103858981
Suspicious: 467 line org.apache.commons.math.linear.EigenDecompositionImpl l: 700, susp 0.9838018103858981
Suspicious: 468 line org.apache.commons.math.linear.EigenDecompositionImpl l: 701, susp 0.9838018103858981
Suspicious: 469 line org.apache.commons.math.linear.EigenDecompositionImpl l: 237, susp 0.9833253930443068
Suspicious: 470 line org.apache.commons.math.linear.EigenDecompositionImpl l: 238, susp 0.9833253930443068
Suspicious: 471 line org.apache.commons.math.linear.EigenDecompositionImpl l: 239, susp 0.9833253930443068
Suspicious: 472 line org.apache.commons.math.linear.EigenDecompositionImpl l: 240, susp 0.9833253930443068
Suspicious: 473 line org.apache.commons.math.linear.EigenDecompositionImpl l: 243, susp 0.9833253930443068
Suspicious: 474 line org.apache.commons.math.linear.EigenDecompositionImpl l: 246, susp 0.9833253930443068
Suspicious: 475 line org.apache.commons.math.linear.EigenDecompositionImpl l: 249, susp 0.9833253930443068
Suspicious: 476 line org.apache.commons.math.linear.EigenDecompositionImpl l: 251, susp 0.9833253930443068
Suspicious: 477 line org.apache.commons.math.linear.ArrayRealVector l: 269, susp 0.9833253930443068
Suspicious: 478 line org.apache.commons.math.linear.EigenDecompositionImpl l: 571, susp 0.9833253930443068
Suspicious: 479 line org.apache.commons.math.linear.EigenDecompositionImpl l: 572, susp 0.9833253930443068
Suspicious: 480 line org.apache.commons.math.linear.EigenDecompositionImpl l: 573, susp 0.9833253930443068
Suspicious: 481 line org.apache.commons.math.linear.EigenDecompositionImpl l: 574, susp 0.9833253930443068
Suspicious: 482 line org.apache.commons.math.linear.EigenDecompositionImpl l: 575, susp 0.9833253930443068
Suspicious: 483 line org.apache.commons.math.linear.EigenDecompositionImpl l: 576, susp 0.9833253930443068
Suspicious: 484 line org.apache.commons.math.linear.EigenDecompositionImpl l: 578, susp 0.9833253930443068
Suspicious: 485 line org.apache.commons.math.linear.EigenDecompositionImpl l: 579, susp 0.9833253930443068
Suspicious: 486 line org.apache.commons.math.linear.EigenDecompositionImpl l: 597, susp 0.9833253930443068
Suspicious: 487 line org.apache.commons.math.linear.EigenDecompositionImpl l: 598, susp 0.9833253930443068
Suspicious: 488 line org.apache.commons.math.linear.EigenDecompositionImpl l: 599, susp 0.9833253930443068
Suspicious: 489 line org.apache.commons.math.linear.EigenDecompositionImpl l: 600, susp 0.9833253930443068
Suspicious: 490 line org.apache.commons.math.linear.EigenDecompositionImpl l: 601, susp 0.9833253930443068
Suspicious: 491 line org.apache.commons.math.linear.EigenDecompositionImpl l: 602, susp 0.9833253930443068
Suspicious: 492 line org.apache.commons.math.linear.EigenDecompositionImpl l: 603, susp 0.9833253930443068
Suspicious: 493 line org.apache.commons.math.linear.EigenDecompositionImpl l: 604, susp 0.9833253930443068
Suspicious: 494 line org.apache.commons.math.linear.EigenDecompositionImpl l: 606, susp 0.9833253930443068
Suspicious: 495 line org.apache.commons.math.linear.EigenDecompositionImpl l: 616, susp 0.9833253930443068
Suspicious: 496 line org.apache.commons.math.linear.EigenDecompositionImpl l: 619, susp 0.9833253930443068
Suspicious: 497 line org.apache.commons.math.linear.EigenDecompositionImpl l: 620, susp 0.9833253930443068
Suspicious: 498 line org.apache.commons.math.linear.EigenDecompositionImpl l: 621, susp 0.9833253930443068
Suspicious: 499 line org.apache.commons.math.linear.EigenDecompositionImpl l: 622, susp 0.9833253930443068
Suspicious: 500 line org.apache.commons.math.linear.EigenDecompositionImpl l: 623, susp 0.9833253930443068
Suspicious: 501 line org.apache.commons.math.linear.EigenDecompositionImpl l: 624, susp 0.9833253930443068
Suspicious: 502 line org.apache.commons.math.linear.EigenDecompositionImpl l: 672, susp 0.9833253930443068
Suspicious: 503 line org.apache.commons.math.linear.EigenDecompositionImpl l: 673, susp 0.9833253930443068
Suspicious: 504 line org.apache.commons.math.linear.EigenDecompositionImpl l: 676, susp 0.9833253930443068
Suspicious: 505 line org.apache.commons.math.linear.EigenDecompositionImpl l: 677, susp 0.9833253930443068
Suspicious: 506 line org.apache.commons.math.linear.EigenDecompositionImpl l: 678, susp 0.9833253930443068
Suspicious: 507 line org.apache.commons.math.linear.EigenDecompositionImpl l: 685, susp 0.9833253930443068
Suspicious: 508 line org.apache.commons.math.linear.EigenDecompositionImpl l: 693, susp 0.9833253930443068
Suspicious: 509 line org.apache.commons.math.linear.EigenDecompositionImpl l: 696, susp 0.9833253930443068
Suspicious: 510 line org.apache.commons.math.linear.EigenDecompositionImpl l: 697, susp 0.9833253930443068
Suspicious: 511 line org.apache.commons.math.linear.EigenDecompositionImpl l: 708, susp 0.9833253930443068
Suspicious: 512 line org.apache.commons.math.linear.EigenDecompositionImpl l: 709, susp 0.9833253930443068
Suspicious: 513 line org.apache.commons.math.linear.ArrayRealVector l: 283, susp 0.9828489757027156
Suspicious: 514 line org.apache.commons.math.linear.ArrayRealVector l: 284, susp 0.9828489757027156
Suspicious: 515 line org.apache.commons.math.linear.ArrayRealVector l: 285, susp 0.9828489757027156
Suspicious: 516 line org.apache.commons.math.linear.ArrayRealVector l: 286, susp 0.9828489757027156
Suspicious: 517 line org.apache.commons.math.linear.ArrayRealVector l: 288, susp 0.9828489757027156
Suspicious: 518 line org.apache.commons.math.linear.ArrayRealVector l: 299, susp 0.9828489757027156
Suspicious: 519 line org.apache.commons.math.linear.ArrayRealVector l: 1292, susp 0.9752262982372558
Suspicious: 520 line org.apache.commons.math.linear.ArrayRealVector l: 1287, susp 0.9747498808956646
Suspicious: 521 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 254, susp 0.9714149595045259
Suspicious: 522 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 271, susp 0.9661743687470223
Suspicious: 523 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 273, susp 0.9661743687470223
Suspicious: 524 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 274, susp 0.9661743687470223
Suspicious: 525 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 275, susp 0.9661743687470223
Suspicious: 526 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 276, susp 0.9661743687470223
Suspicious: 527 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 277, susp 0.9661743687470223
Suspicious: 528 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 278, susp 0.9661743687470223
Suspicious: 529 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 279, susp 0.9661743687470223
Suspicious: 530 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 280, susp 0.9661743687470223
Suspicious: 531 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 281, susp 0.9661743687470223
Suspicious: 532 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 282, susp 0.9661743687470223
Suspicious: 533 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 283, susp 0.9661743687470223
Suspicious: 534 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 285, susp 0.9661743687470223
Suspicious: 535 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 289, susp 0.9661743687470223
Suspicious: 536 line org.apache.commons.math.linear.AbstractRealMatrix l: 603, susp 0.96141019533111
Suspicious: 537 line org.apache.commons.math.linear.AbstractRealMatrix l: 604, susp 0.96141019533111
Suspicious: 538 line org.apache.commons.math.linear.AbstractRealMatrix l: 605, susp 0.96141019533111
Suspicious: 539 line org.apache.commons.math.linear.AbstractRealMatrix l: 606, susp 0.96141019533111
Suspicious: 540 line org.apache.commons.math.linear.AbstractRealMatrix$5 l: 606, susp 0.96141019533111
Suspicious: 541 line org.apache.commons.math.linear.AbstractRealMatrix$5 l: 611, susp 0.96141019533111
Suspicious: 542 line org.apache.commons.math.linear.AbstractRealMatrix$5 l: 612, susp 0.96141019533111
Suspicious: 543 line org.apache.commons.math.linear.AbstractRealMatrix l: 616, susp 0.96141019533111
Suspicious: 544 line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 35, susp 0.9599809433063363
Suspicious: 545 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 482, susp 0.9595045259647451
Suspicious: 546 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 483, susp 0.9595045259647451
Suspicious: 547 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 484, susp 0.9595045259647451
Suspicious: 548 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 485, susp 0.9595045259647451
Suspicious: 549 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 486, susp 0.9595045259647451
Suspicious: 550 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 487, susp 0.9595045259647451
Suspicious: 551 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 488, susp 0.9595045259647451
Suspicious: 552 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 491, susp 0.9595045259647451
Suspicious: 553 line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 30, susp 0.9575988565983802
Suspicious: 554 line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 44, susp 0.9575988565983802
Suspicious: 555 line org.apache.commons.math.linear.AbstractRealMatrix l: 919, susp 0.9575988565983802
Suspicious: 556 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 160, susp 0.957122439256789
Suspicious: 557 line org.apache.commons.math.linear.MatrixUtils l: 650, susp 0.9561696045736064
Suspicious: 558 line org.apache.commons.math.linear.MatrixUtils l: 656, susp 0.9561696045736064
Suspicious: 559 line org.apache.commons.math.linear.MatrixUtils l: 106, susp 0.9547403525488328
Suspicious: 560 line org.apache.commons.math.linear.ArrayRealVector l: 96, susp 0.9447355883754168
Suspicious: 561 line org.apache.commons.math.linear.ArrayRealVector l: 97, susp 0.9447355883754168
Suspicious: 562 line org.apache.commons.math.linear.ArrayRealVector l: 100, susp 0.9447355883754168
Suspicious: 563 line org.apache.commons.math.linear.ArrayRealVector l: 103, susp 0.9447355883754168
Suspicious: 564 line org.apache.commons.math.linear.ArrayRealVector l: 104, susp 0.9447355883754168
Suspicious: 565 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 130, susp 0.9447355883754168
Suspicious: 566 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 114, susp 0.9442591710338256
Suspicious: 567 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 115, susp 0.9442591710338256
Suspicious: 568 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 118, susp 0.9442591710338256
Suspicious: 569 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 121, susp 0.9442591710338256
Suspicious: 570 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 122, susp 0.9442591710338256
Suspicious: 571 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 125, susp 0.9442591710338256
Suspicious: 572 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 126, susp 0.9442591710338256
Suspicious: 573 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 129, susp 0.9442591710338256
Suspicious: 574 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 136, susp 0.9442591710338256
Suspicious: 575 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 138, susp 0.9442591710338256
Suspicious: 576 line org.apache.commons.math.linear.ArrayRealVector l: 77, susp 0.9347308242020009
Suspicious: 577 line org.apache.commons.math.linear.ArrayRealVector l: 78, susp 0.9347308242020009
Suspicious: 578 line org.apache.commons.math.linear.ArrayRealVector l: 79, susp 0.9347308242020009
Suspicious: 579 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 76, susp 0.9213911386374464
Suspicious: 580 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 77, susp 0.9213911386374464
Suspicious: 581 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 78, susp 0.9213911386374464
Suspicious: 582 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 367, susp 0.920438303954264
Suspicious: 583 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 372, susp 0.920438303954264
Suspicious: 584 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 373, susp 0.920438303954264
Suspicious: 585 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 94, susp 0.9190090519294902
Suspicious: 586 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 95, susp 0.9190090519294902
Suspicious: 587 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 96, susp 0.9190090519294902
Suspicious: 588 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 314, susp 0.918532634587899
Suspicious: 589 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 315, susp 0.918532634587899
Suspicious: 590 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 320, susp 0.918532634587899
Suspicious: 591 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 325, susp 0.918532634587899
Suspicious: 592 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 326, susp 0.918532634587899
Suspicious: 593 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 330, susp 0.918532634587899
Suspicious: 594 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 331, susp 0.918532634587899
Suspicious: 595 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 334, susp 0.918532634587899
Suspicious: 596 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 335, susp 0.918532634587899
Suspicious: 597 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 336, susp 0.918532634587899
Suspicious: 598 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 341, susp 0.918532634587899
Suspicious: 599 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 343, susp 0.918532634587899
Suspicious: 600 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 347, susp 0.918532634587899
Suspicious: 601 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 622, susp 0.918532634587899
Suspicious: 602 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 623, susp 0.918532634587899
Suspicious: 603 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 410, susp 0.8947117675083374
Suspicious: 604 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 404, susp 0.894235350166746
Suspicious: 605 line org.apache.commons.math.linear.AbstractRealMatrix l: 43, susp 0.8789899952358265
Suspicious: 606 line org.apache.commons.math.linear.AbstractRealMatrix l: 44, susp 0.8789899952358265
Suspicious: 607 line org.apache.commons.math.linear.AbstractRealMatrix l: 45, susp 0.8789899952358265
Suspicious: 608 line org.apache.commons.math.linear.AbstractRealMatrix l: 61, susp 0.857551214864221
Suspicious: 609 line org.apache.commons.math.linear.AbstractRealMatrix l: 66, susp 0.857551214864221
Suspicious: 610 line org.apache.commons.math.linear.AbstractRealMatrix l: 67, susp 0.857551214864221
Suspicious: 611 line org.apache.commons.math.linear.AbstractRealMatrix l: 55, susp 0.8565983801810386
Suspicious: 612 line org.apache.commons.math.linear.AbstractRealMatrix l: 56, susp 0.8565983801810386
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 871, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 872, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 944, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 945, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 957, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 958, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 959, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 960, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1055, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1056, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1057, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1058, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1059, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1060, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1061, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1062, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1063, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1135, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1136, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1137, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1138, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1139, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1140, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1142, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1144, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1384, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1385, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1386, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1387, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1404, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1405, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1406, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1407, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1414, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1415, susp 1.0
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1090, susp 0.9995235826584088
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1091, susp 0.9995235826584088
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1092, susp 0.9995235826584088
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1093, susp 0.9995235826584088
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 336, susp 0.9990471653168176
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 337, susp 0.9990471653168176
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 339, susp 0.9990471653168176
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1088, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1105, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1106, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1530, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1531, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1534, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1535, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1536, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1537, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1538, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1541, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1544, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1564, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1565, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1570, susp 0.9985707479752263
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 225, susp 0.9976179132920439
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 870, susp 0.9976179132920439
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 175, susp 0.9971414959504526
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 176, susp 0.9971414959504526
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 177, susp 0.9971414959504526
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 900, susp 0.9971414959504526
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1488, susp 0.9961886612672701
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1489, susp 0.9961886612672701
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1490, susp 0.9961886612672701
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1491, susp 0.9961886612672701
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1494, susp 0.9961886612672701
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1495, susp 0.9961886612672701
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1498, susp 0.9961886612672701
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1499, susp 0.9961886612672701
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1085, susp 0.9957122439256789
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1094, susp 0.9957122439256789
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1096, susp 0.9957122439256789
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1099, susp 0.9957122439256789
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1101, susp 0.9957122439256789
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1102, susp 0.9957122439256789
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 666, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 667, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 905, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 906, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 907, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 909, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1475, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1476, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1479, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1503, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1504, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1518, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1521, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1522, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1524, susp 0.9952358265840877
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1027, susp 0.9928537398761315
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1028, susp 0.9928537398761315
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1029, susp 0.9928537398761315
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1030, susp 0.9928537398761315
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1034, susp 0.9928537398761315
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1035, susp 0.9928537398761315
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1036, susp 0.9928537398761315
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1356, susp 0.9928537398761315
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 191, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 193, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 194, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 195, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 198, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 199, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 200, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 201, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 204, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 205, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 207, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 644, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 645, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 646, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 647, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 648, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 649, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 650, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 652, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 655, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 658, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 661, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 827, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 828, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 829, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 830, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 831, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 834, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 840, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 843, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 846, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 847, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 848, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 849, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 850, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 851, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 852, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 855, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 856, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 857, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 860, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 861, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 864, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 865, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 866, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 867, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 868, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 869, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 870, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 874, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 875, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 876, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 878, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 879, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 881, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 884, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 886, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 887, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 888, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 889, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 894, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 895, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 899, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 927, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 929, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 937, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 938, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 941, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 942, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 943, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 947, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 952, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 953, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 954, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 955, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 956, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 961, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 963, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 964, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 965, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 966, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 971, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 974, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 978, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 993, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 996, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 997, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 999, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1001, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1004, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1006, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1012, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1013, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1015, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1020, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1026, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1038, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1039, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1040, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1044, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1048, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1050, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1053, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1054, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1067, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1068, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1069, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1072, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1075, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1078, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1081, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1083, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1084, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1119, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1121, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1133, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1146, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1158, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1159, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1160, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1161, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1162, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1163, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1164, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1168, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1169, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1170, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1171, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1172, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1173, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1176, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1177, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1178, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1180, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1181, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1182, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1184, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1187, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1188, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1189, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1191, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1195, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1198, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1199, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1200, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1202, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1203, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1204, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1206, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1209, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1210, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1211, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1213, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1217, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1219, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1231, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1232, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1233, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1234, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1235, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1236, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1239, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1254, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1255, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1256, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1257, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1258, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1259, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1260, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1261, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1262, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1264, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1274, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1275, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1276, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1277, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1279, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1280, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1289, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1300, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1301, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1302, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1303, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1304, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1305, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1306, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1307, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1309, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1310, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1311, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1312, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1313, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1314, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1315, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1317, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1318, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1320, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1331, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1332, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1333, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1335, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1336, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1337, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1338, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1343, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1345, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1346, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1347, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1348, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1352, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1353, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1378, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1379, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1380, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1381, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1382, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1383, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1388, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1390, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1391, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1392, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1393, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1397, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1399, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1400, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1401, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1402, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1403, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1408, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1410, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1411, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1412, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1413, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1417, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1419, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1420, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1422, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1433, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1434, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1435, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1439, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1445, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1446, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1449, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1451, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1452, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1453, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1455, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1457, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1458, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1459, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1460, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1461, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1473, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1527, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1673, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1683, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1684, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1685, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1686, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1687, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1688, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1689, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1690, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1691, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1693, susp 0.9923773225345403
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 312, susp 0.9899952358265841
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 884, susp 0.9899952358265841
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 885, susp 0.9899952358265841
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 886, susp 0.9899952358265841
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 887, susp 0.9899952358265841
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 889, susp 0.9899952358265841
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1751, susp 0.9899952358265841
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1752, susp 0.9899952358265841
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1770, susp 0.9899952358265841
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1771, susp 0.9899952358265841
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1772, susp 0.9899952358265841
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1700, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1701, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1704, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1705, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1707, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1708, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1709, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1710, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1711, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1712, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1713, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1714, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1715, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1719, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1720, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1723, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1739, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1740, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1741, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1745, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1746, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1747, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1748, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1749, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1750, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1754, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1759, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1760, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1761, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1762, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1763, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1764, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1765, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1766, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1768, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1769, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1776, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1777, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1778, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1781, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1797, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1798, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1799, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1800, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1801, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1802, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1803, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1804, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1805, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1806, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1807, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1808, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1809, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1811, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1812, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1813, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1825, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1826, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1827, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1828, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1829, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1830, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1831, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1832, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1833, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1834, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1835, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1836, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1837, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1839, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1840, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1841, susp 0.9895188184849929
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 581, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 582, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 583, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 584, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 585, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 587, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 588, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 589, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 591, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 592, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 593, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 679, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 680, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 681, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 682, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 698, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 699, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 700, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 701, susp 0.9838018103858981
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 237, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 238, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 239, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 240, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 243, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 246, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 249, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 251, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 269, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 571, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 572, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 573, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 574, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 575, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 576, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 578, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 579, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 597, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 598, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 599, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 600, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 601, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 602, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 603, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 604, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 606, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 616, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 619, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 620, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 621, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 622, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 623, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 624, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 672, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 673, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 676, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 677, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 678, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 685, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 693, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 696, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 697, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 708, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 709, susp 0.9833253930443068
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 283, susp 0.9828489757027156
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 284, susp 0.9828489757027156
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 285, susp 0.9828489757027156
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 286, susp 0.9828489757027156
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 288, susp 0.9828489757027156
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 299, susp 0.9828489757027156
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 1292, susp 0.9752262982372558
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 1287, susp 0.9747498808956646
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 254, susp 0.9714149595045259
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 271, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 273, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 274, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 275, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 276, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 277, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 278, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 279, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 280, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 281, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 282, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 283, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 285, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 289, susp 0.9661743687470223
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 603, susp 0.96141019533111
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 604, susp 0.96141019533111
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 605, susp 0.96141019533111
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 606, susp 0.96141019533111
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 606, susp 0.96141019533111
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 611, susp 0.96141019533111
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 612, susp 0.96141019533111
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 616, susp 0.96141019533111
Suspicious:  line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 35, susp 0.9599809433063363
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 482, susp 0.9595045259647451
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 483, susp 0.9595045259647451
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 484, susp 0.9595045259647451
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 485, susp 0.9595045259647451
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 486, susp 0.9595045259647451
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 487, susp 0.9595045259647451
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 488, susp 0.9595045259647451
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 491, susp 0.9595045259647451
Suspicious:  line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 30, susp 0.9575988565983802
Suspicious:  line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 44, susp 0.9575988565983802
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 919, susp 0.9575988565983802
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 160, susp 0.957122439256789
Suspicious:  line org.apache.commons.math.linear.MatrixUtils l: 650, susp 0.9561696045736064
Suspicious:  line org.apache.commons.math.linear.MatrixUtils l: 656, susp 0.9561696045736064
Suspicious:  line org.apache.commons.math.linear.MatrixUtils l: 106, susp 0.9547403525488328
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 96, susp 0.9447355883754168
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 97, susp 0.9447355883754168
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 100, susp 0.9447355883754168
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 103, susp 0.9447355883754168
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 104, susp 0.9447355883754168
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 130, susp 0.9447355883754168
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 114, susp 0.9442591710338256
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 115, susp 0.9442591710338256
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 118, susp 0.9442591710338256
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 121, susp 0.9442591710338256
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 122, susp 0.9442591710338256
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 125, susp 0.9442591710338256
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 126, susp 0.9442591710338256
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 129, susp 0.9442591710338256
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 136, susp 0.9442591710338256
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 138, susp 0.9442591710338256
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 77, susp 0.9347308242020009
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 78, susp 0.9347308242020009
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 79, susp 0.9347308242020009
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 76, susp 0.9213911386374464
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 77, susp 0.9213911386374464
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 78, susp 0.9213911386374464
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 367, susp 0.920438303954264
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 372, susp 0.920438303954264
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 373, susp 0.920438303954264
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 94, susp 0.9190090519294902
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 95, susp 0.9190090519294902
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 96, susp 0.9190090519294902
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 314, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 315, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 320, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 325, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 326, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 330, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 331, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 334, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 335, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 336, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 341, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 343, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 347, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 622, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 623, susp 0.918532634587899
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 410, susp 0.8947117675083374
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 404, susp 0.894235350166746
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 43, susp 0.8789899952358265
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 44, susp 0.8789899952358265
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 45, susp 0.8789899952358265
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 61, susp 0.857551214864221
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 66, susp 0.857551214864221
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 67, susp 0.857551214864221
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 55, susp 0.8565983801810386
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 56, susp 0.8565983801810386
Executing time Fault localization: 72 sec
Setting up the max to 724030 milliseconds (724 sec)
---- Initial suspicious size: 612
Creating variant 1
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 871, file EigenDecompositionImpl.java
--ModifPoint:CtBreakImpl, suspValue 1.0, line 872, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 944, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 945, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 957, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 958, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 959, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 960, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1055, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1056, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1059, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1062, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1063, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 1.0, line 1135, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 1.0, line 1136, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 1.0, line 1137, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 1.0, line 1138, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1139, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1140, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 1.0, line 1142, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 1.0, line 1144, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1384, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1385, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1386, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1387, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1404, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1405, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1406, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1407, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1414, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 1.0, line 1415, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9995235826584088, line 1090, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9995235826584088, line 1091, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9995235826584088, line 1092, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9995235826584088, line 1093, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9990471653168176, line 336, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9990471653168176, line 337, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9990471653168176, line 339, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9985707479752263, line 1105, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9985707479752263, line 1106, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9985707479752263, line 1530, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9985707479752263, line 1531, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9985707479752263, line 1534, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9985707479752263, line 1535, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9985707479752263, line 1536, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9985707479752263, line 1537, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9985707479752263, line 1538, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9985707479752263, line 1541, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9985707479752263, line 1544, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9985707479752263, line 1564, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9985707479752263, line 1565, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9976179132920439, line 225, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9976179132920439, line 870, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9971414959504526, line 176, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9971414959504526, line 900, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9961886612672701, line 1488, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9961886612672701, line 1489, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9961886612672701, line 1490, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9961886612672701, line 1491, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9961886612672701, line 1494, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9961886612672701, line 1495, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9961886612672701, line 1498, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9961886612672701, line 1499, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9957122439256789, line 1085, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9957122439256789, line 1094, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9957122439256789, line 1096, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9957122439256789, line 1099, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9957122439256789, line 1101, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9957122439256789, line 1102, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9952358265840877, line 666, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9952358265840877, line 667, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9952358265840877, line 905, file ArrayRealVector.java
--ModifPoint:CtForEachImpl, suspValue 0.9952358265840877, line 906, file ArrayRealVector.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9952358265840877, line 907, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9952358265840877, line 909, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9952358265840877, line 1475, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9952358265840877, line 1476, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9952358265840877, line 1479, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9952358265840877, line 1503, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9952358265840877, line 1504, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9952358265840877, line 1518, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9952358265840877, line 1521, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9952358265840877, line 1522, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9952358265840877, line 1524, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928537398761315, line 1027, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928537398761315, line 1028, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928537398761315, line 1029, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928537398761315, line 1030, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928537398761315, line 1034, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9928537398761315, line 1035, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928537398761315, line 1036, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928537398761315, line 1356, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 193, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 194, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 195, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 198, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 199, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 200, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 201, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 204, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9923773225345403, line 205, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 827, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 828, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 829, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 830, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9923773225345403, line 831, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 834, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9923773225345403, line 840, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9923773225345403, line 843, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 846, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 847, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 848, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 849, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 850, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 851, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 852, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 855, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 856, file EigenDecompositionImpl.java
--ModifPoint:CtWhileImpl, suspValue 0.9923773225345403, line 857, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 860, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 861, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 864, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 865, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 866, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 867, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 868, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 869, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 870, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 874, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 875, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 876, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 878, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 879, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 881, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 884, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 886, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 887, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 888, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 889, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 894, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 895, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 899, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 937, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 938, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 941, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 942, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 943, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9923773225345403, line 947, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 952, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 953, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 954, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 955, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 956, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 961, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 963, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 964, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9923773225345403, line 965, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 971, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 974, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 993, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 996, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 997, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 999, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9923773225345403, line 1001, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1004, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1006, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1012, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9923773225345403, line 1013, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1015, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1020, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1026, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1038, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1039, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9923773225345403, line 1040, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1044, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1050, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1053, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1054, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1067, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9923773225345403, line 1072, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 1075, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9923773225345403, line 1078, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1081, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9923773225345403, line 1083, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9923773225345403, line 1084, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9923773225345403, line 1119, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9923773225345403, line 1121, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1133, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9923773225345403, line 1146, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1158, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1159, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1160, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1161, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 1162, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1163, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1164, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1168, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1169, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1170, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1171, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1173, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1176, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1177, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 1178, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1180, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1181, file EigenDecompositionImpl.java
--ModifPoint:CtBreakImpl, suspValue 0.9923773225345403, line 1184, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1187, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1188, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1189, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1191, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1195, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1198, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1199, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 1200, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1202, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1203, file EigenDecompositionImpl.java
--ModifPoint:CtBreakImpl, suspValue 0.9923773225345403, line 1206, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1209, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1210, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1211, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1213, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1217, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9923773225345403, line 1219, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1231, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1232, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 1233, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1234, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1235, file EigenDecompositionImpl.java
--ModifPoint:CtUnaryOperatorImpl, suspValue 0.9923773225345403, line 1236, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9923773225345403, line 1239, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1254, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1255, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 1256, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1257, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1258, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1259, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1260, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1261, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1262, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1274, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1275, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1276, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1277, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1279, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 1280, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 1289, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1300, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1301, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1302, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1303, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1304, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1305, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1306, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1307, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1309, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1310, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1311, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1312, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1313, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1314, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1315, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1317, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1318, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1331, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1332, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1333, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1335, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9923773225345403, line 1336, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1337, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1338, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1343, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1345, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1346, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9923773225345403, line 1347, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1352, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1353, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1378, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1379, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1380, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1381, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1382, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1383, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1388, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1390, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1391, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1392, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1397, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1399, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1400, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1401, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1402, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1403, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1408, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1410, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1411, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1412, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1417, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1419, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1420, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1433, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1434, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1435, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1439, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1445, file EigenDecompositionImpl.java
--ModifPoint:CtSwitchImpl, suspValue 0.9923773225345403, line 1446, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1451, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1452, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1453, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1455, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1457, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1458, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1459, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1460, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1461, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1527, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9923773225345403, line 1683, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9923773225345403, line 1684, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1685, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9923773225345403, line 1686, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1687, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9923773225345403, line 1689, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9923773225345403, line 1690, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9923773225345403, line 1691, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9899952358265841, line 312, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9899952358265841, line 884, file ArrayRealVector.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9899952358265841, line 885, file ArrayRealVector.java
--ModifPoint:CtForImpl, suspValue 0.9899952358265841, line 886, file ArrayRealVector.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9899952358265841, line 887, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9899952358265841, line 889, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9899952358265841, line 1751, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9899952358265841, line 1752, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9899952358265841, line 1770, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9899952358265841, line 1771, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9899952358265841, line 1772, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1700, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1701, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1704, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1705, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1707, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1708, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1709, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9895188184849929, line 1710, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1711, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1712, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1713, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1714, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1715, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9895188184849929, line 1719, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1720, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1739, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9895188184849929, line 1740, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9895188184849929, line 1741, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1745, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1746, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1747, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9895188184849929, line 1748, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1749, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9895188184849929, line 1750, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9895188184849929, line 1754, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1759, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1760, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1761, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1762, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9895188184849929, line 1763, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9895188184849929, line 1764, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1765, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9895188184849929, line 1766, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1768, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9895188184849929, line 1769, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1776, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9895188184849929, line 1777, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9895188184849929, line 1778, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9895188184849929, line 1781, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1797, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1798, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1799, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9895188184849929, line 1800, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1801, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1802, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1803, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1804, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1805, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1806, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1807, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1808, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9895188184849929, line 1809, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1811, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1812, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1825, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1826, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1827, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9895188184849929, line 1828, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1829, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1830, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1831, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9895188184849929, line 1832, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1833, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1834, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1835, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1836, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9895188184849929, line 1837, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1839, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9895188184849929, line 1840, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9838018103858981, line 581, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9838018103858981, line 582, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9838018103858981, line 583, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9838018103858981, line 584, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9838018103858981, line 585, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9838018103858981, line 587, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9838018103858981, line 588, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9838018103858981, line 589, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9838018103858981, line 591, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9838018103858981, line 592, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9838018103858981, line 593, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9838018103858981, line 679, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9838018103858981, line 680, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9838018103858981, line 681, file EigenDecompositionImpl.java
--ModifPoint:CtUnaryOperatorImpl, suspValue 0.9838018103858981, line 682, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9838018103858981, line 698, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9838018103858981, line 699, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9838018103858981, line 700, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9838018103858981, line 701, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 237, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 238, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 239, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 240, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9833253930443068, line 243, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9833253930443068, line 246, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 249, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9833253930443068, line 269, file ArrayRealVector.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 571, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 572, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 573, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 574, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 575, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 576, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 578, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9833253930443068, line 579, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 597, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 598, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 599, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 600, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 601, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 602, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 603, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 604, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 616, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 619, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 620, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 621, file EigenDecompositionImpl.java
--ModifPoint:CtForEachImpl, suspValue 0.9833253930443068, line 622, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 623, file EigenDecompositionImpl.java
--ModifPoint:CtSwitchImpl, suspValue 0.9833253930443068, line 624, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9833253930443068, line 672, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9833253930443068, line 676, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 677, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9833253930443068, line 678, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 693, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9833253930443068, line 696, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9833253930443068, line 697, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9833253930443068, line 708, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9833253930443068, line 709, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9828489757027156, line 283, file ArrayRealVector.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9828489757027156, line 284, file ArrayRealVector.java
--ModifPoint:CtForImpl, suspValue 0.9828489757027156, line 285, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9828489757027156, line 286, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9828489757027156, line 288, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9828489757027156, line 299, file ArrayRealVector.java
--ModifPoint:CtIfImpl, suspValue 0.9747498808956646, line 1287, file ArrayRealVector.java
--ModifPoint:CtReturnImpl, suspValue 0.9714149595045259, line 254, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9661743687470223, line 271, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9661743687470223, line 273, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9661743687470223, line 274, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9661743687470223, line 275, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9661743687470223, line 276, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9661743687470223, line 277, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9661743687470223, line 278, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9661743687470223, line 279, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9661743687470223, line 280, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9661743687470223, line 281, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9661743687470223, line 282, file Array2DRowRealMatrix.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9661743687470223, line 283, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9661743687470223, line 285, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9661743687470223, line 289, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.96141019533111, line 603, file AbstractRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.96141019533111, line 604, file AbstractRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.96141019533111, line 605, file AbstractRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.96141019533111, line 606, file AbstractRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.96141019533111, line 606, file AbstractRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.96141019533111, line 611, file AbstractRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.96141019533111, line 616, file AbstractRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9595045259647451, line 482, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9595045259647451, line 483, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9595045259647451, line 484, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9595045259647451, line 485, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9595045259647451, line 486, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9595045259647451, line 487, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9595045259647451, line 488, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9595045259647451, line 491, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9575988565983802, line 44, file DefaultRealMatrixPreservingVisitor.java
--ModifPoint:CtReturnImpl, suspValue 0.9575988565983802, line 919, file AbstractRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.957122439256789, line 160, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9561696045736064, line 650, file MatrixUtils.java
--ModifPoint:CtReturnImpl, suspValue 0.9547403525488328, line 106, file MatrixUtils.java
--ModifPoint:CtIfImpl, suspValue 0.9447355883754168, line 97, file ArrayRealVector.java
--ModifPoint:CtIfImpl, suspValue 0.9447355883754168, line 100, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9447355883754168, line 103, file ArrayRealVector.java
--ModifPoint:CtIfImpl, suspValue 0.9447355883754168, line 130, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9442591710338256, line 115, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9442591710338256, line 118, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9442591710338256, line 121, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9442591710338256, line 122, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9442591710338256, line 125, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9442591710338256, line 126, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9442591710338256, line 129, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9442591710338256, line 136, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9347308242020009, line 78, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9213911386374464, line 77, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.920438303954264, line 367, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9190090519294902, line 95, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.918532634587899, line 314, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.918532634587899, line 315, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.918532634587899, line 320, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.918532634587899, line 325, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.918532634587899, line 326, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.918532634587899, line 330, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.918532634587899, line 331, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.918532634587899, line 334, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.918532634587899, line 335, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.918532634587899, line 336, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.918532634587899, line 341, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.918532634587899, line 622, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.8947117675083374, line 410, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.894235350166746, line 404, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.8789899952358265, line 44, file AbstractRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.857551214864221, line 61, file AbstractRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.857551214864221, line 66, file AbstractRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.8565983801810386, line 56, file AbstractRealMatrix.java
Total suspicious from FL: 612,  539
Total ModPoint created: 539
Creating program variant #1, [Variant id: 1, #gens: 539, #ops: 0, parent:-]
Calculating fitness
Calculating fitness for original program variant.
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Test Failing is passing, Executing regression
Executing process: (timeout724secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.stat.data.LotteryTest  org.apache.commons.math.linear.FieldMatrixImplTest  org.apache.commons.math.ode.sampling.StepNormalizerTest  org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest  org.apache.commons.math.geometry.RotationOrderTest  org.apache.commons.math.analysis.solvers.NewtonSolverTest  org.apache.commons.math.estimation.EstimatedParameterTest  org.apache.commons.math.linear.CholeskyDecompositionImplTest  org.apache.commons.math.linear.Array2DRowRealMatrixTest  org.apache.commons.math.linear.SparseRealMatrixTest  org.apache.commons.math.util.OpenIntToFieldTest  org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest  org.apache.commons.math.optimization.fitting.PolynomialFitterTest  org.apache.commons.math.linear.ArrayRealVectorTest  org.apache.commons.math.distribution.HypergeometricDistributionTest  org.apache.commons.math.random.RandomAdaptorTest  org.apache.commons.math.ode.FirstOrderConverterTest  org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest  org.apache.commons.math.stat.inference.TestUtilsTest  org.apache.commons.math.stat.data.LewTest  org.apache.commons.math.distribution.GammaDistributionTest  org.apache.commons.math.stat.descriptive.rank.MedianTest  org.apache.commons.math.distribution.ZipfDistributionTest  org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest  org.apache.commons.math.stat.CertifiedDataTest  org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest  org.apache.commons.math.complex.FrenchComplexFormatTest  org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest  org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest  org.apache.commons.math.DuplicateSampleAbscissaExceptionTest  org.apache.commons.math.estimation.MinpackTest  org.apache.commons.math.genetics.FixedGenerationCountTest  org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest  org.apache.commons.math.fraction.BigFractionFormatTest  org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest  org.apache.commons.math.random.RandomDataTest  org.apache.commons.math.distribution.FDistributionTest  org.apache.commons.math.FunctionEvaluationExceptionTest  org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest  org.apache.commons.math.stat.inference.TTestFactoryTest  org.apache.commons.math.stat.descriptive.moment.SkewnessTest  org.apache.commons.math.special.GammaTest  org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest  org.apache.commons.math.analysis.integration.RombergIntegratorTest  org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest  org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest  org.apache.commons.math.stat.descriptive.SummaryStatisticsTest  org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest  org.apache.commons.math.stat.descriptive.moment.FirstMomentTest  org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest  org.apache.commons.math.complex.ComplexTest  org.apache.commons.math.distribution.BetaDistributionTest  org.apache.commons.math.special.ErfTest  org.apache.commons.math.special.BetaTest  org.apache.commons.math.ode.nonstiff.GillIntegratorTest  org.apache.commons.math.random.EmpiricalDistributionTest  org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest  org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest  org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest  org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest  org.apache.commons.math.random.AbstractRandomGeneratorTest  org.apache.commons.math.fraction.BigFractionFieldTest  org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest  org.apache.commons.math.genetics.GeneticAlgorithmTestBinary  org.apache.commons.math.linear.BiDiagonalTransformerTest  org.apache.commons.math.util.DefaultTransformerTest  org.apache.commons.math.linear.LUDecompositionImplTest  org.apache.commons.math.random.ValueServerTest  org.apache.commons.math.stat.descriptive.moment.MeanTest  org.apache.commons.math.util.BigRealFieldTest  org.apache.commons.math.linear.QRDecompositionImplTest  org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest  org.apache.commons.math.stat.descriptive.moment.VarianceTest  org.apache.commons.math.genetics.OnePointCrossoverTest  org.apache.commons.math.stat.ranking.NaturalRankingTest  org.apache.commons.math.optimization.linear.SimplexSolverTest  org.apache.commons.math.stat.descriptive.moment.FourthMomentTest  org.apache.commons.math.linear.BlockRealMatrixTest  org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest  org.apache.commons.math.random.MersenneTwisterTest  org.apache.commons.math.genetics.RandomKeyTest  org.apache.commons.math.stat.descriptive.summary.ProductTest  org.apache.commons.math.fraction.FractionTest  org.apache.commons.math.util.OpenIntToDoubleHashMapTest  org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest  org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest  org.apache.commons.math.genetics.ChromosomeTest  org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest  org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest  org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest  org.apache.commons.math.geometry.Vector3DTest  org.apache.commons.math.stat.descriptive.rank.MinTest  org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest  org.apache.commons.math.linear.FieldLUDecompositionImplTest  org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest  org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest  org.apache.commons.math.transform.FastHadamardTransformerTest  org.apache.commons.math.optimization.fitting.HarmonicFitterTest  org.apache.commons.math.stat.correlation.PearsonsCorrelationTest  org.apache.commons.math.random.GaussianRandomGeneratorTest  org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest  org.apache.commons.math.linear.FrenchRealVectorFormatTest  org.apache.commons.math.fraction.BigFractionTest  org.apache.commons.math.util.ContinuedFractionTest  org.apache.commons.math.util.TransformerMapTest  org.apache.commons.math.analysis.solvers.BisectionSolverTest  org.apache.commons.math.genetics.BinaryChromosomeTest  org.apache.commons.math.linear.BlockFieldMatrixTest  org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest  org.apache.commons.math.linear.SingularValueDecompositionImplTest  org.apache.commons.math.distribution.TDistributionTest  org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest  org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest  org.apache.commons.math.linear.InvalidMatrixExceptionTest  org.apache.commons.math.distribution.BinomialDistributionTest  org.apache.commons.math.linear.EigenSolverTest  org.apache.commons.math.stat.inference.TTestTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest  org.apache.commons.math.random.UniformRandomGeneratorTest  org.apache.commons.math.stat.descriptive.rank.PercentileTest  org.apache.commons.math.analysis.solvers.RiddersSolverTest  org.apache.commons.math.linear.ArrayFieldVectorTest  org.apache.commons.math.ode.ContinuousOutputModelTest  org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest  org.apache.commons.math.optimization.linear.SimplexTableauTest  org.apache.commons.math.ConvergenceExceptionTest  org.apache.commons.math.util.ResizableDoubleArrayTest  org.apache.commons.math.complex.ComplexFormatTest  org.apache.commons.math.linear.RealMatrixImplTest  org.apache.commons.math.stat.descriptive.summary.SumTest  org.apache.commons.math.linear.SparseFieldVectorTest  org.apache.commons.math.genetics.ElitisticListPopulationTest  org.apache.commons.math.stat.descriptive.summary.SumSqTest  org.apache.commons.math.linear.SparseRealVectorTest  org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest  org.apache.commons.math.linear.EigenDecompositionImplTest  org.apache.commons.math.analysis.integration.SimpsonIntegratorTest  org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest  org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest  org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations  org.apache.commons.math.stat.descriptive.moment.KurtosisTest  org.apache.commons.math.transform.FastFourierTransformerTest  org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest  org.apache.commons.math.distribution.NormalDistributionTest  org.apache.commons.math.distribution.PoissonDistributionTest  org.apache.commons.math.geometry.Vector3DFormatTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest  org.apache.commons.math.genetics.TournamentSelectionTest  org.apache.commons.math.optimization.general.MinpackTest  org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest  org.apache.commons.math.analysis.solvers.BrentSolverTest  org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest  org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest  org.apache.commons.math.estimation.WeightedMeasurementTest  org.apache.commons.math.stat.inference.ChiSquareTestTest  org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest  org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest  org.apache.commons.math.linear.MatrixIndexExceptionTest  org.apache.commons.math.genetics.BinaryMutationTest  org.apache.commons.math.fraction.FractionFormatTest  org.apache.commons.math.distribution.PascalDistributionTest  org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest  org.apache.commons.math.util.MathUtilsTest  org.apache.commons.math.complex.ComplexUtilsTest  org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest  org.apache.commons.math.optimization.direct.MultiDirectionalTest  org.apache.commons.math.genetics.FitnessCachingTest  org.apache.commons.math.linear.BigMatrixImplTest  org.apache.commons.math.stat.inference.ChiSquareFactoryTest  org.apache.commons.math.fraction.FractionFieldTest  org.apache.commons.math.stat.descriptive.InteractionTest  org.apache.commons.math.stat.correlation.CovarianceTest  org.apache.commons.math.optimization.univariate.BrentMinimizerTest  org.apache.commons.math.linear.QRSolverTest  org.apache.commons.math.linear.RealVectorFormatTest  org.apache.commons.math.analysis.solvers.LaguerreSolverTest  org.apache.commons.math.linear.CholeskySolverTest  org.apache.commons.math.distribution.WeibullDistributionTest  org.apache.commons.math.stat.StatUtilsTest  org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest  org.apache.commons.math.analysis.solvers.MullerSolverTest  org.apache.commons.math.linear.TriDiagonalTransformerTest  org.apache.commons.math.distribution.ChiSquareDistributionTest  org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest  org.apache.commons.math.transform.FastSineTransformerTest  org.apache.commons.math.stat.inference.OneWayAnovaTest  org.apache.commons.math.transform.FastCosineTransformerTest  org.apache.commons.math.ArgumentOutsideDomainExceptionTest  org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest  org.apache.commons.math.ode.nonstiff.EulerIntegratorTest  org.apache.commons.math.stat.descriptive.rank.MaxTest  org.apache.commons.math.complex.ComplexFieldTest  org.apache.commons.math.stat.descriptive.ListUnivariateImplTest  org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest  org.apache.commons.math.MaxIterationsExceededExceptionTest  org.apache.commons.math.linear.MatrixUtilsTest  org.apache.commons.math.optimization.direct.NelderMeadTest  org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest  org.apache.commons.math.geometry.RotationTest  org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest  org.apache.commons.math.linear.SingularValueSolverTest  org.apache.commons.math.genetics.RandomKeyMutationTest  org.apache.commons.math.util.BigRealTest  org.apache.commons.math.distribution.ExponentialDistributionTest  org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest  org.apache.commons.math.geometry.FrenchVector3DFormatTest  org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest  org.apache.commons.math.stat.regression.SimpleRegressionTest  org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest  org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest  org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest  org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest  org.apache.commons.math.linear.LUSolverTest  org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest  org.apache.commons.math.MathConfigurationExceptionTest  org.apache.commons.math.estimation.GaussNewtonEstimatorTest  org.apache.commons.math.genetics.ListPopulationTest  org.apache.commons.math.MathExceptionTest  org.apache.commons.math.distribution.CauchyDistributionTest  org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest  org.apache.commons.math.linear.SparseFieldMatrixTest  org.apache.commons.math.stat.descriptive.summary.SumLogTest  org.apache.commons.math.stat.FrequencyTest  org.apache.commons.math.stat.descriptive.moment.SecondMomentTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 2104] ,[]
The original fitness is : 1.0
----------------------------
---Configuration properties
p:lastJUnitVersion= ./examples/libs/junit-4.11.jar
p:alternativecompliancelevel= 8
p:ignoredTestCases= 
p:workingDirectory= /Users/marekmazur/astor/./output_astor
p:manipulatesuper= false
p:validation= process
p:jvm4testexecution= /Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin
p:operatorspace= irr-statements
p:diffcontext= 0
p:binjavafolder= /target/classes/
p:synthesis_depth= 3
p:gzoltartestpackagetoexclude= junit.framework
p:skipfitnessinitialpopulation= false
p:evosuiteresultfolder= evosuite
p:flthreshold= 0
p:regressionforfaultlocalization= true
p:collectonlyusedmethod= false
p:folderDiff= ./diffSolutions
p:preservelinenumbers= true
p:tmax2= 724030
p:tmax1= 10000
p:probagenmutation= false
p:nomodificationconvergence= 100
p:diff_type= relative
p:nolog= False
p:targetelementprocessor= statements
p:srctestfolder= /src/test/
p:forceExecuteRegression= false
p:clusteringfilename= clustering.csv
p:failing= org.apache.commons.math.linear.EigenDecompositionImplTest
p:logtestexecution= false
p:evo_buggy_class= true
p:numberExecutions= 1
p:maxnumbersolutions= 1000000
p:evo_affected_by_op= true
p:population= 1
p:maxCombinationVariableLimit= false
p:savesolution= true
p:javacompliancelevel= 8
p:uniqueoptogen= false
p:gzoltarpackagetonotinstrument= junit.framework
p:projectIdentifier= 
p:modificationpointnavigation= weight
p:stopfirst= true
p:multipointmodification= false
p:elementsToMutate= 10
p:jsonoutputname= astor_output
p:evoDSE= false
p:bintestfolder= /target/test-classes/
p:testbystep= false
p:version-location= ./math-version/
p:gzoltarVersion= 1.7.3
p:locationGzoltarJar= ./lib/
p:reintroduce= PARENTS:ORIGINAL
p:executorjar= ./lib/jtestex7.jar
p:maxGeneration= 1000000
p:max_synthesis_step= 10000
p:projectinfocommand= com.github.tdurieux:project-config-maven-plugin:info
p:maxVarCombination= 1000
p:includeZeros= false
p:maxtime= 60
p:evosuitejar= ./lib/evosuite-master-1.0.4-SNAPSHOT.jar
p:jvmversion= 1.8.0_202
p:commandTrunk= 50000
p:faultlocalization= flacoco
p:resetmodel= true
p:maxsuspcandidates= 1000
p:mode= jgenprog
p:learningdir= 
p:jvm4evosuitetestexecution= /Users/marekmazur/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin
p:filterfaultlocalization= true
p:mutationrate= 1 
p:pathToMVNRepository= 
p:resourcesfolder= /src/main/resources:/src/test/resources:
p:timezone= America/Los_Angeles
p:runjava7code= false
p:evoRunOnBuggyClass= true
p:compiler= fr.inria.astor.core.manipulation.bytecode.compiler.SpoonClassCompiler
p:limitbysuspicious= true
p:logsattemps= true
p:dependenciespath= /Users/marekmazur/astor/examples/libs/junit-4.4.jar
p:packageToInstrument= org.apache.commons
p:skipfaultlocalization= false
p:scope= local
p:transformingredient= false
p:fitnessfunction= fr.inria.astor.core.solutionsearch.population.TestCaseFitnessFunction
p:maxnumvariablesperingredient= 10
p:parsesourcefromoriginal= true
p:pvariantfoldername= variant-
p:savespoonmodelondisk= false
p:srcjavafolder= /src/java/
p:populationcontroller= fr.inria.astor.core.solutionsearch.population.TestCaseBasedFitnessPopulationController
p:ignoreflakyinfl= false
p:cleantemplates= true
p:applyCrossover= false
p:maxmodificationpoints= 1000
p:duplicateingredientsinspace= false
p:metid= 0
p:continuewhenmodelfail= true
p:saveall= false
p:seed= 10
p:savecompletepatched= true
p:resetoperations= false
p:keepcomments= true
p:processoutputinfile= false
p:location= /Users/marekmazur/astor/defects4j/math-80
p:probabilistictransformation= true
p:overridemaxtime= true
p:outputjsonresult= true
p:allpoints= false
p:antipattern= false
p:bugId= 280
p:evosuitetimeout= 120
p:maxtimefactor= 10
p:nrPlaceholders= 1
p:forcesubprocesskilling= false
----------------------------
----Starting Solution Search
----------Running generation: 1, population size: 1

***** Generation 1 : 0
**Parent Variant: [Variant id: 1, #gens: 539, #ops: 0, parent:-]

--Child created id: 2
--Creating new operations for variant [Variant id: 2, #gens: 539, #ops: 0, parent:1]
---analyzing modificationPoint position: 390
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  double pi = d[nM1] - lambda
---analyzing modificationPoint position: 137
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  for (int k = 0; i0 < n0; ++k) { 	if (k >= maxIter) { 		throw new org.apache.commons.math.linear.Inva[...]
---analyzing modificationPoint position: 31
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  // convergence hidden by negative DN. work[((4 * deflatedEnd) - 3) - pingPong] = 0.0
---analyzing modificationPoint position: 130
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2])
---analyzing modificationPoint position: 438
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java579
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < (m - 1); ++i) {  	final double dCurrent = main[i]; 	final double ePrevious = eCu[...] ` -topatch--> `// process split segments int i0 = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 579, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < (m - 1); ++i) {  	final double dCurrent = main[i]; 	final double ePrevious = eCu[...] ` -topatch--> `// process split segments int i0 = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 2, #gens: 540, #ops: 1, parent:1] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child does NOT compile: 2, errors: [EigenDecompositionImpl.java:862: error: <identifier> expected
					if (chooseLeft) { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda + work[4 * i];}} else { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda - work[4 * i];}}} 			begin = end;} 		// sort the realEigenvalues in decreasing order 		java.util.Arrays.sort(realEigenvalues); 		int j = realEigenvalues.length - 1; 		for (int i = 0; i < j; ++i) { 			final double tmp = realEigenvalues[i]; 			realEigenvalues[i] = realEigenvalues[j]; 			realEigenvalues[j] = tmp; 			--j;}} 	/**
					                  						                              							                                                            						                              							                                                      			     ^, EigenDecompositionImpl.java:863: error: class, interface, or enum expected
	 * Compute splitting points.
	 ^, EigenDecompositionImpl.java:865: error: <identifier> expected
	 * @return list of indices after matrix can be split
	    ^, EigenDecompositionImpl.java:865: error: class, interface, or enum expected
	 * @return list of indices after matrix can be split
	           ^, EigenDecompositionImpl.java:866: error: class, interface, or enum expected
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	                                                            		      ^, EigenDecompositionImpl.java:867: error: class, interface, or enum expected
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:870: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:872: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                    ^, EigenDecompositionImpl.java:872: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                                 		                                     ^, EigenDecompositionImpl.java:880: error: class, interface, or enum expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                     ^, EigenDecompositionImpl.java:884: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:886: error: class, interface, or enum expected
	 * @exception InvalidMatrixException
	              ^, EigenDecompositionImpl.java:888: error: class, interface, or enum expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                     ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                       ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			       ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		                                ^, EigenDecompositionImpl.java:902: error: class, interface, or enum expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                       ^, EigenDecompositionImpl.java:903: error: class, interface, or enum expected
			return;} 		// initial checks for splits (see Parlett & Marques section 3.3) 		flipIfWarranted(n, 2); 		// two iterations with Li's test for initial splits 		initialSplits(n); 		// initialize parameters used by goodStep 		tType = 0; 		dMin1 = 0; 		dMin2 = 0; 		dN = 0; 		dN1 = 0; 		dN2 = 0; 		tau = 0; 		// process split segments 		int i0 = 0; 		int n0 = n; 		while (n0 > 0) { 			// retrieve shift that was temporarily stored as a negative off-diagonal element 			sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2]; 			sigmaLow = 0; 			// find start of a new split segment to process 			double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6]; 			double offDiagMax = 0; 			double diagMax = work[(4 * n0) - 4]; 			double diagMin = diagMax; 			i0 = 0; 			for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { 				if (work[i + 2] <= 0) { 					i0 = 1 + (i / 4); 					break;} 				if (diagMin >= (4 * offDiagMax)) { 					diagMin = java.lang.Math.min(diagMin, work[i + 4]); 					offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);} 				diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]); 				offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);} 			work[(4 * n0) - 2] = offDiagMin; 			// lower bound of Gershgorin disk 			dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax))); 			pingPong = 0; 			int maxIter = 30 * (n0 - i0); 			for (int k = 0; i0 < n0; ++k) { 				if (k >= maxIter) { 					throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));} 				// perform one step 				n0 = goodStep(i0, n0); 				pingPong = 1 - pingPong; 				// check for new splits after "ping" steps 				// when the last elements of qd array are very small
			       ^, EigenDecompositionImpl.java:904: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0];
				                                                                                                                                                                                                                                                              					                    					^, EigenDecompositionImpl.java:905: error: class, interface, or enum expected
					offDiagMin = work[(4 * i0) + 2];
					^, EigenDecompositionImpl.java:906: error: class, interface, or enum expected
					double previousEMin = work[(4 * i0) + 3];
					^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					                     ^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					                                          ^, EigenDecompositionImpl.java:912: error: class, interface, or enum expected
							split = i / 4;
							^, EigenDecompositionImpl.java:913: error: class, interface, or enum expected
							diagMax = 0;
							^, EigenDecompositionImpl.java:914: error: class, interface, or enum expected
							offDiagMin = work[i + 6];
							^, EigenDecompositionImpl.java:915: error: class, interface, or enum expected
							previousEMin = work[i + 7];
							^, EigenDecompositionImpl.java:916: error: class, interface, or enum expected
						} else {
						^, EigenDecompositionImpl.java:918: error: class, interface, or enum expected
							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);
							^, EigenDecompositionImpl.java:919: error: class, interface, or enum expected
							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);
							^, EigenDecompositionImpl.java:920: error: class, interface, or enum expected
						}
						^, EigenDecompositionImpl.java:923: error: class, interface, or enum expected
					work[(4 * n0) - 1] = previousEMin;
					^, EigenDecompositionImpl.java:924: error: class, interface, or enum expected
					i0 = split + 1;
					^, EigenDecompositionImpl.java:925: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:937: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) {
	    	                                 ^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		                ^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		                       ^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			                                       ^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			                                               ^, EigenDecompositionImpl.java:946: error: class, interface, or enum expected
					d = work[i];
					^, EigenDecompositionImpl.java:947: error: class, interface, or enum expected
				} else {
				^, EigenDecompositionImpl.java:949: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			                           ^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			                                              ^, EigenDecompositionImpl.java:955: error: class, interface, or enum expected
				final int j = (i - (2 * pingPong)) - 1;
				      ^, EigenDecompositionImpl.java:956: error: class, interface, or enum expected
				work[j] = d + work[i];
				^, EigenDecompositionImpl.java:957: error: class, interface, or enum expected
				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {
				^, EigenDecompositionImpl.java:959: error: class, interface, or enum expected
					work[j] = d;
					^, EigenDecompositionImpl.java:960: error: class, interface, or enum expected
					work[j + 2] = 0.0;
					^, EigenDecompositionImpl.java:961: error: class, interface, or enum expected
					d = work[i + 2];
					^, EigenDecompositionImpl.java:962: error: class, interface, or enum expected
				} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && 
				^, EigenDecompositionImpl.java:964: error: class, interface, or enum expected
					final double tmp = work[i + 2] / work[j];
					      ^, EigenDecompositionImpl.java:965: error: class, interface, or enum expected
					work[j + 2] = work[i] * tmp;
					^, EigenDecompositionImpl.java:966: error: class, interface, or enum expected
					d *= tmp;
					^, EigenDecompositionImpl.java:967: error: class, interface, or enum expected
				} else {
				^, EigenDecompositionImpl.java:969: error: class, interface, or enum expected
					d *= work[i + 2] / work[j];
					^, EigenDecompositionImpl.java:970: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:975: error: class, interface, or enum expected
			pingPong = 1 - pingPong;
			^, EigenDecompositionImpl.java:977: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:994: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0;
	    	                           ^, EigenDecompositionImpl.java:994: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0;
	    	                                            ^, EigenDecompositionImpl.java:997: error: class, interface, or enum expected
		int deflatedEnd = end;
		^, EigenDecompositionImpl.java:998: error: class, interface, or enum expected
		for (boolean deflating = true; deflating;) {
		^, EigenDecompositionImpl.java:998: error: class, interface, or enum expected
		for (boolean deflating = true; deflating;) {
		                               ^, EigenDecompositionImpl.java:998: error: class, interface, or enum expected
		for (boolean deflating = true; deflating;) {
		                                         ^, EigenDecompositionImpl.java:1003: error: class, interface, or enum expected
			}
			^, EigenDecompositionImpl.java:1005: error: class, interface, or enum expected
			final int k = ((4 * deflatedEnd) + pingPong) - 1;
			      ^, EigenDecompositionImpl.java:1007: error: class, interface, or enum expected
			if ((start == (deflatedEnd - 1)) || 
			^, EigenDecompositionImpl.java:1014: error: class, interface, or enum expected
				deflatedEnd -= 1;
				^, EigenDecompositionImpl.java:1016: error: class, interface, or enum expected
			} else if (((start == (deflatedEnd - 2)) || 
			^, EigenDecompositionImpl.java:1022: error: class, interface, or enum expected
					final double tmp = work[k - 3];
					      ^, EigenDecompositionImpl.java:1023: error: class, interface, or enum expected
					work[k - 3] = work[k - 7];
					^, EigenDecompositionImpl.java:1024: error: class, interface, or enum expected
					work[k - 7] = tmp;
					^, EigenDecompositionImpl.java:1025: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:1029: error: class, interface, or enum expected
					double s = work[k - 3] * (work[k - 5] / t);
					^]
Ingredient counter is Zero
---Undoing: gnrtn(1): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < (m - 1); ++i) {  	final double dCurrent = main[i]; 	final double ePrevious = eCu[...] ` -topatch--> `// process split segments int i0 = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (1(f=1.0), 2(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (1(f=1.0), )
----------Running generation: 2, population size: 1

***** Generation 2 : 0
**Parent Variant: [Variant id: 3, #gens: 539, #ops: 0, parent:-]

--Child created id: 4
--Creating new operations for variant [Variant id: 4, #gens: 539, #ops: 0, parent:3]
---analyzing modificationPoint position: 320
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  sigma = t
---analyzing modificationPoint position: 457
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  for (int i = 0; i < j; ++i) { 	final double tmp = realEigenvalues[i]; 	realEigenvalues[i] = realEige[...]
---analyzing modificationPoint position: 97
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  final double s = secondary[i]
---analyzing modificationPoint position: 250
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 3 not mutation generated in  int j4p2 = (j4 + (2 * pingPong)) - 1
---analyzing modificationPoint position: 185
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  // perform a dqd step (i.e. no shift) dqd(start, deflatedEnd)
---analyzing modificationPoint position: 195
location: EigenDecompositionImpl.java1164
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 4, #gens: 538, #ops: 1, parent:3] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 4
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-4/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 10, was successful: false, cases executed: 18] ,[]
-Valid?: |false|10|18|[]|, fitness 10.0
Ingredient counter is Zero
---Undoing: gnrtn(2): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (3(f=1.0), 4(f=10.0), )
Selected to next generation: IDs2--> (3(f=1.0), )
----------Running generation: 3, population size: 1

***** Generation 3 : 0
**Parent Variant: [Variant id: 5, #gens: 539, #ops: 0, parent:-]

--Child created id: 6
--Creating new operations for variant [Variant id: 6, #gens: 539, #ops: 0, parent:5]
---analyzing modificationPoint position: 251
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  work[j4 - 2] = dN2 + work[j4p2]
---analyzing modificationPoint position: 389
---modifPoint 1 not mutation generated in  final int nM1 = d.length - 1
---analyzing modificationPoint position: 14
Templates availables42
Attempts Base Ingredients  1 total 42
---modifPoint 2 not mutation generated in  for (int i = 0; i < j; i += 4) { 	for (int k = 0; k < 4; k += step) { 		final double tmp = work[i + [...]
---analyzing modificationPoint position: 118
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  while (n0 > 0) {  	// retrieve shift that was temporarily stored as a negative off-diagonal element [...]
---analyzing modificationPoint position: 201
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1176
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// search lower eigenvalue double left = lower - margin ` -topatch--> `double s = 0.0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1176, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// search lower eigenvalue double left = lower - margin ` -topatch--> `double s = 0.0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 6, #gens: 540, #ops: 1, parent:5] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child does NOT compile: 6, errors: [EigenDecompositionImpl.java:1465: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			^, EigenDecompositionImpl.java:1465: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                    ^, EigenDecompositionImpl.java:1465: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                     ^, EigenDecompositionImpl.java:1465: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                           ^, EigenDecompositionImpl.java:1465: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                     ^, EigenDecompositionImpl.java:1465: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                 ^, EigenDecompositionImpl.java:1465: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                     ^, EigenDecompositionImpl.java:1465: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				    ^, EigenDecompositionImpl.java:1465: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				               ^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				      ^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			      ^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				               ^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				              ^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		                                    ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                   ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                    ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                       ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				        ^, EigenDecompositionImpl.java:1476: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				           		             ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                          ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                       ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			      ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			      ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			      ^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			^, EigenDecompositionImpl.java:1490: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			                                     ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                        ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                         ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                               ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                      ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				      ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                          ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                               ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                      ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				      ^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1498: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				                                              ^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1504: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                       ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                        ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                               ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                     ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					           ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                          ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                               ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                     ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					           ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1506: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                              ^]
Ingredient counter is Zero
---Undoing: gnrtn(3): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// search lower eigenvalue double left = lower - margin ` -topatch--> `double s = 0.0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (5(f=1.0), 6(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (5(f=1.0), )
----------Running generation: 4, population size: 1

***** Generation 4 : 0
**Parent Variant: [Variant id: 7, #gens: 539, #ops: 0, parent:-]

--Child created id: 8
--Creating new operations for variant [Variant id: 8, #gens: 539, #ops: 0, parent:7]
---analyzing modificationPoint position: 527
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  if (nCols == 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException[...]
---analyzing modificationPoint position: 195
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dMin1, dN1, tau]
--> var from patch: dMin1 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: dN1 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1164
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `if (dMin1 == dN1) { 	tau = 0.5 * dMin1; }` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1164, pointed element: CtIfImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `if (dMin1 == dN1) { 	tau = 0.5 * dMin1; }` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 8, #gens: 540, #ops: 1, parent:7] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 8, errors: [EigenDecompositionImpl.java:1627: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			^, EigenDecompositionImpl.java:1627: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                    ^, EigenDecompositionImpl.java:1627: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                     ^, EigenDecompositionImpl.java:1627: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                           ^, EigenDecompositionImpl.java:1627: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                     ^, EigenDecompositionImpl.java:1627: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                 ^, EigenDecompositionImpl.java:1627: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                     ^, EigenDecompositionImpl.java:1627: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				    ^, EigenDecompositionImpl.java:1627: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				               ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				      ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			      ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				               ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				              ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		                                    ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                   ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                    ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                       ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				        ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				           		             ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                          ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                       ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			      ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			      ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			      ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			                                     ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                        ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                         ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                               ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                      ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				      ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                          ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                               ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                      ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				      ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				                                              ^, EigenDecompositionImpl.java:1664: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1666: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                       ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                        ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                               ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                     ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					           ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                          ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                               ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                     ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					           ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                              ^]
Ingredient counter is Zero
---Undoing: gnrtn(4): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.max(upper, work[(upperStart + index) + i]) ` -topatch--> `if (dMin1 == dN1) { 	tau = 0.5 * dMin1; }` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (7(f=1.0), 8(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (7(f=1.0), )
----------Running generation: 5, population size: 1

***** Generation 5 : 0
**Parent Variant: [Variant id: 9, #gens: 539, #ops: 0, parent:-]

--Child created id: 10
--Creating new operations for variant [Variant id: 10, #gens: 539, #ops: 0, parent:9]
---analyzing modificationPoint position: 430
location: ArrayRealVector.java269
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtReturnImpl) `return subtract(((org.apache.commons.math.linear.ArrayRealVector) (v))) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 10, #gens: 538, #ops: 1, parent:9] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 10, errors: [ArrayRealVector.java:279: error: missing return statement
	}
	^]
Ingredient counter is Zero
---Undoing: gnrtn(5): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtReturnImpl) `return subtract(((org.apache.commons.math.linear.ArrayRealVector) (v))) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (9(f=1.0), 10(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (9(f=1.0), )
----------Running generation: 6, population size: 1

***** Generation 6 : 0
**Parent Variant: [Variant id: 11, #gens: 539, #ops: 0, parent:-]

--Child created id: 12
--Creating new operations for variant [Variant id: 12, #gens: 539, #ops: 0, parent:11]
---analyzing modificationPoint position: 29
location: EigenDecompositionImpl.java1414
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 12, #gens: 538, #ops: 1, parent:11] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 12
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-12/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(6): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (11(f=1.0), 12(f=1.0), )
Selected to next generation: IDs2--> (11(f=1.0), )
----------Running generation: 7, population size: 1

***** Generation 7 : 0
**Parent Variant: [Variant id: 13, #gens: 539, #ops: 0, parent:-]

--Child created id: 14
--Creating new operations for variant [Variant id: 14, #gens: 539, #ops: 0, parent:13]
---analyzing modificationPoint position: 303
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...]
---analyzing modificationPoint position: 293
location: EigenDecompositionImpl.java1408
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) &&  ((org.ap[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 14, #gens: 538, #ops: 1, parent:13] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 14
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-14/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 18] ,[]
-Valid?: |false|9|18|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(7): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) &&  ((org.ap[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (13(f=1.0), 14(f=9.0), )
Selected to next generation: IDs2--> (13(f=1.0), )
----------Running generation: 8, population size: 1

***** Generation 8 : 0
**Parent Variant: [Variant id: 15, #gens: 539, #ops: 0, parent:-]

--Child created id: 16
--Creating new operations for variant [Variant id: 16, #gens: 539, #ops: 0, parent:15]
---analyzing modificationPoint position: 477
---modifPoint 0 not mutation generated in  final double[] dataRow = data[row]
---analyzing modificationPoint position: 269
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  work[j4 - 2] = d + work[j4 - 1]
---analyzing modificationPoint position: 517
Templates availables83
Attempts Base Ingredients  1 total 83
---modifPoint 2 not mutation generated in  data = d.clone()
---analyzing modificationPoint position: 368
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  z = 1
---analyzing modificationPoint position: 22
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  dN1 = work[j4p2 + 2]
---analyzing modificationPoint position: 271
location: EigenDecompositionImpl.java1343
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) &&  ((org.apac[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 16, #gens: 538, #ops: 1, parent:15] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 16
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-16/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 18] ,[]
-Valid?: |false|9|18|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(8): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) &&  ((org.apac[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (15(f=1.0), 16(f=9.0), )
Selected to next generation: IDs2--> (15(f=1.0), )
----------Running generation: 9, population size: 1

***** Generation 9 : 0
**Parent Variant: [Variant id: 17, #gens: 539, #ops: 0, parent:-]

--Child created id: 18
--Creating new operations for variant [Variant id: 18, #gens: 539, #ops: 0, parent:17]
---analyzing modificationPoint position: 342
Templates availables42
Attempts Base Ingredients  1 total 42
---modifPoint 0 not mutation generated in  for (int i = 1; i < m; ++i) { 	final double eiM1 = secondary[i - 1]; 	final double ratio = eiM1 / di[...]
---analyzing modificationPoint position: 329
Templates availables45
Attempts Base Ingredients  1 total 45
vars from patch []
location: ArrayRealVector.java889
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return dot ` -topatch--> `return true` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.ArrayRealVector line: 889, pointed element: CtReturnImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return dot ` -topatch--> `return true` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 18, #gens: 539, #ops: 1, parent:17] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 18, errors: [ArrayRealVector.java:1302: error: incompatible types: boolean cannot be converted to double
		return true;} 	/**
		       ^]
Ingredient counter is Zero
---Undoing: gnrtn(9): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return dot ` -topatch--> `return true` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (17(f=1.0), 18(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (17(f=1.0), )
----------Running generation: 10, population size: 1

***** Generation 10 : 0
**Parent Variant: [Variant id: 19, #gens: 539, #ops: 0, parent:-]

--Child created id: 20
--Creating new operations for variant [Variant id: 20, #gens: 539, #ops: 0, parent:19]
---analyzing modificationPoint position: 484
---modifPoint 0 not mutation generated in  return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false)
---analyzing modificationPoint position: 481
Templates availables120
Attempts Base Ingredients  1 total 120
vars from patch []
location: Array2DRowRealMatrix.java282
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < nSum; i++) { 	sum += dataRow[i] * m.data[i][col]; } ` -topatch--> `final int columnCount = getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 282, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < nSum; i++) { 	sum += dataRow[i] * m.data[i][col]; } ` -topatch--> `final int columnCount = getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 20, #gens: 540, #ops: 1, parent:19] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 20
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-20/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(10): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < nSum; i++) { 	sum += dataRow[i] * m.data[i][col]; } ` -topatch--> `final int columnCount = getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (19(f=1.0), 20(f=1.0), )
Selected to next generation: IDs2--> (19(f=1.0), )
----------Running generation: 11, population size: 1

***** Generation 11 : 0
**Parent Variant: [Variant id: 21, #gens: 539, #ops: 0, parent:-]

--Child created id: 22
--Creating new operations for variant [Variant id: 22, #gens: 539, #ops: 0, parent:21]
---analyzing modificationPoint position: 180
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // step 4a: dqds for (boolean loop = true; loop;) {  	// perform one dqds step with the chosen shift[...]
---analyzing modificationPoint position: 73
Templates availables281
Attempts Base Ingredients  1 total 281
---modifPoint 1 not mutation generated in  sum += a * a
---analyzing modificationPoint position: 369
location: EigenDecompositionImpl.java1769
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = r + 1; i < m; ++i) { 	z *= -work[(6 * i) - 1]; 	eigenvector[i] = z; 	n2 += z * z; } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 22, #gens: 538, #ops: 1, parent:21] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 22
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-22/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 7, was successful: false, cases executed: 18] ,[]
-Valid?: |false|7|18|[]|, fitness 7.0
Ingredient counter is Zero
---Undoing: gnrtn(11): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = r + 1; i < m; ++i) { 	z *= -work[(6 * i) - 1]; 	eigenvector[i] = z; 	n2 += z * z; } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (21(f=1.0), 22(f=7.0), )
Selected to next generation: IDs2--> (21(f=1.0), )
----------Running generation: 12, population size: 1

***** Generation 12 : 0
**Parent Variant: [Variant id: 23, #gens: 539, #ops: 0, parent:-]

--Child created id: 24
--Creating new operations for variant [Variant id: 24, #gens: 539, #ops: 0, parent:23]
---analyzing modificationPoint position: 353
---modifPoint 0 not mutation generated in  // select the twist index leading to // the least diagonal element in the twisted factorization int [...]
---analyzing modificationPoint position: 523
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 1 not mutation generated in  if (column > 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalStateException( 	[...]
---analyzing modificationPoint position: 396
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  final double t = di / diP1
---analyzing modificationPoint position: 411
Templates availables241
Attempts Base Ingredients  1 total 241
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [cachedV, m]
--> var from patch: cachedV spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: m spoon.support.reflect.code.CtVariableReadImpl
location: EigenDecompositionImpl.java589
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Math.min(lowerSpectra, lower) ` -topatch--> `cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 589, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Math.min(lowerSpectra, lower) ` -topatch--> `cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 24, #gens: 539, #ops: 1, parent:23] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 24
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-24/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 6, was successful: false, cases executed: 18] ,[]
-Valid?: |false|6|18|[]|, fitness 6.0
Ingredient counter is Zero
---Undoing: gnrtn(12): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Math.min(lowerSpectra, lower) ` -topatch--> `cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (23(f=1.0), 24(f=6.0), )
Selected to next generation: IDs2--> (23(f=1.0), )
----------Running generation: 13, population size: 1

***** Generation 13 : 0
**Parent Variant: [Variant id: 25, #gens: 539, #ops: 0, parent:-]

--Child created id: 26
--Creating new operations for variant [Variant id: 26, #gens: 539, #ops: 0, parent:25]
---analyzing modificationPoint position: 422
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 0 not mutation generated in  if (java.lang.Math.abs(secondary[i]) <= max) { 	list.add(i + 1); 	secondary[i] = 0; 	squaredSecondar[...]
---analyzing modificationPoint position: 230
Templates availables20
Attempts Base Ingredients  1 total 20
---modifPoint 1 not mutation generated in  return count
---analyzing modificationPoint position: 123
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  double diagMax = work[(4 * n0) - 4]
---analyzing modificationPoint position: 108
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  // two iterations with Li's test for initial splits initialSplits(n)
---analyzing modificationPoint position: 51
Templates availables281
Attempts Base Ingredients  1 total 281
vars from patch [data]
--> var from patch: data spoon.support.reflect.code.CtFieldReadImpl
location: ArrayRealVector.java225
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtReturnImpl) `return new org.apache.commons.math.linear.ArrayRealVector(this, true) ` -topatch--> `return data` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.ArrayRealVector line: 225, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtReturnImpl) `return new org.apache.commons.math.linear.ArrayRealVector(this, true) ` -topatch--> `return data` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 26, #gens: 540, #ops: 1, parent:25] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child does NOT compile: 26, errors: [ArrayRealVector.java:864: error: incompatible types: double[] cannot be converted to org.apache.commons.math.linear.RealVector
		return data; 		return new org.apache.commons.math.linear.ArrayRealVector(this, true);} 	/**
		       ^]
Ingredient counter is Zero
---Undoing: gnrtn(13): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtReturnImpl) `return new org.apache.commons.math.linear.ArrayRealVector(this, true) ` -topatch--> `return data` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (25(f=1.0), 26(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (25(f=1.0), )
----------Running generation: 14, population size: 1

***** Generation 14 : 0
**Parent Variant: [Variant id: 27, #gens: 539, #ops: 0, parent:-]

--Child created id: 28
--Creating new operations for variant [Variant id: 28, #gens: 539, #ops: 0, parent:27]
---analyzing modificationPoint position: 357
---modifPoint 0 not mutation generated in  final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10]))
---analyzing modificationPoint position: 224
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  double ratio = main[index] - t
---analyzing modificationPoint position: 371
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  for (int i = 0; i < m; ++i) { 	eigenvector[i] *= inv; }
---analyzing modificationPoint position: 272
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [realEigenvalues]
--> var from patch: realEigenvalues spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1345
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double tmp = work[j4 + 1] / work[j4 - 2] ` -topatch--> `return realEigenvalues.clone()` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1345, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double tmp = work[j4 + 1] / work[j4 - 2] ` -topatch--> `return realEigenvalues.clone()` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 28, #gens: 540, #ops: 1, parent:27] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child does NOT compile: 28, errors: [EigenDecompositionImpl.java:1346: error: incompatible types: unexpected return value
					final double tmp = work[j4 + 1] / work[j4 - 2]; 					return realEigenvalues.clone();
					                                                					                            ^]
Ingredient counter is Zero
---Undoing: gnrtn(14): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double tmp = work[j4 + 1] / work[j4 - 2] ` -topatch--> `return realEigenvalues.clone()` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (27(f=1.0), 28(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (27(f=1.0), )
----------Running generation: 15, population size: 1

***** Generation 15 : 0
**Parent Variant: [Variant id: 29, #gens: 539, #ops: 0, parent:-]

--Child created id: 30
--Creating new operations for variant [Variant id: 30, #gens: 539, #ops: 0, parent:29]
---analyzing modificationPoint position: 253
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau
---analyzing modificationPoint position: 182
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [eMin, work, start, pingPong]
--> var from patch: eMin spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: start spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1081
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `// check result of the dqds step if ((dMin >= 0) && (dMin1 > 0)) { 	// the shift was good 	updateSig[...] ` -topatch--> `eMin = work[((4 * start) + pingPong) + 4]` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1081, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `// check result of the dqds step if ((dMin >= 0) && (dMin1 > 0)) { 	// the shift was good 	updateSig[...] ` -topatch--> `eMin = work[((4 * start) + pingPong) + 4]` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 30, #gens: 540, #ops: 1, parent:29] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 30, errors: [EigenDecompositionImpl.java:1276: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1276: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1276: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1276: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1276: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1278: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1278: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1279: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1279: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1279: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1279: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1280: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1281: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1281: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1281: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1281: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1281: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1281: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1281: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1281: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1282: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1282: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1282: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1282: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1282: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1282: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1282: error: ';' expected
	 * 		only every other element)
	   		                        ^, EigenDecompositionImpl.java:1283: error: <identifier> expected
	 * @return true if qd array was flipped
	    ^, EigenDecompositionImpl.java:1283: error: <identifier> expected
	 * @return true if qd array was flipped
	          ^, EigenDecompositionImpl.java:1283: error: ';' expected
	 * @return true if qd array was flipped
	               ^, EigenDecompositionImpl.java:1283: error: ';' expected
	 * @return true if qd array was flipped
	                           ^, EigenDecompositionImpl.java:1283: error: ';' expected
	 * @return true if qd array was flipped
	                                       ^, EigenDecompositionImpl.java:1284: error: illegal start of expression
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	^, EigenDecompositionImpl.java:1284: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                               ^, EigenDecompositionImpl.java:1284: error: <identifier> expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                            ^, EigenDecompositionImpl.java:1284: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                                           ^, EigenDecompositionImpl.java:1285: error: illegal start of expression
	 * Compute an interval containing all realEigenvalues of a block.
	 ^, EigenDecompositionImpl.java:1285: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	          ^, EigenDecompositionImpl.java:1285: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                      ^, EigenDecompositionImpl.java:1285: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                                     ^, EigenDecompositionImpl.java:1285: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                                                        ^, EigenDecompositionImpl.java:1285: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                                                                ^, EigenDecompositionImpl.java:1287: error: <identifier> expected
	 * @param index
	               ^, EigenDecompositionImpl.java:1288: error: ';' expected
	 * 		index of the first row of the block
	   		        ^, EigenDecompositionImpl.java:1288: error: ';' expected
	 * 		index of the first row of the block
	   		                  ^, EigenDecompositionImpl.java:1288: error: ';' expected
	 * 		index of the first row of the block
	   		                         ^, EigenDecompositionImpl.java:1288: error: ';' expected
	 * 		index of the first row of the block
	   		                                   ^, EigenDecompositionImpl.java:1289: error: <identifier> expected
	 * @param n
	           ^, EigenDecompositionImpl.java:1290: error: ';' expected
	 * 		number of rows of the block
	   		         ^, EigenDecompositionImpl.java:1290: error: ';' expected
	 * 		number of rows of the block
	   		                 ^, EigenDecompositionImpl.java:1290: error: ';' expected
	 * 		number of rows of the block
	   		                           ^, EigenDecompositionImpl.java:1291: error: <identifier> expected
	 * @return an interval containing the realEigenvalues
	    ^, EigenDecompositionImpl.java:1291: error: ';' expected
	 * @return an interval containing the realEigenvalues
	             ^, EigenDecompositionImpl.java:1291: error: ';' expected
	 * @return an interval containing the realEigenvalues
	                                 ^, EigenDecompositionImpl.java:1291: error: ';' expected
	 * @return an interval containing the realEigenvalues
	                                                     ^, EigenDecompositionImpl.java:1292: error: illegal start of expression
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
	    	^, EigenDecompositionImpl.java:1292: error: ';' expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
	    	                                 ^, EigenDecompositionImpl.java:1292: error: <identifier> expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
	    	                                                  ^, EigenDecompositionImpl.java:1292: error: ';' expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
	    	                                                              ^, EigenDecompositionImpl.java:1294: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		     ^, EigenDecompositionImpl.java:1294: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		^, EigenDecompositionImpl.java:1294: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		      ^, EigenDecompositionImpl.java:1294: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		                   ^, EigenDecompositionImpl.java:1294: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		                          ^, EigenDecompositionImpl.java:1294: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		                                 ^, EigenDecompositionImpl.java:1294: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		                                    ^, EigenDecompositionImpl.java:1304: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                   ^, EigenDecompositionImpl.java:1304: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1304: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                    ^, EigenDecompositionImpl.java:1304: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		^, EigenDecompositionImpl.java:1304: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		^, EigenDecompositionImpl.java:1304: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                ^, EigenDecompositionImpl.java:1304: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                       ^, EigenDecompositionImpl.java:1304: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			^, EigenDecompositionImpl.java:1304: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				        ^, EigenDecompositionImpl.java:1304: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				           		             ^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                          ^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                ^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                       ^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			      ^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			      ^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			      ^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			^, EigenDecompositionImpl.java:1318: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			                                     ^, EigenDecompositionImpl.java:1326: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                        ^, EigenDecompositionImpl.java:1326: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                         ^, EigenDecompositionImpl.java:1326: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		^, EigenDecompositionImpl.java:1326: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		^, EigenDecompositionImpl.java:1326: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		^, EigenDecompositionImpl.java:1326: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		^, EigenDecompositionImpl.java:1326: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                               ^, EigenDecompositionImpl.java:1326: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                      ^, EigenDecompositionImpl.java:1326: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				      ^, EigenDecompositionImpl.java:1326: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				^]
Ingredient counter is Zero
---Undoing: gnrtn(15): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `// check result of the dqds step if ((dMin >= 0) && (dMin1 > 0)) { 	// the shift was good 	updateSig[...] ` -topatch--> `eMin = work[((4 * start) + pingPong) + 4]` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (29(f=1.0), 30(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (29(f=1.0), )
----------Running generation: 16, population size: 1

***** Generation 16 : 0
**Parent Variant: [Variant id: 31, #gens: 539, #ops: 0, parent:-]

--Child created id: 32
--Creating new operations for variant [Variant id: 32, #gens: 539, #ops: 0, parent:31]
---analyzing modificationPoint position: 523
Templates availables11
Attempts Base Ingredients  1 total 11
---modifPoint 0 not mutation generated in  if (column > 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalStateException( 	[...]
---analyzing modificationPoint position: 473
Templates availables23
Attempts Base Ingredients  1 total 23
---modifPoint 1 not mutation generated in  final int nCols = m.getColumnDimension()
---analyzing modificationPoint position: 396
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 2 not mutation generated in  final double t = di / diP1
---analyzing modificationPoint position: 487
Templates availables216
Attempts Base Ingredients  1 total 216
---modifPoint 3 not mutation generated in  final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows)
---analyzing modificationPoint position: 264
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  eMin = work[((4 * start) + pingPong) + 4]
---analyzing modificationPoint position: 137
Templates availables42
Attempts Base Ingredients  1 total 42
---modifPoint 5 not mutation generated in  for (int k = 0; i0 < n0; ++k) { 	if (k >= maxIter) { 		throw new org.apache.commons.math.linear.Inva[...]
---analyzing modificationPoint position: 357
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 6 not mutation generated in  final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10]))
---analyzing modificationPoint position: 404
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 7 not mutation generated in  final double dCurrent = main[i]
---analyzing modificationPoint position: 190
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 8 not mutation generated in  final int upperStart = 5 * main.length
---analyzing modificationPoint position: 86
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [main]
--> var from patch: main spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1029
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if (s <= t) { 	s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t)))); } els[...] ` -topatch--> `// splitting preserving relative accuracy double absDCurrent = java.lang.Math.abs(main[0])` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1029, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if (s <= t) { 	s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t)))); } els[...] ` -topatch--> `// splitting preserving relative accuracy double absDCurrent = java.lang.Math.abs(main[0])` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 32, #gens: 540, #ops: 1, parent:31] gen mutated: 1 , gen not mut: 9, gen not applied  0
-The child compiles: id 32
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-32/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(16): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if (s <= t) { 	s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t)))); } els[...] ` -topatch--> `// splitting preserving relative accuracy double absDCurrent = java.lang.Math.abs(main[0])` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (31(f=1.0), 32(f=1.0), )
Selected to next generation: IDs2--> (31(f=1.0), )
----------Running generation: 17, population size: 1

***** Generation 17 : 0
**Parent Variant: [Variant id: 33, #gens: 539, #ops: 0, parent:-]

--Child created id: 34
--Creating new operations for variant [Variant id: 34, #gens: 539, #ops: 0, parent:33]
---analyzing modificationPoint position: 406
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  eCurrent = java.lang.Math.abs(secondary[i])
---analyzing modificationPoint position: 223
---modifPoint 1 not mutation generated in  return new double[]{ lower, upper }
---analyzing modificationPoint position: 245
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 	work[j4 - 2] = d + work[j4 - 1]; 	[...]
---analyzing modificationPoint position: 487
Templates availables216
Attempts Base Ingredients  1 total 216
---modifPoint 3 not mutation generated in  final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows)
---analyzing modificationPoint position: 465
Templates availables281
Attempts Base Ingredients  1 total 281
---modifPoint 4 not mutation generated in  for (int i = 0; i < data.length; i++) { 	out[i] = data[i] - v[i]; }
---analyzing modificationPoint position: 37
---modifPoint 5 not mutation generated in  return eigenvectors[i].copy()
---analyzing modificationPoint position: 447
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dN1]
--> var from patch: dN1 spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java616
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// compute splitting points java.util.List<java.lang.Integer> splitIndices = computeSplits() ` -topatch--> `dN1 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 616, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// compute splitting points java.util.List<java.lang.Integer> splitIndices = computeSplits() ` -topatch--> `dN1 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 34, #gens: 540, #ops: 1, parent:33] gen mutated: 1 , gen not mut: 6, gen not applied  0
-The child does NOT compile: 34, errors: [EigenDecompositionImpl.java:852: error: <identifier> expected
					if (chooseLeft) { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda + work[4 * i];}} else { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda - work[4 * i];}}} 			begin = end;} 		// sort the realEigenvalues in decreasing order 		java.util.Arrays.sort(realEigenvalues); 		int j = realEigenvalues.length - 1; 		for (int i = 0; i < j; ++i) { 			final double tmp = realEigenvalues[i]; 			realEigenvalues[i] = realEigenvalues[j]; 			realEigenvalues[j] = tmp; 			--j;}} 	/**
					                  						                              							                                                            						                              							                                                      			     ^, EigenDecompositionImpl.java:853: error: class, interface, or enum expected
	 * Compute splitting points.
	 ^, EigenDecompositionImpl.java:855: error: <identifier> expected
	 * @return list of indices after matrix can be split
	    ^, EigenDecompositionImpl.java:855: error: class, interface, or enum expected
	 * @return list of indices after matrix can be split
	           ^, EigenDecompositionImpl.java:856: error: class, interface, or enum expected
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	                                                            		      ^, EigenDecompositionImpl.java:857: error: class, interface, or enum expected
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:860: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:862: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                    ^, EigenDecompositionImpl.java:862: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                                 		                                     ^, EigenDecompositionImpl.java:870: error: class, interface, or enum expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                     ^, EigenDecompositionImpl.java:874: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:876: error: class, interface, or enum expected
	 * @exception InvalidMatrixException
	              ^, EigenDecompositionImpl.java:878: error: class, interface, or enum expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                     ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                       ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		      ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		      ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		      ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		      ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			      ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			       ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		                                ^, EigenDecompositionImpl.java:892: error: class, interface, or enum expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                       ^, EigenDecompositionImpl.java:893: error: class, interface, or enum expected
			return;} 		// initial checks for splits (see Parlett & Marques section 3.3) 		flipIfWarranted(n, 2); 		// two iterations with Li's test for initial splits 		initialSplits(n); 		// initialize parameters used by goodStep 		tType = 0; 		dMin1 = 0; 		dMin2 = 0; 		dN = 0; 		dN1 = 0; 		dN2 = 0; 		tau = 0; 		// process split segments 		int i0 = 0; 		int n0 = n; 		while (n0 > 0) { 			// retrieve shift that was temporarily stored as a negative off-diagonal element 			sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2]; 			sigmaLow = 0; 			// find start of a new split segment to process 			double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6]; 			double offDiagMax = 0; 			double diagMax = work[(4 * n0) - 4]; 			double diagMin = diagMax; 			i0 = 0; 			for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { 				if (work[i + 2] <= 0) { 					i0 = 1 + (i / 4); 					break;} 				if (diagMin >= (4 * offDiagMax)) { 					diagMin = java.lang.Math.min(diagMin, work[i + 4]); 					offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);} 				diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]); 				offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);} 			work[(4 * n0) - 2] = offDiagMin; 			// lower bound of Gershgorin disk 			dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax))); 			pingPong = 0; 			int maxIter = 30 * (n0 - i0); 			for (int k = 0; i0 < n0; ++k) { 				if (k >= maxIter) { 					throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));}
			       ^, EigenDecompositionImpl.java:896: error: class, interface, or enum expected
				pingPong = 1 - pingPong;
				^, EigenDecompositionImpl.java:900: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && 
				^, EigenDecompositionImpl.java:904: error: class, interface, or enum expected
					diagMax = work[4 * i0];
					^, EigenDecompositionImpl.java:905: error: class, interface, or enum expected
					offDiagMin = work[(4 * i0) + 2];
					^, EigenDecompositionImpl.java:906: error: class, interface, or enum expected
					double previousEMin = work[(4 * i0) + 3];
					^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					                     ^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					                                          ^, EigenDecompositionImpl.java:912: error: class, interface, or enum expected
							split = i / 4;
							^, EigenDecompositionImpl.java:913: error: class, interface, or enum expected
							diagMax = 0;
							^, EigenDecompositionImpl.java:914: error: class, interface, or enum expected
							offDiagMin = work[i + 6];
							^, EigenDecompositionImpl.java:915: error: class, interface, or enum expected
							previousEMin = work[i + 7];
							^, EigenDecompositionImpl.java:916: error: class, interface, or enum expected
						} else {
						^, EigenDecompositionImpl.java:918: error: class, interface, or enum expected
							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);
							^, EigenDecompositionImpl.java:919: error: class, interface, or enum expected
							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);
							^, EigenDecompositionImpl.java:920: error: class, interface, or enum expected
						}
						^, EigenDecompositionImpl.java:923: error: class, interface, or enum expected
					work[(4 * n0) - 1] = previousEMin;
					^, EigenDecompositionImpl.java:924: error: class, interface, or enum expected
					i0 = split + 1;
					^, EigenDecompositionImpl.java:925: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:937: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) {
	    	                                 ^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		                ^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		                       ^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			                                       ^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			                                               ^, EigenDecompositionImpl.java:946: error: class, interface, or enum expected
					d = work[i];
					^, EigenDecompositionImpl.java:947: error: class, interface, or enum expected
				} else {
				^, EigenDecompositionImpl.java:949: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			                           ^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			                                              ^, EigenDecompositionImpl.java:955: error: class, interface, or enum expected
				final int j = (i - (2 * pingPong)) - 1;
				      ^, EigenDecompositionImpl.java:956: error: class, interface, or enum expected
				work[j] = d + work[i];
				^, EigenDecompositionImpl.java:957: error: class, interface, or enum expected
				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {
				^, EigenDecompositionImpl.java:959: error: class, interface, or enum expected
					work[j] = d;
					^, EigenDecompositionImpl.java:960: error: class, interface, or enum expected
					work[j + 2] = 0.0;
					^, EigenDecompositionImpl.java:961: error: class, interface, or enum expected
					d = work[i + 2];
					^, EigenDecompositionImpl.java:962: error: class, interface, or enum expected
				} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && 
				^, EigenDecompositionImpl.java:964: error: class, interface, or enum expected
					final double tmp = work[i + 2] / work[j];
					      ^, EigenDecompositionImpl.java:965: error: class, interface, or enum expected
					work[j + 2] = work[i] * tmp;
					^, EigenDecompositionImpl.java:966: error: class, interface, or enum expected
					d *= tmp;
					^, EigenDecompositionImpl.java:967: error: class, interface, or enum expected
				} else {
				^, EigenDecompositionImpl.java:969: error: class, interface, or enum expected
					d *= work[i + 2] / work[j];
					^, EigenDecompositionImpl.java:970: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:975: error: class, interface, or enum expected
			pingPong = 1 - pingPong;
			^, EigenDecompositionImpl.java:977: error: class, interface, or enum expected
		}
		^, EigenDecompositionImpl.java:994: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0;
	    	                           ^, EigenDecompositionImpl.java:994: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0;
	    	                                            ^, EigenDecompositionImpl.java:997: error: class, interface, or enum expected
		int deflatedEnd = end;
		^, EigenDecompositionImpl.java:998: error: class, interface, or enum expected
		for (boolean deflating = true; deflating;) {
		^, EigenDecompositionImpl.java:998: error: class, interface, or enum expected
		for (boolean deflating = true; deflating;) {
		                               ^, EigenDecompositionImpl.java:998: error: class, interface, or enum expected
		for (boolean deflating = true; deflating;) {
		                                         ^, EigenDecompositionImpl.java:1003: error: class, interface, or enum expected
			}
			^, EigenDecompositionImpl.java:1005: error: class, interface, or enum expected
			final int k = ((4 * deflatedEnd) + pingPong) - 1;
			      ^, EigenDecompositionImpl.java:1007: error: class, interface, or enum expected
			if ((start == (deflatedEnd - 1)) || 
			^, EigenDecompositionImpl.java:1014: error: class, interface, or enum expected
				deflatedEnd -= 1;
				^, EigenDecompositionImpl.java:1016: error: class, interface, or enum expected
			} else if (((start == (deflatedEnd - 2)) || 
			^, EigenDecompositionImpl.java:1022: error: class, interface, or enum expected
					final double tmp = work[k - 3];
					      ^, EigenDecompositionImpl.java:1023: error: class, interface, or enum expected
					work[k - 3] = work[k - 7];
					^, EigenDecompositionImpl.java:1024: error: class, interface, or enum expected
					work[k - 7] = tmp;
					^]
Ingredient counter is Zero
---Undoing: gnrtn(17): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// compute splitting points java.util.List<java.lang.Integer> splitIndices = computeSplits() ` -topatch--> `dN1 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (33(f=1.0), 34(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (33(f=1.0), )
----------Running generation: 18, population size: 1

***** Generation 18 : 0
**Parent Variant: [Variant id: 35, #gens: 539, #ops: 0, parent:-]

--Child created id: 36
--Creating new operations for variant [Variant id: 36, #gens: 539, #ops: 0, parent:35]
---analyzing modificationPoint position: 39
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  tType -= 12
---analyzing modificationPoint position: 175
---modifPoint 1 not mutation generated in  final int l = ((4 * deflatedEnd) + pingPong) - 1
---analyzing modificationPoint position: 26
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [eMin, work, start, pingPong]
--> var from patch: eMin spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: start spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1405
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dN = work[j4p2 + 2] ` -topatch--> `eMin = work[((4 * start) + pingPong) + 4]` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1405, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dN = work[j4p2 + 2] ` -topatch--> `eMin = work[((4 * start) + pingPong) + 4]` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 36, #gens: 540, #ops: 1, parent:35] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 36
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-36/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(18): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dN = work[j4p2 + 2] ` -topatch--> `eMin = work[((4 * start) + pingPong) + 4]` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (35(f=1.0), 36(f=1.0), )
Selected to next generation: IDs2--> (35(f=1.0), )
----------Running generation: 19, population size: 1

***** Generation 19 : 0
**Parent Variant: [Variant id: 37, #gens: 539, #ops: 0, parent:-]

--Child created id: 38
--Creating new operations for variant [Variant id: 38, #gens: 539, #ops: 0, parent:37]
---analyzing modificationPoint position: 334
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  n2 += z * z
---analyzing modificationPoint position: 284
Templates availables156
Attempts Base Ingredients  1 total 156
vars from patch [dMin2]
--> var from patch: dMin2 spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1390
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double tmp = work[j4p2 + 2] / work[j4 - 2] ` -topatch--> `final double s = 0.333 * dMin2` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1390, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double tmp = work[j4p2 + 2] / work[j4 - 2] ` -topatch--> `final double s = 0.333 * dMin2` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 38, #gens: 539, #ops: 1, parent:37] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 38, errors: [EigenDecompositionImpl.java:1669: error: orphaned default
			default : 				// case 12, more than two realEigenvalues deflated. no information.
			^, EigenDecompositionImpl.java:1681: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	^, EigenDecompositionImpl.java:1681: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	        ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                        ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                                           ^, EigenDecompositionImpl.java:1699: error: illegal start of expression
	private void findEigenVectors() {
	^, EigenDecompositionImpl.java:1699: error: illegal start of expression
	private void findEigenVectors() {
	        ^, EigenDecompositionImpl.java:1699: error: ';' expected
	private void findEigenVectors() {
	                             ^, EigenDecompositionImpl.java:1737: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	^, EigenDecompositionImpl.java:1737: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                      ^, EigenDecompositionImpl.java:1737: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                               ^, EigenDecompositionImpl.java:1737: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1737: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1799: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1799: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^, EigenDecompositionImpl.java:1799: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                  ^, EigenDecompositionImpl.java:1799: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                    ^, EigenDecompositionImpl.java:1799: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                      ^, EigenDecompositionImpl.java:1799: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                                          ^, EigenDecompositionImpl.java:1827: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	^, EigenDecompositionImpl.java:1827: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	        ^, EigenDecompositionImpl.java:1827: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                   ^, EigenDecompositionImpl.java:1827: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                     ^, EigenDecompositionImpl.java:1827: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                       ^, EigenDecompositionImpl.java:1827: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                                           ^, EigenDecompositionImpl.java:1844: error: reached end of file while parsing
}
 ^]
Ingredient counter is Zero
---Undoing: gnrtn(19): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double tmp = work[j4p2 + 2] / work[j4 - 2] ` -topatch--> `final double s = 0.333 * dMin2` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (37(f=1.0), 38(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (37(f=1.0), )
----------Running generation: 20, population size: 1

***** Generation 20 : 0
**Parent Variant: [Variant id: 39, #gens: 539, #ops: 0, parent:-]

--Child created id: 40
--Creating new operations for variant [Variant id: 40, #gens: 539, #ops: 0, parent:39]
---analyzing modificationPoint position: 311
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 0 not mutation generated in  final double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 / gap2) * b2 : b1 + b2)
---analyzing modificationPoint position: 246
location: EigenDecompositionImpl.java1289
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 	work[j4 - 3] = d + work[j4]; 	fina[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 40, #gens: 538, #ops: 1, parent:39] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 40
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-40/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 18] ,[]
-Valid?: |false|9|18|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(20): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 	work[j4 - 3] = d + work[j4]; 	fina[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (39(f=1.0), 40(f=9.0), )
Selected to next generation: IDs2--> (39(f=1.0), )
----------Running generation: 21, population size: 1

***** Generation 21 : 0
**Parent Variant: [Variant id: 41, #gens: 539, #ops: 0, parent:-]

--Child created id: 42
--Creating new operations for variant [Variant id: 42, #gens: 539, #ops: 0, parent:41]
---analyzing modificationPoint position: 457
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dMin2]
--> var from patch: dMin2 spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java678
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < j; ++i) { 	final double tmp = realEigenvalues[i]; 	realEigenvalues[i] = realEige[...] ` -topatch--> `final double s = 0.333 * dMin2` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 678, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < j; ++i) { 	final double tmp = realEigenvalues[i]; 	realEigenvalues[i] = realEige[...] ` -topatch--> `final double s = 0.333 * dMin2` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 42, #gens: 540, #ops: 1, parent:41] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 42, errors: [EigenDecompositionImpl.java:1641: error: illegal start of expression
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:1641: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	       ^, EigenDecompositionImpl.java:1641: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	                     ^, EigenDecompositionImpl.java:1641: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	                             ^, EigenDecompositionImpl.java:1641: error: not a statement
	 * Find eigenvalue in a block with 1 row.
	                              ^, EigenDecompositionImpl.java:1641: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	                                  ^, EigenDecompositionImpl.java:1641: error: <identifier> expected
	 * Find eigenvalue in a block with 1 row.
	                                         ^, EigenDecompositionImpl.java:1642: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	      ^, EigenDecompositionImpl.java:1642: error: not a statement
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	 ^, EigenDecompositionImpl.java:1642: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                           ^, EigenDecompositionImpl.java:1642: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                        ^, EigenDecompositionImpl.java:1642: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                           ^, EigenDecompositionImpl.java:1642: error: illegal start of type
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                        ^, EigenDecompositionImpl.java:1642: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                          ^, EigenDecompositionImpl.java:1644: error: illegal start of expression
	 * @param index
	 ^, EigenDecompositionImpl.java:1644: error: illegal start of expression
	 * @param index
	   ^, EigenDecompositionImpl.java:1645: error: not a statement
	 * 		index of the first row of the block
	 ^, EigenDecompositionImpl.java:1645: error: ';' expected
	 * 		index of the first row of the block
	   		     ^, EigenDecompositionImpl.java:1645: error: ';' expected
	 * 		index of the first row of the block
	   		            ^, EigenDecompositionImpl.java:1645: error: ';' expected
	 * 		index of the first row of the block
	   		                      ^, EigenDecompositionImpl.java:1645: error: ';' expected
	 * 		index of the first row of the block
	   		                             ^, EigenDecompositionImpl.java:1646: error: illegal start of expression
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	  ^, EigenDecompositionImpl.java:1646: error: illegal start of expression
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	^, EigenDecompositionImpl.java:1646: error: illegal start of expression
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	        ^, EigenDecompositionImpl.java:1646: error: ';' expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                             ^, EigenDecompositionImpl.java:1646: error: ';' expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                             ^, EigenDecompositionImpl.java:1654: error: illegal start of expression
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	^, EigenDecompositionImpl.java:1654: error: illegal start of expression
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	        ^, EigenDecompositionImpl.java:1654: error: ';' expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                              ^, EigenDecompositionImpl.java:1654: error: ';' expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                              ^, EigenDecompositionImpl.java:1654: error: not a statement
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                                                                     ^, EigenDecompositionImpl.java:1654: error: ';' expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                                                                                            ^, EigenDecompositionImpl.java:1655: error: illegal start of expression
	 * Find realEigenvalues in a block with 3 rows.
	 ^, EigenDecompositionImpl.java:1655: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	       ^, EigenDecompositionImpl.java:1655: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                          ^, EigenDecompositionImpl.java:1655: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                                  ^, EigenDecompositionImpl.java:1655: error: not a statement
	 * Find realEigenvalues in a block with 3 rows.
	                                   ^, EigenDecompositionImpl.java:1655: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                                       ^, EigenDecompositionImpl.java:1655: error: <identifier> expected
	 * Find realEigenvalues in a block with 3 rows.
	                                               ^, EigenDecompositionImpl.java:1656: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	      ^, EigenDecompositionImpl.java:1656: error: not a statement
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	 ^, EigenDecompositionImpl.java:1656: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                           ^, EigenDecompositionImpl.java:1656: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                        ^, EigenDecompositionImpl.java:1656: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                           ^, EigenDecompositionImpl.java:1656: error: illegal start of type
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                        ^, EigenDecompositionImpl.java:1656: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                          ^, EigenDecompositionImpl.java:1658: error: illegal start of expression
	 * @param index
	 ^, EigenDecompositionImpl.java:1658: error: illegal start of expression
	 * @param index
	   ^, EigenDecompositionImpl.java:1659: error: not a statement
	 * 		index of the first row of the block
	 ^, EigenDecompositionImpl.java:1659: error: ';' expected
	 * 		index of the first row of the block
	   		     ^, EigenDecompositionImpl.java:1659: error: ';' expected
	 * 		index of the first row of the block
	   		            ^, EigenDecompositionImpl.java:1659: error: ';' expected
	 * 		index of the first row of the block
	   		                      ^, EigenDecompositionImpl.java:1659: error: ';' expected
	 * 		index of the first row of the block
	   		                             ^, EigenDecompositionImpl.java:1660: error: illegal start of expression
	 * @exception InvalidMatrixException
	   ^, EigenDecompositionImpl.java:1661: error: illegal start of expression
	 * 		if diagonal elements are not positive
	   		^, EigenDecompositionImpl.java:1661: error: not a statement
	 * 		if diagonal elements are not positive
	 ^, EigenDecompositionImpl.java:1661: error: ';' expected
	 * 		if diagonal elements are not positive
	   		                    ^, EigenDecompositionImpl.java:1661: error: ';' expected
	 * 		if diagonal elements are not positive
	   		                            ^, EigenDecompositionImpl.java:1662: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	  ^, EigenDecompositionImpl.java:1662: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	^, EigenDecompositionImpl.java:1662: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	        ^, EigenDecompositionImpl.java:1662: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                              ^, EigenDecompositionImpl.java:1662: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                              ^, EigenDecompositionImpl.java:1662: error: not a statement
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                                                                     ^, EigenDecompositionImpl.java:1662: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                                                                                            ^, EigenDecompositionImpl.java:1676: error: illegal start of expression
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	^, EigenDecompositionImpl.java:1676: error: illegal start of expression
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	        ^, EigenDecompositionImpl.java:1676: error: ';' expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                ^, EigenDecompositionImpl.java:1676: error: ';' expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                            ^, EigenDecompositionImpl.java:1676: error: not a statement
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                                                                   ^, EigenDecompositionImpl.java:1676: error: ';' expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                                                                                          ^, EigenDecompositionImpl.java:1679: error: illegal start of expression
	 * Perform two iterations with Li's tests for initial splits.
	 ^, EigenDecompositionImpl.java:1679: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	          ^, EigenDecompositionImpl.java:1679: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                         ^, EigenDecompositionImpl.java:1679: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1679: error: not a statement
	 * Perform two iterations with Li's tests for initial splits.
	                                    ^, EigenDecompositionImpl.java:1679: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                         ^, EigenDecompositionImpl.java:1679: error: '(' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                             ^, EigenDecompositionImpl.java:1679: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                                            ^, EigenDecompositionImpl.java:1681: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1681: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1682: error: ';' expected
	 * 		number of rows of the matrix to process
	   		      ^, EigenDecompositionImpl.java:1682: error: not a statement
	 * 		number of rows of the matrix to process
	   		       ^, EigenDecompositionImpl.java:1682: error: ')' expected
	 * 		number of rows of the matrix to process
	   		         ^, EigenDecompositionImpl.java:1682: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                 ^, EigenDecompositionImpl.java:1682: error: variable declaration not allowed here
	 * 		number of rows of the matrix to process
	   		               ^, EigenDecompositionImpl.java:1682: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                            ^, EigenDecompositionImpl.java:1682: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                                       ^, EigenDecompositionImpl.java:1683: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	^, EigenDecompositionImpl.java:1683: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	        ^, EigenDecompositionImpl.java:1683: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                          ^, EigenDecompositionImpl.java:1683: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1684: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1684: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1684: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1684: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1684: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1684: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1684: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1685: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^]
Ingredient counter is Zero
---Undoing: gnrtn(21): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < j; ++i) { 	final double tmp = realEigenvalues[i]; 	realEigenvalues[i] = realEige[...] ` -topatch--> `final double s = 0.333 * dMin2` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (41(f=1.0), 42(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (41(f=1.0), )
----------Running generation: 22, population size: 1

***** Generation 22 : 0
**Parent Variant: [Variant id: 43, #gens: 539, #ops: 0, parent:-]

--Child created id: 44
--Creating new operations for variant [Variant id: 44, #gens: 539, #ops: 0, parent:43]
---analyzing modificationPoint position: 214
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  for (int i = 0; i < maxIter; ++i) {  	final double range = right - left; 	if ((range < absoluteToler[...]
---analyzing modificationPoint position: 311
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1458
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 / gap2) * b2 : b1 + b2) ` -topatch--> `int np` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1458, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 / gap2) * b2 : b1 + b2) ` -topatch--> `int np` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 44, #gens: 540, #ops: 1, parent:43] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 44, errors: [EigenDecompositionImpl.java:1481: error: cannot find symbol
							gam = dN;
							^
  symbol:   variable gam
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1487: error: cannot find symbol
							np = nn - 9;
							^
  symbol:   variable np
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1489: error: cannot find symbol
							np = nn - (2 * pingPong);
							^
  symbol:   variable np
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1490: error: cannot find symbol
							b2 = work[np - 2];
							          ^
  symbol:   variable np
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1491: error: cannot find symbol
							gam = dN1;
							^
  symbol:   variable gam
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1492: error: cannot find symbol
							if (work[np - 4] > work[np - 2]) {
							         ^
  symbol:   variable np
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1492: error: cannot find symbol
							if (work[np - 4] > work[np - 2]) {
							                        ^
  symbol:   variable np
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1495: error: cannot find symbol
							a2 = work[np - 4] / work[np - 2];
							          ^
  symbol:   variable np
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1495: error: cannot find symbol
							a2 = work[np - 4] / work[np - 2];
							                         ^
  symbol:   variable np
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1500: error: cannot find symbol
							np = nn - 13;
							^
  symbol:   variable np
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1505: error: cannot find symbol
						for (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {
						              ^
  symbol:   variable np
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1523: error: cannot find symbol
							s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);
							^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1523: error: cannot find symbol
							s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);
							     ^
  symbol:   variable gam
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1525: error: cannot find symbol
						tau = s;
						      ^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl]
Ingredient counter is Zero
---Undoing: gnrtn(22): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 / gap2) * b2 : b1 + b2) ` -topatch--> `int np` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (43(f=1.0), 44(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (43(f=1.0), )
----------Running generation: 23, population size: 1

***** Generation 23 : 0
**Parent Variant: [Variant id: 45, #gens: 539, #ops: 0, parent:-]

--Child created id: 46
--Creating new operations for variant [Variant id: 46, #gens: 539, #ops: 0, parent:45]
---analyzing modificationPoint position: 122
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 0 not mutation generated in  double offDiagMax = 0
---analyzing modificationPoint position: 394
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  final double li = l[i]
---analyzing modificationPoint position: 253
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau
---analyzing modificationPoint position: 503
location: MatrixUtils.java650
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (left.getColumnDimension() != right.getRowDimension()) { 	throw org.apache.commons.math.MathRunti[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 46, #gens: 538, #ops: 1, parent:45] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 46
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-46/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(23): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (left.getColumnDimension() != right.getRowDimension()) { 	throw org.apache.commons.math.MathRunti[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (45(f=1.0), 46(f=1.0), )
Selected to next generation: IDs2--> (45(f=1.0), )
----------Running generation: 24, population size: 1

***** Generation 24 : 0
**Parent Variant: [Variant id: 47, #gens: 539, #ops: 0, parent:-]

--Child created id: 48
--Creating new operations for variant [Variant id: 48, #gens: 539, #ops: 0, parent:47]
---analyzing modificationPoint position: 44
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  double b2 = work[np - 6]
---analyzing modificationPoint position: 431
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  final int m = main.length
---analyzing modificationPoint position: 180
Templates availables42
Attempts Base Ingredients  1 total 42
---modifPoint 2 not mutation generated in  // step 4a: dqds for (boolean loop = true; loop;) {  	// perform one dqds step with the chosen shift[...]
---analyzing modificationPoint position: 515
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 3 not mutation generated in  for (int r = 1; r < nRows; r++) { 	if (d[r].length != nCols) { 		throw org.apache.commons.math.MathR[...]
---analyzing modificationPoint position: 32
location: EigenDecompositionImpl.java1091
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = 0.0 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 48, #gens: 538, #ops: 1, parent:47] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child compiles: id 48
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-48/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(24): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = 0.0 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (47(f=1.0), 48(f=1.0), )
Selected to next generation: IDs2--> (47(f=1.0), )
----------Running generation: 25, population size: 1

***** Generation 25 : 0
**Parent Variant: [Variant id: 49, #gens: 539, #ops: 0, parent:-]

--Child created id: 50
--Creating new operations for variant [Variant id: 50, #gens: 539, #ops: 0, parent:49]
---analyzing modificationPoint position: 528
Templates availables12
Attempts Base Ingredients  1 total 12
---modifPoint 0 not mutation generated in  data = new double[subMatrix.length][nCols]
---analyzing modificationPoint position: 247
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 1 not mutation generated in  // unroll last two steps. dN2 = d
---analyzing modificationPoint position: 526
Templates availables23
Attempts Base Ingredients  1 total 23
---modifPoint 2 not mutation generated in  final int nCols = subMatrix[0].length
---analyzing modificationPoint position: 439
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  final double dCurrent = main[m - 1]
---analyzing modificationPoint position: 507
Templates availables281
Attempts Base Ingredients  1 total 281
---modifPoint 4 not mutation generated in  data = (copyArray) ? d.clone() : d
---analyzing modificationPoint position: 147
location: EigenDecompositionImpl.java947
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `d *= work[i] / (d + work[i + 2]) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 50, #gens: 538, #ops: 1, parent:49] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 50
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-50/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 18] ,[]
-Valid?: |false|1|18|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(25): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `d *= work[i] / (d + work[i + 2]) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (49(f=1.0), 50(f=1.0), )
Selected to next generation: IDs2--> (49(f=1.0), )
----------Running generation: 26, population size: 1

***** Generation 26 : 0
**Parent Variant: [Variant id: 51, #gens: 539, #ops: 0, parent:-]

--Child created id: 52
--Creating new operations for variant [Variant id: 52, #gens: 539, #ops: 0, parent:51]
---analyzing modificationPoint position: 392
location: EigenDecompositionImpl.java1828
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = nM1 - 1; i >= 0; --i) { 	final double di = d[i]; 	final double li = l[i]; 	final double[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 52, #gens: 538, #ops: 1, parent:51] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 52
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-52/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 6, was successful: false, cases executed: 18] ,[]
-Valid?: |false|6|18|[]|, fitness 6.0
Ingredient counter is Zero
---Undoing: gnrtn(26): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = nM1 - 1; i >= 0; --i) { 	final double di = d[i]; 	final double li = l[i]; 	final double[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (51(f=1.0), 52(f=6.0), )
Selected to next generation: IDs2--> (51(f=1.0), )
----------Running generation: 27, population size: 1

***** Generation 27 : 0
**Parent Variant: [Variant id: 53, #gens: 539, #ops: 0, parent:-]

--Child created id: 54
--Creating new operations for variant [Variant id: 54, #gens: 539, #ops: 0, parent:53]
---analyzing modificationPoint position: 125
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  i0 = 0
---analyzing modificationPoint position: 189
Templates availables156
Attempts Base Ingredients  1 total 156
vars from patch [work, n, pingPong]
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: n spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1158
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// find the bounds of the spectra of the local block final int lowerStart = 4 * main.length ` -topatch--> `// apply Li's reverse test double d = work[(4 * (n - 1)) + pingPong]` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1158, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// find the bounds of the spectra of the local block final int lowerStart = 4 * main.length ` -topatch--> `// apply Li's reverse test double d = work[(4 * (n - 1)) + pingPong]` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 54, #gens: 539, #ops: 1, parent:53] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 54, errors: [EigenDecompositionImpl.java:1164: error: cannot find symbol
			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]);
			                                        ^
  symbol:   variable lowerStart
  location: class org.apache.commons.math.linear.EigenDecompositionImpl]
Ingredient counter is Zero
---Undoing: gnrtn(27): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// find the bounds of the spectra of the local block final int lowerStart = 4 * main.length ` -topatch--> `// apply Li's reverse test double d = work[(4 * (n - 1)) + pingPong]` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (53(f=1.0), 54(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (53(f=1.0), )
----------Running generation: 28, population size: 1

***** Generation 28 : 0
**Parent Variant: [Variant id: 55, #gens: 539, #ops: 0, parent:-]

--Child created id: 56
--Creating new operations for variant [Variant id: 56, #gens: 539, #ops: 0, parent:55]
---analyzing modificationPoint position: 245
location: EigenDecompositionImpl.java1280
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 	work[j4 - 2] = d + work[j4 - 1]; 	[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 56, #gens: 538, #ops: 1, parent:55] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 56
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-56/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 18] ,[]
-Valid?: |false|9|18|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(28): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 	work[j4 - 2] = d + work[j4 - 1]; 	[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (55(f=1.0), 56(f=9.0), )
Selected to next generation: IDs2--> (55(f=1.0), )
----------Running generation: 29, population size: 1

***** Generation 29 : 0
**Parent Variant: [Variant id: 57, #gens: 539, #ops: 0, parent:-]

--Child created id: 58
--Creating new operations for variant [Variant id: 58, #gens: 539, #ops: 0, parent:57]
---analyzing modificationPoint position: 174
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // no more realEigenvalues found, we need to iterate deflating = false
---analyzing modificationPoint position: 507
Templates availables281
Attempts Base Ingredients  1 total 281
---modifPoint 1 not mutation generated in  data = (copyArray) ? d.clone() : d
---analyzing modificationPoint position: 207
---modifPoint 2 not mutation generated in  final double middle = 0.5 * (left + right)
---analyzing modificationPoint position: 497
location: Array2DRowRealMatrix.java487
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int j = 0; j < columns; ++j) { 	visitor.visit(i, j, rowI[j]); } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 58, #gens: 538, #ops: 1, parent:57] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child does NOT compile: 58, errors: [Array2DRowRealMatrix.java:487: error: variable declaration not allowed here
			final double[] rowI = data[i];
			               ^]
Ingredient counter is Zero
---Undoing: gnrtn(29): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int j = 0; j < columns; ++j) { 	visitor.visit(i, j, rowI[j]); } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (57(f=1.0), 58(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (57(f=1.0), )
----------Running generation: 30, population size: 1

***** Generation 30 : 0
**Parent Variant: [Variant id: 59, #gens: 539, #ops: 0, parent:-]

--Child created id: 60
--Creating new operations for variant [Variant id: 60, #gens: 539, #ops: 0, parent:59]
---analyzing modificationPoint position: 84
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 0 not mutation generated in  double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5])
---analyzing modificationPoint position: 128
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 1 not mutation generated in  if (diagMin >= (4 * offDiagMax)) { 	diagMin = java.lang.Math.min(diagMin, work[i + 4]); 	offDiagMax [...]
---analyzing modificationPoint position: 325
Templates availables23
Attempts Base Ingredients  1 total 23
---modifPoint 2 not mutation generated in  checkVectorDimensions(v.length)
---analyzing modificationPoint position: 20
---modifPoint 3 not mutation generated in  return true
---analyzing modificationPoint position: 221
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  left = middle
---analyzing modificationPoint position: 223
---modifPoint 5 not mutation generated in  return new double[]{ lower, upper }
---analyzing modificationPoint position: 192
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1161
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double upper = java.lang.Double.NEGATIVE_INFINITY ` -topatch--> `// case 5. tType = -5` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1161, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double upper = java.lang.Double.NEGATIVE_INFINITY ` -topatch--> `// case 5. tType = -5` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 60, #gens: 540, #ops: 1, parent:59] gen mutated: 1 , gen not mut: 6, gen not applied  0
-The child does NOT compile: 60, errors: [EigenDecompositionImpl.java:1532: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			^, EigenDecompositionImpl.java:1532: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                    ^, EigenDecompositionImpl.java:1532: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                     ^, EigenDecompositionImpl.java:1532: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                           ^, EigenDecompositionImpl.java:1532: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                     ^, EigenDecompositionImpl.java:1532: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                 ^, EigenDecompositionImpl.java:1532: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                     ^, EigenDecompositionImpl.java:1532: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				    ^, EigenDecompositionImpl.java:1532: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				               ^, EigenDecompositionImpl.java:1533: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				^, EigenDecompositionImpl.java:1533: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				      ^, EigenDecompositionImpl.java:1533: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			      ^, EigenDecompositionImpl.java:1533: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			^, EigenDecompositionImpl.java:1533: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				               ^, EigenDecompositionImpl.java:1533: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				              ^, EigenDecompositionImpl.java:1533: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		^, EigenDecompositionImpl.java:1533: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		                                    ^, EigenDecompositionImpl.java:1543: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                   ^, EigenDecompositionImpl.java:1543: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1543: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                    ^, EigenDecompositionImpl.java:1543: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		^, EigenDecompositionImpl.java:1543: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		^, EigenDecompositionImpl.java:1543: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                ^, EigenDecompositionImpl.java:1543: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                       ^, EigenDecompositionImpl.java:1543: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			^, EigenDecompositionImpl.java:1543: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				        ^, EigenDecompositionImpl.java:1543: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				           		             ^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                          ^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                ^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                       ^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			      ^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			      ^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			      ^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			^, EigenDecompositionImpl.java:1557: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			                                     ^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                        ^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                         ^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                               ^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                      ^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				      ^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                          ^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                               ^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                      ^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				      ^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1565: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				                                              ^, EigenDecompositionImpl.java:1569: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                       ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                        ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                               ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                     ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					           ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                          ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                               ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                     ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					           ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1573: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                              ^]
Ingredient counter is Zero
---Undoing: gnrtn(30): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double upper = java.lang.Double.NEGATIVE_INFINITY ` -topatch--> `// case 5. tType = -5` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (59(f=1.0), 60(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (59(f=1.0), )
----------Running generation: 31, population size: 1

***** Generation 31 : 0
**Parent Variant: [Variant id: 61, #gens: 539, #ops: 0, parent:-]

--Child created id: 62
--Creating new operations for variant [Variant id: 62, #gens: 539, #ops: 0, parent:61]
---analyzing modificationPoint position: 462
Templates availables20
Attempts Base Ingredients  1 total 20
vars from patch []
location: EigenDecompositionImpl.java709
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return list ` -topatch--> `// matrix is already diagonal return` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 709, pointed element: CtReturnImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return list ` -topatch--> `// matrix is already diagonal return` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 62, #gens: 539, #ops: 1, parent:61] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 62, errors: [EigenDecompositionImpl.java:852: error: illegal start of expression
	 * Find realEigenvalues in a block with 3 rows.
	 ^, EigenDecompositionImpl.java:852: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	       ^, EigenDecompositionImpl.java:852: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                          ^, EigenDecompositionImpl.java:852: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                                  ^, EigenDecompositionImpl.java:852: error: not a statement
	 * Find realEigenvalues in a block with 3 rows.
	                                   ^, EigenDecompositionImpl.java:852: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                                       ^, EigenDecompositionImpl.java:852: error: <identifier> expected
	 * Find realEigenvalues in a block with 3 rows.
	                                               ^, EigenDecompositionImpl.java:853: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	      ^, EigenDecompositionImpl.java:853: error: not a statement
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	 ^, EigenDecompositionImpl.java:853: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                           ^, EigenDecompositionImpl.java:853: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                        ^, EigenDecompositionImpl.java:853: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                           ^, EigenDecompositionImpl.java:853: error: illegal start of type
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                        ^, EigenDecompositionImpl.java:853: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                          ^, EigenDecompositionImpl.java:855: error: illegal start of expression
	 * @param index
	 ^, EigenDecompositionImpl.java:855: error: illegal start of expression
	 * @param index
	   ^, EigenDecompositionImpl.java:856: error: not a statement
	 * 		index of the first row of the block
	 ^, EigenDecompositionImpl.java:856: error: ';' expected
	 * 		index of the first row of the block
	   		     ^, EigenDecompositionImpl.java:856: error: ';' expected
	 * 		index of the first row of the block
	   		            ^, EigenDecompositionImpl.java:856: error: ';' expected
	 * 		index of the first row of the block
	   		                      ^, EigenDecompositionImpl.java:856: error: ';' expected
	 * 		index of the first row of the block
	   		                             ^, EigenDecompositionImpl.java:857: error: illegal start of expression
	 * @exception InvalidMatrixException
	   ^, EigenDecompositionImpl.java:858: error: illegal start of expression
	 * 		if diagonal elements are not positive
	   		^, EigenDecompositionImpl.java:858: error: not a statement
	 * 		if diagonal elements are not positive
	 ^, EigenDecompositionImpl.java:858: error: ';' expected
	 * 		if diagonal elements are not positive
	   		                    ^, EigenDecompositionImpl.java:858: error: ';' expected
	 * 		if diagonal elements are not positive
	   		                            ^, EigenDecompositionImpl.java:859: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	  ^, EigenDecompositionImpl.java:859: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	^, EigenDecompositionImpl.java:859: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	        ^, EigenDecompositionImpl.java:859: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                              ^, EigenDecompositionImpl.java:859: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                              ^, EigenDecompositionImpl.java:859: error: not a statement
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                                                                     ^, EigenDecompositionImpl.java:859: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                                                                                            ^, EigenDecompositionImpl.java:875: error: illegal start of type
				if (diagMin >= (4 * offDiagMax)) {
				^, EigenDecompositionImpl.java:875: error: <identifier> expected
				if (diagMin >= (4 * offDiagMax)) {
				           ^, EigenDecompositionImpl.java:875: error: ';' expected
				if (diagMin >= (4 * offDiagMax)) {
				              ^, EigenDecompositionImpl.java:875: error: illegal start of type
				if (diagMin >= (4 * offDiagMax)) {
				                ^, EigenDecompositionImpl.java:875: error: <identifier> expected
				if (diagMin >= (4 * offDiagMax)) {
				                 ^, EigenDecompositionImpl.java:875: error: ';' expected
				if (diagMin >= (4 * offDiagMax)) {
				                   ^, EigenDecompositionImpl.java:875: error: illegal start of type
				if (diagMin >= (4 * offDiagMax)) {
				                              ^, EigenDecompositionImpl.java:875: error: <identifier> expected
				if (diagMin >= (4 * offDiagMax)) {
				                               ^, EigenDecompositionImpl.java:875: error: ';' expected
				if (diagMin >= (4 * offDiagMax)) {
				                                ^, EigenDecompositionImpl.java:876: error: <identifier> expected
					diagMin = java.lang.Math.min(diagMin, work[i + 4]);
					       ^, EigenDecompositionImpl.java:877: error: <identifier> expected
					offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);
					          ^, EigenDecompositionImpl.java:879: error: class, interface, or enum expected
				diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]);
				^, EigenDecompositionImpl.java:880: error: class, interface, or enum expected
				offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);
				^, EigenDecompositionImpl.java:881: error: class, interface, or enum expected
			}
			^, EigenDecompositionImpl.java:885: error: class, interface, or enum expected
			dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax)));
			^, EigenDecompositionImpl.java:887: error: class, interface, or enum expected
			pingPong = 0;
			^, EigenDecompositionImpl.java:888: error: class, interface, or enum expected
			int maxIter = 30 * (n0 - i0);
			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			for (int k = 0; i0 < n0; ++k) {
			^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			for (int k = 0; i0 < n0; ++k) {
			                ^, EigenDecompositionImpl.java:889: error: class, interface, or enum expected
			for (int k = 0; i0 < n0; ++k) {
			                         ^, EigenDecompositionImpl.java:892: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:896: error: class, interface, or enum expected
				pingPong = 1 - pingPong;
				^, EigenDecompositionImpl.java:900: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && 
				^, EigenDecompositionImpl.java:904: error: class, interface, or enum expected
					diagMax = work[4 * i0];
					^, EigenDecompositionImpl.java:905: error: class, interface, or enum expected
					offDiagMin = work[(4 * i0) + 2];
					^, EigenDecompositionImpl.java:906: error: class, interface, or enum expected
					double previousEMin = work[(4 * i0) + 3];
					^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					                     ^, EigenDecompositionImpl.java:907: error: class, interface, or enum expected
					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {
					                                          ^, EigenDecompositionImpl.java:912: error: class, interface, or enum expected
							split = i / 4;
							^, EigenDecompositionImpl.java:913: error: class, interface, or enum expected
							diagMax = 0;
							^, EigenDecompositionImpl.java:914: error: class, interface, or enum expected
							offDiagMin = work[i + 6];
							^, EigenDecompositionImpl.java:915: error: class, interface, or enum expected
							previousEMin = work[i + 7];
							^, EigenDecompositionImpl.java:916: error: class, interface, or enum expected
						} else {
						^, EigenDecompositionImpl.java:918: error: class, interface, or enum expected
							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);
							^, EigenDecompositionImpl.java:919: error: class, interface, or enum expected
							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);
							^, EigenDecompositionImpl.java:920: error: class, interface, or enum expected
						}
						^, EigenDecompositionImpl.java:923: error: class, interface, or enum expected
					work[(4 * n0) - 1] = previousEMin;
					^, EigenDecompositionImpl.java:924: error: class, interface, or enum expected
					i0 = split + 1;
					^, EigenDecompositionImpl.java:925: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:937: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) {
	    	                                 ^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		                ^, EigenDecompositionImpl.java:939: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		                       ^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			                                       ^, EigenDecompositionImpl.java:943: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			                                               ^, EigenDecompositionImpl.java:946: error: class, interface, or enum expected
					d = work[i];
					^, EigenDecompositionImpl.java:947: error: class, interface, or enum expected
				} else {
				^, EigenDecompositionImpl.java:949: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			                           ^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			                                              ^, EigenDecompositionImpl.java:955: error: class, interface, or enum expected
				final int j = (i - (2 * pingPong)) - 1;
				      ^, EigenDecompositionImpl.java:956: error: class, interface, or enum expected
				work[j] = d + work[i];
				^, EigenDecompositionImpl.java:957: error: class, interface, or enum expected
				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {
				^, EigenDecompositionImpl.java:959: error: class, interface, or enum expected
					work[j] = d;
					^, EigenDecompositionImpl.java:960: error: class, interface, or enum expected
					work[j + 2] = 0.0;
					^, EigenDecompositionImpl.java:961: error: class, interface, or enum expected
					d = work[i + 2];
					^, EigenDecompositionImpl.java:962: error: class, interface, or enum expected
				} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && 
				^, EigenDecompositionImpl.java:964: error: class, interface, or enum expected
					final double tmp = work[i + 2] / work[j];
					      ^, EigenDecompositionImpl.java:965: error: class, interface, or enum expected
					work[j + 2] = work[i] * tmp;
					^, EigenDecompositionImpl.java:966: error: class, interface, or enum expected
					d *= tmp;
					^, EigenDecompositionImpl.java:967: error: class, interface, or enum expected
				} else {
				^, EigenDecompositionImpl.java:969: error: class, interface, or enum expected
					d *= work[i + 2] / work[j];
					^, EigenDecompositionImpl.java:970: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:975: error: class, interface, or enum expected
			pingPong = 1 - pingPong;
			^]
Ingredient counter is Zero
---Undoing: gnrtn(31): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return list ` -topatch--> `// matrix is already diagonal return` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (61(f=1.0), 62(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (61(f=1.0), )
----------Running generation: 32, population size: 1

***** Generation 32 : 0
**Parent Variant: [Variant id: 63, #gens: 539, #ops: 0, parent:-]

--Child created id: 64
--Creating new operations for variant [Variant id: 64, #gens: 539, #ops: 0, parent:63]
---analyzing modificationPoint position: 154
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  final double tmp = work[i + 2] / work[j]
---analyzing modificationPoint position: 343
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  final double eiM1 = secondary[i - 1]
---analyzing modificationPoint position: 317
location: EigenDecompositionImpl.java1684
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `sigmaLow += shift ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 64, #gens: 538, #ops: 1, parent:63] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 64
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-64/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 18] ,[]
-Valid?: |false|9|18|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(32): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `sigmaLow += shift ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (63(f=1.0), 64(f=9.0), )
Selected to next generation: IDs2--> (63(f=1.0), )
----------Running generation: 33, population size: 1

***** Generation 33 : 0
**Parent Variant: [Variant id: 65, #gens: 539, #ops: 0, parent:-]

--Child created id: 66
--Creating new operations for variant [Variant id: 66, #gens: 539, #ops: 0, parent:65]
---analyzing modificationPoint position: 443
---modifPoint 0 not mutation generated in  final double upper = dCurrent + eCurrent
---analyzing modificationPoint position: 528
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 1 not mutation generated in  data = new double[subMatrix.length][nCols]
---analyzing modificationPoint position: 102
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  for (int i = 0; i < (n - 1); ++i) { 	final int fourI = 4 * i; 	final double ei = work[fourI + 2]; 	s[...]
---analyzing modificationPoint position: 406
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dN2]
--> var from patch: dN2 spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java583
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `eCurrent = java.lang.Math.abs(secondary[i]) ` -topatch--> `final double gam = dN2` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 583, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `eCurrent = java.lang.Math.abs(secondary[i]) ` -topatch--> `final double gam = dN2` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 66, #gens: 540, #ops: 1, parent:65] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child does NOT compile: 66, errors: [EigenDecompositionImpl.java:1544: error: <identifier> expected
					if (chooseLeft) { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda + work[4 * i];}} else { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda - work[4 * i];}}} 			begin = end;} 		// sort the realEigenvalues in decreasing order 		java.util.Arrays.sort(realEigenvalues); 		int j = realEigenvalues.length - 1; 		for (int i = 0; i < j; ++i) { 			final double tmp = realEigenvalues[i]; 			realEigenvalues[i] = realEigenvalues[j]; 			realEigenvalues[j] = tmp; 			--j;}} 	/**
					                  						                              							                                                            						                              							                                                      			     ^, EigenDecompositionImpl.java:1545: error: class, interface, or enum expected
	 * Compute splitting points.
	 ^, EigenDecompositionImpl.java:1547: error: <identifier> expected
	 * @return list of indices after matrix can be split
	    ^, EigenDecompositionImpl.java:1547: error: class, interface, or enum expected
	 * @return list of indices after matrix can be split
	           ^, EigenDecompositionImpl.java:1548: error: class, interface, or enum expected
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	                                                            		      ^, EigenDecompositionImpl.java:1549: error: class, interface, or enum expected
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:1552: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1554: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                    ^, EigenDecompositionImpl.java:1554: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                                 		                                     ^, EigenDecompositionImpl.java:1562: error: class, interface, or enum expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1566: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1568: error: class, interface, or enum expected
	 * @exception InvalidMatrixException
	              ^, EigenDecompositionImpl.java:1570: error: class, interface, or enum expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                     ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                       ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		      ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		      ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		      ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		      ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			      ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			       ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		^, EigenDecompositionImpl.java:1571: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		                                ^, EigenDecompositionImpl.java:1584: error: class, interface, or enum expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                       ^, EigenDecompositionImpl.java:1585: error: class, interface, or enum expected
			return;} 		// initial checks for splits (see Parlett & Marques section 3.3) 		flipIfWarranted(n, 2); 		// two iterations with Li's test for initial splits 		initialSplits(n); 		// initialize parameters used by goodStep 		tType = 0; 		dMin1 = 0; 		dMin2 = 0; 		dN = 0; 		dN1 = 0; 		dN2 = 0; 		tau = 0; 		// process split segments 		int i0 = 0; 		int n0 = n; 		while (n0 > 0) { 			// retrieve shift that was temporarily stored as a negative off-diagonal element 			sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2]; 			sigmaLow = 0; 			// find start of a new split segment to process 			double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6]; 			double offDiagMax = 0; 			double diagMax = work[(4 * n0) - 4]; 			double diagMin = diagMax; 			i0 = 0; 			for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { 				if (work[i + 2] <= 0) { 					i0 = 1 + (i / 4); 					break;} 				if (diagMin >= (4 * offDiagMax)) { 					diagMin = java.lang.Math.min(diagMin, work[i + 4]); 					offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);} 				diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]); 				offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);} 			work[(4 * n0) - 2] = offDiagMin; 			// lower bound of Gershgorin disk 			dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax))); 			pingPong = 0; 			int maxIter = 30 * (n0 - i0); 			for (int k = 0; i0 < n0; ++k) { 				if (k >= maxIter) { 					throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));} 				// perform one step 				n0 = goodStep(i0, n0); 				pingPong = 1 - pingPong; 				// check for new splits after "ping" steps 				// when the last elements of qd array are very small
			       ^, EigenDecompositionImpl.java:1586: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) || (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					^, EigenDecompositionImpl.java:1586: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) || (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					^, EigenDecompositionImpl.java:1586: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) || (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					^, EigenDecompositionImpl.java:1586: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) || (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					^, EigenDecompositionImpl.java:1586: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) || (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					                     ^, EigenDecompositionImpl.java:1586: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) || (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					                                          ^, EigenDecompositionImpl.java:1587: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1589: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1591: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                 ^, EigenDecompositionImpl.java:1591: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		^, EigenDecompositionImpl.java:1591: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		                ^, EigenDecompositionImpl.java:1591: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		                       ^, EigenDecompositionImpl.java:1599: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1601: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1603: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1603: error: class, interface, or enum expected
	 * @return new end (maybe deflated)
	           ^, EigenDecompositionImpl.java:1603: error: class, interface, or enum expected
	 * @return new end (maybe deflated)
	               ^, EigenDecompositionImpl.java:1604: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                           ^, EigenDecompositionImpl.java:1604: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                            ^, EigenDecompositionImpl.java:1605: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				^, EigenDecompositionImpl.java:1605: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                   ^, EigenDecompositionImpl.java:1605: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                     			      ^, EigenDecompositionImpl.java:1605: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                     			                                                  			^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					      ^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                  ^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                               ^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                         ^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                ^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				                                                   				^, EigenDecompositionImpl.java:1606: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				                                                   				                 ^, EigenDecompositionImpl.java:1607: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				^, EigenDecompositionImpl.java:1607: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				^, EigenDecompositionImpl.java:1607: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				^, EigenDecompositionImpl.java:1607: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				                                                                                             				^, EigenDecompositionImpl.java:1607: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				                                                                                             				            ^, EigenDecompositionImpl.java:1608: error: class, interface, or enum expected
			for (boolean loop = true; loop;) { 				// perform one dqds step with the chosen shift 				dqds(start, deflatedEnd); 				// check result of the dqds step
			                          ^, EigenDecompositionImpl.java:1608: error: class, interface, or enum expected
			for (boolean loop = true; loop;) { 				// perform one dqds step with the chosen shift 				dqds(start, deflatedEnd); 				// check result of the dqds step
			                               ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1615: error: class, interface, or enum expected
	 * @param step
	          ^, EigenDecompositionImpl.java:1618: error: <identifier> expected
	 * @return true if qd array was flipped
	    ^, EigenDecompositionImpl.java:1618: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	           ^, EigenDecompositionImpl.java:1618: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	                ^, EigenDecompositionImpl.java:1618: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	                   ^, EigenDecompositionImpl.java:1619: error: class, interface, or enum expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1619: error: class, interface, or enum expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1622: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1624: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1626: error: <identifier> expected
	 * @return an interval containing the realEigenvalues
	    ^, EigenDecompositionImpl.java:1626: error: class, interface, or enum expected
	 * @return an interval containing the realEigenvalues
	           ^, EigenDecompositionImpl.java:1627: error: class, interface, or enum expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
	    	                                        ^, EigenDecompositionImpl.java:1627: error: class, interface, or enum expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
	    	                                                         ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				      ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			      ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			^]
Ingredient counter is Zero
---Undoing: gnrtn(33): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `eCurrent = java.lang.Math.abs(secondary[i]) ` -topatch--> `final double gam = dN2` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (65(f=1.0), 66(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (65(f=1.0), )
----------Running generation: 34, population size: 1

***** Generation 34 : 0
**Parent Variant: [Variant id: 67, #gens: 539, #ops: 0, parent:-]

--Child created id: 68
--Creating new operations for variant [Variant id: 68, #gens: 539, #ops: 0, parent:67]
---analyzing modificationPoint position: 26
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  dN = work[j4p2 + 2]
---analyzing modificationPoint position: 332
Templates availables26
Attempts Base Ingredients  1 total 26
---modifPoint 1 not mutation generated in  z *= -work[(6 * i) - 1]
---analyzing modificationPoint position: 384
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  work[sixI + 2] = liP1
---analyzing modificationPoint position: 1
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  break
---analyzing modificationPoint position: 17
location: EigenDecompositionImpl.java1139
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[i + k] = work[j - k] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 68, #gens: 538, #ops: 1, parent:67] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child compiles: id 68
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-68/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: true, failTest= 0, was successful: true, cases executed: 18] ,[]
-Test Failing is passing, Executing regression
Executing process: (timeout724secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/variant-68/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-80/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.stat.data.LotteryTest  org.apache.commons.math.linear.FieldMatrixImplTest  org.apache.commons.math.ode.sampling.StepNormalizerTest  org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest  org.apache.commons.math.geometry.RotationOrderTest  org.apache.commons.math.analysis.solvers.NewtonSolverTest  org.apache.commons.math.estimation.EstimatedParameterTest  org.apache.commons.math.linear.CholeskyDecompositionImplTest  org.apache.commons.math.linear.Array2DRowRealMatrixTest  org.apache.commons.math.linear.SparseRealMatrixTest  org.apache.commons.math.util.OpenIntToFieldTest  org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest  org.apache.commons.math.optimization.fitting.PolynomialFitterTest  org.apache.commons.math.linear.ArrayRealVectorTest  org.apache.commons.math.distribution.HypergeometricDistributionTest  org.apache.commons.math.random.RandomAdaptorTest  org.apache.commons.math.ode.FirstOrderConverterTest  org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest  org.apache.commons.math.stat.inference.TestUtilsTest  org.apache.commons.math.stat.data.LewTest  org.apache.commons.math.distribution.GammaDistributionTest  org.apache.commons.math.stat.descriptive.rank.MedianTest  org.apache.commons.math.distribution.ZipfDistributionTest  org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest  org.apache.commons.math.stat.CertifiedDataTest  org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest  org.apache.commons.math.complex.FrenchComplexFormatTest  org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest  org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest  org.apache.commons.math.DuplicateSampleAbscissaExceptionTest  org.apache.commons.math.estimation.MinpackTest  org.apache.commons.math.genetics.FixedGenerationCountTest  org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest  org.apache.commons.math.fraction.BigFractionFormatTest  org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest  org.apache.commons.math.random.RandomDataTest  org.apache.commons.math.distribution.FDistributionTest  org.apache.commons.math.FunctionEvaluationExceptionTest  org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest  org.apache.commons.math.stat.inference.TTestFactoryTest  org.apache.commons.math.stat.descriptive.moment.SkewnessTest  org.apache.commons.math.special.GammaTest  org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest  org.apache.commons.math.analysis.integration.RombergIntegratorTest  org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest  org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest  org.apache.commons.math.stat.descriptive.SummaryStatisticsTest  org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest  org.apache.commons.math.stat.descriptive.moment.FirstMomentTest  org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest  org.apache.commons.math.complex.ComplexTest  org.apache.commons.math.distribution.BetaDistributionTest  org.apache.commons.math.special.ErfTest  org.apache.commons.math.special.BetaTest  org.apache.commons.math.ode.nonstiff.GillIntegratorTest  org.apache.commons.math.random.EmpiricalDistributionTest  org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest  org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest  org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest  org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest  org.apache.commons.math.random.AbstractRandomGeneratorTest  org.apache.commons.math.fraction.BigFractionFieldTest  org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest  org.apache.commons.math.genetics.GeneticAlgorithmTestBinary  org.apache.commons.math.linear.BiDiagonalTransformerTest  org.apache.commons.math.util.DefaultTransformerTest  org.apache.commons.math.linear.LUDecompositionImplTest  org.apache.commons.math.random.ValueServerTest  org.apache.commons.math.stat.descriptive.moment.MeanTest  org.apache.commons.math.util.BigRealFieldTest  org.apache.commons.math.linear.QRDecompositionImplTest  org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest  org.apache.commons.math.stat.descriptive.moment.VarianceTest  org.apache.commons.math.genetics.OnePointCrossoverTest  org.apache.commons.math.stat.ranking.NaturalRankingTest  org.apache.commons.math.optimization.linear.SimplexSolverTest  org.apache.commons.math.stat.descriptive.moment.FourthMomentTest  org.apache.commons.math.linear.BlockRealMatrixTest  org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest  org.apache.commons.math.random.MersenneTwisterTest  org.apache.commons.math.genetics.RandomKeyTest  org.apache.commons.math.stat.descriptive.summary.ProductTest  org.apache.commons.math.fraction.FractionTest  org.apache.commons.math.util.OpenIntToDoubleHashMapTest  org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest  org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest  org.apache.commons.math.genetics.ChromosomeTest  org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest  org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest  org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest  org.apache.commons.math.geometry.Vector3DTest  org.apache.commons.math.stat.descriptive.rank.MinTest  org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest  org.apache.commons.math.linear.FieldLUDecompositionImplTest  org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest  org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest  org.apache.commons.math.transform.FastHadamardTransformerTest  org.apache.commons.math.optimization.fitting.HarmonicFitterTest  org.apache.commons.math.stat.correlation.PearsonsCorrelationTest  org.apache.commons.math.random.GaussianRandomGeneratorTest  org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest  org.apache.commons.math.linear.FrenchRealVectorFormatTest  org.apache.commons.math.fraction.BigFractionTest  org.apache.commons.math.util.ContinuedFractionTest  org.apache.commons.math.util.TransformerMapTest  org.apache.commons.math.analysis.solvers.BisectionSolverTest  org.apache.commons.math.genetics.BinaryChromosomeTest  org.apache.commons.math.linear.BlockFieldMatrixTest  org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest  org.apache.commons.math.linear.SingularValueDecompositionImplTest  org.apache.commons.math.distribution.TDistributionTest  org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest  org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest  org.apache.commons.math.linear.InvalidMatrixExceptionTest  org.apache.commons.math.distribution.BinomialDistributionTest  org.apache.commons.math.linear.EigenSolverTest  org.apache.commons.math.stat.inference.TTestTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest  org.apache.commons.math.random.UniformRandomGeneratorTest  org.apache.commons.math.stat.descriptive.rank.PercentileTest  org.apache.commons.math.analysis.solvers.RiddersSolverTest  org.apache.commons.math.linear.ArrayFieldVectorTest  org.apache.commons.math.ode.ContinuousOutputModelTest  org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest  org.apache.commons.math.optimization.linear.SimplexTableauTest  org.apache.commons.math.ConvergenceExceptionTest  org.apache.commons.math.util.ResizableDoubleArrayTest  org.apache.commons.math.complex.ComplexFormatTest  org.apache.commons.math.linear.RealMatrixImplTest  org.apache.commons.math.stat.descriptive.summary.SumTest  org.apache.commons.math.linear.SparseFieldVectorTest  org.apache.commons.math.genetics.ElitisticListPopulationTest  org.apache.commons.math.stat.descriptive.summary.SumSqTest  org.apache.commons.math.linear.SparseRealVectorTest  org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest  org.apache.commons.math.linear.EigenDecompositionImplTest  org.apache.commons.math.analysis.integration.SimpsonIntegratorTest  org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest  org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest  org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations  org.apache.commons.math.stat.descriptive.moment.KurtosisTest  org.apache.commons.math.transform.FastFourierTransformerTest  org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest  org.apache.commons.math.distribution.NormalDistributionTest  org.apache.commons.math.distribution.PoissonDistributionTest  org.apache.commons.math.geometry.Vector3DFormatTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest  org.apache.commons.math.genetics.TournamentSelectionTest  org.apache.commons.math.optimization.general.MinpackTest  org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest  org.apache.commons.math.analysis.solvers.BrentSolverTest  org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest  org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest  org.apache.commons.math.estimation.WeightedMeasurementTest  org.apache.commons.math.stat.inference.ChiSquareTestTest  org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest  org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest  org.apache.commons.math.linear.MatrixIndexExceptionTest  org.apache.commons.math.genetics.BinaryMutationTest  org.apache.commons.math.fraction.FractionFormatTest  org.apache.commons.math.distribution.PascalDistributionTest  org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest  org.apache.commons.math.util.MathUtilsTest  org.apache.commons.math.complex.ComplexUtilsTest  org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest  org.apache.commons.math.optimization.direct.MultiDirectionalTest  org.apache.commons.math.genetics.FitnessCachingTest  org.apache.commons.math.linear.BigMatrixImplTest  org.apache.commons.math.stat.inference.ChiSquareFactoryTest  org.apache.commons.math.fraction.FractionFieldTest  org.apache.commons.math.stat.descriptive.InteractionTest  org.apache.commons.math.stat.correlation.CovarianceTest  org.apache.commons.math.optimization.univariate.BrentMinimizerTest  org.apache.commons.math.linear.QRSolverTest  org.apache.commons.math.linear.RealVectorFormatTest  org.apache.commons.math.analysis.solvers.LaguerreSolverTest  org.apache.commons.math.linear.CholeskySolverTest  org.apache.commons.math.distribution.WeibullDistributionTest  org.apache.commons.math.stat.StatUtilsTest  org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest  org.apache.commons.math.analysis.solvers.MullerSolverTest  org.apache.commons.math.linear.TriDiagonalTransformerTest  org.apache.commons.math.distribution.ChiSquareDistributionTest  org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest  org.apache.commons.math.transform.FastSineTransformerTest  org.apache.commons.math.stat.inference.OneWayAnovaTest  org.apache.commons.math.transform.FastCosineTransformerTest  org.apache.commons.math.ArgumentOutsideDomainExceptionTest  org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest  org.apache.commons.math.ode.nonstiff.EulerIntegratorTest  org.apache.commons.math.stat.descriptive.rank.MaxTest  org.apache.commons.math.complex.ComplexFieldTest  org.apache.commons.math.stat.descriptive.ListUnivariateImplTest  org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest  org.apache.commons.math.MaxIterationsExceededExceptionTest  org.apache.commons.math.linear.MatrixUtilsTest  org.apache.commons.math.optimization.direct.NelderMeadTest  org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest  org.apache.commons.math.geometry.RotationTest  org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest  org.apache.commons.math.linear.SingularValueSolverTest  org.apache.commons.math.genetics.RandomKeyMutationTest  org.apache.commons.math.util.BigRealTest  org.apache.commons.math.distribution.ExponentialDistributionTest  org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest  org.apache.commons.math.geometry.FrenchVector3DFormatTest  org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest  org.apache.commons.math.stat.regression.SimpleRegressionTest  org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest  org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest  org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest  org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest  org.apache.commons.math.linear.LUSolverTest  org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest  org.apache.commons.math.MathConfigurationExceptionTest  org.apache.commons.math.estimation.GaussNewtonEstimatorTest  org.apache.commons.math.genetics.ListPopulationTest  org.apache.commons.math.MathExceptionTest  org.apache.commons.math.distribution.CauchyDistributionTest  org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest  org.apache.commons.math.linear.SparseFieldMatrixTest  org.apache.commons.math.stat.descriptive.summary.SumLogTest  org.apache.commons.math.stat.FrequencyTest  org.apache.commons.math.stat.descriptive.moment.SecondMomentTest
Analyzing output from process
TR: Success: true, failTest= 0, was successful: true, cases executed: 2104] ,[]
-Valid?: |true|0|2104|[]|, fitness 0.0
-Found Solution, child variant #68
Ingredient counter is Zero

Attempts to find patch Id 68: 0, successful 0, failing 0

-Saving child on disk variant #68 at /Users/marekmazur/astor/./output_astor/AstorMain-math-80//src//variant-68

-Saving child on disk variant #68 at /Users/marekmazur/astor/./output_astor/AstorMain-math-80//src//variant-68_f
---Undoing: gnrtn(34): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[i + k] = work[j - k] ` -topatch--> `-` (null) 
/Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/default_f/org/apache/commons/math/linear/EigenDecompositionImpl.java
/Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/variant-68_f/org/apache/commons/math/linear/EigenDecompositionImpl.java
diff command : diff -w -b  --label=/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java --label=/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java /Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/default_f/org/apache/commons/math/linear/EigenDecompositionImpl.java /Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/variant-68_f/org/apache/commons/math/linear/EigenDecompositionImpl.java --unified=0
/Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/default/org/apache/commons/math/linear/EigenDecompositionImpl.java
/Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/variant-68/org/apache/commons/math/linear/EigenDecompositionImpl.java
diff command : diff -w -b  --label=/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java --label=/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java /Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/default/org/apache/commons/math/linear/EigenDecompositionImpl.java /Users/marekmazur/astor/./output_astor/AstorMain-math-80/src/variant-68/org/apache/commons/math/linear/EigenDecompositionImpl.java --unified=0
Generation 1
Generation 2
Generation 3
Generation 4
Generation 5
Generation 6
Generation 7
Generation 8
Generation 9
Generation 10
Generation 11
Generation 12
Generation 13
Generation 14
Generation 15
Generation 16
Generation 17
Generation 18
Generation 19
Generation 20
Generation 21
Generation 22
Generation 23
Generation 24
Generation 25
Generation 26
Generation 27
Generation 28
Generation 29
Generation 30
Generation 31
Generation 32
Generation 33
Generation 34
Storing ing JSON at ./diffSolutions/patchinfo_68.json
./diffSolutions/patchinfo_68.json:
{"VARIANT_ID":"68","VALIDATION":"|true|0|2104|[]|","patchhunks":[{"LOCATION":"org.apache.commons.math.linear.EigenDecompositionImpl","PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/defects4j\\\/math-80\\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","INGREDIENT_SCOPE":"-","ORIGINAL_CODE":"work[i + k] = work[j - k]","BUGGY_CODE_TYPE":"CtAssignmentImpl|CtBlockImpl","OPERATOR":"RemoveOp","MODIFIED_FILE_PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-80\\\/\\\/src\\\/\\\/variant-68\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","LINE":"1139","SUSPICIOUNESS":"1","MP_RANKING":"17"}],"TIME":"49","GENERATION":"34","FOLDER_SOLUTION_CODE":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-80\\\/\\\/src\\\/\\\/variant-68","PATCH_DIFF_ORIG":"--- \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n+++ \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n@@ -1139 +1139 @@\\n-\\t\\t\\t\\t\\twork[i + k] = work[j - k];\\n+\\n\\n"}
Saving patch info at ./diffSolutions/patchinfo_68.json
Storing ing JSON at /Users/marekmazur/astor/./diffSolutions/patch_49972_68.diff
/Users/marekmazur/astor/./diffSolutions/patch_49972_68.diff:
{"VARIANT_ID":"68","VALIDATION":"|true|0|2104|[]|","patchhunks":[{"LOCATION":"org.apache.commons.math.linear.EigenDecompositionImpl","PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/defects4j\\\/math-80\\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","INGREDIENT_SCOPE":"-","ORIGINAL_CODE":"work[i + k] = work[j - k]","BUGGY_CODE_TYPE":"CtAssignmentImpl|CtBlockImpl","OPERATOR":"RemoveOp","MODIFIED_FILE_PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-80\\\/\\\/src\\\/\\\/variant-68\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","LINE":"1139","SUSPICIOUNESS":"1","MP_RANKING":"17"}],"TIME":"49","GENERATION":"34","FOLDER_SOLUTION_CODE":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-80\\\/\\\/src\\\/\\\/variant-68","PATCH_DIFF_ORIG":"--- \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n+++ \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n@@ -1139 +1139 @@\\n-\\t\\t\\t\\t\\twork[i + k] = work[j - k];\\n+\\n\\n"}
Saving patch diff at /Users/marekmazur/astor/./diffSolutions/patch_49972_68.diff
End analysis generation - Solutions found:--> (68(SOLUTION)(f=0.0), )
Variants to next generation from: 2-->IDs: (68(f=0.0)[SOL], 67(f=1.0), )
Selected to next generation: IDs2--> (67(f=1.0), )
Max Solution found 1
Time Repair Loop (s): 49.973
generationsexecuted: 34
----SUMMARY_EXECUTION---
End Repair Search: Found solution
Solution stored at: /Users/marekmazur/astor/./output_astor/AstorMain-math-80//src/
Number solutions:1
f (sol): 0.0, [Variant id: 68 (SOL) , #gens: 538, #ops: 1, parent:67]
All variants:
f 1.0, [Variant id: 69, #gens: 539, #ops: 0, parent:-]
Number suspicious:1

 --SOLUTIONS DESCRIPTION--

 ----
ProgramVariant 68
 
time(sec)= 49
operation: RemoveOp
location= org.apache.commons.math.linear.EigenDecompositionImpl
line= 1139
lineSuspiciousness= 1
lineSuspiciousness= 17
original statement= work[i + k] = work[j - k]
buggy kind= CtAssignmentImpl|CtBlockImpl
fixed statement= 
generation= 34
ingredientScope= -
validation=|true|0|2104|[]|
diffpatch=--- /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
+++ /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
@@ -1090 +1089,0 @@
-					work[i + k] = work[j - k];


diffpatchoriginal=--- /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
+++ /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
@@ -1139 +1139 @@
-					work[i + k] = work[j - k];
+



Astor Output:

General stats:
EXECUTION_IDENTIFIER=
TOTAL_TIME=49.973
NR_GENERATIONS=34
NR_RIGHT_COMPILATIONS=17
NR_FAILLING_COMPILATIONS=17
NR_ERRONEOUS_VARIANCES=null
NR_FAILING_VALIDATION_PROCESS=null
OUTPUT_STATUS=STOP_BY_PATCH_FOUND
FAULT_LOCALIZATION=flacoco

Patch stats:

Patch 1
VARIANT_ID=68
TIME=49
VALIDATION=|true|0|2104|[]|
GENERATION=34
FOLDER_SOLUTION_CODE=/Users/marekmazur/astor/./output_astor/AstorMain-math-80//src//variant-68
--Patch Hunk #1
OPERATOR=RemoveOp

LOCATION=org.apache.commons.math.linear.EigenDecompositionImpl

PATH=/Users/marekmazur/astor/defects4j/math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java

MODIFIED_FILE_PATH=/Users/marekmazur/astor/./output_astor/AstorMain-math-80//src//variant-68/org/apache/commons/math/linear/EigenDecompositionImpl.java

LINE=1139

SUSPICIOUNESS=1

MP_RANKING=17

ORIGINAL_CODE=work[i + k] = work[j - k]

BUGGY_CODE_TYPE=CtAssignmentImpl|CtBlockImpl

PATCH_HUNK_CODE=null

PATCH_HUNK_TYPE=null

INGREDIENT_SCOPE=-

INGREDIENT_PARENT=null

PATCH_DIFF_ORIG=--- /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
+++ /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
@@ -1139 +1139 @@
-					work[i + k] = work[j - k];
+



Storing ing JSON at /Users/marekmazur/astor/./output_astor/AstorMain-math-80//astor_output.json
astor_output:
{"general":{"NR_RIGHT_COMPILATIONS":17,"NR_ERRONEOUS_VARIANCES":null,"EXECUTION_IDENTIFIER":"","FAULT_LOCALIZATION":"flacoco","OUTPUT_STATUS":"STOP_BY_PATCH_FOUND","NR_FAILLING_COMPILATIONS":17,"NR_GENERATIONS":34,"TOTAL_TIME":49.973,"NR_FAILING_VALIDATION_PROCESS":null},"patches":[{"VARIANT_ID":"68","VALIDATION":"|true|0|2104|[]|","patchhunks":[{"LOCATION":"org.apache.commons.math.linear.EigenDecompositionImpl","PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/defects4j\\\/math-80\\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","INGREDIENT_SCOPE":"-","ORIGINAL_CODE":"work[i + k] = work[j - k]","BUGGY_CODE_TYPE":"CtAssignmentImpl|CtBlockImpl","OPERATOR":"RemoveOp","MODIFIED_FILE_PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-80\\\/\\\/src\\\/\\\/variant-68\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","LINE":"1139","SUSPICIOUNESS":"1","MP_RANKING":"17"}],"TIME":"49","GENERATION":"34","FOLDER_SOLUTION_CODE":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-80\\\/\\\/src\\\/\\\/variant-68","PATCH_DIFF_ORIG":"--- \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n+++ \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n@@ -1139 +1139 @@\\n-\\t\\t\\t\\t\\twork[i + k] = work[j - k];\\n+\\n\\n"}]}
Time Total(s): 250.425
