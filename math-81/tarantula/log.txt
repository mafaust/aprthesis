[0] INFO ProjectConfiguration - Version of the JVM used: 1.8.0_202
[1] INFO main - Java version of the JDK used to run tests: 1.8.0_202
[1] INFO main - The compliance of the JVM is:  8
[2] INFO main - command line arguments: [-location  /Users/marekmazur/astor/defects4j/math-81  -mode  jgenprog  -package  org.apache.commons  -jvm4testexecution  /Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin  -failing  org.apache.commons.math.linear.EigenDecompositionImplTest  -srcjavafolder  /src/java/  -srctestfolder  /src/test/  -binjavafolder  /target/classes/  -bintestfolder  /target/test-classes/  -stopfirst  true  -dependencies  /Users/marekmazur/astor/examples/libs/junit-4.4.jar  -maxgen  1000000  -seed  10  -maxtime  60  -scope  local  -stopfirst  true  -flthreshold  0  -population  1  -faultlocalization  flacoco]
[5] INFO AstorMain - Running Astor on a JDK at /Users/marekmazur/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/jre
Source folders: [/Users/marekmazur/astor/defects4j/math-81/src/main/java]
Source Test folders: [/Users/marekmazur/astor/defects4j/math-81/src/test]
---- Creating spoon model
Creating model,  Code location from working folder: /Users/marekmazur/astor/defects4j/math-81/src/main/java
building model: /Users/marekmazur/astor/defects4j/math-81/src/main/java, compliance level: 8
Classpath (Dependencies) for building SpoonModel: [/Users/marekmazur/astor/examples/libs/junit-4.4.jar]
Spoon Model built from location: /Users/marekmazur/astor/defects4j/math-81/src/main/java
Number of CtTypes created: 393
Running chosen test detection strategy: CLASSLOADER
Test retrieved from classes: 225
Running Flacoco...
Running spectrum-based fault localization...
FlacocoConfig{workspace='/Users/marekmazur/astor/.', projectPath='/Users/marekmazur/astor/defects4j/math-81', srcJavaDir=[/Users/marekmazur/astor/defects4j/math-81/src/main/java], srcTestDir=[/Users/marekmazur/astor/defects4j/math-81/src/test], binJavaDir=[/Users/marekmazur/astor/defects4j/math-81/target/classes], binTestDir=[/Users/marekmazur/astor/defects4j/math-81/target/test-classes], classpath='/Users/marekmazur/astor/examples/libs/junit-4.4.jar', customJUnitClasspath='null', customJacocoClasspath='null', mavenHome='/Users/marekmazur/.m2/repository/', coverTests=false, testRunnerVerbose=false, testRunnerTimeoutInMs=3600000, testRunnerJVMArgs='null', threshold=0.0, includeZeros=false, complianceLevel=8, testDetectionStrategy=CLASSLOADER, ignoredTests=[], jUnit4Tests=[org.apache.commons.math.linear.SparseRealMatrixTest#testSerial, org.apache.commons.math.util.MathUtilsTest#testL2DistanceInt, org.apache.commons.math.linear.QRSolverTest#testOverdetermined, org.apache.commons.math.linear.SingularValueSolverTest#testSolveSingularityErrors, org.apache.commons.math.fraction.BigFractionTest#testPow, org.apache.commons.math.linear.BigMatrixImplTest#testSubMatrix, org.apache.commons.math.geometry.RotationTest#testCompose, org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testParameters, org.apache.commons.math.linear.RealMatrixImplTest#testAdd, org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowFieldMatrix, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testDimensions, org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.ode.FirstOrderConverterTest#testSmallStep, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithSplit, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNonDefaultSetting, org.apache.commons.math.stat.StatUtilsTest#testStats, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testSwissFertility, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeReal, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFitting, org.apache.commons.math.stat.regression.SimpleRegressionTest#testCorr, org.apache.commons.math.linear.BiDiagonalTransformerTest#testDimensions, org.apache.commons.math.util.MathUtilsTest#testNextAfterSpecialCases, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testPerfectFit, org.apache.commons.math.distribution.TDistributionTest#testConsistency, org.apache.commons.math.stat.inference.TTestTest#testOneSampleT, org.apache.commons.math.random.RandomAdaptorTest#testConfig, org.apache.commons.math.complex.ComplexTest#testConstructor, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testIllConditioned, org.apache.commons.math.complex.ComplexTest#testMultiplyNaN, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testConsistency, org.apache.commons.math.util.MathUtilsTest#testSubAndCheckLong, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowMatrix, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testGetValues, org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArguments, org.apache.commons.math.distribution.WeibullDistributionTest#testSampling, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSanityChecks, org.apache.commons.math.linear.BlockRealMatrixTest#testCopyFunctions, org.apache.commons.math.linear.LUSolverTest#testSolveDimensionErrors, org.apache.commons.math.linear.BigMatrixImplTest#testPlusMinus, org.apache.commons.math.distribution.CauchyDistributionTest#testIllegalArguments, org.apache.commons.math.random.ValueServerTest#testReplay, org.apache.commons.math.util.MathUtilsTest#testSignInt, org.apache.commons.math.distribution.GammaDistributionTest#testCumulativeProbabilities, org.apache.commons.math.linear.BlockFieldMatrixTest#testAddFail, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnLarge, org.apache.commons.math.fraction.FractionTest#testDoubleValue, org.apache.commons.math.linear.SparseFieldVectorTest#testMapFunctions, org.apache.commons.math.distribution.HypergeometricDistributionTest#testIllegalArguments, org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#checkClone, org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestNegative, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testIncrementation, org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewNewtonSolverValid, org.apache.commons.math.complex.ComplexTest#testGetArgumentNaN, org.apache.commons.math.geometry.Vector3DTest#testAdd, org.apache.commons.math.transform.FastSineTransformerTest#testSinFunction, org.apache.commons.math.stat.FrequencyTest#testSerial, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowMatrix, org.apache.commons.math.linear.LUDecompositionImplTest#testDimensions, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPlusMinus, org.apache.commons.math.special.BetaTest#testLogBetaPositiveZero, org.apache.commons.math.fraction.BigFractionFieldTest#testSerial, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testString, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerial, org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructor, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPermutation, org.apache.commons.math.linear.EigenSolverTest#testSolve, org.apache.commons.math.complex.ComplexTest#testTan, org.apache.commons.math.distribution.PoissonDistributionTest#testDensities, org.apache.commons.math.util.BigRealTest#testConstructor, org.apache.commons.math.linear.BigMatrixImplTest#testIsSingular, org.apache.commons.math.MaxIterationsExceededExceptionTest#testSimpleConstructor, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateSin, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonEqualCounts, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testMinStep, org.apache.commons.math.linear.SingularValueSolverTest#testSolveDimensionErrors, org.apache.commons.math.special.BetaTest#testLogBetaNanPositive, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testDeprecated, org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSimplistic, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTrivial, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEvaluation, org.apache.commons.math.util.MathUtilsTest#testPermutedArrayHash, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowLarge, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentEquations, org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#derivativesConsistency, org.apache.commons.math.linear.SparseRealMatrixTest#testTranspose, org.apache.commons.math.geometry.Vector3DTest#testNorm, org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumn, org.apache.commons.math.complex.ComplexTest#testCosNaN, org.apache.commons.math.linear.BigMatrixImplTest#testPremultiplyVector, org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testSinFunction, org.apache.commons.math.linear.CholeskySolverTest#testDeterminant, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataThatIsNotSquare, org.apache.commons.math.genetics.RandomKeyTest#testIsSame, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotSymmetricMatrixException, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testEqualsAndHashCode, org.apache.commons.math.random.RandomDataTest#testNextUniform, org.apache.commons.math.fraction.FractionTest#testCompareTo, org.apache.commons.math.linear.RealMatrixImplTest#testSetRow, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEvaluation, org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnVector, org.apache.commons.math.linear.FieldMatrixImplTest#testSetSubMatrix, org.apache.commons.math.stat.CertifiedDataTest#testSummaryStatistics, org.apache.commons.math.util.BigRealTest#testCompareTo, org.apache.commons.math.stat.descriptive.rank.MinTest#testConsistency, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonUnEqualCounts, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFittingBadInit, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsErrors, org.apache.commons.math.linear.RealMatrixImplTest#testToString, org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearFullRank, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexTest#testDivideInfinite, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNonInversible, org.apache.commons.math.fraction.FractionTest#testDoubleConstructor, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFittingBadInit, org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#serialization, org.apache.commons.math.genetics.RandomKeyMutationTest#testMutate, org.apache.commons.math.optimization.linear.SimplexSolverTest#testEpsilon, org.apache.commons.math.linear.RealMatrixImplTest#testGetRowVector, org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#serialization, org.apache.commons.math.estimation.WeightedMeasurementTest#testTheory, org.apache.commons.math.complex.ComplexTest#testSubtractNaN, org.apache.commons.math.random.RandomAdaptorTest#testNextPoisson, org.apache.commons.math.stat.descriptive.moment.MeanTest#testIncrementation, org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquare, org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedConsistency, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testNonSquare, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testInconsistentEquations, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleNoDecimals, org.apache.commons.math.complex.ComplexTest#testSqrtRealZero, org.apache.commons.math.linear.RealMatrixImplTest#testDimensions, org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproperNegative, org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testSinFunction, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveBadParameters, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testN0andN1Conditions, org.apache.commons.math.complex.ComplexFormatTest#testGetImaginaryFormat, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSetQuantile, org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryNegative, org.apache.commons.math.stat.FrequencyTest#testAddNonComparable, org.apache.commons.math.linear.BlockRealMatrixTest#testPlusMinus, org.apache.commons.math.linear.BigMatrixImplTest#testConstructors, org.apache.commons.math.complex.ComplexTest#testSinhNaN, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerial, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSerial, org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnVector, org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowVector, org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleTTest, org.apache.commons.math.fraction.BigFractionTest#testDoubleValue, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testWindowSize, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testQRColumnsPermutation, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testCopy, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerialization, org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvalues, org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate1, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testGetSummary, org.apache.commons.math.linear.BlockFieldMatrixTest#testPlusMinus, org.apache.commons.math.complex.FrenchComplexFormatTest#testPositiveInfinity, org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate0, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowLarge, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersSimple, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetFromEmpty, org.apache.commons.math.special.BetaTest#testRegularizedBetaNegativePositivePositive, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumn, org.apache.commons.math.stat.descriptive.summary.SumTest#testSerialization, org.apache.commons.math.linear.EigenDecompositionImplTest#testTridiagonal, org.apache.commons.math.linear.SparseFieldVectorTest#testBasicFunctions, org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.linear.SparseRealMatrixTest#testMath209, org.apache.commons.math.distribution.HypergeometricDistributionTest#testCumulativeProbabilities, org.apache.commons.math.linear.FieldMatrixImplTest#testGetVectors, org.apache.commons.math.geometry.RotationTest#testAngles, org.apache.commons.math.linear.BigMatrixImplTest#testEqualsAndHashCode, org.apache.commons.math.analysis.solvers.BrentSolverTest#testQuinticZero, org.apache.commons.math.optimization.linear.SimplexSolverTest#testSolutionWithNegativeDecisionVariable, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testMultiplication, org.apache.commons.math.distribution.ChiSquareDistributionTest#testDfAccessors, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLaguerrePolynomials, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnMatrix, org.apache.commons.math.ode.ContinuousOutputModelTest#testRandomAccess, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterInjection, org.apache.commons.math.genetics.RandomKeyTest#testIdentityPermutation, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testCovarianceConsistency, org.apache.commons.math.distribution.BetaDistributionTest#testDensity, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testIncreasingTolerance, org.apache.commons.math.fraction.BigFractionFormatTest#testParseBig, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testSanityChecks, org.apache.commons.math.linear.SparseRealMatrixTest#testSetSubMatrix, org.apache.commons.math.linear.QRSolverTest#testSolveRankErrors, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testShuffledStatistics, org.apache.commons.math.geometry.Vector3DTest#testDistanceSq, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterInjection, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumn, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHermiteDifferentials, org.apache.commons.math.distribution.NormalDistributionTest#testGetMean, org.apache.commons.math.genetics.RandomKeyTest#testComparatorPermutation, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIntegratorControls, org.apache.commons.math.stat.regression.SimpleRegressionTest#testSSENonNegative, org.apache.commons.math.linear.RealMatrixImplTest#testGetEntry, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSerialization, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension1, org.apache.commons.math.optimization.linear.SimplexSolverTest#testTrivialModel, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension2, org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#testDerivativesConsistency, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMatricesValues, org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeY, org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeZ, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFitting, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension3, org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnVector, org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeX, org.apache.commons.math.fraction.FractionFormatTest#testParseProperInvalidMinus, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSeparator, org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne2, org.apache.commons.math.genetics.GeneticAlgorithmTestBinary#test, org.apache.commons.math.complex.ComplexTest#testTanhCritical, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateDegenerate, org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne1, org.apache.commons.math.geometry.Vector3DTest#testSubtract, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testIllegalArguments, org.apache.commons.math.complex.ComplexFormatTest#testNegativeImaginary, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIncreasingTolerance, org.apache.commons.math.random.RandomAdaptorTest#testNextSample, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetFunctionValueAccuracy, org.apache.commons.math.linear.SparseRealMatrixTest#testTrace, org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnBigMatrix, org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumn, org.apache.commons.math.linear.ArrayFieldVectorTest#testMapFunctions, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTwoSets, org.apache.commons.math.stat.descriptive.rank.MaxTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.moment.MeanTest#testEvaluation, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testMomentSmallSamples, org.apache.commons.math.linear.BlockFieldMatrixTest#testDimensions, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEqualsAndHashCode, org.apache.commons.math.fraction.FractionFieldTest#testSerial, org.apache.commons.math.linear.SparseRealVectorTest#testMisc, org.apache.commons.math.special.GammaTest#testLogGammaPositive, org.apache.commons.math.stat.StatUtilsTest#testProduct, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterIllegalState, org.apache.commons.math.complex.ComplexTest#testCosInf, org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownAlmostLinear, org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest#testRosenbrock, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.estimation.MinpackTest#testMinpackBrownAlmostLinear, org.apache.commons.math.genetics.BinaryChromosomeTest#testInvalidConstructor, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testMomentSmallSamples, org.apache.commons.math.geometry.Vector3DTest#testNormalize, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction2, org.apache.commons.math.genetics.RandomKeyTest#testEqualRepr, org.apache.commons.math.complex.FrenchComplexFormatTest#testStaticFormatComplex, org.apache.commons.math.stat.correlation.CovarianceTest#testConstant, org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaTest, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutOnExisting, org.apache.commons.math.complex.ComplexFormatTest#testParseZeroReal, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParsePositiveInfinity, org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testExpm1Function, org.apache.commons.math.geometry.Vector3DFormatTest#testParsePositiveInfinity, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDimensionCheck, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimensions, org.apache.commons.math.geometry.Vector3DTest#testAngular, org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacity, org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testSinFunction, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testIllConditioned, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArguments, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testVariableSteps, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerial, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketSin, org.apache.commons.math.util.MathUtilsTest#testGcd, org.apache.commons.math.distribution.GammaDistributionTest#testValues, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeBoth, org.apache.commons.math.linear.FieldMatrixImplTest#testEqualsAndHashCode, org.apache.commons.math.linear.BigMatrixImplTest#testMultiply2, org.apache.commons.math.genetics.FitnessCachingTest#testFitnessCaching, org.apache.commons.math.random.RandomAdaptorTest#testNextUniform, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiplyVector, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeZ, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSample, org.apache.commons.math.distribution.WeibullDistributionTest#testConsistency, org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoSuccesses, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeX, org.apache.commons.math.stat.FrequencyTest#testAdd, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeY, org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeImaginary, org.apache.commons.math.distribution.BetaDistributionTest#testCumulative, org.apache.commons.math.random.RandomDataTest#testNextPoisson, org.apache.commons.math.distribution.ChiSquareDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290LEQ, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetMatrixLarge, org.apache.commons.math.distribution.HypergeometricDistributionTest#testLargeValues, org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexInf, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#backward, org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testQuinticMin, org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate1, org.apache.commons.math.special.BetaTest#testLogBetaNegativePositive, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testOneSet, org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate0, org.apache.commons.math.distribution.CauchyDistributionTest#testScale, org.apache.commons.math.util.MathUtilsTest#testSubAndCheck, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testNaNContracts, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testToString, org.apache.commons.math.fraction.BigFractionTest#testNegate, org.apache.commons.math.complex.ComplexTest#testExpInf, org.apache.commons.math.stat.regression.SimpleRegressionTest#testNorris, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroImaginary, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseIgnoredWhitespace, org.apache.commons.math.genetics.RandomKeyTest#testDecode, org.apache.commons.math.optimization.general.MinpackTest#testMinpackChebyquad, org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigMatrix, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConstant, org.apache.commons.math.analysis.integration.RombergIntegratorTest#testSinFunction, org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareIndependence, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testCopy, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBadParameters, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowVector, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testProductAndGeometricMean, org.apache.commons.math.genetics.FixedGenerationCountTest#testIsSatisfied, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGet, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveZeroPositive, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstChebyshevPolynomials, org.apache.commons.math.linear.RealMatrixImplTest#testTrace, org.apache.commons.math.optimization.direct.NelderMeadTest#testMinimizeMaximize, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopyConsistency, org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testInconsistentEquations, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testVariableSteps, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testConstructorSingleFormat, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testStepSize, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSpecialValues, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testIncrementation, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testNaN, org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSuffix, org.apache.commons.math.linear.QRSolverTest#testSolve, org.apache.commons.math.util.OpenIntToFieldTest#testGetAbsent, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testExamples, org.apache.commons.math.util.TransformerMapTest#testTransformers, org.apache.commons.math.util.OpenIntToFieldTest#testIterator, org.apache.commons.math.complex.ComplexFormatTest#testNegativeInfinity, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testConstants, org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply2, org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_fourthRoot, org.apache.commons.math.distribution.ZipfDistributionTest#testCumulativeProbabilities, org.apache.commons.math.special.GammaTest#testDigammaSmallArgs, org.apache.commons.math.linear.BlockRealMatrixTest#testGetVectors, org.apache.commons.math.stat.regression.SimpleRegressionTest#testInference, org.apache.commons.math.stat.descriptive.rank.PercentileTest#test5, org.apache.commons.math.linear.ArrayRealVectorTest#testMisc, org.apache.commons.math.distribution.WeibullDistributionTest#testIllegalArguments, org.apache.commons.math.optimization.direct.NelderMeadTest#testRosenbrock, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetEntry, org.apache.commons.math.stat.regression.SimpleRegressionTest#testClear, org.apache.commons.math.linear.SparseFieldMatrixTest#testAddFail, org.apache.commons.math.special.BetaTest#testRegularizedBetaZeroPositivePositive, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEvaluation, org.apache.commons.math.optimization.linear.SimplexSolverTest#testInfeasibleSolution, org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testQuinticFunction, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testSetterInjection, org.apache.commons.math.random.MersenneTwisterTest#testNextIntNeg, org.apache.commons.math.complex.ComplexTest#testEqualsTrue, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerial, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDecreasingSteps, org.apache.commons.math.complex.ComplexTest#testEqualsNull, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerialization, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply2, org.apache.commons.math.linear.SparseFieldMatrixTest#testSubMatrix, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArgumentCause, org.apache.commons.math.util.BigRealFieldTest#testOne, org.apache.commons.math.complex.ComplexTest#testScalarMultiply, org.apache.commons.math.linear.RealMatrixImplTest#testGetRow, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopy, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromSingle, org.apache.commons.math.util.TransformerMapTest#testClear, org.apache.commons.math.complex.ComplexTest#testSqrtPolar, org.apache.commons.math.random.ValueServerTest#testFill, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testWeightedConsistency, org.apache.commons.math.fraction.BigFractionFormatTest#testFormatZero, org.apache.commons.math.distribution.ChiSquareDistributionTest#testSmallDf, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNan, org.apache.commons.math.util.MathUtilsTest#testL1DistanceInt, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.stat.descriptive.summary.ProductTest#testSpecialValues, org.apache.commons.math.distribution.NormalDistributionTest#testMath280, org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareLargeTestStatistic, org.apache.commons.math.linear.EigenDecompositionImplTest#testDistinctEigenvalues, org.apache.commons.math.fraction.FractionFormatTest#testDoubleFormat, org.apache.commons.math.linear.BlockFieldMatrixTest#testSerial, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testDimensionCheck, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumn, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBigStep, org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testSerial, org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMath226, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLong, org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowVector, org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowMatrix, org.apache.commons.math.genetics.ElitisticListPopulationTest#testNextGeneration, org.apache.commons.math.analysis.integration.RombergIntegratorTest#testParameters, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureHex, org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexNaN, org.apache.commons.math.linear.RealVectorFormatTest#testParseZeroX, org.apache.commons.math.ConvergenceExceptionTest#testConstructor, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#checklone, org.apache.commons.math.estimation.MinpackTest#testMinpackHelicalValley, org.apache.commons.math.genetics.ListPopulationTest#testGetFittestChromosome, org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSeparator, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testLongly, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testMomentSmallSamples, org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowBigMatrix, org.apache.commons.math.linear.LUDecompositionImplTest#testLLowerTriangular, org.apache.commons.math.distribution.BinomialDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.util.MathUtilsTest#testLInfDistanceInt, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowVector, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNoDependency, org.apache.commons.math.linear.BiDiagonalTransformerTest#testUOrthogonal, org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiply, org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowRealMatrix, org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated2, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseManyComponents, org.apache.commons.math.special.GammaTest#testRegularizedGammaPositivePositive, org.apache.commons.math.util.TransformerMapTest#testPutTransformer, org.apache.commons.math.optimization.linear.SimplexSolverTest#testDegeneracy, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeAll, org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testQuinticFunction, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testDimension, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFittingBadInit, org.apache.commons.math.optimization.linear.SimplexTableauTest#testDropPhase1Objective, org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatObject, org.apache.commons.math.fraction.BigFractionFormatTest#testWholeFormat, org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testStepSize, org.apache.commons.math.util.MathUtilsTest#testNormalizeAngle, org.apache.commons.math.MathExceptionTest#testConstructorCause, org.apache.commons.math.complex.ComplexTest#testAbsNaN, org.apache.commons.math.stat.descriptive.rank.MinTest#testWeightedConsistency, org.apache.commons.math.util.MathUtilsTest#testIndicatorInt, org.apache.commons.math.linear.BlockRealMatrixTest#testAdd, org.apache.commons.math.linear.RealMatrixImplTest#testScalarAdd, org.apache.commons.math.special.GammaTest#testLogGammaZero, org.apache.commons.math.stat.StatUtilsTest#testPercentile, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareLargeTestStatistic, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopyConsistency, org.apache.commons.math.linear.RealMatrixImplTest#testOperate, org.apache.commons.math.stat.descriptive.rank.MaxTest#testMomentSmallSamples, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenPrefix, org.apache.commons.math.stat.correlation.CovarianceTest#testLongly, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTrivial, org.apache.commons.math.ode.ContinuousOutputModelTest#testErrorConditions, org.apache.commons.math.complex.ComplexFormatTest#testZeroImaginary, org.apache.commons.math.fraction.BigFractionFormatTest#testParseInteger, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testWeightedConsistency, org.apache.commons.math.random.MersenneTwisterTest#testNexBytes, org.apache.commons.math.complex.ComplexUtilsTest#testPolar2Complex, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testPercentileSetter, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testUnstableDerivative, org.apache.commons.math.complex.ComplexTest#testMath221, org.apache.commons.math.complex.ComplexTest#testSqrt1z, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnDistortedSine, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopy, org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowMatrix, org.apache.commons.math.geometry.RotationTest#testQuaternion, org.apache.commons.math.linear.ArrayFieldVectorTest#testDataInOut, org.apache.commons.math.random.RandomAdaptorTest#testNextPermutation, org.apache.commons.math.linear.RealMatrixImplTest#testMultiply, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testRedundantEquations, org.apache.commons.math.linear.QRDecompositionImplTest#testHTrapezoidal, org.apache.commons.math.linear.RealVectorFormatTest#testParseNan, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNoRoot, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testDimensions, org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.analysis.integration.RombergIntegratorTest#testQuinticFunction, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testN0andN1Conditions, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseZeroX, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterIllegalState, org.apache.commons.math.linear.QRDecompositionImplTest#testQOrthogonal, org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testMismatch, org.apache.commons.math.fraction.FractionFormatTest#testFormatZero, org.apache.commons.math.distribution.GammaDistributionTest#testConsistency, org.apache.commons.math.distribution.WeibullDistributionTest#testSetBeta, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDimensionCheck, org.apache.commons.math.linear.BiDiagonalTransformerTest#testMatricesValues, org.apache.commons.math.stat.data.LotteryTest#testCertifiedValues, org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testFixedState, org.apache.commons.math.fraction.BigFractionTest#testGetReducedFraction, org.apache.commons.math.linear.RealMatrixImplTest#testAddFail, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testSmallLastStep, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.util.TransformerMapTest#testContainsClass, org.apache.commons.math.linear.BlockFieldMatrixTest#testSeveralBlocks, org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFat, org.apache.commons.math.geometry.RotationTest#testMatrix, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerialization, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopy, org.apache.commons.math.stat.descriptive.summary.ProductTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.linear.SparseFieldMatrixTest#testCopyFunctions, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetAbsoluteAccuracy, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopyConsistency, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextHex, org.apache.commons.math.linear.BiDiagonalTransformerTest#testVOrthogonal, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMinimization, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testConsistency, org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHeterscedastic, org.apache.commons.math.geometry.Vector3DFormatTest#testParseIgnoredWhitespace, org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnMatrix, org.apache.commons.math.linear.RealVectorFormatTest#testNonDefaultSetting, org.apache.commons.math.fraction.FractionFieldTest#testZero, org.apache.commons.math.util.MathUtilsTest#test0Choose0, org.apache.commons.math.util.DefaultTransformerTest#testTransformString, org.apache.commons.math.distribution.NormalDistributionTest#testSetMean, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testCopy, org.apache.commons.math.linear.EigenDecompositionImplTest#testRepeatedEigenvalue, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerial, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerialization, org.apache.commons.math.stat.descriptive.rank.MinTest#testIncrementation, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testIncrementation, org.apache.commons.math.genetics.ChromosomeTest#testFindSameChromosome, org.apache.commons.math.linear.BlockFieldMatrixTest#testOperatePremultiplyLarge, org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimals, org.apache.commons.math.stat.descriptive.rank.MaxTest#testSpecialValues, org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiply, org.apache.commons.math.geometry.Vector3DFormatTest#testNan, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressandVariance, org.apache.commons.math.complex.ComplexTest#testConjugate, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testIncrementation, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevDifferentials, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNan, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsNoConvergence, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetEntry, org.apache.commons.math.distribution.WeibullDistributionTest#testAlpha, org.apache.commons.math.linear.BigMatrixImplTest#testTranspose, org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedUlps, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetRelativeAccuracy, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracySin, org.apache.commons.math.complex.FrenchComplexFormatTest#testNan, org.apache.commons.math.linear.ArrayRealVectorTest#testBasicFunctions, org.apache.commons.math.distribution.BinomialDistributionTest#testDensities, org.apache.commons.math.random.ValueServerTest#testEmptyDigestFile, org.apache.commons.math.fraction.BigFractionTest#testDivide, org.apache.commons.math.linear.BlockRealMatrixTest#testCopySubMatrix, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testConsistency, org.apache.commons.math.random.RandomAdaptorTest#testNextInt, org.apache.commons.math.complex.ComplexFormatTest#testParseZeroImaginary, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNullIntervalCheck, org.apache.commons.math.special.GammaTest#testTrigamma, org.apache.commons.math.fraction.BigFractionTest#testSerial, org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHeterscedastic, org.apache.commons.math.complex.ComplexTest#testDivideReal, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAdd, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testWeightedConsistency, org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply, org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testParameters, org.apache.commons.math.linear.MatrixUtilsTest#testCreateIdentityMatrix, org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove2, org.apache.commons.math.linear.FieldMatrixImplTest#testCopyFunctions, org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalid, org.apache.commons.math.distribution.NormalDistributionTest#testQuantiles, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testIncreasingTolerance, org.apache.commons.math.special.GammaTest#testDigammaLargeArgs, org.apache.commons.math.linear.ArrayRealVectorTest#testPredicates, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testVOrthogonal, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBackward, org.apache.commons.math.distribution.NormalDistributionTest#testCumulativeProbabilities, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRandom, org.apache.commons.math.linear.ArrayFieldVectorTest#testConstructors, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testRemoval, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetMaximalIterationCount, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testWalk, org.apache.commons.math.complex.ComplexTest#testDivideNaN, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnTwoPoints, org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testNoError, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnVector, org.apache.commons.math.fraction.FractionFormatTest#testParseProper, org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testSerialization, org.apache.commons.math.geometry.Vector3DTest#testScalarProduct, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArgumentsCause, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowMatrix, org.apache.commons.math.transform.FastCosineTransformerTest#testSinFunction, org.apache.commons.math.stat.descriptive.summary.SumTest#testEqualsAndHashCode, org.apache.commons.math.linear.RealMatrixImplTest#testTranspose, org.apache.commons.math.geometry.RotationTest#testVectorOnePair, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testIncreasingTolerance, org.apache.commons.math.linear.TriDiagonalTransformerTest#testQOrthogonal, org.apache.commons.math.special.BetaTest#testLogBetaPositiveNan, org.apache.commons.math.special.BetaTest#testLogBetaPositiveNegative, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testWrongDerivative, org.apache.commons.math.linear.SparseRealMatrixTest#testSubMatrix, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testQuinticFunction, org.apache.commons.math.distribution.PoissonDistributionTest#testNormalApproximateProbability, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMaximalTiesMinimum, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testMomentSmallSamples, org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#serialization, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationInside, org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleT, org.apache.commons.math.complex.ComplexTest#testNegateNaN, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNonDefaultSetting, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetVectors, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testStats, org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopy, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTranspose, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetEntry, org.apache.commons.math.linear.BigMatrixImplTest#testPremultiply, org.apache.commons.math.optimization.linear.SimplexTableauTest#testSerial, org.apache.commons.math.stat.descriptive.rank.MinTest#testMomentSmallSamples, org.apache.commons.math.fraction.BigFractionFormatTest#testDenominatorFormat, org.apache.commons.math.linear.BlockRealMatrixTest#testDimensions, org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#serialization, org.apache.commons.math.complex.ComplexTest#testSinNaN, org.apache.commons.math.complex.ComplexTest#testScalarMultiplyInf, org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testParaboloid2D, org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testEqualsAndHashCode, org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues2, org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues1, org.apache.commons.math.stat.descriptive.rank.MaxTest#testIncrementation, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentSizes, org.apache.commons.math.linear.RealVectorFormatTest#testNan, org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiplyVector, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwissFertility, org.apache.commons.math.genetics.RandomKeyTest#testConstructor2, org.apache.commons.math.genetics.RandomKeyTest#testConstructor1, org.apache.commons.math.util.BigRealTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexTest#testLogZero, org.apache.commons.math.util.ResizableDoubleArrayTest#testMinMax, org.apache.commons.math.linear.LUDecompositionImplTest#testUUpperTriangular, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNonInversible, org.apache.commons.math.random.RandomDataTest#testNextLongExtremeValues, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerialization, org.apache.commons.math.linear.TriDiagonalTransformerTest#testNonSquare, org.apache.commons.math.complex.ComplexTest#testCosh, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopyConsistency, org.apache.commons.math.linear.ArrayFieldVectorTest#testSerial, org.apache.commons.math.estimation.MinpackTest#testMinpackLinearFullRank, org.apache.commons.math.geometry.Vector3DFormatTest#testPositiveInfinity, org.apache.commons.math.stat.descriptive.rank.MinTest#testNaNs, org.apache.commons.math.stat.descriptive.summary.SumTest#testCopy, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testKepler, org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfect, org.apache.commons.math.linear.RealVectorFormatTest#testParseManyComponents, org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuinticFunction, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEqualsAndHashCode, org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply2, org.apache.commons.math.linear.ArrayFieldVectorTest#testBasicFunctions, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEqualsAndHashCode, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnLarge, org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeImaginary, org.apache.commons.math.linear.BlockFieldMatrixTest#testAdd, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNonDefaultSetting, org.apache.commons.math.fraction.BigFractionTest#testSubtract, org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnVector, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testConsistency, org.apache.commons.math.distribution.ChiSquareDistributionTest#testConsistency, org.apache.commons.math.fraction.FractionFormatTest#testParse, org.apache.commons.math.linear.FieldMatrixImplTest#testGetRow, org.apache.commons.math.linear.RealMatrixImplTest#testSetRowMatrix, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMaxIterations, org.apache.commons.math.linear.BigMatrixImplTest#testNorm, org.apache.commons.math.distribution.GammaDistributionTest#testDensity, org.apache.commons.math.fraction.BigFractionTest#testDigitLimitConstructor, org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnMatrix, org.apache.commons.math.linear.MatrixUtilsTest#testBigFractionConverter, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeInfinity, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#test20090720, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testIllConditioned, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTwoSets, org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testLinearFunction2D, org.apache.commons.math.linear.ArrayRealVectorTest#testSerial, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopyConsistency, org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGet, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMath199, org.apache.commons.math.linear.BlockFieldMatrixTest#testTrace, org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testStats, org.apache.commons.math.complex.ComplexFormatTest#testFormatObject, org.apache.commons.math.stat.descriptive.summary.SumTest#testCopyConsistency, org.apache.commons.math.transform.FastFourierTransformerTest#testSinFunction, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#serialization, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testContainsKey, org.apache.commons.math.complex.ComplexFormatTest#testSetRealFormatNull, org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantUnsolvable, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonBadCounts, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#backward, org.apache.commons.math.analysis.solvers.NewtonSolverTest#testSinZero, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testSmallStep, org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnMatrix, org.apache.commons.math.linear.FieldMatrixImplTest#testToString, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testKepler, org.apache.commons.math.linear.BlockRealMatrixTest#testWalk, org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated, org.apache.commons.math.linear.BlockFieldMatrixTest#testOperateLarge, org.apache.commons.math.stat.descriptive.rank.MinTest#testEvaluation, org.apache.commons.math.optimization.general.MinpackTest#testMinpackBox3Dimensional, org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeImaginary, org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnMatrix, org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArgumentsCause, org.apache.commons.math.linear.BlockRealMatrixTest#testOperateLarge, org.apache.commons.math.geometry.Vector3DTest#testDistanceInf, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBigStep, org.apache.commons.math.linear.BlockFieldMatrixTest#testTranspose, org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiplyVector, org.apache.commons.math.fraction.BigFractionTest#testGoldenRatio, org.apache.commons.math.linear.ArrayRealVectorTest#testDataInOut, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEvaluation, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEvaluation, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMaxIterations, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnOnePoint, org.apache.commons.math.ode.sampling.StepNormalizerTest#testBoundaries, org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiply, org.apache.commons.math.geometry.Vector3DTest#testAngularSeparation, org.apache.commons.math.random.RandomAdaptorTest#testNextSecureInt, org.apache.commons.math.linear.BigMatrixImplTest#testInverse, org.apache.commons.math.linear.SparseRealMatrixTest#testToString, org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testBackward, org.apache.commons.math.util.DefaultTransformerTest#testTransformDouble, org.apache.commons.math.MathExceptionTest#testSerialization, org.apache.commons.math.util.MathUtilsTest#testCosh, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterInjection, org.apache.commons.math.optimization.linear.SimplexTableauTest#testTableauWithNoArtificialVars, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetSubMatrix, org.apache.commons.math.util.MathUtilsTest#testScalb, org.apache.commons.math.genetics.BinaryChromosomeTest#testRandomConstructor, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeZ, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquare, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeY, org.apache.commons.math.estimation.EstimatedParameterTest#testEstimate, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeX, org.apache.commons.math.optimization.general.MinpackTest#testMinpackPowellSingular, org.apache.commons.math.util.OpenIntToFieldTest#testContainsKey, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testDeprecated, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testUUpperTriangular, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testConsistency, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopy, org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_thirdRoot, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNan, org.apache.commons.math.linear.BigMatrixImplTest#testToString, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath272, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleNoDecimals, org.apache.commons.math.stat.inference.TTestTest#testOneSampleTTest, org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSeparator, org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testSerialization, org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeReal, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMinimizeMaximize, org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply, org.apache.commons.math.stat.descriptive.summary.ProductTest#testConsistency, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnStraightLine, org.apache.commons.math.complex.ComplexTest#testSinh, org.apache.commons.math.random.RandomAdaptorTest#testNextExponential, org.apache.commons.math.linear.LUSolverTest#testDeterminant, org.apache.commons.math.stat.StatUtilsTest#testArrayIndexConditions, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testNaN, org.apache.commons.math.estimation.WeightedMeasurementTest#testConstruction, org.apache.commons.math.linear.SparseFieldMatrixTest#testMath209, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testVariableSteps, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testToString, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testGetSummary, org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedConsistency, org.apache.commons.math.util.MathUtilsTest#testNormalizeArray, org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath288, org.apache.commons.math.linear.EigenDecompositionImplTest#testDiagonal, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath286, org.apache.commons.math.analysis.solvers.BrentSolverTest#testInitialGuess, org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnRealMatrix, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testDimensionCheck, org.apache.commons.math.fraction.BigFractionFormatTest#testFormat, org.apache.commons.math.util.MathUtilsTest#testSignByte, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFitting, org.apache.commons.math.ode.ContinuousOutputModelTest#testBoundaries, org.apache.commons.math.complex.ComplexFormatTest#testPaseNegativeInfinity, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNan, org.apache.commons.math.random.RandomAdaptorTest#testNextSecureLong, org.apache.commons.math.distribution.PascalDistributionTest#testCumulativeProbabilities, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSpecialValues, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConsistency, org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopy, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeInfinity, org.apache.commons.math.stat.StatUtilsTest#testN0andN1Conditions, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath293, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopySubMatrix, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseZeroX, org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#derivativesConsistency, org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.linear.FieldMatrixImplTest#testOperate, org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testConstructor, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testOperate, org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWith0ExpectedSize, org.apache.commons.math.special.ErfTest#testErf3291, org.apache.commons.math.complex.ComplexTest#testHashCode, org.apache.commons.math.linear.EigenDecompositionImplTest#testMath308, org.apache.commons.math.linear.SparseRealMatrixTest#testNorm, org.apache.commons.math.linear.ArrayRealVectorTest#testConstructors, org.apache.commons.math.linear.EigenSolverTest#testSolveDimensionErrors, org.apache.commons.math.complex.ComplexTest#testAddNaN, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testFrobeniusNorm, org.apache.commons.math.linear.SparseFieldMatrixTest#testPlusMinus, org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne2, org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimals, org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnMatrix, org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testDistance, org.apache.commons.math.linear.BlockRealMatrixTest#testTrace, org.apache.commons.math.linear.QRDecompositionImplTest#testRUpperTriangular, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowVector, org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne1, org.apache.commons.math.linear.BlockFieldMatrixTest#testCopySubMatrix, org.apache.commons.math.linear.BlockRealMatrixTest#testOperatePremultiplyLarge, org.apache.commons.math.complex.ComplexTest#testConjugateNaN, org.apache.commons.math.linear.FieldMatrixImplTest#testMath209, org.apache.commons.math.stat.inference.TTestTest#testSmallSamples, org.apache.commons.math.linear.RealMatrixImplTest#testSetSubMatrix, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreRows, org.apache.commons.math.linear.BigMatrixImplTest#testMath209, org.apache.commons.math.distribution.ChiSquareDistributionTest#testDensity, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTwoSets, org.apache.commons.math.complex.FrenchComplexFormatTest#testConstructorSingleFormat, org.apache.commons.math.linear.BlockFieldMatrixTest#testScalarAdd, org.apache.commons.math.complex.ComplexTest#testCos, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSuffix, org.apache.commons.math.special.BetaTest#testRegularizedBetaNanPositivePositive, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testMinStep, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuintic, org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#checklone, org.apache.commons.math.linear.BlockFieldMatrixTest#testCopyFunctions, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextIntExtremeValues, org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testSinMin, org.apache.commons.math.random.RandomDataTest#testConfig, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedVariance, org.apache.commons.math.complex.ComplexTest#testAsinInf, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testNorm, org.apache.commons.math.distribution.PoissonDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNISTExample, org.apache.commons.math.complex.ComplexTest#testAtanNaN, org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbability2, org.apache.commons.math.complex.ComplexTest#testAcosInf, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testKepler, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testInsufficientBandwidth, org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterEmpty, org.apache.commons.math.complex.ComplexTest#testDivideImaginary, org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuadraticFunction, org.apache.commons.math.linear.BlockFieldMatrixTest#testExamples, org.apache.commons.math.distribution.HypergeometricDistributionTest#testMoreLargeValues, org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedMean, org.apache.commons.math.complex.ComplexTest#testPow, org.apache.commons.math.linear.RealVectorFormatTest#testFormatObject, org.apache.commons.math.distribution.FDistributionTest#testDfAccessors, org.apache.commons.math.util.MathUtilsTest#testArrayEquals, org.apache.commons.math.stat.descriptive.moment.MeanTest#testEqualsAndHashCode, org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownDennis, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRow, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesMaximum, org.apache.commons.math.stat.correlation.CovarianceTest#testSwissFertility, org.apache.commons.math.random.RandomDataTest#testNextSecureInt, org.apache.commons.math.geometry.Vector3DTest#testOrthogonal, org.apache.commons.math.geometry.Vector3DTest#testDistance, org.apache.commons.math.distribution.WeibullDistributionTest#testCumulativeProbabilities, org.apache.commons.math.distribution.CauchyDistributionTest#testSetScale, org.apache.commons.math.stat.FrequencyTest#testEmptyTable, org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxIterations, org.apache.commons.math.linear.RealMatrixImplTest#testMultiply2, org.apache.commons.math.special.BetaTest#testLogBetaZeroPositive, org.apache.commons.math.fraction.BigFractionFormatTest#testFormatNegative, org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientLarge, org.apache.commons.math.random.RandomAdaptorTest#testNextIntExtremeValues, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testWindowSize, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesAverage, org.apache.commons.math.stat.descriptive.rank.MinTest#testCopyConsistency, org.apache.commons.math.complex.ComplexFormatTest#testConstructorSingleFormat, org.apache.commons.math.linear.LUDecompositionImplTest#testNonSquare, org.apache.commons.math.fraction.FractionFormatTest#testWholeFormat, org.apache.commons.math.distribution.PascalDistributionTest#testFloatingPointArguments, org.apache.commons.math.stat.StatUtilsTest#testVariance, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testNaNContracts, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNegative, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerialization, org.apache.commons.math.geometry.Vector3DTest#testConstructors, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testWeightedConsistency, org.apache.commons.math.util.MathUtilsTest#testIndicatorLong, org.apache.commons.math.stat.descriptive.rank.MaxTest#testNaNs, org.apache.commons.math.util.TransformerMapTest#testRemoveTransformer, org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimals, org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldMatrix, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testNaNContracts, org.apache.commons.math.linear.BlockRealMatrixTest#testSerial, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeX, org.apache.commons.math.linear.BiDiagonalTransformerTest#testUpperOrLower, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeY, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeZ, org.apache.commons.math.distribution.ExponentialDistributionTest#testIllegalArguments, org.apache.commons.math.random.MersenneTwisterTest#testDouble, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersSimple, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testStepSize, org.apache.commons.math.MaxIterationsExceededExceptionTest#testComplexConstructor, org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHeterscedastic, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testUnstableDerivative, org.apache.commons.math.stat.FrequencyTest#testPcts, org.apache.commons.math.geometry.Vector3DTest#testAngle, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testMomentSmallSamples, org.apache.commons.math.random.MersenneTwisterTest#testGaussian, org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction2, org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBrentSolverValid, org.apache.commons.math.fraction.FractionFormatTest#testLongFormat, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSerialization, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testStats, org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testProductAndGeometricMean, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextGaussian, org.apache.commons.math.linear.BigMatrixImplTest#testLUDecomposition, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerial, org.apache.commons.math.random.ValueServerTest#testProperties, org.apache.commons.math.linear.RealMatrixImplTest#testEqualsAndHashCode, org.apache.commons.math.geometry.Vector3DTest#testNorm1, org.apache.commons.math.complex.ComplexTest#testAtanInf, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowVector, org.apache.commons.math.special.ErfTest#testErf2807, org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testArrayIsReference, org.apache.commons.math.random.AbstractRandomGeneratorTest#testConfig, org.apache.commons.math.random.MersenneTwisterTest#testNexBoolean, org.apache.commons.math.linear.BigMatrixImplTest#testOperate, org.apache.commons.math.util.TransformerMapTest#testClasses, org.apache.commons.math.linear.SparseRealVectorTest#testMapFunctions, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testCovarianceConsistency, org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilities, org.apache.commons.math.complex.ComplexTest#testSqrt1zNaN, org.apache.commons.math.stat.correlation.CovarianceTest#testConsistency, org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.util.MathUtilsTest#testSignShort, org.apache.commons.math.stat.descriptive.summary.SumTest#testSerial, org.apache.commons.math.special.ErfTest#testErf1960, org.apache.commons.math.util.MathUtilsTest#testHash, org.apache.commons.math.linear.RealVectorFormatTest#testSimpleNoDecimals, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, org.apache.commons.math.fraction.FractionTest#testReciprocal, org.apache.commons.math.linear.BlockRealMatrixTest#testNorm, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEvaluation, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testMomentSmallSamples, org.apache.commons.math.linear.ArrayFieldVectorTest#testMisc, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testDimensions, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testIncrementation, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testWeightedConsistency, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testInconsistentEquations, org.apache.commons.math.fraction.BigFractionTest#testConstructor, org.apache.commons.math.complex.ComplexTest#testGetArgumentInf, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testStats, org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest#dimension2, org.apache.commons.math.stat.FrequencyTest#testIntegerValues, org.apache.commons.math.linear.SparseRealMatrixTest#testPlusMinus, org.apache.commons.math.linear.QRSolverTest#testSolveDimensionErrors, org.apache.commons.math.estimation.EstimatedParameterTest#testConstruction, org.apache.commons.math.genetics.BinaryMutationTest#testMutate, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.linear.BigMatrixImplTest#testGetRowMatrix, org.apache.commons.math.fraction.FractionTest#testIntValue, org.apache.commons.math.util.OpenIntToFieldTest#testRemoveAbsent, org.apache.commons.math.complex.ComplexTest#testAcosNaN, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerial, org.apache.commons.math.complex.ComplexTest#testAddInfinite, org.apache.commons.math.stat.descriptive.rank.MinTest#testSpecialValues, org.apache.commons.math.linear.SparseRealMatrixTest#testGetVectors, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testDimension, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testQRColumnsPermutation, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNonInversible, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testToString, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetSubMatrix, org.apache.commons.math.distribution.FDistributionTest#testLargeDegreesOfFreedom, org.apache.commons.math.random.MersenneTwisterTest#testNextInt, org.apache.commons.math.linear.FieldMatrixImplTest#testWalk, org.apache.commons.math.complex.ComplexTest#testLog, org.apache.commons.math.distribution.CauchyDistributionTest#testCumulativeProbabilities, org.apache.commons.math.complex.ComplexTest#testScalarMultiplyNaN, org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiplyVector, org.apache.commons.math.linear.MatrixUtilsTest#testCreateRealMatrix, org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.linear.BlockRealMatrixTest#testExamples, org.apache.commons.math.genetics.BinaryChromosomeTest#testIsSame, org.apache.commons.math.linear.RealVectorFormatTest#testParseNonDefaultSetting, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testEvaluation, org.apache.commons.math.fraction.FractionFieldTest#testOne, org.apache.commons.math.linear.BlockRealMatrixTest#testAddFail, org.apache.commons.math.estimation.MinpackTest#testMinpackKowalikOsborne, org.apache.commons.math.MathExceptionTest#testConstructorPatternArgumentsCause, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureLong, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTrivial, org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedSum, org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testNoReset, org.apache.commons.math.fraction.BigFractionTest#testBigDecimalValue, org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRootMatrix, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevBounds, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopy, org.apache.commons.math.util.MathUtilsTest#testMulAndCheckLong, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConstant, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniform, org.apache.commons.math.complex.ComplexFormatTest#testParsePositiveInfinity, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseIgnoredWhitespace, org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumn, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testRedundantEquations, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareIndependence, org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacityAndExpansionFactor, org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuadraticFunction, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMath209, org.apache.commons.math.linear.RealMatrixImplTest#testPremultiply, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testCopy, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNullEmpty, org.apache.commons.math.complex.ComplexTest#testEqualsSame, org.apache.commons.math.random.EmpiricalDistributionTest#testNext, org.apache.commons.math.util.MathUtilsTest#testRoundDouble, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnMatrix, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSerialization, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withWeights, org.apache.commons.math.DuplicateSampleAbscissaExceptionTest#testConstructor, org.apache.commons.math.complex.ComplexTest#testMultiplyNaNInf, org.apache.commons.math.linear.FieldMatrixImplTest#testPlusMinus, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNull, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinear, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopy, org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerial, org.apache.commons.math.complex.ComplexFormatTest#testGetRealFormat, org.apache.commons.math.random.RandomAdaptorTest#testNextPoissonConsistency, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testNullIntervalCheck, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testPercentile, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateSpecialValues, org.apache.commons.math.util.ResizableDoubleArrayTest#testGetValues, org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnMatrix, org.apache.commons.math.fraction.BigFractionFormatTest#testParseNegative, org.apache.commons.math.complex.ComplexFormatTest#testParseDifferentImaginaryChar, org.apache.commons.math.linear.CholeskySolverTest#testSolve, org.apache.commons.math.fraction.FractionTest#testToString, org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullURL, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonUnEqualCounts, org.apache.commons.math.random.RandomDataTest#testNextExponential, org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290GEQ, org.apache.commons.math.linear.BlockRealMatrixTest#testFrobeniusNorm, org.apache.commons.math.fraction.BigFractionTest#testEpsilonLimitConstructor, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregationConsistency, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimals, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnVectorLarge, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testShuffledStatistics, org.apache.commons.math.util.MathUtilsTest#testRoundFloat, org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientFail, org.apache.commons.math.distribution.NormalDistributionTest#testSetStandardDeviation, org.apache.commons.math.stat.descriptive.summary.ProductTest#testMomentSmallSamples, org.apache.commons.math.complex.ComplexTest#testLogInf, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testShuffledStatistics, org.apache.commons.math.util.ResizableDoubleArrayTest#testSubstitute, org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testParameters, org.apache.commons.math.linear.RealMatrixImplTest#testPlusMinus, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregate, org.apache.commons.math.estimation.MinpackTest#testMinpackPowellSingular, org.apache.commons.math.complex.ComplexTest#testCoshNaN, org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testSinMin, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoisson, org.apache.commons.math.ode.FirstOrderConverterTest#testBigStep, org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiply, org.apache.commons.math.linear.LUSolverTest#testSolve, org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testCentroid, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEqualsAndHashCode, org.apache.commons.math.linear.InvalidMatrixExceptionTest#testConstructorMessage, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoissonConsistency, org.apache.commons.math.distribution.NormalDistributionTest#testIllegalArguments, org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBisectionSolverValid, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testIllConditioned, org.apache.commons.math.transform.FastCosineTransformerTest#testParameters, org.apache.commons.math.linear.QRDecompositionImplTest#testAEqualQR, org.apache.commons.math.fraction.BigFractionFormatTest#testNumeratorFormat, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testEvents, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnMatrixLarge, org.apache.commons.math.complex.FrenchComplexFormatTest#testSetRealFormatNull, org.apache.commons.math.special.GammaTest#testLogGammaNegative, org.apache.commons.math.transform.FastFourierTransformerTest#testAdHocData, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withoutWeights, org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeAll, org.apache.commons.math.linear.BigMatrixImplTest#testCopyFunctions, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLegendrePolynomials, org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiplyVector, org.apache.commons.math.fraction.BigFractionTest#testReciprocal, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowVectorLarge, org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilityExtremes, org.apache.commons.math.random.RandomAdaptorTest#testNextSecureHex, org.apache.commons.math.random.UniformRandomGeneratorTest#testMeanAndStandardDeviation, org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testMismatch, org.apache.commons.math.linear.SparseRealVectorTest#testBasicFunctions, org.apache.commons.math.distribution.PascalDistributionTest#testIllegalArguments, org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testParameters, org.apache.commons.math.linear.RealVectorFormatTest#testPositiveInfinity, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLLowerTriangular, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testCopy, org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#serialization, org.apache.commons.math.estimation.EstimatedParameterTest#testBound, org.apache.commons.math.transform.FastHadamardTransformerTest#test8Points, org.apache.commons.math.stat.ranking.NaturalRankingTest#testDefault, org.apache.commons.math.util.ResizableDoubleArrayTest#testConstructors, org.apache.commons.math.transform.FastSineTransformerTest#testAdHocData, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddNullYSampleData, org.apache.commons.math.linear.BigMatrixImplTest#testGetVectors, org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAbsentOnExisting, org.apache.commons.math.complex.ComplexFormatTest#testPositiveInfinity, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testControlParameters, org.apache.commons.math.genetics.TournamentSelectionTest#testSelect, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testPopulation, org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregation, org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilities, org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowMatrix, org.apache.commons.math.distribution.TDistributionTest#testIllegalArguments, org.apache.commons.math.complex.FrenchComplexFormatTest#testForgottenImaginaryCharacter, org.apache.commons.math.fraction.FractionFormatTest#testFormat, org.apache.commons.math.analysis.solvers.BrentSolverTest#testRootEndpoints, org.apache.commons.math.optimization.general.MinpackTest#testMinpackWatson, org.apache.commons.math.fraction.BigFractionTest#testDoubleConstructor, org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryFormatNull, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#polynomial, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNoDependency, org.apache.commons.math.optimization.linear.SimplexSolverTest#testModelWithNoArtificialVars, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopyFunctions, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testSingular, org.apache.commons.math.linear.FieldMatrixImplTest#testCopySubMatrix, org.apache.commons.math.complex.ComplexTest#testEqualsImaginaryDifference, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testEqualsAndHashCode, org.apache.commons.math.optimization.general.MinpackTest#testMinpackFreudensteinRoth, org.apache.commons.math.fraction.FractionTest#testDivide, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveSingle, org.apache.commons.math.complex.ComplexTest#testAbs, org.apache.commons.math.linear.ArrayRealVectorTest#testMapFunctions, org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.random.RandomAdaptorTest#testAdaptor, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNonSquare, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testCircleFitting, org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares3, org.apache.commons.math.distribution.ExponentialDistributionTest#testMeanAccessors, org.apache.commons.math.complex.ComplexTest#testGetArgument, org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares1, org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares2, org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnMatrix, org.apache.commons.math.random.RandomDataTest#testNextInt, org.apache.commons.math.stat.inference.TestUtilsTest#testSmallSamples, org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullDoubleArray, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testDecreasingSteps, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testToString, org.apache.commons.math.linear.BlockRealMatrixTest#testMath209, org.apache.commons.math.estimation.MinpackTest#testMinpackBox3Dimensional, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowMatrix, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply, org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilityExtremes, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSerialization, org.apache.commons.math.complex.ComplexTest#testDivideNaNInf, org.apache.commons.math.linear.FieldMatrixImplTest#testExamples, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRow, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSmallStep, org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithoutSplit, org.apache.commons.math.distribution.ZipfDistributionTest#testIllegalArguments, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetSubMatrix, org.apache.commons.math.complex.ComplexTest#testSqrtNaN, org.apache.commons.math.distribution.NormalDistributionTest#testGetStandardDeviation, org.apache.commons.math.linear.MatrixIndexExceptionTest#testConstructorMessage, org.apache.commons.math.distribution.HypergeometricDistributionTest#testDensities, org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDecreasingSteps, org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testParameters, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareIndependence, org.apache.commons.math.fraction.BigFractionTest#testConstructorDouble, org.apache.commons.math.stat.descriptive.rank.MaxTest#testConsistency, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsRemovedTiesSequential, org.apache.commons.math.fraction.FractionFormatTest#testNumeratorFormat, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues1, org.apache.commons.math.util.OpenIntToFieldTest#testPutAbsentOnExisting, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues2, org.apache.commons.math.linear.BigMatrixImplTest#testDeterminant, org.apache.commons.math.complex.ComplexTest#testEqualsClass, org.apache.commons.math.fraction.BigFractionTest#testEqualsAndHashCode, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollision2, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testStepSize, org.apache.commons.math.complex.ComplexTest#testCoshInf, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreColumns, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiple, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetAbsoluteAccuracy, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testSetterInjection, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSingleton, org.apache.commons.math.fraction.BigFractionFormatTest#testLongFormat, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#notEnoughData, org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilityAgaintStackOverflow, org.apache.commons.math.stat.inference.TestUtilsTest#testOneWayAnovaUtils, org.apache.commons.math.optimization.direct.NelderMeadTest#testPowell, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testIllConditioned, org.apache.commons.math.geometry.Vector3DFormatTest#testParseZeroX, org.apache.commons.math.util.MathUtilsTest#testL2DistanceDouble, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testLongly, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testHighPercentile, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testMinStep, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveSin, org.apache.commons.math.util.MathUtilsTest#testNextAfter, org.apache.commons.math.linear.LUDecompositionImplTest#testSingular, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testGetValues, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonEqualCounts, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveFromEmpty, org.apache.commons.math.geometry.Vector3DTest#testCoordinates, org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollisions, org.apache.commons.math.complex.ComplexTest#testAsinNaN, org.apache.commons.math.util.MathUtilsTest#testIndicatorDouble, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTwoSets, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLongExtremeValues, org.apache.commons.math.random.RandomDataTest#testNextSecureLong, org.apache.commons.math.linear.SparseFieldMatrixTest#testScalarAdd, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateResiduals, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testOneSet, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDecreasingSteps, org.apache.commons.math.stat.descriptive.summary.SumTest#testMomentSmallSamples, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBackward, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testNaN, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.linear.MatrixUtilsTest#testFractionConverter, org.apache.commons.math.util.BigRealFieldTest#testSerial, org.apache.commons.math.random.RandomAdaptorTest#testNextLong, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testWeightedConsistency, org.apache.commons.math.stat.descriptive.rank.MinTest#testEqualsAndHashCode, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPAEqualLU, org.apache.commons.math.distribution.PoissonDistributionTest#testMean, org.apache.commons.math.distribution.PoissonDistributionTest#testIllegalArguments, org.apache.commons.math.stat.descriptive.rank.MedianTest#testCopy, org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.analysis.solvers.BrentSolverTest#testSinZero, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNonInversible, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testProductAndGeometricMean, org.apache.commons.math.util.ResizableDoubleArrayTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexTest#testAdd, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareLargeTestStatistic, org.apache.commons.math.special.GammaTest#testRegularizedGammaNegativePositive, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBigStep, org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#checkClone, org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuinticFunction, org.apache.commons.math.complex.ComplexTest#testSqrtInf, org.apache.commons.math.distribution.NormalDistributionTest#testConsistency, org.apache.commons.math.complex.ComplexTest#testAbsInfinite, org.apache.commons.math.complex.ComplexFieldTest#testZero, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataWithSampleSizeMismatch, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#exceedMaxEvaluations, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testStdErrorConsistency, org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproper, org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWithExpectedSize, org.apache.commons.math.random.MersenneTwisterTest#testFloat, org.apache.commons.math.stat.descriptive.rank.MaxTest#testEvaluation, org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_realPartZero, org.apache.commons.math.complex.ComplexTest#testEqualsNaN, org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryZero, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopyConsistency, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEvaluation, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextFloat, org.apache.commons.math.stat.inference.TTestTest#testPaired, org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testImpossibleSerialization, org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroImaginary, org.apache.commons.math.linear.QRDecompositionImplTest#testDimensions, org.apache.commons.math.distribution.GammaDistributionTest#testParameterAccessors, org.apache.commons.math.random.ValueServerTest#testNextDigestFail, org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperInvalidMinus, org.apache.commons.math.complex.ComplexFormatTest#testNegativeBoth, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testMomentSmallSamples, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEqualsAndHashCode, org.apache.commons.math.linear.SparseRealVectorTest#testDataInOut, org.apache.commons.math.random.RandomAdaptorTest#testNextUniformExclusiveEndpoints, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBackward, org.apache.commons.math.complex.FrenchComplexFormatTest#testParsePositiveInfinity, org.apache.commons.math.stat.StatUtilsTest#testMax, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopyConsistency, org.apache.commons.math.optimization.linear.SimplexSolverTest#testRestrictVariablesToNonNegative, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerialization, org.apache.commons.math.stat.correlation.CovarianceTest#testInsufficientData, org.apache.commons.math.optimization.linear.SimplexTableauTest#testInitialization, org.apache.commons.math.linear.EigenSolverTest#testNonInvertible, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveXY, org.apache.commons.math.linear.RealMatrixImplTest#testGetRowMatrix, org.apache.commons.math.ode.ContinuousOutputModelTest#testModelsMerging, org.apache.commons.math.stat.FrequencyTest#testToString, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testEqualsAndHashCode, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNonDefaultSetting, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testStats, org.apache.commons.math.complex.ComplexTest#testPowInf, org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testValues, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#noReset, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testRedundantEquations, org.apache.commons.math.stat.descriptive.summary.ProductTest#testEvaluation, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth1, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth2, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.transform.FastCosineTransformerTest#testAdHocData, org.apache.commons.math.distribution.ChiSquareDistributionTest#testIllegalArguments, org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterNull, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testIncrementation, org.apache.commons.math.complex.ComplexTest#testTanh, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testConsistency, org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerial, org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerialization, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testIncrementation, org.apache.commons.math.linear.RealMatrixImplTest#testGetColumn, org.apache.commons.math.linear.RealMatrixImplTest#testMath209, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#serialization, org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMax, org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testN0andN1Conditions, org.apache.commons.math.util.OpenIntToFieldTest#testRemove2, org.apache.commons.math.complex.ComplexTest#testSqrtRealNegative, org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArguments, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testUOrthogonal, org.apache.commons.math.linear.BiDiagonalTransformerTest#testBBiDiagonal, org.apache.commons.math.linear.BigMatrixImplTest#testGetColumnMatrix, org.apache.commons.math.complex.ComplexTest#testpowNull, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBigStep, org.apache.commons.math.stat.descriptive.summary.SumTest#testSpecialValues, org.apache.commons.math.linear.BlockRealMatrixTest#testScalarAdd, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSerialization, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEqualsAndHashCode, org.apache.commons.math.fraction.FractionTest#testConstructor, org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetMatrixLarge, org.apache.commons.math.linear.EigenDecompositionImplTest#testVOrthogonal, org.apache.commons.math.distribution.PoissonDistributionTest#testDegenerateInverseCumulativeProbability, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#polynomial, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSinZero, org.apache.commons.math.fraction.FractionTest#testGetReducedFraction, org.apache.commons.math.distribution.FDistributionTest#testConsistency, org.apache.commons.math.analysis.solvers.BrentSolverTest#testDeprecated, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues2, org.apache.commons.math.fraction.FractionFormatTest#testParseInteger, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testStaticFormatRealVectorImpl, org.apache.commons.math.estimation.MinpackTest#testMinpackMeyer, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues1, org.apache.commons.math.random.RandomAdaptorTest#testNextGaussian, org.apache.commons.math.util.BigRealTest#testDoubleValue, org.apache.commons.math.linear.FieldMatrixImplTest#testSerial, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNanPositive, org.apache.commons.math.linear.FieldMatrixImplTest#testDimensions, org.apache.commons.math.linear.RealMatrixImplTest#testGetSubMatrix, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetMaximalIterationCount, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterInjection, org.apache.commons.math.linear.TriDiagonalTransformerTest#testTTriDiagonal, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testRedundantEquations, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracyNull, org.apache.commons.math.complex.ComplexTest#testConstructorNaN, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersSimple, org.apache.commons.math.stat.descriptive.summary.SumTest#testConsistency, org.apache.commons.math.fraction.BigFractionFieldTest#testZero, org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigIdentityMatrix, org.apache.commons.math.linear.SparseRealVectorTest#testPredicates, org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testLinearFunction, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositivePositive, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testStepSize, org.apache.commons.math.linear.SparseFieldMatrixTest#testOperate, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopyConsistency, org.apache.commons.math.linear.BlockRealMatrixTest#testSetRow, org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest#testMeanAndCorrelation, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testConcurrentModification, org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopyConsistency, org.apache.commons.math.linear.SparseFieldMatrixTest#testTranspose, org.apache.commons.math.optimization.general.MinpackTest#testMinpackRosenbrok, org.apache.commons.math.util.MathUtilsTest#testSignFloat, org.apache.commons.math.util.MathUtilsTest#testSignDouble, org.apache.commons.math.fraction.FractionFormatTest#testParseInvalid, org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowVector, org.apache.commons.math.geometry.RotationTest#testVectorTwoPairs, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetVectors, org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#serialization, org.apache.commons.math.distribution.NormalDistributionTest#testExtremeValues, org.apache.commons.math.linear.LUSolverTest#testThreshold, org.apache.commons.math.geometry.RotationOrderTest#testName, org.apache.commons.math.util.MathUtilsTest#testIndicatorShort, org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanCumulativeProbability, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTrivial, org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollisions, org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeInfinity, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testMinStep, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testConsistency, org.apache.commons.math.complex.ComplexFormatTest#testStaticFormatComplex, org.apache.commons.math.linear.TriDiagonalTransformerTest#testAEqualQTQt, org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerialization, org.apache.commons.math.util.MathUtilsTest#testSinh, org.apache.commons.math.complex.FrenchComplexFormatTest#testGetImaginaryFormat, org.apache.commons.math.distribution.GammaDistributionTest#testIllegalArguments, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testKepler, org.apache.commons.math.linear.BlockFieldMatrixTest#testEqualsAndHashCode, org.apache.commons.math.linear.SparseRealMatrixTest#testAddFail, org.apache.commons.math.linear.BlockRealMatrixTest#testSetSubMatrix, org.apache.commons.math.complex.ComplexTest#testTanNaN, org.apache.commons.math.genetics.RandomKeyTest#testInducedPermutation, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTrace, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnVectorLarge, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSeparator, org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaPValue, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#dimensionCheck, org.apache.commons.math.ConvergenceExceptionTest#testConstructorCause, org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnMatrix, org.apache.commons.math.estimation.MinpackTest#testMinpackRosenbrok, org.apache.commons.math.fraction.BigFractionTest#testAdd, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testNaNContracts, org.apache.commons.math.random.RandomDataTest#testNextSample, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroReal, org.apache.commons.math.linear.RealVectorFormatTest#testParseIgnoredWhitespace, org.apache.commons.math.distribution.PoissonDistributionTest#testFloatingPointArguments, org.apache.commons.math.linear.EigenDecompositionImplTest#testZeroDivide, org.apache.commons.math.linear.CholeskySolverTest#testSolveDimensionErrors, org.apache.commons.math.linear.EigenDecompositionImplTest#testBigMatrix, org.apache.commons.math.linear.QRSolverTest#testRank, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddXSampleData, org.apache.commons.math.linear.EigenDecompositionImplTest#testAEqualVDVt, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSubMatrix, org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.geometry.RotationTest#testSingularities, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerialization, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullCovarianceData, org.apache.commons.math.fraction.BigFractionFormatTest#testDoubleFormat, org.apache.commons.math.util.MathUtilsTest#testFactorialFail, org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply2, org.apache.commons.math.linear.TriDiagonalTransformerTest#testQTOrthogonal, org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSimplistic, org.apache.commons.math.fraction.BigFractionTest#testAbs, org.apache.commons.math.linear.SparseFieldMatrixTest#testAdd, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testParameters, org.apache.commons.math.linear.RealMatrixImplTest#testCopySubMatrix, org.apache.commons.math.distribution.WeibullDistributionTest#testSetAlpha, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLaguerreDifferentials, org.apache.commons.math.complex.ComplexFieldTest#testOne, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, org.apache.commons.math.linear.RealMatrixImplTest#testSetRowVector, org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedConsistency, org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testTrivial, org.apache.commons.math.linear.BigMatrixImplTest#testTrace, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSuffix, org.apache.commons.math.linear.FieldMatrixImplTest#testGetEntry, org.apache.commons.math.linear.SparseRealMatrixTest#testExamples, org.apache.commons.math.distribution.NormalDistributionTest#testDensity, org.apache.commons.math.geometry.Vector3DTest#testNormInf, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSerial, org.apache.commons.math.random.MersenneTwisterTest#testMakotoNishimura, org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantSolvable, org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowMatrix, org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply, org.apache.commons.math.complex.ComplexTest#testLogNaN, org.apache.commons.math.distribution.ZipfDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative, org.apache.commons.math.transform.FastHadamardTransformerTest#testNoIntInverse, org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterEmpty, org.apache.commons.math.random.EmpiricalDistributionTest#testBinIndexOverflow, org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor, org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaFValue, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testSwissFertility, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBackward, org.apache.commons.math.util.MathUtilsTest#testFactorial, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterIllegalState, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testStats, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLegendreDifferentials, org.apache.commons.math.linear.SparseFieldVectorTest#testMisc, org.apache.commons.math.linear.BlockRealMatrixTest#testGetEntry, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopyConsistency, org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentSizes, org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMin, org.apache.commons.math.random.RandomDataTest#testNextUniformExclusiveEndpoints, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.optimization.general.MinpackTest#testMinpackJennrichSampson, org.apache.commons.math.distribution.ChiSquareDistributionTest#testSampling, org.apache.commons.math.distribution.PascalDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateTwoSegment, org.apache.commons.math.linear.RealMatrixImplTest#testSetColumn, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedConsistency, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testBoundParameters, org.apache.commons.math.linear.RealMatrixImplTest#testGetVectors, org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTwoSets, org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilitySpecial, org.apache.commons.math.estimation.MinpackTest#testMinpackFreudensteinRoth, org.apache.commons.math.MathExceptionTest#testConstructor, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEqualsAndHashCode, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateResiduals, org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.random.RandomDataTest#testNextLong, org.apache.commons.math.util.MathUtilsTest#testIndicatorByte, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testAEqualLLT, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testIncrementation, org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testKepler, org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollision2, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testDimensionCheck, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testDeprecated, org.apache.commons.math.geometry.RotationTest#testComposeInverse, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testMinStep, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWithExpectedSize, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNan, org.apache.commons.math.estimation.MinpackTest#testMinpackBrownDennis, org.apache.commons.math.linear.LUSolverTest#testSingular, org.apache.commons.math.stat.descriptive.InteractionTest#testInteraction, org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testBasicStats, org.apache.commons.math.stat.descriptive.summary.SumTest#testEvaluation, org.apache.commons.math.util.MathUtilsTest#testAddAndCheckLong, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopy, org.apache.commons.math.analysis.solvers.MullerSolverTest#testParameters, org.apache.commons.math.random.RandomDataTest#testNextSecureHex, org.apache.commons.math.random.RandomAdaptorTest#testNextHex, org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatNumber, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testToString, org.apache.commons.math.MathConfigurationExceptionTest#testConstructor, org.apache.commons.math.util.BigRealFieldTest#testZero, org.apache.commons.math.linear.QRDecompositionImplTest#testMatricesValues, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.rank.MaxTest#testWeightedConsistency, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeBoth, org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply2, org.apache.commons.math.fraction.BigFractionTest#testMultiply, org.apache.commons.math.util.ResizableDoubleArrayTest#testDiscard, org.apache.commons.math.util.ResizableDoubleArrayTest#testAdd1000, org.apache.commons.math.distribution.TDistributionTest#testSmallDf, org.apache.commons.math.distribution.HypergeometricDistributionTest#testFloatingPointArguments, org.apache.commons.math.linear.RealMatrixImplTest#testWalk, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniformExclusiveEndpoints, org.apache.commons.math.special.GammaTest#testRegularizedGammaZeroPositive, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testWeightedConsistency, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSkewAndKurtosis, org.apache.commons.math.MathExceptionTest#testConstructorPatternArguments, org.apache.commons.math.util.TransformerMapTest#testSerial, org.apache.commons.math.linear.RealMatrixImplTest#testCopyFunctions, org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnFieldMatrix, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersUnsorted, org.apache.commons.math.fraction.FractionTest#testIntegerOverflow, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testConsistency, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testPopulation, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers, org.apache.commons.math.distribution.BinomialDistributionTest#testFloatingPointArguments, org.apache.commons.math.linear.SparseRealMatrixTest#testDimensions, org.apache.commons.math.complex.ComplexTest#testSinInf, org.apache.commons.math.special.GammaTest#testRegularizedGammaNanPositive, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParsePositiveInfinity, org.apache.commons.math.linear.RealVectorFormatTest#testForgottenPrefix, org.apache.commons.math.complex.ComplexFormatTest#testNegativeReal, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testFunctionEvaluationExceptions, org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketEndpointRoot, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNoDependency, org.apache.commons.math.complex.ComplexFormatTest#testParseNan, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerialization, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testPositiveInfinity, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWith0ExpectedSize, org.apache.commons.math.stat.descriptive.rank.MedianTest#testEvaluation, org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArgumentsCause, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentEquations, org.apache.commons.math.util.TransformerMapTest#testContainsTransformer, org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues5, org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues3, org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestPositive, org.apache.commons.math.linear.SparseRealMatrixTest#testOperate, org.apache.commons.math.linear.FieldMatrixImplTest#testGetSubMatrix, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testControlParameters, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeInfinity, org.apache.commons.math.complex.ComplexTest#testAsin, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeInfinity, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowVectorLarge, org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalidDenominator, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, org.apache.commons.math.util.ResizableDoubleArrayTest#testSetElementArbitraryExpansion, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testLinear, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testWeightedConsistency, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testHat, org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_NAN_Inf, org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveZero, org.apache.commons.math.linear.FieldMatrixImplTest#testTranspose, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsAndInfs, org.apache.commons.math.geometry.RotationTest#testAxisAngle, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetRelativeAccuracy, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstHermitePolynomials, org.apache.commons.math.stat.inference.TTestFactoryTest#testPaired, org.apache.commons.math.geometry.RotationTest#testRevert, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerial, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFitting, org.apache.commons.math.optimization.linear.SimplexSolverTest#testLargeModel, org.apache.commons.math.geometry.Vector3DTest#testVectorialProducts, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerial, org.apache.commons.math.genetics.OnePointCrossoverTest#testCrossover, org.apache.commons.math.util.OpenIntToFieldTest#testRemove, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMath283, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowMatrixLarge, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#exceedMaxEvaluations, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing1, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testConditionNumber, org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testParameters, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing2, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testStaticFormatVector3D, org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#derivativesConsistency, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureInt, org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnVector, org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations#test, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testRedundantEquations, org.apache.commons.math.linear.LUSolverTest#testSolveSingularityErrors, org.apache.commons.math.analysis.solvers.NewtonSolverTest#testDeprecated, org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testLinearFunction, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonBadCounts, org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testPercentileSetter, org.apache.commons.math.util.MathUtilsTest#testCoshNaN, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseDifferentImaginaryChar, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testPositiveInfinity, org.apache.commons.math.complex.ComplexTest#testPowNaNExponent, org.apache.commons.math.stat.StatUtilsTest#testSumLog, org.apache.commons.math.complex.ComplexFormatTest#testDifferentImaginaryChar, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testBackward, org.apache.commons.math.linear.BlockFieldMatrixTest#testMath209, org.apache.commons.math.transform.FastSineTransformerTest#testParameters, org.apache.commons.math.util.DefaultTransformerTest#testTransformNull, org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testNoOptimum, org.apache.commons.math.linear.BigMatrixImplTest#testAdd, org.apache.commons.math.complex.ComplexTest#testPowZero, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testOneSet, org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsFixedTiesRandom, org.apache.commons.math.fraction.BigFractionFormatTest#testParseProper, org.apache.commons.math.optimization.linear.SimplexSolverTest#testSingleVariableAndConstraint, org.apache.commons.math.geometry.Vector3DTest#testDistance1, org.apache.commons.math.linear.RealMatrixImplTest#testFrobeniusNorm, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNegativePositive, org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareZeroCount, org.apache.commons.math.linear.RealMatrixImplTest#testPremultiplyVector, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationAtBounds, org.apache.commons.math.stat.descriptive.rank.MinTest#testCopy, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeY, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeZ, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNan, org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSerial, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeX, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromEmpty, org.apache.commons.math.optimization.general.MinpackTest#testMinpackMeyer, org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleTTest, org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimals, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNonInversible, org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.fraction.FractionTest#testFloatValue, org.apache.commons.math.complex.ComplexTest#testDivide, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetAbsent, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testOneSet, org.apache.commons.math.random.MersenneTwisterTest#testNextIntN, org.apache.commons.math.complex.ComplexTest#testSubtract, org.apache.commons.math.linear.LUDecompositionImplTest#testPPermutation, org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoFailures, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRow, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testKepler, org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testUnsorted, org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest#testCircleFitting, org.apache.commons.math.fraction.FractionTest#testMultiply, org.apache.commons.math.estimation.WeightedMeasurementTest#testIgnored, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopyConsistency, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiply, org.apache.commons.math.fraction.BigFractionTest#testFloatValue, org.apache.commons.math.distribution.FDistributionTest#testSmallDegreesOfFreedom, org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testExpm1Function, org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimalsTrunc, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopyConsistency, org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function2, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimals, org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testIncreasingTolerance, org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testMinStep, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testKepler, org.apache.commons.math.complex.ComplexTest#testAtan, org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testIncrementation, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuadraticFunction, org.apache.commons.math.distribution.TDistributionTest#testDfAccessors, org.apache.commons.math.distribution.CauchyDistributionTest#testConsistency, org.apache.commons.math.special.BetaTest#testLogBetaPositivePositive, org.apache.commons.math.util.OpenIntToFieldTest#testPutOnExisting, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testProductAndGeometricMean, org.apache.commons.math.estimation.MinpackTest#testMinpackBard, org.apache.commons.math.random.MersenneTwisterTest#testNextLong, org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLTTransposed, org.apache.commons.math.linear.TriDiagonalTransformerTest#testNoAccessBelowDiagonal, org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRank, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testAEqualUSVt, org.apache.commons.math.stat.descriptive.moment.MeanTest#testConsistency, org.apache.commons.math.stat.descriptive.rank.MinTest#testSerial, org.apache.commons.math.transform.FastFourierTransformerTest#test2DData, org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateThreeSegment, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextInt, org.apache.commons.math.linear.SparseRealMatrixTest#testEqualsAndHashCode, org.apache.commons.math.linear.RealMatrixImplTest#testSerial, org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testSkewAndKurtosis, org.apache.commons.math.stat.StatUtilsTest#testMean, org.apache.commons.math.linear.SingularValueSolverTest#testConditionNumber, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopy, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFittingBadInit, org.apache.commons.math.fraction.FractionFormatTest#testParseNegative, org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerial, org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiplyVector, org.apache.commons.math.util.ResizableDoubleArrayTest#testMutators, org.apache.commons.math.linear.SparseFieldMatrixTest#testEqualsAndHashCode, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRow, org.apache.commons.math.util.ContinuedFractionTest#testGoldenRatio, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testEvents, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testParameters, org.apache.commons.math.stat.StatUtilsTest#testDifferenceStats, org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testInitialGuess, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testSmallStep, org.apache.commons.math.complex.ComplexTest#testSin, org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateFullSample, org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHomoscedastic, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMath199, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextExponential, org.apache.commons.math.linear.RealMatrixImplTest#testExamples, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerialization, org.apache.commons.math.complex.ComplexTest#testExpNaN, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testSmallStep, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowMatrix, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetFunctionValueAccuracy, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testAddition, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerial, org.apache.commons.math.fraction.BigFractionTest#testIntValue, org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHighDegreeLegendre, org.apache.commons.math.optimization.fitting.HarmonicFitterTest#test1PercentError, org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedProduct, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEqualsAndHashCode, org.apache.commons.math.estimation.MinpackTest#testMinpackJennrichSampson, org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowVector, org.apache.commons.math.util.BigRealTest#testBigDecimalValue, org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleNoDecimals, org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#serialization, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testQRColumnsPermutation, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testMomentSmallSamples, org.apache.commons.math.linear.EigenSolverTest#testInvertible, org.apache.commons.math.linear.BlockRealMatrixTest#testTranspose, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNoDenseOutput, org.apache.commons.math.distribution.BinomialDistributionTest#testIllegalArguments, org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullFile, org.apache.commons.math.util.MathUtilsTest#testPow, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnVector, org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopyConsistency, org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testN0andN1Conditions, org.apache.commons.math.distribution.ChiSquareDistributionTest#testCumulativeProbabilities, org.apache.commons.math.distribution.HypergeometricDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testSinFunction, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenPrefix, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testRemoval, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testScalarAdd, org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHomoscedastic, org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNoDependency, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEvaluation, org.apache.commons.math.distribution.ExponentialDistributionTest#testDensity, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnMatrixLarge, org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexIllegalModulus, org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterNull, org.apache.commons.math.linear.RealVectorFormatTest#testParseNoComponents, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnVector, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testInsufficientData, org.apache.commons.math.estimation.MinpackTest#testMinpackWatson, org.apache.commons.math.linear.SparseRealMatrixTest#testCopyFunctions, org.apache.commons.math.geometry.RotationTest#testIdentity, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testLongly, org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testColumnsPermutation, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testDimensions, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArguments, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopy, org.apache.commons.math.random.ValueServerTest#testNextDigest, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArgumentsCause, org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFine, org.apache.commons.math.random.RandomDataTest#testNextGaussian, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testIterator, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuadratic, org.apache.commons.math.distribution.GammaDistributionTest#testProbabilities, org.apache.commons.math.linear.RealMatrixImplTest#testNorm, org.apache.commons.math.stat.inference.TestUtilsTest#testPaired, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTrivial, org.apache.commons.math.MathExceptionTest#testPrintStackTrace, org.apache.commons.math.util.OpenIntToFieldTest#testConcurrentModification, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperNegative, org.apache.commons.math.complex.ComplexFormatTest#testNan, org.apache.commons.math.random.RandomDataTest#testNextPermutation, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenPrefix, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testEmptyData, org.apache.commons.math.linear.BlockFieldMatrixTest#testWalk, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimals, org.apache.commons.math.analysis.solvers.BisectionSolverTest#testQuinticZero, org.apache.commons.math.complex.ComplexTest#testEqualsRealDifference, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultipleToEmpty, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressandVariance, org.apache.commons.math.util.MathUtilsTest#testAddAndCheck, org.apache.commons.math.special.ErfTest#testErf2576, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullYSampleData, org.apache.commons.math.stat.descriptive.summary.ProductTest#testIncrementation, org.apache.commons.math.linear.BigMatrixImplTest#testSetSubMatrix, org.apache.commons.math.geometry.Vector3DFormatTest#testNonDefaultSetting, org.apache.commons.math.distribution.CauchyDistributionTest#testMedian, org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnVector, org.apache.commons.math.linear.BigMatrixImplTest#testScalarAdd, org.apache.commons.math.util.MathUtilsTest#testCompareTo, org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply2, org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#serialization, org.apache.commons.math.random.RandomAdaptorTest#testNextLongExtremeValues, org.apache.commons.math.util.MathUtilsTest#testArrayHash, org.apache.commons.math.distribution.BinomialDistributionTest#testCumulativeProbabilities, org.apache.commons.math.distribution.WeibullDistributionTest#testBeta, org.apache.commons.math.util.MathUtilsTest#testLcm, org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#dimensionCheck, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBackward, org.apache.commons.math.util.MathUtilsTest#testIndicatorFloat, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testNaN, org.apache.commons.math.linear.BlockRealMatrixTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testWeightedConsistency, org.apache.commons.math.random.EmpiricalDistributionTest#testLoad, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveZero, org.apache.commons.math.linear.SparseFieldMatrixTest#testExamples, org.apache.commons.math.complex.FrenchComplexFormatTest#testDifferentImaginaryChar, org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroReal, org.apache.commons.math.complex.ComplexTest#testTanInf, org.apache.commons.math.complex.ComplexFormatTest#testForgottenImaginaryCharacter, org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSuffix, org.apache.commons.math.complex.ComplexTest#testSerial, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetVectors, org.apache.commons.math.ode.FirstOrderConverterTest#testDoubleDimension, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEqualsAndHashCode, org.apache.commons.math.complex.ComplexTest#testTanhInf, org.apache.commons.math.stat.FrequencyTest#testCounts, org.apache.commons.math.linear.SparseFieldVectorTest#testPredicates, org.apache.commons.math.linear.BigMatrixImplTest#testSolve, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParameters, org.apache.commons.math.geometry.Vector3DFormatTest#testConstructorSingleFormat, org.apache.commons.math.util.ResizableDoubleArrayTest#testSetNumberOfElements, org.apache.commons.math.optimization.general.MinpackTest#testMinpackKowalikOsborne, org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvectors, org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanInverseCumulativeProbability, org.apache.commons.math.linear.SparseRealMatrixTest#testAdd, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConsistency, org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testMomentSmallSamples, org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnMatrix, org.apache.commons.math.fraction.BigFractionFormatTest#testParse, org.apache.commons.math.fraction.BigFractionTest#testCompareTo, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopy, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerialization, org.apache.commons.math.complex.ComplexTest#testTanhNaN, org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilityExtremes, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testUnstableDerivative, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEvaluation, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testN0andN1Conditions, org.apache.commons.math.util.MathUtilsTest#testSubAndCheckErrorMessage, org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopy, org.apache.commons.math.fraction.FractionTest#testAbs, org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#derivativesConsistency, org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testMinEndpoints, org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testEqualsAndHashCode, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEvaluation, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testIncrementation, org.apache.commons.math.stat.descriptive.rank.MinTest#testSerialization, org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative, org.apache.commons.math.util.MathUtilsTest#testEquals, org.apache.commons.math.random.EmpiricalDistributionTest#testNexFail, org.apache.commons.math.complex.ComplexFormatTest#testFormatNumber, org.apache.commons.math.linear.SingularValueDecompositionImplTest#testHadamard, org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDecreasingSteps, org.apache.commons.math.stat.descriptive.moment.MeanTest#testSmallSamples, org.apache.commons.math.util.DefaultTransformerTest#testTransformBigDecimal, org.apache.commons.math.linear.BigMatrixImplTest#testDimensions, org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterIllegalState, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testColumnsPermutation, org.apache.commons.math.optimization.direct.NelderMeadTest#testFunctionEvaluationExceptions, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumn, org.apache.commons.math.complex.FrenchComplexFormatTest#testGetRealFormat, org.apache.commons.math.complex.ComplexTest#testSqrtRealPositive, org.apache.commons.math.linear.BlockFieldMatrixTest#testToString, org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiply, org.apache.commons.math.linear.BigMatrixImplTest#testAddFail, org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiplePastEmpty, org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSpecialValues, org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply, org.apache.commons.math.util.MathUtilsTest#testLog, org.apache.commons.math.transform.FastFourierTransformerTest#testParameters, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testFormatObject, org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowVector, org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNan, org.apache.commons.math.util.MathUtilsTest#testSignLong, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testUnequalSizeArguments, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testWeightedConsistency, org.apache.commons.math.complex.ComplexTest#testMultiply, org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleNoDecimals, org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testMomentSmallSamples, org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testBasicStats, org.apache.commons.math.random.GaussianRandomGeneratorTest#testMeanAndStandardDeviation, org.apache.commons.math.util.OpenIntToFieldTest#testRemoveFromEmpty, org.apache.commons.math.util.MathUtilsTest#testMulAndCheck, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testIncreasingTolerance, org.apache.commons.math.stat.StatUtilsTest#testGeometricMean, org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEvents, org.apache.commons.math.fraction.FractionTest#testAdd, org.apache.commons.math.complex.ComplexTest#testNegate, org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSerial, org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowVector, org.apache.commons.math.stat.descriptive.summary.SumSqTest#testConsistency, org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficient, org.apache.commons.math.linear.FieldMatrixImplTest#testSetRow, org.apache.commons.math.stat.descriptive.moment.VarianceTest#testConsistency, org.apache.commons.math.complex.ComplexTest#testSinhInf, org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDimensionCheck, org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testOneSet, org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction2, org.apache.commons.math.distribution.ExponentialDistributionTest#testConsistency, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeZ, org.apache.commons.math.complex.ComplexFormatTest#testZeroReal, org.apache.commons.math.linear.SparseFieldMatrixTest#testTrace, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testLLowerTriangular, org.apache.commons.math.linear.FieldMatrixImplTest#testAddFail, org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testSmallError, org.apache.commons.math.distribution.ZipfDistributionTest#testFloatingPointArguments, org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopyConsistency, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeX, org.apache.commons.math.linear.BlockRealMatrixTest#testGetRow, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeY, org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPPermutation, org.apache.commons.math.stat.descriptive.summary.SumTest#testIncrementation, org.apache.commons.math.util.MathUtilsTest#testL1DistanceDouble, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testRosenbrock, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testConsistency, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#test20090720, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testLinearFunction, org.apache.commons.math.optimization.linear.SimplexSolverTest#testUnboundedSolution, org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewSecantSolverValid, org.apache.commons.math.distribution.FDistributionTest#testIllegalArguments, org.apache.commons.math.stat.StatUtilsTest#testSumSq, org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryFormatNull, org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testNoError, org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testN0andN1Conditions, org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testShuffledStatistics, org.apache.commons.math.complex.ComplexTest#testAcos, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveAbsent, org.apache.commons.math.ode.FirstOrderConverterTest#testDecreasingSteps, org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeReal, org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleT, org.apache.commons.math.ode.sampling.StepNormalizerTest#testBeforeEnd, org.apache.commons.math.util.DefaultTransformerTest#testSerial, org.apache.commons.math.random.RandomDataTest#testNextPoissonConsistency, org.apache.commons.math.linear.SparseRealVectorTest#testConstructors, org.apache.commons.math.util.DefaultTransformerTest#testTransformInteger, org.apache.commons.math.stat.descriptive.rank.MedianTest#testWeightedConsistency, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNoDependency, org.apache.commons.math.complex.ComplexTest#testConjugateInfiinite, org.apache.commons.math.util.OpenIntToFieldTest#testCopy, org.apache.commons.math.optimization.linear.SimplexSolverTest#testSimplexSolver, org.apache.commons.math.linear.RealVectorFormatTest#testStaticFormatRealVectorImpl, org.apache.commons.math.linear.BigMatrixImplTest#testMultiply, org.apache.commons.math.fraction.FractionFormatTest#testParseInvalidDenominator, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnVector, org.apache.commons.math.linear.SparseFieldMatrixTest#testDimensions, org.apache.commons.math.util.ResizableDoubleArrayTest#testAddElementRolling, org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBigStep, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testIncrementation, org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddXSampleData, org.apache.commons.math.linear.BlockRealMatrixTest#testSeveralBlocks, org.apache.commons.math.distribution.PascalDistributionTest#testDensities, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeAll, org.apache.commons.math.complex.FrenchComplexFormatTest#testPaseNegativeInfinity, org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#testDerivativesConsistency, org.apache.commons.math.linear.BlockRealMatrixTest#testToString, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArray, org.apache.commons.math.linear.RealVectorFormatTest#testNegativeX, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDimensionCheck, org.apache.commons.math.complex.ComplexTest#testTanCritical, org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimalsTrunc, org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnVector, org.apache.commons.math.complex.ComplexFormatTest#testSimpleNoDecimals, org.apache.commons.math.linear.RealVectorFormatTest#testNegativeZ, org.apache.commons.math.geometry.RotationTest#testApplyInverseTo, org.apache.commons.math.linear.RealVectorFormatTest#testNegativeY, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeZ, org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNan, org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersSimple, org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMeanAndCovariance, org.apache.commons.math.complex.ComplexTest#testExp, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testEvents, org.apache.commons.math.stat.StatUtilsTest#testMin, org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumn, org.apache.commons.math.util.OpenIntToFieldTest#testGetFromEmpty, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeX, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeY, org.apache.commons.math.stat.inference.TTestFactoryTest#testSmallSamples, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareZeroCount, org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParameters, org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnVector, org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNegative, org.apache.commons.math.MathConfigurationExceptionTest#testConstructorCause, org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleNoDecimals, org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testQuinticFunction, org.apache.commons.math.fraction.FractionTest#testConstructorDouble, org.apache.commons.math.transform.FastHadamardTransformerTest#test4Points, org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSpecialValues, org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEvaluation, org.apache.commons.math.util.DefaultTransformerTest#testTransformObject, org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareZeroCount, org.apache.commons.math.fraction.FractionTest#testSubtract, org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove, org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowMatrix, org.apache.commons.math.geometry.Vector3DFormatTest#testStaticFormatVector3D, org.apache.commons.math.complex.ComplexTest#testPowNaNBase, org.apache.commons.math.linear.LUDecompositionImplTest#testPAEqualLU, org.apache.commons.math.genetics.RandomKeyTest#testRandomPermutation, org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAddFail, org.apache.commons.math.linear.SparseRealVectorTest#testSerial, org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfectNegative, org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilities, org.apache.commons.math.complex.ComplexTest#testDivideZero, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwiss, org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testBackward, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testFormatObject, org.apache.commons.math.genetics.ChromosomeTest#testCompareTo, org.apache.commons.math.special.GammaTest#testLogGammaNan, org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply, org.apache.commons.math.linear.FieldMatrixImplTest#testScalarAdd, org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testMomentSmallSamples, org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNoComponents, org.apache.commons.math.util.MathUtilsTest#testSinhNaN, org.apache.commons.math.random.RandomDataTest#testNextHex, org.apache.commons.math.analysis.solvers.BrentSolverTest#testBadEndpoints, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testWeightedConsistency, org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldIdentityMatrix, org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextBoolean, org.apache.commons.math.fraction.BigFractionTest#testLongValue, org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHomoscedastic, org.apache.commons.math.distribution.HypergeometricDistributionTest#testPopulationSize, org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testSinFunction, org.apache.commons.math.random.EmpiricalDistributionTest#testGetBinUpperBounds, org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquare, org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeBoth, org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testCopy, org.apache.commons.math.linear.BlockRealMatrixTest#testOperate, org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopy, org.apache.commons.math.linear.FieldMatrixImplTest#testAdd, org.apache.commons.math.random.ValueServerTest#testModes, org.apache.commons.math.fraction.FractionTest#testSerial, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testfirstDerivativeComparison, org.apache.commons.math.stat.regression.SimpleRegressionTest#testNaNs, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerial, org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersSimple, org.apache.commons.math.linear.RealVectorFormatTest#testParsePositiveInfinity, org.apache.commons.math.fraction.FractionTest#testLongValue, org.apache.commons.math.analysis.solvers.RiddersSolverTest#testExpm1Function, org.apache.commons.math.random.RandomDataTest#testNextIntExtremeValues, org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testInsufficientData, org.apache.commons.math.ArgumentOutsideDomainExceptionTest#testConstructor, org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilities, org.apache.commons.math.fraction.BigFractionFieldTest#testOne, org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilities, org.apache.commons.math.transform.FastHadamardTransformerTest#test3Points, org.apache.commons.math.optimization.general.MinpackTest#testMinpackHelicalValley, org.apache.commons.math.linear.SparseRealMatrixTest#testScalarAdd, org.apache.commons.math.geometry.Vector3DFormatTest#testFormatObject, org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedDelta, org.apache.commons.math.stat.data.LewTest#testCertifiedValues, org.apache.commons.math.analysis.solvers.NewtonSolverTest#testQuinticZero, org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction, org.apache.commons.math.optimization.direct.MultiDirectionalTest#testPowell, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingBandwidthIncreasesSmoothness, org.apache.commons.math.linear.FieldMatrixImplTest#testTrace, org.apache.commons.math.fraction.FractionFormatTest#testDenominatorFormat, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal3, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal4, org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxEvaluations, org.apache.commons.math.linear.RealVectorFormatTest#testConstructorSingleFormat, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal5, org.apache.commons.math.linear.SparseRealMatrixTest#testGetEntry, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal6, org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testStdErrorConsistency, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal1, org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal2, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNonDefaultSetting, org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction, org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnMatrix, org.apache.commons.math.stat.CertifiedDataTest#testDescriptiveStatistics, org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testSmallStep, org.apache.commons.math.linear.QRSolverTest#testUnderdetermined, org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testExactIntegration, org.apache.commons.math.linear.SparseFieldMatrixTest#testSetSubMatrix, org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerialization, org.apache.commons.math.distribution.ZipfDistributionTest#testDensities, org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1, org.apache.commons.math.linear.SingularValueSolverTest#testSolve, org.apache.commons.math.fraction.FractionTest#testGoldenRatio, org.apache.commons.math.linear.BiDiagonalTransformerTest#testAEqualUSVt, org.apache.commons.math.random.EmpiricalDistributionTest#testSerialization, org.apache.commons.math.stat.descriptive.moment.MeanTest#testMomentSmallSamples, org.apache.commons.math.complex.ComplexFieldTest#testSerial, org.apache.commons.math.random.EmpiricalDistributionTest#testDoubleLoad, org.apache.commons.math.util.MathUtilsTest#testLInfDistanceDouble, org.apache.commons.math.geometry.FrenchVector3DFormatTest#testConstructorSingleFormat, org.apache.commons.math.optimization.general.MinpackTest#testMinpackBard, org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testSinFunction, org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSubtraction, org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeAll, org.apache.commons.math.special.ErfTest#testErf0, org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayArgumentCause, org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testBackward, org.apache.commons.math.fraction.FractionTest#testNegate, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSubMatrix, org.apache.commons.math.estimation.MinpackTest#testMinpackChebyquad, org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowMatrixLarge, org.apache.commons.math.linear.BlockFieldMatrixTest#testOperate, org.apache.commons.math.random.ValueServerTest#testEmptyReplayFile], jUnit5Tests=[], jacocoIncludes=[org.apache.commons.*], jacocoExcludes=[java.*], family=SPECTRUM_BASED, spectrumFormula=TARANTULA, computeSpoonResults=false}
Computing tests from config.
Running TestContext{testMethods=[[Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL2DistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testOverdetermined, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolveSingularityErrors, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testCompose, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowFieldMatrix, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithSplit, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeReal, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testCorr, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNextAfterSpecialCases, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testPerfectFit, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testConfig, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiplyNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheckLong, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSampling, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSanityChecks, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testReplay, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignInt, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnLarge, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#checkClone, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewNewtonSolverValid, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgumentNaN, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAdd, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveZero, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTan, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testIsSingular, [Manual]TestMethod=org.apache.commons.math.MaxIterationsExceededExceptionTest#testSimpleConstructor, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateSin, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonEqualCounts, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaNanPositive, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSimplistic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testPermutedArrayHash, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowLarge, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNorm, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosNaN, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataThatIsNotSquare, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testIsSame, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotSymmetricMatrixException, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.CertifiedDataTest#testSummaryStatistics, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonUnEqualCounts, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsErrors, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearFullRank, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideInfinite, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDoubleConstructor, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyMutationTest#testMutate, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testEpsilon, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testTheory, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSubtractNaN, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealZero, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproperNegative, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveBadParameters, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testGetImaginaryFormat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSetQuantile, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryNegative, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testAddNonComparable, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinhNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testWindowSize, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvalues, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate1, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testGetSummary, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate0, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowLarge, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetFromEmpty, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaNegativePositivePositive, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testTridiagonal, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testAngles, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSolutionWithNegativeDecisionVariable, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testMultiplication, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLaguerrePolynomials, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testRandomAccess, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testIdentityPermutation, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testCovarianceConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.BetaDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseBig, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testSanityChecks, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolveRankErrors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistanceSq, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHermiteDifferentials, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testGetMean, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testComparatorPermutation, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIntegratorControls, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testSSENonNegative, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension1, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testTrivialModel, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#testDerivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension3, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProperInvalidMinus, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne2, [Manual]TestMethod=org.apache.commons.math.genetics.GeneticAlgorithmTestBinary#test, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhCritical, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateDegenerate, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne1, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetFunctionValueAccuracy, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaPositive, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testProduct, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosInf, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownAlmostLinear, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBrownAlmostLinear, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testInvalidConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNormalize, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction2, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testEqualRepr, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testStaticFormatComplex, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testConstant, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaTest, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutOnExisting, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseZeroReal, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngular, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacity, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketSin, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testGcd, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testValues, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeBoth, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.genetics.FitnessCachingTest#testFitnessCaching, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoSuccesses, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.distribution.BetaDistributionTest#testCumulative, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290LEQ, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetMatrixLarge, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testLargeValues, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#backward, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testQuinticMin, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate1, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaNegativePositive, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate0, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testScale, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheck, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testNegate, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExpInf, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testNorris, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroImaginary, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testDecode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackChebyquad, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigMatrix, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConstant, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBadParameters, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.genetics.FixedGenerationCountTest#testIsSatisfied, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGet, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveZeroPositive, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstChebyshevPolynomials, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMinimizeMaximize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testNaN, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testGetAbsent, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testTransformers, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testIterator, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testConstants, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_fourthRoot, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testDigammaSmallArgs, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testInference, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#test5, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testClear, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaZeroPositivePositive, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testInfeasibleSolution, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextIntNeg, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsTrue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsNull, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArgumentCause, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiply, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromSingle, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testClear, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtPolar, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testFill, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatZero, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testSmallDf, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL1DistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testMath280, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDistinctEigenvalues, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testDoubleFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMath226, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.genetics.ElitisticListPopulationTest#testNextGeneration, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexNaN, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#checklone, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackHelicalValley, [Manual]TestMethod=org.apache.commons.math.genetics.ListPopulationTest#testGetFittestChromosome, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testLongly, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLInfDistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testUOrthogonal, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowRealMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseManyComponents, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositivePositive, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testPutTransformer, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testDegeneracy, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testDimension, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testDropPhase1Objective, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testWholeFormat, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNormalizeAngle, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbsNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaZero, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testPercentile, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testLongly, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testErrorConditions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testZeroImaginary, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInteger, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNexBytes, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2Complex, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testPercentileSetter, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMath221, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrt1z, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnDistortedSine, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testQuaternion, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testHTrapezoidal, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNoRoot, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testQOrthogonal, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testMismatch, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatZero, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSetBeta, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.stat.data.LotteryTest#testCertifiedValues, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testFixedState, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testGetReducedFraction, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testSmallLastStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testContainsClass, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSeveralBlocks, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFat, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetAbsoluteAccuracy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMinimization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#test0Choose0, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformString, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testSetMean, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testRepeatedEigenvalue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.genetics.ChromosomeTest#testFindSameChromosome, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperatePremultiplyLarge, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressandVariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevDifferentials, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsNoConvergence, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testAlpha, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedUlps, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetRelativeAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracySin, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testEmptyDigestFile, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDivide, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseZeroImaginary, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNullIntervalCheck, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testTrigamma, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideReal, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove2, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalid, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testQuantiles, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testDigammaLargeArgs, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRandom, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testRemoval, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetMaximalIterationCount, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideNaN, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnTwoPoints, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testNoError, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProper, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testScalarProduct, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testVectorOnePair, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testQOrthogonal, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveNan, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveNegative, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testWrongDerivative, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testNormalApproximateProbability, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMaximalTiesMinimum, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationInside, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNegateNaN, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testDenominatorFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinNaN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiplyInf, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testParaboloid2D, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentSizes, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testConstructor2, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testConstructor1, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogZero, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testMinMax, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testUUpperTriangular, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearFullRank, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testCopy, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfect, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseManyComponents, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParse, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testNorm, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDigitLimitConstructor, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testBigFractionConverter, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#test20090720, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testLinearFunction2D, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGet, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMath199, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testStats, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testContainsKey, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetRealFormatNull, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantUnsolvable, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonBadCounts, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#backward, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperateLarge, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBox3Dimensional, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperateLarge, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistanceInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnOnePoint, [Manual]TestMethod=org.apache.commons.math.ode.sampling.StepNormalizerTest#testBoundaries, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngularSeparation, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testInverse, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformDouble, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCosh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testTableauWithNoArtificialVars, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testScalb, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testRandomConstructor, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testEstimate, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackPowellSingular, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testContainsKey, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testUUpperTriangular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_thirdRoot, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath272, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeReal, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMinimizeMaximize, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnStraightLine, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinh, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testArrayIndexConditions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testNaN, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testConstruction, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testGetSummary, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNormalizeArray, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath288, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDiagonal, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath286, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testInitialGuess, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnRealMatrix, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignByte, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testBoundaries, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testPaseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath293, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWith0ExpectedSize, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf3291, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testHashCode, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testMath308, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAddNaN, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne2, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testDistance, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testRUpperTriangular, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne1, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperatePremultiplyLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugateNaN, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreRows, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCos, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaNanPositivePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuintic, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#checklone, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testSinMin, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testConfig, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedVariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsinInf, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNISTExample, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtanNaN, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbability2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcosInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testInsufficientBandwidth, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterEmpty, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideImaginary, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testMoreLargeValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedMean, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testArrayEquals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownDennis, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesMaximum, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testOrthogonal, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistance, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testSetScale, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testEmptyTable, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaZeroPositive, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatNegative, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientLarge, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testWindowSize, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesAverage, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testWholeFormat, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testVariance, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testRemoveTransformer, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testUpperOrLower, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testDouble, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.MaxIterationsExceededExceptionTest#testComplexConstructor, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testPcts, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngle, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testGaussian, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction2, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBrentSolverValid, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testLongFormat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testLUDecomposition, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testProperties, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNorm1, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtanInf, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf2807, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testArrayIsReference, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testConfig, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNexBoolean, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testClasses, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testCovarianceConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrt1zNaN, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignShort, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSerial, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf1960, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testHash, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testReciprocal, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgumentInf, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest#dimension2, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testIntegerValues, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testConstruction, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryMutationTest#testMutate, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testIntValue, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemoveAbsent, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcosNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerial, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAddInfinite, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testDimension, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testLargeDegreesOfFreedom, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLog, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiplyNaN, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRealMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testIsSame, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackKowalikOsborne, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedSum, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testNoReset, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testBigDecimalValue, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRootMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevBounds, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testMulAndCheckLong, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConstant, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacityAndExpansionFactor, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNullEmpty, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsSame, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testNext, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testRoundDouble, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withWeights, [Manual]TestMethod=org.apache.commons.math.DuplicateSampleAbscissaExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiplyNaNInf, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNull, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinear, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerial, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testGetRealFormat, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testNullIntervalCheck, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testPercentile, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateSpecialValues, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseNegative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testToString, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullURL, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonUnEqualCounts, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290GEQ, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testEpsilonLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregationConsistency, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnVectorLarge, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testRoundFloat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientFail, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testSetStandardDeviation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogInf, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSubstitute, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregate, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackPowellSingular, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCoshNaN, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testSinMin, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testCentroid, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.InvalidMatrixExceptionTest#testConstructorMessage, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBisectionSolverValid, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testAEqualQR, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testNumeratorFormat, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnMatrixLarge, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetRealFormatNull, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaNegative, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withoutWeights, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLegendrePolynomials, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testReciprocal, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowVectorLarge, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.random.UniformRandomGeneratorTest#testMeanAndStandardDeviation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testMismatch, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testCopy, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testBound, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test8Points, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testDefault, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddNullYSampleData, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAbsentOnExisting, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testControlParameters, [Manual]TestMethod=org.apache.commons.math.genetics.TournamentSelectionTest#testSelect, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testPopulation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregation, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testForgottenImaginaryCharacter, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormat, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testRootEndpoints, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackWatson, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDoubleConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryFormatNull, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#polynomial, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testModelWithNoArtificialVars, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testSingular, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsImaginaryDifference, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackFreudensteinRoth, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDivide, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveSingle, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbs, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testAdaptor, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares3, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testMeanAccessors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgument, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares1, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares2, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullDoubleArray, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBox3Dimensional, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideNaNInf, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testExamples, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithoutSplit, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtNaN, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testGetStandardDeviation, [Manual]TestMethod=org.apache.commons.math.linear.MatrixIndexExceptionTest#testConstructorMessage, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testConstructorDouble, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsRemovedTiesSequential, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testNumeratorFormat, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAbsentOnExisting, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsClass, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollision2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCoshInf, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreColumns, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiple, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetAbsoluteAccuracy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSingleton, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testLongFormat, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#notEnoughData, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilityAgaintStackOverflow, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneWayAnovaUtils, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testPowell, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL2DistanceDouble, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testLongly, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testHighPercentile, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveSin, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNextAfter, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testSingular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonEqualCounts, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveFromEmpty, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testCoordinates, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollisions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsinNaN, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorDouble, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateResiduals, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testNaN, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testFractionConverter, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPAEqualLU, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testMean, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testCopy, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaNegativePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#checkClone, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtInf, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbsInfinite, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataWithSampleSizeMismatch, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#exceedMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testStdErrorConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproper, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWithExpectedSize, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testFloat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_realPartZero, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsNaN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryZero, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextFloat, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testPaired, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testImpossibleSerialization, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroImaginary, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testParameterAccessors, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testNextDigestFail, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperInvalidMinus, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeBoth, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMax, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testRestrictVariablesToNonNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testInitialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testNonInvertible, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveXY, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testModelsMerging, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testToString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowInf, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testValues, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#noReset, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth1, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterNull, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMax, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemove2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealNegative, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testUOrthogonal, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testBBiDiagonal, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testpowNull, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetMatrixLarge, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testDegenerateInverseCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#polynomial, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testGetReducedFraction, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInteger, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testStaticFormatRealVectorImpl, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackMeyer, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSerial, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNanPositive, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetMaximalIterationCount, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testTTriDiagonal, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracyNull, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConstructorNaN, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositivePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest#testMeanAndCorrelation, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testConcurrentModification, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackRosenbrok, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignFloat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignDouble, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInvalid, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testVectorTwoPairs, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testExtremeValues, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testThreshold, [Manual]TestMethod=org.apache.commons.math.geometry.RotationOrderTest#testName, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorShort, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollisions, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testStaticFormatComplex, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testAEqualQTQt, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSinh, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testGetImaginaryFormat, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanNaN, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testInducedPermutation, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnVectorLarge, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaPValue, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#dimensionCheck, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackRosenbrok, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroReal, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testZeroDivide, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testRank, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddXSampleData, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testAEqualVDVt, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testSingularities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullCovarianceData, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testDoubleFormat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testFactorialFail, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testQTOrthogonal, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSimplistic, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testAbs, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSetAlpha, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLaguerreDifferentials, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNormInf, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testMakotoNishimura, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantSolvable, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogNaN, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#testNoIntInverse, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterEmpty, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testBinIndexOverflow, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaFValue, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testFactorial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLegendreDifferentials, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentSizes, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMin, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackJennrichSampson, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testSampling, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateTwoSegment, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testBoundParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilitySpecial, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackFreudensteinRoth, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateResiduals, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorByte, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testAEqualLLT, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollision2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testComposeInverse, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWithExpectedSize, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBrownDennis, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSingular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.InteractionTest#testInteraction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testBasicStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testAddAndCheckLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatNumber, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeBoth, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testDiscard, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testAdd1000, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testSmallDf, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testWalk, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaZeroPositive, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSkewAndKurtosis, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnFieldMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testIntegerOverflow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testPopulation, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinInf, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaNanPositive, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeReal, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testFunctionEvaluationExceptions, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketEndpointRoot, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWith0ExpectedSize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testContainsTransformer, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues5, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues3, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestPositive, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testControlParameters, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsin, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowVectorLarge, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalidDenominator, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSetElementArbitraryExpansion, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testLinear, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testHat, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_NAN_Inf, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveZero, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsAndInfs, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testAxisAngle, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetRelativeAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstHermitePolynomials, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testPaired, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testRevert, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerial, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testLargeModel, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testVectorialProducts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.genetics.OnePointCrossoverTest#testCrossover, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemove, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMath283, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowMatrixLarge, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#exceedMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing1, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testConditionNumber, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testParameters, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing2, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testStaticFormatVector3D, [Manual]TestMethod=org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations#test, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolveSingularityErrors, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonBadCounts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testPercentileSetter, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCoshNaN, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowNaNExponent, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testSumLog, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformNull, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testNoOptimum, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowZero, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsFixedTiesRandom, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProper, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSingleVariableAndConstraint, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistance1, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNegativePositive, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationAtBounds, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testCopy, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromEmpty, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackMeyer, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testFloatValue, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivide, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetAbsent, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextIntN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testPPermutation, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoFailures, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testUnsorted, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testIgnored, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testFloatValue, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testSmallDegreesOfFreedom, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositivePositive, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutOnExisting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBard, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLTTransposed, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testNoAccessBelowDiagonal, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRank, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testAEqualUSVt, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSerial, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#test2DData, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateThreeSegment, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testSkewAndKurtosis, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMean, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testConditionNumber, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopy, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testMutators, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.util.ContinuedFractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testDifferenceStats, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testInitialGuess, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSin, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateFullSample, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMath199, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testExamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExpNaN, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetFunctionValueAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testAddition, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testIntValue, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHighDegreeLegendre, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#test1PercentError, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedProduct, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackJennrichSampson, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testBigDecimalValue, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testInvertible, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNoDenseOutput, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullFile, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testRemoval, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnMatrixLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexIllegalModulus, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterNull, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNoComponents, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackWatson, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testIdentity, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testLongly, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopy, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testNextDigest, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFine, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testIterator, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuadratic, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testNorm, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testPaired, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testPrintStackTrace, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testConcurrentModification, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperNegative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testEmptyData, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsRealDifference, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultipleToEmpty, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressandVariance, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testAddAndCheck, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf2576, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullYSampleData, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testMedian, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testArrayHash, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testBeta, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLcm, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#dimensionCheck, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorFloat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testNaN, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoad, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveZero, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroReal, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanInf, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testForgottenImaginaryCharacter, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testDoubleDimension, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhInf, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testCounts, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSolve, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParameters, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSetNumberOfElements, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackKowalikOsborne, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvectors, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanInverseCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParse, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhNaN, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheckErrorMessage, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopy, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testAbs, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testMinEndpoints, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEquals, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testNexFail, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testFormatNumber, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testHadamard, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformBigDecimal, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testFunctionEvaluationExceptions, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testGetRealFormat, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealPositive, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiplePastEmpty, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLog, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNan, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignLong, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testUnequalSizeArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testBasicStats, [Manual]TestMethod=org.apache.commons.math.random.GaussianRandomGeneratorTest#testMeanAndStandardDeviation, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemoveFromEmpty, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testMulAndCheck, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testGeometricMean, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNegate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficient, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinhInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction2, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testZeroReal, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testSmallError, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL1DistanceDouble, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#test20090720, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testUnboundedSolution, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewSecantSolverValid, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testSumSq, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryFormatNull, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testNoError, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcos, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveAbsent, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeReal, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.ode.sampling.StepNormalizerTest#testBeforeEnd, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformInteger, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugateInfiinite, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testCopy, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSimplexSolver, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testStaticFormatRealVectorImpl, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInvalidDenominator, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testAddElementRolling, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddXSampleData, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSeveralBlocks, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testPaseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#testDerivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArray, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanCritical, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testApplyInverseTo, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNan, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMeanAndCovariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExp, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMin, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testGetFromEmpty, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParameters, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNegative, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testConstructorDouble, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test4Points, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformObject, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testStaticFormatVector3D, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowNaNBase, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testPAEqualLU, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testRandomPermutation, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfectNegative, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideZero, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwiss, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.genetics.ChromosomeTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaNan, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNoComponents, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSinhNaN, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testBadEndpoints, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextBoolean, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testLongValue, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testPopulationSize, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGetBinUpperBounds, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeBoth, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testModes, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testfirstDerivativeComparison, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testLongValue, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.ArgumentOutsideDomainExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test3Points, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackHelicalValley, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedDelta, [Manual]TestMethod=org.apache.commons.math.stat.data.LewTest#testCertifiedValues, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testPowell, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingBandwidthIncreasesSmoothness, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testDenominatorFormat, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal3, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal4, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal5, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal6, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testStdErrorConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal1, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal2, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.CertifiedDataTest#testDescriptiveStatistics, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testUnderdetermined, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testExactIntegration, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testAEqualUSVt, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testDoubleLoad, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLInfDistanceDouble, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBard, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSubtraction, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf0, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayArgumentCause, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testNegate, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackChebyquad, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowMatrixLarge, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testEmptyReplayFile], testFrameworkStrategy=fr.spoonlabs.flacoco.core.coverage.framework.JUnit4Strategy@6256ac4f}
Running TestContext{testMethods=[[Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL2DistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testOverdetermined, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolveSingularityErrors, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testCompose, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowFieldMatrix, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithSplit, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeReal, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testCorr, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNextAfterSpecialCases, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testPerfectFit, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testConfig, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiplyNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheckLong, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSampling, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSanityChecks, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testReplay, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignInt, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnLarge, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#checkClone, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewNewtonSolverValid, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgumentNaN, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAdd, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveZero, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTan, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testIsSingular, [Manual]TestMethod=org.apache.commons.math.MaxIterationsExceededExceptionTest#testSimpleConstructor, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateSin, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonEqualCounts, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaNanPositive, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSimplistic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testPermutedArrayHash, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowLarge, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNorm, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosNaN, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataThatIsNotSquare, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testIsSame, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotSymmetricMatrixException, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.CertifiedDataTest#testSummaryStatistics, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonUnEqualCounts, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsErrors, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearFullRank, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideInfinite, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDoubleConstructor, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyMutationTest#testMutate, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testEpsilon, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testTheory, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSubtractNaN, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealZero, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproperNegative, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveBadParameters, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testGetImaginaryFormat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSetQuantile, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryNegative, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testAddNonComparable, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinhNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testWindowSize, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvalues, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate1, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testGetSummary, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDegenerate0, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowLarge, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetFromEmpty, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaNegativePositivePositive, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testTridiagonal, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testAngles, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSolutionWithNegativeDecisionVariable, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testMultiplication, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLaguerrePolynomials, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testRandomAccess, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testIdentityPermutation, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testCovarianceConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.BetaDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseBig, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testSanityChecks, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolveRankErrors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistanceSq, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHermiteDifferentials, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testGetMean, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testComparatorPermutation, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIntegratorControls, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testSSENonNegative, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension1, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testTrivialModel, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest#testDerivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension3, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProperInvalidMinus, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne2, [Manual]TestMethod=org.apache.commons.math.genetics.GeneticAlgorithmTestBinary#test, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhCritical, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateDegenerate, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackOsborne1, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetFunctionValueAccuracy, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaPositive, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testProduct, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosInf, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownAlmostLinear, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBrownAlmostLinear, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testInvalidConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNormalize, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction2, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testEqualRepr, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testStaticFormatComplex, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testConstant, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaTest, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutOnExisting, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseZeroReal, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngular, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacity, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketSin, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testGcd, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testValues, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeBoth, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.genetics.FitnessCachingTest#testFitnessCaching, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoSuccesses, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.distribution.BetaDistributionTest#testCumulative, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290LEQ, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetMatrixLarge, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testLargeValues, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#backward, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testQuinticMin, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate1, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaNegativePositive, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDegenerate0, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testScale, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheck, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testNegate, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExpInf, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testNorris, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroImaginary, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testDecode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackChebyquad, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigMatrix, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConstant, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBadParameters, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.genetics.FixedGenerationCountTest#testIsSatisfied, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGet, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveZeroPositive, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstChebyshevPolynomials, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMinimizeMaximize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testNaN, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testGetAbsent, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testTransformers, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testIterator, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testConstants, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_fourthRoot, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testDigammaSmallArgs, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testInference, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#test5, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testClear, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaZeroPositivePositive, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testInfeasibleSolution, [Manual]TestMethod=org.apache.commons.math.analysis.integration.SimpsonIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextIntNeg, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsTrue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsNull, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArgumentCause, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiply, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromSingle, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testClear, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtPolar, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testFill, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatZero, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testSmallDf, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL1DistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testMath280, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDistinctEigenvalues, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testDoubleFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMath226, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.genetics.ElitisticListPopulationTest#testNextGeneration, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexNaN, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#checklone, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackHelicalValley, [Manual]TestMethod=org.apache.commons.math.genetics.ListPopulationTest#testGetFittestChromosome, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testLongly, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLInfDistanceInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testUOrthogonal, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRowRealMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseManyComponents, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositivePositive, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testPutTransformer, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testDegeneracy, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testDimension, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testDropPhase1Objective, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testWholeFormat, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNormalizeAngle, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbsNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaZero, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testPercentile, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testLongly, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testErrorConditions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testZeroImaginary, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInteger, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNexBytes, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2Complex, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testPercentileSetter, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMath221, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrt1z, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnDistortedSine, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testQuaternion, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testHTrapezoidal, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNoRoot, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.analysis.integration.RombergIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testQOrthogonal, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testMismatch, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatZero, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSetBeta, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.stat.data.LotteryTest#testCertifiedValues, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testFixedState, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testGetReducedFraction, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testSmallLastStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testContainsClass, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSeveralBlocks, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFat, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetAbsoluteAccuracy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMinimization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#test0Choose0, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformString, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testSetMean, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testRepeatedEigenvalue, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.genetics.ChromosomeTest#testFindSameChromosome, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperatePremultiplyLarge, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressandVariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevDifferentials, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEventsNoConvergence, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testAlpha, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedUlps, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetRelativeAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracySin, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testEmptyDigestFile, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDivide, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseZeroImaginary, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNullIntervalCheck, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testTrigamma, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideReal, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove2, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalid, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testQuantiles, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testDigammaLargeArgs, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRandom, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testRemoval, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetMaximalIterationCount, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideNaN, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnTwoPoints, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testNoError, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProper, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testScalarProduct, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testVectorOnePair, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testQOrthogonal, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveNan, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositiveNegative, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testWrongDerivative, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testSubMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testNormalApproximateProbability, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMaximalTiesMinimum, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationInside, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNegateNaN, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testDenominatorFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinNaN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiplyInf, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testParaboloid2D, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentSizes, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testConstructor2, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testConstructor1, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogZero, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testMinMax, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testUUpperTriangular, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCosh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearFullRank, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testCopy, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfect, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseManyComponents, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParse, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testNorm, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDigitLimitConstructor, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testBigFractionConverter, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#test20090720, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest#testLinearFunction2D, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGet, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMath199, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testStats, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testContainsKey, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetRealFormatNull, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantUnsolvable, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareDataSetsComparisonBadCounts, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#backward, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperateLarge, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBox3Dimensional, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseNegativeImaginary, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperateLarge, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistanceInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnOnePoint, [Manual]TestMethod=org.apache.commons.math.ode.sampling.StepNormalizerTest#testBoundaries, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngularSeparation, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testInverse, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformDouble, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCosh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testTableauWithNoArtificialVars, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testScalb, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testRandomConstructor, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testEstimate, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackPowellSingular, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testContainsKey, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testUUpperTriangular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_normal_thirdRoot, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testToString, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath272, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeReal, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMinimizeMaximize, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testOnStraightLine, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinh, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testArrayIndexConditions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testNaN, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testConstruction, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testVariableSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testGetSummary, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNormalizeArray, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath288, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDiagonal, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath286, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testInitialGuess, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnRealMatrix, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignByte, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testBoundaries, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testPaseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath293, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWith0ExpectedSize, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf3291, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testHashCode, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testMath308, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAddNaN, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne2, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testDistance, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testRUpperTriangular, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackOsborne1, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperatePremultiplyLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugateNaN, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreRows, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCos, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaNanPositivePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuintic, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#checklone, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testSinMin, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testConfig, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedVariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsinInf, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNISTExample, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtanNaN, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbability2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcosInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testInsufficientBandwidth, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterEmpty, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideImaginary, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testMoreLargeValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedMean, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testArrayEquals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBrownDennis, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesMaximum, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testOrthogonal, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistance, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testSetScale, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testEmptyTable, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxIterations, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaZeroPositive, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatNegative, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientLarge, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testWindowSize, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsMinimalTiesAverage, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testWholeFormat, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testVariance, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testRemoveTransformer, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testUpperOrLower, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testDouble, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.MaxIterationsExceededExceptionTest#testComplexConstructor, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHeterscedastic, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testPcts, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testAngle, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testGaussian, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction2, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBrentSolverValid, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testLongFormat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testLUDecomposition, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testProperties, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNorm1, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtanInf, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf2807, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testArrayIsReference, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testConfig, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNexBoolean, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testOperate, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testClasses, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testCovarianceConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrt1zNaN, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignShort, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSerial, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf1960, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testHash, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testReciprocal, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testNorm, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.ArrayFieldVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgumentInf, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest#dimension2, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testIntegerValues, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testConstruction, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryMutationTest#testMutate, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testIntValue, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemoveAbsent, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcosNaN, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testSerial, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAddInfinite, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testDimension, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testLargeDegreesOfFreedom, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLog, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testScalarMultiplyNaN, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateRealMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.genetics.BinaryChromosomeTest#testIsSame, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackKowalikOsborne, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testWeightedSum, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testNoReset, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testBigDecimalValue, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRootMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testChebyshevBounds, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testMulAndCheckLong, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testConstant, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniform, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testWithInitialCapacityAndExpansionFactor, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testNullEmpty, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsSame, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testNext, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testRoundDouble, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withWeights, [Manual]TestMethod=org.apache.commons.math.DuplicateSampleAbscissaExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiplyNaNInf, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveNull, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinear, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerial, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testGetRealFormat, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testNullIntervalCheck, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testPercentile, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregateSpecialValues, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseNegative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testToString, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullURL, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonUnEqualCounts, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath290GEQ, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testEpsilonLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregationConsistency, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnVectorLarge, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testRoundFloat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientFail, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testSetStandardDeviation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogInf, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSubstitute, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPlusMinus, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregate, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackPowellSingular, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCoshNaN, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testSinMin, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoisson, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest#testCentroid, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.InvalidMatrixExceptionTest#testConstructorMessage, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewBisectionSolverValid, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testAEqualQR, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testNumeratorFormat, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetColumnMatrixLarge, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetRealFormatNull, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaNegative, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testMath296withoutWeights, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstLegendrePolynomials, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testReciprocal, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowVectorLarge, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.random.UniformRandomGeneratorTest#testMeanAndStandardDeviation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testMismatch, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testBasicFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testCopy, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.EstimatedParameterTest#testBound, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test8Points, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testDefault, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddNullYSampleData, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAbsentOnExisting, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testControlParameters, [Manual]TestMethod=org.apache.commons.math.genetics.TournamentSelectionTest#testSelect, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testPopulation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest#testAggregation, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testForgottenImaginaryCharacter, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormat, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testRootEndpoints, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackWatson, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testDoubleConstructor, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryFormatNull, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#polynomial, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testModelWithNoArtificialVars, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testSingular, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsImaginaryDifference, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackFreudensteinRoth, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testDivide, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveSingle, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbs, [Manual]TestMethod=org.apache.commons.math.linear.ArrayRealVectorTest#testMapFunctions, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testAdaptor, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNonSquare, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares3, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testMeanAccessors, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testGetArgument, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares1, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testLeastSquares2, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullDoubleArray, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBox3Dimensional, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideNaNInf, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testExamples, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testDimension4WithoutSplit, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtNaN, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testGetStandardDeviation, [Manual]TestMethod=org.apache.commons.math.linear.MatrixIndexExceptionTest#testConstructorMessage, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testParameters, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareIndependence, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testConstructorDouble, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsRemovedTiesSequential, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testNumeratorFormat, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAbsentOnExisting, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testDeterminant, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsClass, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollision2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testCoshInf, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreColumns, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiple, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetAbsoluteAccuracy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSingleton, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testLongFormat, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#notEnoughData, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilityAgaintStackOverflow, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneWayAnovaUtils, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testPowell, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testIllConditioned, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseZeroX, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL2DistanceDouble, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testLongly, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testHighPercentile, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveSin, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testNextAfter, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testSingular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testGetValues, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonEqualCounts, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveFromEmpty, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testCoordinates, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutKeysWithCollisions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsinNaN, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorDouble, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureLong, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateResiduals, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testNaN, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testFractionConverter, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPAEqualLU, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testMean, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testCopy, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareLargeTestStatistic, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaNegativePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest#checkClone, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtInf, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAbsInfinite, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddCovarianceDataWithSampleSizeMismatch, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#exceedMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testStdErrorConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testFormatImproper, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutAndGetWithExpectedSize, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testFloat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_realPartZero, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsNaN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtImaginaryZero, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextFloat, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testPaired, [Manual]TestMethod=org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest#testImpossibleSerialization, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroImaginary, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testParameterAccessors, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testNextDigestFail, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperInvalidMinus, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeBoth, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testDataInOut, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMax, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testRestrictVariablesToNonNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.correlation.CovarianceTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexTableauTest#testInitialization, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testNonInvertible, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveXY, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.ode.ContinuousOutputModelTest#testModelsMerging, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testToString, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowInf, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest#testValues, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#noReset, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth1, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testCompletelyIncorrectBandwidth2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.transform.FastCosineTransformerTest#testAdHocData, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterNull, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanh, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testMath209, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMax, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemove2, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealNegative, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testUOrthogonal, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testBBiDiagonal, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testpowNull, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetMatrixLarge, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testVOrthogonal, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testDegenerateInverseCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#polynomial, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSinZero, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testGetReducedFraction, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues2, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInteger, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testStaticFormatRealVectorImpl, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackMeyer, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testMatricesValues1, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testDoubleValue, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSerial, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNanPositive, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testSetMaximalIterationCount, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testSetterInjection, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testTTriDiagonal, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testSolveAccuracyNull, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConstructorNaN, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateBigIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositivePositive, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testStepSize, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest#testMeanAndCorrelation, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testConcurrentModification, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackRosenbrok, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignFloat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignDouble, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInvalid, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testVectorTwoPairs, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testExtremeValues, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testThreshold, [Manual]TestMethod=org.apache.commons.math.geometry.RotationOrderTest#testName, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorShort, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollisions, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testStaticFormatComplex, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testAEqualQTQt, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSinh, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testGetImaginaryFormat, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanNaN, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testInducedPermutation, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnVectorLarge, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSeparator, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaPValue, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#dimensionCheck, [Manual]TestMethod=org.apache.commons.math.ConvergenceExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackRosenbrok, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testNaNContracts, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSample, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseZeroReal, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseIgnoredWhitespace, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testZeroDivide, [Manual]TestMethod=org.apache.commons.math.linear.CholeskySolverTest#testSolveDimensionErrors, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testBigMatrix, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testRank, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddXSampleData, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testAEqualVDVt, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testSingularities, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullCovarianceData, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testDoubleFormat, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testFactorialFail, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testQTOrthogonal, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSimplistic, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testAbs, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testCopySubMatrix, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testSetAlpha, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLaguerreDifferentials, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddSampleDataWithSizeMismatch, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testNormInf, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testMakotoNishimura, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testRedundantSolvable, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testLogNaN, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#testNoIntInverse, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryCharacterEmpty, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testBinIndexOverflow, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor, [Manual]TestMethod=org.apache.commons.math.stat.inference.OneWayAnovaTest#testAnovaFValue, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testSwissFertility, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testFactorial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testStats, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testLegendreDifferentials, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testMisc, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testInconsistentSizes, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testQuinticMin, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackJennrichSampson, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testSampling, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateTwoSegment, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSetColumn, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testBoundParameters, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testTwoSets, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testCumulativeProbabilitySpecial, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackFreudensteinRoth, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateResiduals, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorByte, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testAEqualLLT, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutKeysWithCollision2, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testComposeInverse, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWithExpectedSize, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBrownDennis, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSingular, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.InteractionTest#testInteraction, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testBasicStats, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testAddAndCheckLong, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testCopy, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextSecureHex, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testFormatNumber, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.util.BigRealFieldTest#testZero, [Manual]TestMethod=org.apache.commons.math.linear.QRDecompositionImplTest#testMatricesValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNegativeBoth, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testDiscard, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testAdd1000, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testSmallDf, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testWalk, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextUniformExclusiveEndpoints, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaZeroPositive, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testSkewAndKurtosis, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testConstructorPatternArguments, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testCreateColumnFieldMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testMoreEstimatedParametersUnsorted, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testIntegerOverflow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testPopulation, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinInf, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaNanPositive, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNegativeReal, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testFunctionEvaluationExceptions, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest#testBracketEndpointRoot, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testPutAndGetWith0ExpectedSize, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testInconsistentEquations, [Manual]TestMethod=org.apache.commons.math.util.TransformerMapTest#testContainsTransformer, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues5, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testMatricesValues3, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest#testTestPositive, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testControlParameters, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAsin, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowVectorLarge, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseInvalidDenominator, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParametersVariance, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSetElementArbitraryExpansion, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testLinear, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testHat, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_NAN_Inf, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveZero, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsAndInfs, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testAxisAngle, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetRelativeAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testFirstHermitePolynomials, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testPaired, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testRevert, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testSerial, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testLargeModel, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testVectorialProducts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.genetics.OnePointCrossoverTest#testCrossover, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemove, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMath283, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetRowMatrixLarge, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#exceedMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing1, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testConditionNumber, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testParameters, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNonStrictlyIncreasing2, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testStaticFormatVector3D, [Manual]TestMethod=org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextSecureInt, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations#test, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testRedundantEquations, [Manual]TestMethod=org.apache.commons.math.linear.LUSolverTest#testSolveSingularityErrors, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testDeprecated, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareDataSetsComparisonBadCounts, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest#testPercentileSetter, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCoshNaN, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testPositiveInfinity, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowNaNExponent, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testSumLog, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testMath209, [Manual]TestMethod=org.apache.commons.math.transform.FastSineTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformNull, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest#testNoOptimum, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowZero, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.stat.ranking.NaturalRankingTest#testNaNsFixedTiesRandom, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProper, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSingleVariableAndConstraint, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DTest#testDistance1, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testFrobeniusNorm, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositiveNegativePositive, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#interpolationAtBounds, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testCopy, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveObsFromEmpty, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackMeyer, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleTTest, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNonInversible, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testFloatValue, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivide, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testGetAbsent, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextIntN, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testPPermutation, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateNoFailures, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testUnsorted, [Manual]TestMethod=org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest#testCircleFitting, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.estimation.WeightedMeasurementTest#testIgnored, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testFloatValue, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testSmallDegreesOfFreedom, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testExpm1Function2, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest#testMinStep, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testKepler, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAtan, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuadraticFunction, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testDfAccessors, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testLogBetaPositivePositive, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testPutOnExisting, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testProductAndGeometricMean, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackBard, [Manual]TestMethod=org.apache.commons.math.random.MersenneTwisterTest#testNextLong, [Manual]TestMethod=org.apache.commons.math.linear.CholeskyDecompositionImplTest#testLTTransposed, [Manual]TestMethod=org.apache.commons.math.linear.TriDiagonalTransformerTest#testNoAccessBelowDiagonal, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testRank, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testAEqualUSVt, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSerial, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#test2DData, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest#testInterpolateLinearDegenerateThreeSegment, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextInt, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testSkewAndKurtosis, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMean, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testConditionNumber, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testCopy, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testCircleFittingBadInit, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseNegative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testPremultiplyVector, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testMutators, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.util.ContinuedFractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testParameters, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testDifferenceStats, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#testInitialGuess, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSin, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testDegenerateFullSample, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testMath199, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextExponential, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testExamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExpNaN, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetRowMatrix, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testResetFunctionValueAccuracy, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testAddition, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testIntValue, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest#testHighDegreeLegendre, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.HarmonicFitterTest#test1PercentError, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testWeightedProduct, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackJennrichSampson, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.util.BigRealTest#testBigDecimalValue, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testQRColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.EigenSolverTest#testInvertible, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testTranspose, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testNoDenseOutput, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoadNullFile, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testPow, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.distribution.ChiSquareDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testRemoval, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testDensity, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetSetColumnMatrixLarge, [Manual]TestMethod=org.apache.commons.math.complex.ComplexUtilsTest#testPolar2ComplexIllegalModulus, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSetImaginaryCharacterNull, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParseNoComponents, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testSetColumnVector, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackWatson, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testCopyFunctions, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testIdentity, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#testLongly, [Manual]TestMethod=org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest#testColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayPatternArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopy, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testNextDigest, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorPatternArgumentsCause, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGridTooFine, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextGaussian, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testIterator, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testQuadratic, [Manual]TestMethod=org.apache.commons.math.distribution.GammaDistributionTest#testProbabilities, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testNorm, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testPaired, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testTrivial, [Manual]TestMethod=org.apache.commons.math.MathExceptionTest#testPrintStackTrace, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testConcurrentModification, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParseProperNegative, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testNan, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPermutation, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testForgottenPrefix, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testEmptyData, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testWalk, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleWithDecimals, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BisectionSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testEqualsRealDifference, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultipleToEmpty, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressandVariance, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testAddAndCheck, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf2576, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#cannotAddNullYSampleData, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.ProductTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.distribution.CauchyDistributionTest#testMedian, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testMultiply2, [Manual]TestMethod=org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest#serialization, [Manual]TestMethod=org.apache.commons.math.random.RandomAdaptorTest#testNextLongExtremeValues, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testArrayHash, [Manual]TestMethod=org.apache.commons.math.distribution.BinomialDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testBeta, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLcm, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#dimensionCheck, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testIndicatorFloat, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testNaN, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testLoad, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveZero, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testExamples, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testDifferentImaginaryChar, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testZeroReal, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanInf, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testForgottenImaginaryCharacter, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testForgottenSuffix, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetVectors, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testDoubleDimension, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhInf, [Manual]TestMethod=org.apache.commons.math.stat.FrequencyTest#testCounts, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldVectorTest#testPredicates, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testSolve, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#canEstimateRegressionParameters, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testSetNumberOfElements, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackKowalikOsborne, [Manual]TestMethod=org.apache.commons.math.linear.EigenDecompositionImplTest#testEigenvectors, [Manual]TestMethod=org.apache.commons.math.distribution.PoissonDistributionTest#testLargeMeanInverseCumulativeProbability, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testAdd, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FirstMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testGetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFormatTest#testParse, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testCopy, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanhNaN, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testInverseCumulativeProbabilityExtremes, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testUnstableDerivative, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSubAndCheckErrorMessage, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest#testCopy, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testAbs, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest#derivativesConsistency, [Manual]TestMethod=org.apache.commons.math.optimization.univariate.BrentMinimizerTest#testMinEndpoints, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest#testEqualsAndHashCode, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MinTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEquals, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testNexFail, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testFormatNumber, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueDecompositionImplTest#testHadamard, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformBigDecimal, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testSetterIllegalState, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testColumnsPermutation, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testFunctionEvaluationExceptions, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testGetRealFormat, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSqrtRealPositive, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testPremultiply, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testRemoveMultiplePastEmpty, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.PercentileTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLog, [Manual]TestMethod=org.apache.commons.math.transform.FastFourierTransformerTest#testParameters, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNan, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSignLong, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testUnequalSizeArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testBasicStats, [Manual]TestMethod=org.apache.commons.math.random.GaussianRandomGeneratorTest#testMeanAndStandardDeviation, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testRemoveFromEmpty, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testMulAndCheck, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testIncreasingTolerance, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testGeometricMean, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testAdd, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testNegate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest#testSerial, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testGetRowVector, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumSqTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficient, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testSetRow, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.VarianceTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testSinhInf, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testOneSet, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testQuinticFunction2, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testZeroReal, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testTrace, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testLLowerTriangular, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testSmallError, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testFloatingPointArguments, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.KurtosisTest#testCopyConsistency, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetRow, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.linear.FieldLUDecompositionImplTest#testPPermutation, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testL1DistanceDouble, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testRosenbrock, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testConsistency, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#test20090720, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testLinearFunction, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testUnboundedSolution, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest#testNewSecantSolverValid, [Manual]TestMethod=org.apache.commons.math.distribution.FDistributionTest#testIllegalArguments, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testSumSq, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testSetImaginaryFormatNull, [Manual]TestMethod=org.apache.commons.math.optimization.fitting.PolynomialFitterTest#testNoError, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.ListUnivariateImplTest#testN0andN1Conditions, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest#testShuffledStatistics, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testAcos, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemoveAbsent, [Manual]TestMethod=org.apache.commons.math.ode.FirstOrderConverterTest#testDecreasingSteps, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeReal, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testOneSampleT, [Manual]TestMethod=org.apache.commons.math.ode.sampling.StepNormalizerTest#testBeforeEnd, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextPoissonConsistency, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testConstructors, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformInteger, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MedianTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testNoDependency, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testConjugateInfiinite, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testCopy, [Manual]TestMethod=org.apache.commons.math.optimization.linear.SimplexSolverTest#testSimplexSolver, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testStaticFormatRealVectorImpl, [Manual]TestMethod=org.apache.commons.math.linear.BigMatrixImplTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testParseInvalidDenominator, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testDimensions, [Manual]TestMethod=org.apache.commons.math.util.ResizableDoubleArrayTest#testAddElementRolling, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GillIntegratorTest#testBigStep, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testIncrementation, [Manual]TestMethod=org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest#cannotAddXSampleData, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSeveralBlocks, [Manual]TestMethod=org.apache.commons.math.distribution.PascalDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testPaseNegativeInfinity, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest#testDerivativesConsistency, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testToString, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArray, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeX, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testDimensionCheck, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testTanCritical, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleWithDecimalsTrunc, [Manual]TestMethod=org.apache.commons.math.linear.RealMatrixImplTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFormatTest#testSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeZ, [Manual]TestMethod=org.apache.commons.math.geometry.RotationTest#testApplyInverseTo, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testNegativeY, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeZ, [Manual]TestMethod=org.apache.commons.math.special.BetaTest#testRegularizedBetaPositivePositiveNan, [Manual]TestMethod=org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest#testMeanAndCovariance, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testExp, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testEvents, [Manual]TestMethod=org.apache.commons.math.stat.StatUtilsTest#testMin, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testGetColumn, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToFieldTest#testGetFromEmpty, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeX, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeY, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testSmallSamples, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest#canEstimateRegressionParameters, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetColumnVector, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testRegularizedGammaPositiveNegative, [Manual]TestMethod=org.apache.commons.math.MathConfigurationExceptionTest#testConstructorCause, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testParseSimpleNoDecimals, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testConstructorDouble, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test4Points, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.summary.SumLogTest#testSpecialValues, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.FourthMomentTest#testEvaluation, [Manual]TestMethod=org.apache.commons.math.util.DefaultTransformerTest#testTransformObject, [Manual]TestMethod=org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareZeroCount, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testSubtract, [Manual]TestMethod=org.apache.commons.math.distribution.NormalDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.util.OpenIntToDoubleHashMapTest#testRemove, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testSetRowMatrix, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testStaticFormatVector3D, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testPowNaNBase, [Manual]TestMethod=org.apache.commons.math.linear.LUDecompositionImplTest#testPAEqualLU, [Manual]TestMethod=org.apache.commons.math.genetics.RandomKeyTest#testRandomPermutation, [Manual]TestMethod=org.apache.commons.math.linear.Array2DRowRealMatrixTest#testAddFail, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealVectorTest#testSerial, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testPerfectNegative, [Manual]TestMethod=org.apache.commons.math.distribution.TDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.complex.ComplexTest#testDivideZero, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testSwiss, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.genetics.ChromosomeTest#testCompareTo, [Manual]TestMethod=org.apache.commons.math.special.GammaTest#testLogGammaNan, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testMultiply, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SkewnessTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.linear.FrenchRealVectorFormatTest#testParseNoComponents, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testSinhNaN, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextHex, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.BrentSolverTest#testBadEndpoints, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testWeightedConsistency, [Manual]TestMethod=org.apache.commons.math.linear.MatrixUtilsTest#testcreateFieldIdentityMatrix, [Manual]TestMethod=org.apache.commons.math.random.AbstractRandomGeneratorTest#testNextBoolean, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionTest#testLongValue, [Manual]TestMethod=org.apache.commons.math.stat.inference.TTestFactoryTest#testTwoSampleTHomoscedastic, [Manual]TestMethod=org.apache.commons.math.distribution.HypergeometricDistributionTest#testPopulationSize, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testGetBinUpperBounds, [Manual]TestMethod=org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquare, [Manual]TestMethod=org.apache.commons.math.complex.FrenchComplexFormatTest#testNegativeBoth, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.rank.MaxTest#testCopy, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testAdd, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testModes, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testSerial, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testfirstDerivativeComparison, [Manual]TestMethod=org.apache.commons.math.stat.regression.SimpleRegressionTest#testNaNs, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerial, [Manual]TestMethod=org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest#testMoreEstimatedParametersSimple, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testParsePositiveInfinity, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testLongValue, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.RiddersSolverTest#testExpm1Function, [Manual]TestMethod=org.apache.commons.math.random.RandomDataTest#testNextIntExtremeValues, [Manual]TestMethod=org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testInsufficientData, [Manual]TestMethod=org.apache.commons.math.ArgumentOutsideDomainExceptionTest#testConstructor, [Manual]TestMethod=org.apache.commons.math.distribution.WeibullDistributionTest#testInverseCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.fraction.BigFractionFieldTest#testOne, [Manual]TestMethod=org.apache.commons.math.distribution.ExponentialDistributionTest#testCumulativeProbabilities, [Manual]TestMethod=org.apache.commons.math.transform.FastHadamardTransformerTest#test3Points, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackHelicalValley, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testScalarAdd, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testFormatObject, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedDelta, [Manual]TestMethod=org.apache.commons.math.stat.data.LewTest#testCertifiedValues, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.NewtonSolverTest#testQuinticZero, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.MullerSolverTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.optimization.direct.MultiDirectionalTest#testPowell, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testIncreasingBandwidthIncreasesSmoothness, [Manual]TestMethod=org.apache.commons.math.linear.FieldMatrixImplTest#testTrace, [Manual]TestMethod=org.apache.commons.math.fraction.FractionFormatTest#testDenominatorFormat, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal3, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal4, [Manual]TestMethod=org.apache.commons.math.optimization.direct.NelderMeadTest#testMaxEvaluations, [Manual]TestMethod=org.apache.commons.math.linear.RealVectorFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal5, [Manual]TestMethod=org.apache.commons.math.linear.SparseRealMatrixTest#testGetEntry, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal6, [Manual]TestMethod=org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testStdErrorConsistency, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal1, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest#testNotAllFiniteReal2, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testNonDefaultSetting, [Manual]TestMethod=org.apache.commons.math.analysis.solvers.LaguerreSolverTest#testQuinticFunction, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testSetColumnMatrix, [Manual]TestMethod=org.apache.commons.math.stat.CertifiedDataTest#testDescriptiveStatistics, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest#testSmallStep, [Manual]TestMethod=org.apache.commons.math.linear.QRSolverTest#testUnderdetermined, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackLinearRank1ZeroColsAndRows, [Manual]TestMethod=org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest#testExactIntegration, [Manual]TestMethod=org.apache.commons.math.linear.SparseFieldMatrixTest#testSetSubMatrix, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.SecondMomentTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.distribution.ZipfDistributionTest#testDensities, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackLinearRank1, [Manual]TestMethod=org.apache.commons.math.linear.SingularValueSolverTest#testSolve, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testGoldenRatio, [Manual]TestMethod=org.apache.commons.math.linear.BiDiagonalTransformerTest#testAEqualUSVt, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testSerialization, [Manual]TestMethod=org.apache.commons.math.stat.descriptive.moment.MeanTest#testMomentSmallSamples, [Manual]TestMethod=org.apache.commons.math.complex.ComplexFieldTest#testSerial, [Manual]TestMethod=org.apache.commons.math.random.EmpiricalDistributionTest#testDoubleLoad, [Manual]TestMethod=org.apache.commons.math.util.MathUtilsTest#testLInfDistanceDouble, [Manual]TestMethod=org.apache.commons.math.geometry.FrenchVector3DFormatTest#testConstructorSingleFormat, [Manual]TestMethod=org.apache.commons.math.optimization.general.MinpackTest#testMinpackBard, [Manual]TestMethod=org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest#testSinFunction, [Manual]TestMethod=org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest#testSubtraction, [Manual]TestMethod=org.apache.commons.math.geometry.Vector3DFormatTest#testParseNegativeAll, [Manual]TestMethod=org.apache.commons.math.special.ErfTest#testErf0, [Manual]TestMethod=org.apache.commons.math.FunctionEvaluationExceptionTest#testConstructorArrayArgumentCause, [Manual]TestMethod=org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testBackward, [Manual]TestMethod=org.apache.commons.math.fraction.FractionTest#testNegate, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSubMatrix, [Manual]TestMethod=org.apache.commons.math.estimation.MinpackTest#testMinpackChebyquad, [Manual]TestMethod=org.apache.commons.math.linear.BlockRealMatrixTest#testGetSetRowMatrixLarge, [Manual]TestMethod=org.apache.commons.math.linear.BlockFieldMatrixTest#testOperate, [Manual]TestMethod=org.apache.commons.math.random.ValueServerTest#testEmptyReplayFile], testFrameworkStrategy=fr.spoonlabs.flacoco.core.coverage.framework.JUnit4Strategy@6256ac4f}
Path to runner Classes: /Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar
Adding a line where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@1544
Adding a line from the block where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@1544
Adding a line where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@1071
Adding a line from the block where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@1071
Adding a line where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@893
Adding a line from the block where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@888
Adding a line from the block where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@893
Adding a line where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@657
Adding a line from the block where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@622
Adding a line from the block where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@623
Adding a line where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@246
Adding a line from the block where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@237
Adding a line from the block where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@238
Adding a line from the block where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@239
Adding a line from the block where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@240
Adding a line from the block where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@243
Adding a line from the block where an exception was thrown: org.apache.commons.math.linear.EigenDecompositionImpl@-@246
Tests found: 2103
Tests executed: 2103
Suspicious: 1 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1087, susp 0.9990471653168176
Suspicious: 2 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1509, susp 0.9990471653168176
Suspicious: 3 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1544, susp 0.9990471653168176
Suspicious: 4 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1621, susp 0.9990471653168176
Suspicious: 5 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1622, susp 0.9990471653168176
Suspicious: 6 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1625, susp 0.9990471653168176
Suspicious: 7 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1627, susp 0.9990471653168176
Suspicious: 8 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1479, susp 0.9985714285714287
Suspicious: 9 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1480, susp 0.9985714285714287
Suspicious: 10 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1481, susp 0.9985714285714287
Suspicious: 11 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1484, susp 0.9985714285714287
Suspicious: 12 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1485, susp 0.9985714285714287
Suspicious: 13 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1504, susp 0.9985714285714287
Suspicious: 14 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1507, susp 0.9985714285714287
Suspicious: 15 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1508, susp 0.9985714285714287
Suspicious: 16 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1511, susp 0.9985714285714287
Suspicious: 17 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1512, susp 0.9985714285714287
Suspicious: 18 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1513, susp 0.9985714285714287
Suspicious: 19 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1586, susp 0.9985714285714287
Suspicious: 20 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1084, susp 0.9961995249406175
Suspicious: 21 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1093, susp 0.9961995249406175
Suspicious: 22 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1095, susp 0.9961995249406175
Suspicious: 23 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1098, susp 0.9961995249406175
Suspicious: 24 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1100, susp 0.9961995249406175
Suspicious: 25 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1101, susp 0.9961995249406175
Suspicious: 26 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1474, susp 0.9957264957264956
Suspicious: 27 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1475, susp 0.9957264957264956
Suspicious: 28 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1478, susp 0.9957264957264956
Suspicious: 29 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1502, susp 0.9957264957264956
Suspicious: 30 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1503, susp 0.9957264957264956
Suspicious: 31 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1517, susp 0.9957264957264956
Suspicious: 32 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1520, susp 0.9957264957264956
Suspicious: 33 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1521, susp 0.9957264957264956
Suspicious: 34 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1523, susp 0.9957264957264956
Suspicious: 35 line org.apache.commons.math.linear.EigenDecompositionImpl l: 191, susp 0.9928977272727273
Suspicious: 36 line org.apache.commons.math.linear.EigenDecompositionImpl l: 193, susp 0.9928977272727273
Suspicious: 37 line org.apache.commons.math.linear.EigenDecompositionImpl l: 194, susp 0.9928977272727273
Suspicious: 38 line org.apache.commons.math.linear.EigenDecompositionImpl l: 195, susp 0.9928977272727273
Suspicious: 39 line org.apache.commons.math.linear.EigenDecompositionImpl l: 198, susp 0.9928977272727273
Suspicious: 40 line org.apache.commons.math.linear.EigenDecompositionImpl l: 199, susp 0.9928977272727273
Suspicious: 41 line org.apache.commons.math.linear.EigenDecompositionImpl l: 200, susp 0.9928977272727273
Suspicious: 42 line org.apache.commons.math.linear.EigenDecompositionImpl l: 201, susp 0.9928977272727273
Suspicious: 43 line org.apache.commons.math.linear.EigenDecompositionImpl l: 204, susp 0.9928977272727273
Suspicious: 44 line org.apache.commons.math.linear.EigenDecompositionImpl l: 643, susp 0.9928977272727273
Suspicious: 45 line org.apache.commons.math.linear.EigenDecompositionImpl l: 644, susp 0.9928977272727273
Suspicious: 46 line org.apache.commons.math.linear.EigenDecompositionImpl l: 645, susp 0.9928977272727273
Suspicious: 47 line org.apache.commons.math.linear.EigenDecompositionImpl l: 646, susp 0.9928977272727273
Suspicious: 48 line org.apache.commons.math.linear.EigenDecompositionImpl l: 647, susp 0.9928977272727273
Suspicious: 49 line org.apache.commons.math.linear.EigenDecompositionImpl l: 648, susp 0.9928977272727273
Suspicious: 50 line org.apache.commons.math.linear.EigenDecompositionImpl l: 649, susp 0.9928977272727273
Suspicious: 51 line org.apache.commons.math.linear.EigenDecompositionImpl l: 651, susp 0.9928977272727273
Suspicious: 52 line org.apache.commons.math.linear.EigenDecompositionImpl l: 654, susp 0.9928977272727273
Suspicious: 53 line org.apache.commons.math.linear.EigenDecompositionImpl l: 657, susp 0.9928977272727273
Suspicious: 54 line org.apache.commons.math.linear.EigenDecompositionImpl l: 826, susp 0.9928977272727273
Suspicious: 55 line org.apache.commons.math.linear.EigenDecompositionImpl l: 827, susp 0.9928977272727273
Suspicious: 56 line org.apache.commons.math.linear.EigenDecompositionImpl l: 828, susp 0.9928977272727273
Suspicious: 57 line org.apache.commons.math.linear.EigenDecompositionImpl l: 829, susp 0.9928977272727273
Suspicious: 58 line org.apache.commons.math.linear.EigenDecompositionImpl l: 830, susp 0.9928977272727273
Suspicious: 59 line org.apache.commons.math.linear.EigenDecompositionImpl l: 833, susp 0.9928977272727273
Suspicious: 60 line org.apache.commons.math.linear.EigenDecompositionImpl l: 839, susp 0.9928977272727273
Suspicious: 61 line org.apache.commons.math.linear.EigenDecompositionImpl l: 842, susp 0.9928977272727273
Suspicious: 62 line org.apache.commons.math.linear.EigenDecompositionImpl l: 845, susp 0.9928977272727273
Suspicious: 63 line org.apache.commons.math.linear.EigenDecompositionImpl l: 846, susp 0.9928977272727273
Suspicious: 64 line org.apache.commons.math.linear.EigenDecompositionImpl l: 847, susp 0.9928977272727273
Suspicious: 65 line org.apache.commons.math.linear.EigenDecompositionImpl l: 848, susp 0.9928977272727273
Suspicious: 66 line org.apache.commons.math.linear.EigenDecompositionImpl l: 849, susp 0.9928977272727273
Suspicious: 67 line org.apache.commons.math.linear.EigenDecompositionImpl l: 850, susp 0.9928977272727273
Suspicious: 68 line org.apache.commons.math.linear.EigenDecompositionImpl l: 851, susp 0.9928977272727273
Suspicious: 69 line org.apache.commons.math.linear.EigenDecompositionImpl l: 854, susp 0.9928977272727273
Suspicious: 70 line org.apache.commons.math.linear.EigenDecompositionImpl l: 855, susp 0.9928977272727273
Suspicious: 71 line org.apache.commons.math.linear.EigenDecompositionImpl l: 856, susp 0.9928977272727273
Suspicious: 72 line org.apache.commons.math.linear.EigenDecompositionImpl l: 859, susp 0.9928977272727273
Suspicious: 73 line org.apache.commons.math.linear.EigenDecompositionImpl l: 860, susp 0.9928977272727273
Suspicious: 74 line org.apache.commons.math.linear.EigenDecompositionImpl l: 863, susp 0.9928977272727273
Suspicious: 75 line org.apache.commons.math.linear.EigenDecompositionImpl l: 864, susp 0.9928977272727273
Suspicious: 76 line org.apache.commons.math.linear.EigenDecompositionImpl l: 865, susp 0.9928977272727273
Suspicious: 77 line org.apache.commons.math.linear.EigenDecompositionImpl l: 866, susp 0.9928977272727273
Suspicious: 78 line org.apache.commons.math.linear.EigenDecompositionImpl l: 867, susp 0.9928977272727273
Suspicious: 79 line org.apache.commons.math.linear.EigenDecompositionImpl l: 868, susp 0.9928977272727273
Suspicious: 80 line org.apache.commons.math.linear.EigenDecompositionImpl l: 869, susp 0.9928977272727273
Suspicious: 81 line org.apache.commons.math.linear.EigenDecompositionImpl l: 873, susp 0.9928977272727273
Suspicious: 82 line org.apache.commons.math.linear.EigenDecompositionImpl l: 874, susp 0.9928977272727273
Suspicious: 83 line org.apache.commons.math.linear.EigenDecompositionImpl l: 875, susp 0.9928977272727273
Suspicious: 84 line org.apache.commons.math.linear.EigenDecompositionImpl l: 877, susp 0.9928977272727273
Suspicious: 85 line org.apache.commons.math.linear.EigenDecompositionImpl l: 878, susp 0.9928977272727273
Suspicious: 86 line org.apache.commons.math.linear.EigenDecompositionImpl l: 880, susp 0.9928977272727273
Suspicious: 87 line org.apache.commons.math.linear.EigenDecompositionImpl l: 883, susp 0.9928977272727273
Suspicious: 88 line org.apache.commons.math.linear.EigenDecompositionImpl l: 885, susp 0.9928977272727273
Suspicious: 89 line org.apache.commons.math.linear.EigenDecompositionImpl l: 886, susp 0.9928977272727273
Suspicious: 90 line org.apache.commons.math.linear.EigenDecompositionImpl l: 887, susp 0.9928977272727273
Suspicious: 91 line org.apache.commons.math.linear.EigenDecompositionImpl l: 888, susp 0.9928977272727273
Suspicious: 92 line org.apache.commons.math.linear.EigenDecompositionImpl l: 893, susp 0.9928977272727273
Suspicious: 93 line org.apache.commons.math.linear.EigenDecompositionImpl l: 894, susp 0.9928977272727273
Suspicious: 94 line org.apache.commons.math.linear.EigenDecompositionImpl l: 898, susp 0.9928977272727273
Suspicious: 95 line org.apache.commons.math.linear.EigenDecompositionImpl l: 936, susp 0.9928977272727273
Suspicious: 96 line org.apache.commons.math.linear.EigenDecompositionImpl l: 937, susp 0.9928977272727273
Suspicious: 97 line org.apache.commons.math.linear.EigenDecompositionImpl l: 940, susp 0.9928977272727273
Suspicious: 98 line org.apache.commons.math.linear.EigenDecompositionImpl l: 941, susp 0.9928977272727273
Suspicious: 99 line org.apache.commons.math.linear.EigenDecompositionImpl l: 942, susp 0.9928977272727273
Suspicious: 100 line org.apache.commons.math.linear.EigenDecompositionImpl l: 946, susp 0.9928977272727273
Suspicious: 101 line org.apache.commons.math.linear.EigenDecompositionImpl l: 951, susp 0.9928977272727273
Suspicious: 102 line org.apache.commons.math.linear.EigenDecompositionImpl l: 952, susp 0.9928977272727273
Suspicious: 103 line org.apache.commons.math.linear.EigenDecompositionImpl l: 953, susp 0.9928977272727273
Suspicious: 104 line org.apache.commons.math.linear.EigenDecompositionImpl l: 954, susp 0.9928977272727273
Suspicious: 105 line org.apache.commons.math.linear.EigenDecompositionImpl l: 955, susp 0.9928977272727273
Suspicious: 106 line org.apache.commons.math.linear.EigenDecompositionImpl l: 960, susp 0.9928977272727273
Suspicious: 107 line org.apache.commons.math.linear.EigenDecompositionImpl l: 962, susp 0.9928977272727273
Suspicious: 108 line org.apache.commons.math.linear.EigenDecompositionImpl l: 963, susp 0.9928977272727273
Suspicious: 109 line org.apache.commons.math.linear.EigenDecompositionImpl l: 964, susp 0.9928977272727273
Suspicious: 110 line org.apache.commons.math.linear.EigenDecompositionImpl l: 965, susp 0.9928977272727273
Suspicious: 111 line org.apache.commons.math.linear.EigenDecompositionImpl l: 970, susp 0.9928977272727273
Suspicious: 112 line org.apache.commons.math.linear.EigenDecompositionImpl l: 973, susp 0.9928977272727273
Suspicious: 113 line org.apache.commons.math.linear.EigenDecompositionImpl l: 977, susp 0.9928977272727273
Suspicious: 114 line org.apache.commons.math.linear.EigenDecompositionImpl l: 992, susp 0.9928977272727273
Suspicious: 115 line org.apache.commons.math.linear.EigenDecompositionImpl l: 995, susp 0.9928977272727273
Suspicious: 116 line org.apache.commons.math.linear.EigenDecompositionImpl l: 996, susp 0.9928977272727273
Suspicious: 117 line org.apache.commons.math.linear.EigenDecompositionImpl l: 998, susp 0.9928977272727273
Suspicious: 118 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1003, susp 0.9928977272727273
Suspicious: 119 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1005, susp 0.9928977272727273
Suspicious: 120 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1011, susp 0.9928977272727273
Suspicious: 121 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1012, susp 0.9928977272727273
Suspicious: 122 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1014, susp 0.9928977272727273
Suspicious: 123 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1043, susp 0.9928977272727273
Suspicious: 124 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1047, susp 0.9928977272727273
Suspicious: 125 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1049, susp 0.9928977272727273
Suspicious: 126 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1052, susp 0.9928977272727273
Suspicious: 127 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1053, susp 0.9928977272727273
Suspicious: 128 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1066, susp 0.9928977272727273
Suspicious: 129 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1067, susp 0.9928977272727273
Suspicious: 130 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1068, susp 0.9928977272727273
Suspicious: 131 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1071, susp 0.9928977272727273
Suspicious: 132 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1074, susp 0.9928977272727273
Suspicious: 133 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1077, susp 0.9928977272727273
Suspicious: 134 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1080, susp 0.9928977272727273
Suspicious: 135 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1082, susp 0.9928977272727273
Suspicious: 136 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1083, susp 0.9928977272727273
Suspicious: 137 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1118, susp 0.9928977272727273
Suspicious: 138 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1120, susp 0.9928977272727273
Suspicious: 139 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1132, susp 0.9928977272727273
Suspicious: 140 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1145, susp 0.9928977272727273
Suspicious: 141 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1157, susp 0.9928977272727273
Suspicious: 142 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1158, susp 0.9928977272727273
Suspicious: 143 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1159, susp 0.9928977272727273
Suspicious: 144 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1160, susp 0.9928977272727273
Suspicious: 145 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1161, susp 0.9928977272727273
Suspicious: 146 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1162, susp 0.9928977272727273
Suspicious: 147 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1163, susp 0.9928977272727273
Suspicious: 148 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1167, susp 0.9928977272727273
Suspicious: 149 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1168, susp 0.9928977272727273
Suspicious: 150 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1169, susp 0.9928977272727273
Suspicious: 151 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1170, susp 0.9928977272727273
Suspicious: 152 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1171, susp 0.9928977272727273
Suspicious: 153 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1172, susp 0.9928977272727273
Suspicious: 154 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1175, susp 0.9928977272727273
Suspicious: 155 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1176, susp 0.9928977272727273
Suspicious: 156 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1177, susp 0.9928977272727273
Suspicious: 157 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1179, susp 0.9928977272727273
Suspicious: 158 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1180, susp 0.9928977272727273
Suspicious: 159 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1181, susp 0.9928977272727273
Suspicious: 160 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1183, susp 0.9928977272727273
Suspicious: 161 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1186, susp 0.9928977272727273
Suspicious: 162 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1187, susp 0.9928977272727273
Suspicious: 163 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1188, susp 0.9928977272727273
Suspicious: 164 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1190, susp 0.9928977272727273
Suspicious: 165 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1194, susp 0.9928977272727273
Suspicious: 166 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1197, susp 0.9928977272727273
Suspicious: 167 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1198, susp 0.9928977272727273
Suspicious: 168 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1199, susp 0.9928977272727273
Suspicious: 169 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1201, susp 0.9928977272727273
Suspicious: 170 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1202, susp 0.9928977272727273
Suspicious: 171 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1203, susp 0.9928977272727273
Suspicious: 172 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1205, susp 0.9928977272727273
Suspicious: 173 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1208, susp 0.9928977272727273
Suspicious: 174 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1209, susp 0.9928977272727273
Suspicious: 175 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1210, susp 0.9928977272727273
Suspicious: 176 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1212, susp 0.9928977272727273
Suspicious: 177 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1216, susp 0.9928977272727273
Suspicious: 178 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1218, susp 0.9928977272727273
Suspicious: 179 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1230, susp 0.9928977272727273
Suspicious: 180 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1231, susp 0.9928977272727273
Suspicious: 181 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1232, susp 0.9928977272727273
Suspicious: 182 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1233, susp 0.9928977272727273
Suspicious: 183 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1234, susp 0.9928977272727273
Suspicious: 184 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1235, susp 0.9928977272727273
Suspicious: 185 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1238, susp 0.9928977272727273
Suspicious: 186 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1253, susp 0.9928977272727273
Suspicious: 187 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1254, susp 0.9928977272727273
Suspicious: 188 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1255, susp 0.9928977272727273
Suspicious: 189 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1256, susp 0.9928977272727273
Suspicious: 190 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1257, susp 0.9928977272727273
Suspicious: 191 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1258, susp 0.9928977272727273
Suspicious: 192 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1259, susp 0.9928977272727273
Suspicious: 193 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1260, susp 0.9928977272727273
Suspicious: 194 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1261, susp 0.9928977272727273
Suspicious: 195 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1263, susp 0.9928977272727273
Suspicious: 196 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1273, susp 0.9928977272727273
Suspicious: 197 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1274, susp 0.9928977272727273
Suspicious: 198 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1275, susp 0.9928977272727273
Suspicious: 199 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1276, susp 0.9928977272727273
Suspicious: 200 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1278, susp 0.9928977272727273
Suspicious: 201 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1279, susp 0.9928977272727273
Suspicious: 202 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1280, susp 0.9928977272727273
Suspicious: 203 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1281, susp 0.9928977272727273
Suspicious: 204 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1282, susp 0.9928977272727273
Suspicious: 205 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1283, susp 0.9928977272727273
Suspicious: 206 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1284, susp 0.9928977272727273
Suspicious: 207 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1285, susp 0.9928977272727273
Suspicious: 208 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1288, susp 0.9928977272727273
Suspicious: 209 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1289, susp 0.9928977272727273
Suspicious: 210 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1290, susp 0.9928977272727273
Suspicious: 211 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1291, susp 0.9928977272727273
Suspicious: 212 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1292, susp 0.9928977272727273
Suspicious: 213 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1293, susp 0.9928977272727273
Suspicious: 214 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1294, susp 0.9928977272727273
Suspicious: 215 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1299, susp 0.9928977272727273
Suspicious: 216 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1300, susp 0.9928977272727273
Suspicious: 217 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1301, susp 0.9928977272727273
Suspicious: 218 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1302, susp 0.9928977272727273
Suspicious: 219 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1303, susp 0.9928977272727273
Suspicious: 220 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1304, susp 0.9928977272727273
Suspicious: 221 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1305, susp 0.9928977272727273
Suspicious: 222 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1306, susp 0.9928977272727273
Suspicious: 223 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1308, susp 0.9928977272727273
Suspicious: 224 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1309, susp 0.9928977272727273
Suspicious: 225 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1310, susp 0.9928977272727273
Suspicious: 226 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1311, susp 0.9928977272727273
Suspicious: 227 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1312, susp 0.9928977272727273
Suspicious: 228 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1313, susp 0.9928977272727273
Suspicious: 229 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1314, susp 0.9928977272727273
Suspicious: 230 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1316, susp 0.9928977272727273
Suspicious: 231 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1317, susp 0.9928977272727273
Suspicious: 232 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1319, susp 0.9928977272727273
Suspicious: 233 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1330, susp 0.9928977272727273
Suspicious: 234 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1331, susp 0.9928977272727273
Suspicious: 235 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1332, susp 0.9928977272727273
Suspicious: 236 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1334, susp 0.9928977272727273
Suspicious: 237 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1335, susp 0.9928977272727273
Suspicious: 238 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1336, susp 0.9928977272727273
Suspicious: 239 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1337, susp 0.9928977272727273
Suspicious: 240 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1342, susp 0.9928977272727273
Suspicious: 241 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1344, susp 0.9928977272727273
Suspicious: 242 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1345, susp 0.9928977272727273
Suspicious: 243 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1346, susp 0.9928977272727273
Suspicious: 244 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1347, susp 0.9928977272727273
Suspicious: 245 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1351, susp 0.9928977272727273
Suspicious: 246 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1352, susp 0.9928977272727273
Suspicious: 247 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1377, susp 0.9928977272727273
Suspicious: 248 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1378, susp 0.9928977272727273
Suspicious: 249 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1379, susp 0.9928977272727273
Suspicious: 250 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1380, susp 0.9928977272727273
Suspicious: 251 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1381, susp 0.9928977272727273
Suspicious: 252 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1382, susp 0.9928977272727273
Suspicious: 253 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1387, susp 0.9928977272727273
Suspicious: 254 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1389, susp 0.9928977272727273
Suspicious: 255 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1390, susp 0.9928977272727273
Suspicious: 256 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1391, susp 0.9928977272727273
Suspicious: 257 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1392, susp 0.9928977272727273
Suspicious: 258 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1396, susp 0.9928977272727273
Suspicious: 259 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1398, susp 0.9928977272727273
Suspicious: 260 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1399, susp 0.9928977272727273
Suspicious: 261 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1400, susp 0.9928977272727273
Suspicious: 262 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1401, susp 0.9928977272727273
Suspicious: 263 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1402, susp 0.9928977272727273
Suspicious: 264 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1407, susp 0.9928977272727273
Suspicious: 265 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1409, susp 0.9928977272727273
Suspicious: 266 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1410, susp 0.9928977272727273
Suspicious: 267 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1411, susp 0.9928977272727273
Suspicious: 268 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1412, susp 0.9928977272727273
Suspicious: 269 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1416, susp 0.9928977272727273
Suspicious: 270 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1418, susp 0.9928977272727273
Suspicious: 271 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1419, susp 0.9928977272727273
Suspicious: 272 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1421, susp 0.9928977272727273
Suspicious: 273 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1432, susp 0.9928977272727273
Suspicious: 274 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1433, susp 0.9928977272727273
Suspicious: 275 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1434, susp 0.9928977272727273
Suspicious: 276 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1438, susp 0.9928977272727273
Suspicious: 277 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1444, susp 0.9928977272727273
Suspicious: 278 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1445, susp 0.9928977272727273
Suspicious: 279 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1448, susp 0.9928977272727273
Suspicious: 280 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1450, susp 0.9928977272727273
Suspicious: 281 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1451, susp 0.9928977272727273
Suspicious: 282 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1452, susp 0.9928977272727273
Suspicious: 283 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1454, susp 0.9928977272727273
Suspicious: 284 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1456, susp 0.9928977272727273
Suspicious: 285 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1457, susp 0.9928977272727273
Suspicious: 286 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1458, susp 0.9928977272727273
Suspicious: 287 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1459, susp 0.9928977272727273
Suspicious: 288 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1460, susp 0.9928977272727273
Suspicious: 289 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1472, susp 0.9928977272727273
Suspicious: 290 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1526, susp 0.9928977272727273
Suspicious: 291 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1672, susp 0.9928977272727273
Suspicious: 292 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1682, susp 0.9928977272727273
Suspicious: 293 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1683, susp 0.9928977272727273
Suspicious: 294 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1684, susp 0.9928977272727273
Suspicious: 295 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1685, susp 0.9928977272727273
Suspicious: 296 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1686, susp 0.9928977272727273
Suspicious: 297 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1687, susp 0.9928977272727273
Suspicious: 298 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1688, susp 0.9928977272727273
Suspicious: 299 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1689, susp 0.9928977272727273
Suspicious: 300 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1690, susp 0.9928977272727273
Suspicious: 301 line org.apache.commons.math.linear.EigenDecompositionImpl l: 1692, susp 0.9928977272727273
Suspicious: 302 line org.apache.commons.math.linear.EigenDecompositionImpl l: 581, susp 0.9845070422535211
Suspicious: 303 line org.apache.commons.math.linear.EigenDecompositionImpl l: 582, susp 0.9845070422535211
Suspicious: 304 line org.apache.commons.math.linear.EigenDecompositionImpl l: 583, susp 0.9845070422535211
Suspicious: 305 line org.apache.commons.math.linear.EigenDecompositionImpl l: 584, susp 0.9845070422535211
Suspicious: 306 line org.apache.commons.math.linear.EigenDecompositionImpl l: 585, susp 0.9845070422535211
Suspicious: 307 line org.apache.commons.math.linear.EigenDecompositionImpl l: 587, susp 0.9845070422535211
Suspicious: 308 line org.apache.commons.math.linear.EigenDecompositionImpl l: 588, susp 0.9845070422535211
Suspicious: 309 line org.apache.commons.math.linear.EigenDecompositionImpl l: 589, susp 0.9845070422535211
Suspicious: 310 line org.apache.commons.math.linear.EigenDecompositionImpl l: 591, susp 0.9845070422535211
Suspicious: 311 line org.apache.commons.math.linear.EigenDecompositionImpl l: 592, susp 0.9845070422535211
Suspicious: 312 line org.apache.commons.math.linear.EigenDecompositionImpl l: 593, susp 0.9845070422535211
Suspicious: 313 line org.apache.commons.math.linear.EigenDecompositionImpl l: 697, susp 0.9845070422535211
Suspicious: 314 line org.apache.commons.math.linear.EigenDecompositionImpl l: 698, susp 0.9845070422535211
Suspicious: 315 line org.apache.commons.math.linear.EigenDecompositionImpl l: 699, susp 0.9845070422535211
Suspicious: 316 line org.apache.commons.math.linear.EigenDecompositionImpl l: 700, susp 0.9845070422535211
Suspicious: 317 line org.apache.commons.math.linear.EigenDecompositionImpl l: 237, susp 0.984045049272642
Suspicious: 318 line org.apache.commons.math.linear.EigenDecompositionImpl l: 238, susp 0.984045049272642
Suspicious: 319 line org.apache.commons.math.linear.EigenDecompositionImpl l: 239, susp 0.984045049272642
Suspicious: 320 line org.apache.commons.math.linear.EigenDecompositionImpl l: 240, susp 0.984045049272642
Suspicious: 321 line org.apache.commons.math.linear.EigenDecompositionImpl l: 243, susp 0.984045049272642
Suspicious: 322 line org.apache.commons.math.linear.EigenDecompositionImpl l: 246, susp 0.984045049272642
Suspicious: 323 line org.apache.commons.math.linear.EigenDecompositionImpl l: 571, susp 0.984045049272642
Suspicious: 324 line org.apache.commons.math.linear.EigenDecompositionImpl l: 572, susp 0.984045049272642
Suspicious: 325 line org.apache.commons.math.linear.EigenDecompositionImpl l: 573, susp 0.984045049272642
Suspicious: 326 line org.apache.commons.math.linear.EigenDecompositionImpl l: 574, susp 0.984045049272642
Suspicious: 327 line org.apache.commons.math.linear.EigenDecompositionImpl l: 575, susp 0.984045049272642
Suspicious: 328 line org.apache.commons.math.linear.EigenDecompositionImpl l: 576, susp 0.984045049272642
Suspicious: 329 line org.apache.commons.math.linear.EigenDecompositionImpl l: 578, susp 0.984045049272642
Suspicious: 330 line org.apache.commons.math.linear.EigenDecompositionImpl l: 579, susp 0.984045049272642
Suspicious: 331 line org.apache.commons.math.linear.EigenDecompositionImpl l: 597, susp 0.984045049272642
Suspicious: 332 line org.apache.commons.math.linear.EigenDecompositionImpl l: 598, susp 0.984045049272642
Suspicious: 333 line org.apache.commons.math.linear.EigenDecompositionImpl l: 599, susp 0.984045049272642
Suspicious: 334 line org.apache.commons.math.linear.EigenDecompositionImpl l: 600, susp 0.984045049272642
Suspicious: 335 line org.apache.commons.math.linear.EigenDecompositionImpl l: 601, susp 0.984045049272642
Suspicious: 336 line org.apache.commons.math.linear.EigenDecompositionImpl l: 602, susp 0.984045049272642
Suspicious: 337 line org.apache.commons.math.linear.EigenDecompositionImpl l: 603, susp 0.984045049272642
Suspicious: 338 line org.apache.commons.math.linear.EigenDecompositionImpl l: 605, susp 0.984045049272642
Suspicious: 339 line org.apache.commons.math.linear.EigenDecompositionImpl l: 615, susp 0.984045049272642
Suspicious: 340 line org.apache.commons.math.linear.EigenDecompositionImpl l: 618, susp 0.984045049272642
Suspicious: 341 line org.apache.commons.math.linear.EigenDecompositionImpl l: 619, susp 0.984045049272642
Suspicious: 342 line org.apache.commons.math.linear.EigenDecompositionImpl l: 620, susp 0.984045049272642
Suspicious: 343 line org.apache.commons.math.linear.EigenDecompositionImpl l: 621, susp 0.984045049272642
Suspicious: 344 line org.apache.commons.math.linear.EigenDecompositionImpl l: 622, susp 0.984045049272642
Suspicious: 345 line org.apache.commons.math.linear.EigenDecompositionImpl l: 623, susp 0.984045049272642
Suspicious: 346 line org.apache.commons.math.linear.EigenDecompositionImpl l: 692, susp 0.984045049272642
Suspicious: 347 line org.apache.commons.math.linear.EigenDecompositionImpl l: 695, susp 0.984045049272642
Suspicious: 348 line org.apache.commons.math.linear.EigenDecompositionImpl l: 696, susp 0.984045049272642
Suspicious: 349 line org.apache.commons.math.linear.EigenDecompositionImpl l: 707, susp 0.984045049272642
Suspicious: 350 line org.apache.commons.math.linear.EigenDecompositionImpl l: 708, susp 0.984045049272642
Suspicious: 351 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 254, susp 0.9726345083487941
Suspicious: 352 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 271, susp 0.9676972773419473
Suspicious: 353 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 273, susp 0.9676972773419473
Suspicious: 354 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 274, susp 0.9676972773419473
Suspicious: 355 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 275, susp 0.9676972773419473
Suspicious: 356 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 276, susp 0.9676972773419473
Suspicious: 357 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 277, susp 0.9676972773419473
Suspicious: 358 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 278, susp 0.9676972773419473
Suspicious: 359 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 279, susp 0.9676972773419473
Suspicious: 360 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 280, susp 0.9676972773419473
Suspicious: 361 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 281, susp 0.9676972773419473
Suspicious: 362 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 282, susp 0.9676972773419473
Suspicious: 363 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 283, susp 0.9676972773419473
Suspicious: 364 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 285, susp 0.9676972773419473
Suspicious: 365 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 289, susp 0.9676972773419473
Suspicious: 366 line org.apache.commons.math.linear.AbstractRealMatrix l: 603, susp 0.9632521819016997
Suspicious: 367 line org.apache.commons.math.linear.AbstractRealMatrix l: 604, susp 0.9632521819016997
Suspicious: 368 line org.apache.commons.math.linear.AbstractRealMatrix l: 605, susp 0.9632521819016997
Suspicious: 369 line org.apache.commons.math.linear.AbstractRealMatrix l: 606, susp 0.9632521819016997
Suspicious: 370 line org.apache.commons.math.linear.AbstractRealMatrix$5 l: 606, susp 0.9632521819016997
Suspicious: 371 line org.apache.commons.math.linear.AbstractRealMatrix$5 l: 611, susp 0.9632521819016997
Suspicious: 372 line org.apache.commons.math.linear.AbstractRealMatrix$5 l: 612, susp 0.9632521819016997
Suspicious: 373 line org.apache.commons.math.linear.AbstractRealMatrix l: 616, susp 0.9632521819016997
Suspicious: 374 line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 35, susp 0.9619266055045871
Suspicious: 375 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 482, susp 0.9614855570839064
Suspicious: 376 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 483, susp 0.9614855570839064
Suspicious: 377 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 484, susp 0.9614855570839064
Suspicious: 378 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 485, susp 0.9614855570839064
Suspicious: 379 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 486, susp 0.9614855570839064
Suspicious: 380 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 487, susp 0.9614855570839064
Suspicious: 381 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 488, susp 0.9614855570839064
Suspicious: 382 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 491, susp 0.9614855570839064
Suspicious: 383 line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 30, susp 0.9597254004576659
Suspicious: 384 line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 44, susp 0.9597254004576659
Suspicious: 385 line org.apache.commons.math.linear.AbstractRealMatrix l: 919, susp 0.9597254004576659
Suspicious: 386 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 160, susp 0.9592863677950595
Suspicious: 387 line org.apache.commons.math.linear.MatrixUtils l: 650, susp 0.9584095063985375
Suspicious: 388 line org.apache.commons.math.linear.MatrixUtils l: 656, susp 0.9584095063985375
Suspicious: 389 line org.apache.commons.math.linear.MatrixUtils l: 106, susp 0.9570972158831584
Suspicious: 390 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 130, susp 0.9480108499095841
Suspicious: 391 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 114, susp 0.947582467239042
Suspicious: 392 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 115, susp 0.947582467239042
Suspicious: 393 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 118, susp 0.947582467239042
Suspicious: 394 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 121, susp 0.947582467239042
Suspicious: 395 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 122, susp 0.947582467239042
Suspicious: 396 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 125, susp 0.947582467239042
Suspicious: 397 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 126, susp 0.947582467239042
Suspicious: 398 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 129, susp 0.947582467239042
Suspicious: 399 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 136, susp 0.947582467239042
Suspicious: 400 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 138, susp 0.947582467239042
Suspicious: 401 line org.apache.commons.math.linear.ArrayRealVector l: 77, susp 0.9390953873712495
Suspicious: 402 line org.apache.commons.math.linear.ArrayRealVector l: 78, susp 0.9390953873712495
Suspicious: 403 line org.apache.commons.math.linear.ArrayRealVector l: 79, susp 0.9390953873712495
Suspicious: 404 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 76, susp 0.9274657231313578
Suspicious: 405 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 77, susp 0.9274657231313578
Suspicious: 406 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 78, susp 0.9274657231313578
Suspicious: 407 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 367, susp 0.9266460450729122
Suspicious: 408 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 372, susp 0.9266460450729122
Suspicious: 409 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 373, susp 0.9266460450729122
Suspicious: 410 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 94, susp 0.9254192409532216
Suspicious: 411 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 95, susp 0.9254192409532216
Suspicious: 412 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 96, susp 0.9254192409532216
Suspicious: 413 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 314, susp 0.9250110277900307
Suspicious: 414 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 315, susp 0.9250110277900307
Suspicious: 415 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 320, susp 0.9250110277900307
Suspicious: 416 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 325, susp 0.9250110277900307
Suspicious: 417 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 326, susp 0.9250110277900307
Suspicious: 418 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 330, susp 0.9250110277900307
Suspicious: 419 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 331, susp 0.9250110277900307
Suspicious: 420 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 334, susp 0.9250110277900307
Suspicious: 421 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 335, susp 0.9250110277900307
Suspicious: 422 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 336, susp 0.9250110277900307
Suspicious: 423 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 341, susp 0.9250110277900307
Suspicious: 424 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 343, susp 0.9250110277900307
Suspicious: 425 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 347, susp 0.9250110277900307
Suspicious: 426 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 622, susp 0.9250110277900307
Suspicious: 427 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 623, susp 0.9250110277900307
Suspicious: 428 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 410, susp 0.9050496331463098
Suspicious: 429 line org.apache.commons.math.linear.Array2DRowRealMatrix l: 404, susp 0.9046591889559965
Suspicious: 430 line org.apache.commons.math.linear.AbstractRealMatrix l: 43, susp 0.892340425531915
Suspicious: 431 line org.apache.commons.math.linear.AbstractRealMatrix l: 44, susp 0.892340425531915
Suspicious: 432 line org.apache.commons.math.linear.AbstractRealMatrix l: 45, susp 0.892340425531915
Suspicious: 433 line org.apache.commons.math.linear.AbstractRealMatrix l: 61, susp 0.8755741127348643
Suspicious: 434 line org.apache.commons.math.linear.AbstractRealMatrix l: 66, susp 0.8755741127348643
Suspicious: 435 line org.apache.commons.math.linear.AbstractRealMatrix l: 67, susp 0.8755741127348643
Suspicious: 436 line org.apache.commons.math.linear.AbstractRealMatrix l: 55, susp 0.8748435544430538
Suspicious: 437 line org.apache.commons.math.linear.AbstractRealMatrix l: 56, susp 0.8748435544430538
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1087, susp 0.9990471653168176
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1509, susp 0.9990471653168176
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1544, susp 0.9990471653168176
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1621, susp 0.9990471653168176
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1622, susp 0.9990471653168176
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1625, susp 0.9990471653168176
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1627, susp 0.9990471653168176
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1479, susp 0.9985714285714287
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1480, susp 0.9985714285714287
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1481, susp 0.9985714285714287
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1484, susp 0.9985714285714287
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1485, susp 0.9985714285714287
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1504, susp 0.9985714285714287
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1507, susp 0.9985714285714287
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1508, susp 0.9985714285714287
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1511, susp 0.9985714285714287
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1512, susp 0.9985714285714287
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1513, susp 0.9985714285714287
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1586, susp 0.9985714285714287
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1084, susp 0.9961995249406175
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1093, susp 0.9961995249406175
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1095, susp 0.9961995249406175
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1098, susp 0.9961995249406175
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1100, susp 0.9961995249406175
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1101, susp 0.9961995249406175
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1474, susp 0.9957264957264956
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1475, susp 0.9957264957264956
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1478, susp 0.9957264957264956
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1502, susp 0.9957264957264956
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1503, susp 0.9957264957264956
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1517, susp 0.9957264957264956
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1520, susp 0.9957264957264956
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1521, susp 0.9957264957264956
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1523, susp 0.9957264957264956
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 191, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 193, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 194, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 195, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 198, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 199, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 200, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 201, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 204, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 643, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 644, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 645, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 646, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 647, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 648, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 649, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 651, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 654, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 657, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 826, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 827, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 828, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 829, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 830, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 833, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 839, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 842, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 845, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 846, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 847, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 848, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 849, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 850, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 851, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 854, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 855, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 856, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 859, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 860, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 863, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 864, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 865, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 866, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 867, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 868, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 869, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 873, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 874, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 875, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 877, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 878, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 880, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 883, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 885, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 886, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 887, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 888, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 893, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 894, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 898, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 936, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 937, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 940, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 941, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 942, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 946, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 951, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 952, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 953, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 954, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 955, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 960, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 962, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 963, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 964, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 965, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 970, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 973, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 977, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 992, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 995, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 996, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 998, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1003, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1005, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1011, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1012, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1014, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1043, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1047, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1049, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1052, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1053, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1066, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1067, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1068, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1071, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1074, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1077, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1080, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1082, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1083, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1118, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1120, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1132, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1145, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1157, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1158, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1159, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1160, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1161, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1162, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1163, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1167, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1168, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1169, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1170, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1171, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1172, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1175, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1176, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1177, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1179, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1180, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1181, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1183, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1186, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1187, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1188, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1190, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1194, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1197, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1198, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1199, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1201, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1202, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1203, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1205, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1208, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1209, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1210, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1212, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1216, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1218, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1230, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1231, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1232, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1233, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1234, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1235, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1238, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1253, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1254, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1255, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1256, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1257, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1258, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1259, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1260, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1261, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1263, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1273, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1274, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1275, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1276, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1278, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1279, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1280, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1281, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1282, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1283, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1284, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1285, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1288, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1289, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1290, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1291, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1292, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1293, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1294, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1299, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1300, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1301, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1302, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1303, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1304, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1305, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1306, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1308, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1309, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1310, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1311, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1312, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1313, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1314, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1316, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1317, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1319, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1330, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1331, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1332, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1334, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1335, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1336, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1337, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1342, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1344, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1345, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1346, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1347, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1351, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1352, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1377, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1378, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1379, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1380, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1381, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1382, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1387, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1389, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1390, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1391, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1392, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1396, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1398, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1399, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1400, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1401, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1402, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1407, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1409, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1410, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1411, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1412, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1416, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1418, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1419, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1421, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1432, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1433, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1434, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1438, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1444, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1445, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1448, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1450, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1451, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1452, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1454, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1456, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1457, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1458, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1459, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1460, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1472, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1526, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1672, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1682, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1683, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1684, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1685, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1686, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1687, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1688, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1689, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1690, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 1692, susp 0.9928977272727273
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 581, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 582, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 583, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 584, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 585, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 587, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 588, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 589, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 591, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 592, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 593, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 697, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 698, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 699, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 700, susp 0.9845070422535211
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 237, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 238, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 239, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 240, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 243, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 246, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 571, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 572, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 573, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 574, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 575, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 576, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 578, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 579, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 597, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 598, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 599, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 600, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 601, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 602, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 603, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 605, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 615, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 618, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 619, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 620, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 621, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 622, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 623, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 692, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 695, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 696, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 707, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.EigenDecompositionImpl l: 708, susp 0.984045049272642
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 254, susp 0.9726345083487941
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 271, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 273, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 274, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 275, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 276, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 277, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 278, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 279, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 280, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 281, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 282, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 283, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 285, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 289, susp 0.9676972773419473
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 603, susp 0.9632521819016997
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 604, susp 0.9632521819016997
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 605, susp 0.9632521819016997
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 606, susp 0.9632521819016997
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 606, susp 0.9632521819016997
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 611, susp 0.9632521819016997
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 612, susp 0.9632521819016997
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 616, susp 0.9632521819016997
Suspicious:  line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 35, susp 0.9619266055045871
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 482, susp 0.9614855570839064
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 483, susp 0.9614855570839064
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 484, susp 0.9614855570839064
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 485, susp 0.9614855570839064
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 486, susp 0.9614855570839064
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 487, susp 0.9614855570839064
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 488, susp 0.9614855570839064
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 491, susp 0.9614855570839064
Suspicious:  line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 30, susp 0.9597254004576659
Suspicious:  line org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor l: 44, susp 0.9597254004576659
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 919, susp 0.9597254004576659
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 160, susp 0.9592863677950595
Suspicious:  line org.apache.commons.math.linear.MatrixUtils l: 650, susp 0.9584095063985375
Suspicious:  line org.apache.commons.math.linear.MatrixUtils l: 656, susp 0.9584095063985375
Suspicious:  line org.apache.commons.math.linear.MatrixUtils l: 106, susp 0.9570972158831584
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 130, susp 0.9480108499095841
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 114, susp 0.947582467239042
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 115, susp 0.947582467239042
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 118, susp 0.947582467239042
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 121, susp 0.947582467239042
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 122, susp 0.947582467239042
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 125, susp 0.947582467239042
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 126, susp 0.947582467239042
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 129, susp 0.947582467239042
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 136, susp 0.947582467239042
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 138, susp 0.947582467239042
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 77, susp 0.9390953873712495
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 78, susp 0.9390953873712495
Suspicious:  line org.apache.commons.math.linear.ArrayRealVector l: 79, susp 0.9390953873712495
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 76, susp 0.9274657231313578
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 77, susp 0.9274657231313578
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 78, susp 0.9274657231313578
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 367, susp 0.9266460450729122
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 372, susp 0.9266460450729122
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 373, susp 0.9266460450729122
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 94, susp 0.9254192409532216
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 95, susp 0.9254192409532216
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 96, susp 0.9254192409532216
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 314, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 315, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 320, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 325, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 326, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 330, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 331, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 334, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 335, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 336, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 341, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 343, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 347, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 622, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 623, susp 0.9250110277900307
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 410, susp 0.9050496331463098
Suspicious:  line org.apache.commons.math.linear.Array2DRowRealMatrix l: 404, susp 0.9046591889559965
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 43, susp 0.892340425531915
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 44, susp 0.892340425531915
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 45, susp 0.892340425531915
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 61, susp 0.8755741127348643
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 66, susp 0.8755741127348643
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 67, susp 0.8755741127348643
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 55, susp 0.8748435544430538
Suspicious:  line org.apache.commons.math.linear.AbstractRealMatrix l: 56, susp 0.8748435544430538
Executing time Fault localization: 70 sec
Setting up the max to 702320 milliseconds (702 sec)
---- Initial suspicious size: 437
Creating variant 1
--ModifPoint:CtReturnImpl, suspValue 0.9990471653168176, line 1509, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9990471653168176, line 1544, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9990471653168176, line 1621, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9990471653168176, line 1622, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9990471653168176, line 1625, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9985714285714287, line 1479, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9985714285714287, line 1480, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9985714285714287, line 1481, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9985714285714287, line 1484, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9985714285714287, line 1485, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9985714285714287, line 1504, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9985714285714287, line 1507, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9985714285714287, line 1508, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9985714285714287, line 1511, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9985714285714287, line 1512, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9985714285714287, line 1513, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9961995249406175, line 1084, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9961995249406175, line 1093, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9961995249406175, line 1095, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9961995249406175, line 1098, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9961995249406175, line 1100, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9961995249406175, line 1101, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9957264957264956, line 1474, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9957264957264956, line 1475, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9957264957264956, line 1478, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9957264957264956, line 1502, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9957264957264956, line 1503, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9957264957264956, line 1517, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9957264957264956, line 1520, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9957264957264956, line 1521, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9957264957264956, line 1523, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 193, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 194, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 195, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 198, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 199, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 200, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 201, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 204, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 826, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 827, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 828, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 829, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9928977272727273, line 830, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 833, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9928977272727273, line 839, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9928977272727273, line 842, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 845, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 846, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 847, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 848, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 849, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 850, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 851, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 854, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 855, file EigenDecompositionImpl.java
--ModifPoint:CtWhileImpl, suspValue 0.9928977272727273, line 856, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 859, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 860, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 863, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 864, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 865, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 866, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 867, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 868, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 869, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 873, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 874, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 875, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 877, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 878, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 880, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 883, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 885, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 886, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 887, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 888, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 893, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 894, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 898, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 936, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 937, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 940, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 941, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 942, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9928977272727273, line 946, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 951, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 952, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 953, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 954, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 955, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 960, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 962, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 963, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9928977272727273, line 964, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 970, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 973, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 992, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 995, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 996, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 998, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1003, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1005, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1011, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9928977272727273, line 1012, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1014, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1043, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1049, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1052, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1053, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1066, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9928977272727273, line 1071, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 1074, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9928977272727273, line 1077, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1080, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9928977272727273, line 1082, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9928977272727273, line 1083, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.9928977272727273, line 1118, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9928977272727273, line 1120, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1132, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9928977272727273, line 1145, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1157, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1158, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1159, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1160, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 1161, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1162, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1163, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1167, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1168, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1169, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1170, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1172, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1175, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1176, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 1177, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1179, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1180, file EigenDecompositionImpl.java
--ModifPoint:CtBreakImpl, suspValue 0.9928977272727273, line 1183, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1186, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1187, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1188, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1190, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1194, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1197, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1198, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 1199, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1201, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1202, file EigenDecompositionImpl.java
--ModifPoint:CtBreakImpl, suspValue 0.9928977272727273, line 1205, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1208, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1209, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1210, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1212, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1216, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9928977272727273, line 1218, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1230, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1231, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 1232, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1233, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1234, file EigenDecompositionImpl.java
--ModifPoint:CtUnaryOperatorImpl, suspValue 0.9928977272727273, line 1235, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9928977272727273, line 1238, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1253, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1254, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 1255, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1256, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1257, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1258, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1259, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1260, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1261, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1273, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1274, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1275, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1276, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1278, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 1279, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1280, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1281, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1282, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1283, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1284, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1285, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 1288, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1289, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1290, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1291, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1292, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1293, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1294, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1299, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1300, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1301, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1302, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1303, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1304, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1305, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1306, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1308, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1309, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1310, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1311, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1312, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1313, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1314, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1316, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1317, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1330, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1331, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1332, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1334, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.9928977272727273, line 1335, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1336, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1337, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1342, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1344, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1345, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9928977272727273, line 1346, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1351, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1352, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1377, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1378, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1379, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1380, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1381, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1382, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1387, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1389, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1390, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1391, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1396, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1398, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1399, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1400, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1401, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1402, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1407, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1409, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1410, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1411, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1416, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1418, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1419, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1432, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1433, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1434, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1438, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1444, file EigenDecompositionImpl.java
--ModifPoint:CtSwitchImpl, suspValue 0.9928977272727273, line 1445, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1450, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1451, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1452, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1454, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1456, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1457, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1458, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1459, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1460, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1526, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9928977272727273, line 1682, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9928977272727273, line 1683, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1684, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9928977272727273, line 1685, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1686, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9928977272727273, line 1688, file EigenDecompositionImpl.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9928977272727273, line 1689, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9928977272727273, line 1690, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9845070422535211, line 581, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9845070422535211, line 582, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9845070422535211, line 583, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9845070422535211, line 584, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9845070422535211, line 585, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9845070422535211, line 587, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9845070422535211, line 588, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9845070422535211, line 589, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9845070422535211, line 591, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9845070422535211, line 592, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9845070422535211, line 593, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9845070422535211, line 697, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9845070422535211, line 698, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9845070422535211, line 699, file EigenDecompositionImpl.java
--ModifPoint:CtIfImpl, suspValue 0.9845070422535211, line 700, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.984045049272642, line 237, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.984045049272642, line 238, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.984045049272642, line 239, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.984045049272642, line 240, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.984045049272642, line 243, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.984045049272642, line 246, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 571, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 572, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 573, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.984045049272642, line 574, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.984045049272642, line 575, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 576, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 578, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.984045049272642, line 579, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 597, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 598, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.984045049272642, line 599, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.984045049272642, line 600, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 601, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.984045049272642, line 602, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.984045049272642, line 603, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 615, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.984045049272642, line 618, file EigenDecompositionImpl.java
--ModifPoint:CtAssignmentImpl, suspValue 0.984045049272642, line 619, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 620, file EigenDecompositionImpl.java
--ModifPoint:CtForEachImpl, suspValue 0.984045049272642, line 621, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 622, file EigenDecompositionImpl.java
--ModifPoint:CtSwitchImpl, suspValue 0.984045049272642, line 623, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 692, file EigenDecompositionImpl.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.984045049272642, line 695, file EigenDecompositionImpl.java
--ModifPoint:CtForImpl, suspValue 0.984045049272642, line 696, file EigenDecompositionImpl.java
--ModifPoint:CtInvocationImpl, suspValue 0.984045049272642, line 707, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.984045049272642, line 708, file EigenDecompositionImpl.java
--ModifPoint:CtReturnImpl, suspValue 0.9726345083487941, line 254, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9676972773419473, line 271, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9676972773419473, line 273, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9676972773419473, line 274, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9676972773419473, line 275, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9676972773419473, line 276, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9676972773419473, line 277, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9676972773419473, line 278, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9676972773419473, line 279, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9676972773419473, line 280, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9676972773419473, line 281, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9676972773419473, line 282, file Array2DRowRealMatrix.java
--ModifPoint:CtOperatorAssignmentImpl, suspValue 0.9676972773419473, line 283, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9676972773419473, line 285, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9676972773419473, line 289, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9632521819016997, line 603, file AbstractRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9632521819016997, line 604, file AbstractRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9632521819016997, line 605, file AbstractRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9632521819016997, line 606, file AbstractRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9632521819016997, line 606, file AbstractRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9632521819016997, line 611, file AbstractRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9632521819016997, line 616, file AbstractRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9614855570839064, line 482, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9614855570839064, line 483, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9614855570839064, line 484, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9614855570839064, line 485, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9614855570839064, line 486, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9614855570839064, line 487, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9614855570839064, line 488, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9614855570839064, line 491, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9597254004576659, line 44, file DefaultRealMatrixPreservingVisitor.java
--ModifPoint:CtReturnImpl, suspValue 0.9597254004576659, line 919, file AbstractRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9592863677950595, line 160, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9584095063985375, line 650, file MatrixUtils.java
--ModifPoint:CtReturnImpl, suspValue 0.9570972158831584, line 106, file MatrixUtils.java
--ModifPoint:CtIfImpl, suspValue 0.9480108499095841, line 130, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.947582467239042, line 115, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.947582467239042, line 118, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.947582467239042, line 121, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.947582467239042, line 122, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.947582467239042, line 125, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.947582467239042, line 126, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.947582467239042, line 129, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.947582467239042, line 136, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9390953873712495, line 78, file ArrayRealVector.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9274657231313578, line 77, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9266460450729122, line 367, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9254192409532216, line 95, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9250110277900307, line 314, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9250110277900307, line 315, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9250110277900307, line 320, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9250110277900307, line 325, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9250110277900307, line 326, file Array2DRowRealMatrix.java
--ModifPoint:CtLocalVariableImpl, suspValue 0.9250110277900307, line 330, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9250110277900307, line 331, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.9250110277900307, line 334, file Array2DRowRealMatrix.java
--ModifPoint:CtForImpl, suspValue 0.9250110277900307, line 335, file Array2DRowRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.9250110277900307, line 336, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9250110277900307, line 341, file Array2DRowRealMatrix.java
--ModifPoint:CtInvocationImpl, suspValue 0.9250110277900307, line 622, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9050496331463098, line 410, file Array2DRowRealMatrix.java
--ModifPoint:CtReturnImpl, suspValue 0.9046591889559965, line 404, file Array2DRowRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.892340425531915, line 44, file AbstractRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.8755741127348643, line 61, file AbstractRealMatrix.java
--ModifPoint:CtAssignmentImpl, suspValue 0.8755741127348643, line 66, file AbstractRealMatrix.java
--ModifPoint:CtIfImpl, suspValue 0.8748435544430538, line 56, file AbstractRealMatrix.java
Total suspicious from FL: 437,  382
Total ModPoint created: 382
Creating program variant #1, [Variant id: 1, #gens: 382, #ops: 0, parent:-]
Calculating fitness
Calculating fitness for original program variant.
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Test Failing is passing, Executing regression
Executing process: (timeout702secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.stat.data.LotteryTest  org.apache.commons.math.linear.FieldMatrixImplTest  org.apache.commons.math.ode.sampling.StepNormalizerTest  org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest  org.apache.commons.math.geometry.RotationOrderTest  org.apache.commons.math.analysis.solvers.NewtonSolverTest  org.apache.commons.math.estimation.EstimatedParameterTest  org.apache.commons.math.linear.CholeskyDecompositionImplTest  org.apache.commons.math.linear.Array2DRowRealMatrixTest  org.apache.commons.math.linear.SparseRealMatrixTest  org.apache.commons.math.util.OpenIntToFieldTest  org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest  org.apache.commons.math.optimization.fitting.PolynomialFitterTest  org.apache.commons.math.linear.ArrayRealVectorTest  org.apache.commons.math.distribution.HypergeometricDistributionTest  org.apache.commons.math.random.RandomAdaptorTest  org.apache.commons.math.ode.FirstOrderConverterTest  org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest  org.apache.commons.math.stat.inference.TestUtilsTest  org.apache.commons.math.stat.data.LewTest  org.apache.commons.math.distribution.GammaDistributionTest  org.apache.commons.math.stat.descriptive.rank.MedianTest  org.apache.commons.math.distribution.ZipfDistributionTest  org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest  org.apache.commons.math.stat.CertifiedDataTest  org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest  org.apache.commons.math.complex.FrenchComplexFormatTest  org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest  org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest  org.apache.commons.math.DuplicateSampleAbscissaExceptionTest  org.apache.commons.math.estimation.MinpackTest  org.apache.commons.math.genetics.FixedGenerationCountTest  org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest  org.apache.commons.math.fraction.BigFractionFormatTest  org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest  org.apache.commons.math.random.RandomDataTest  org.apache.commons.math.distribution.FDistributionTest  org.apache.commons.math.FunctionEvaluationExceptionTest  org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest  org.apache.commons.math.stat.inference.TTestFactoryTest  org.apache.commons.math.stat.descriptive.moment.SkewnessTest  org.apache.commons.math.special.GammaTest  org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest  org.apache.commons.math.analysis.integration.RombergIntegratorTest  org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest  org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest  org.apache.commons.math.stat.descriptive.SummaryStatisticsTest  org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest  org.apache.commons.math.stat.descriptive.moment.FirstMomentTest  org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest  org.apache.commons.math.complex.ComplexTest  org.apache.commons.math.distribution.BetaDistributionTest  org.apache.commons.math.special.ErfTest  org.apache.commons.math.special.BetaTest  org.apache.commons.math.ode.nonstiff.GillIntegratorTest  org.apache.commons.math.random.EmpiricalDistributionTest  org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest  org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest  org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest  org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest  org.apache.commons.math.random.AbstractRandomGeneratorTest  org.apache.commons.math.fraction.BigFractionFieldTest  org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest  org.apache.commons.math.genetics.GeneticAlgorithmTestBinary  org.apache.commons.math.linear.BiDiagonalTransformerTest  org.apache.commons.math.util.DefaultTransformerTest  org.apache.commons.math.linear.LUDecompositionImplTest  org.apache.commons.math.random.ValueServerTest  org.apache.commons.math.stat.descriptive.moment.MeanTest  org.apache.commons.math.util.BigRealFieldTest  org.apache.commons.math.linear.QRDecompositionImplTest  org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest  org.apache.commons.math.stat.descriptive.moment.VarianceTest  org.apache.commons.math.genetics.OnePointCrossoverTest  org.apache.commons.math.stat.ranking.NaturalRankingTest  org.apache.commons.math.optimization.linear.SimplexSolverTest  org.apache.commons.math.stat.descriptive.moment.FourthMomentTest  org.apache.commons.math.linear.BlockRealMatrixTest  org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest  org.apache.commons.math.random.MersenneTwisterTest  org.apache.commons.math.genetics.RandomKeyTest  org.apache.commons.math.stat.descriptive.summary.ProductTest  org.apache.commons.math.fraction.FractionTest  org.apache.commons.math.util.OpenIntToDoubleHashMapTest  org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest  org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest  org.apache.commons.math.genetics.ChromosomeTest  org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest  org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest  org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest  org.apache.commons.math.geometry.Vector3DTest  org.apache.commons.math.stat.descriptive.rank.MinTest  org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest  org.apache.commons.math.linear.FieldLUDecompositionImplTest  org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest  org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest  org.apache.commons.math.transform.FastHadamardTransformerTest  org.apache.commons.math.optimization.fitting.HarmonicFitterTest  org.apache.commons.math.stat.correlation.PearsonsCorrelationTest  org.apache.commons.math.random.GaussianRandomGeneratorTest  org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest  org.apache.commons.math.linear.FrenchRealVectorFormatTest  org.apache.commons.math.fraction.BigFractionTest  org.apache.commons.math.util.ContinuedFractionTest  org.apache.commons.math.util.TransformerMapTest  org.apache.commons.math.analysis.solvers.BisectionSolverTest  org.apache.commons.math.genetics.BinaryChromosomeTest  org.apache.commons.math.linear.BlockFieldMatrixTest  org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest  org.apache.commons.math.linear.SingularValueDecompositionImplTest  org.apache.commons.math.distribution.TDistributionTest  org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest  org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest  org.apache.commons.math.linear.InvalidMatrixExceptionTest  org.apache.commons.math.distribution.BinomialDistributionTest  org.apache.commons.math.linear.EigenSolverTest  org.apache.commons.math.stat.inference.TTestTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest  org.apache.commons.math.random.UniformRandomGeneratorTest  org.apache.commons.math.stat.descriptive.rank.PercentileTest  org.apache.commons.math.analysis.solvers.RiddersSolverTest  org.apache.commons.math.linear.ArrayFieldVectorTest  org.apache.commons.math.ode.ContinuousOutputModelTest  org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest  org.apache.commons.math.optimization.linear.SimplexTableauTest  org.apache.commons.math.ConvergenceExceptionTest  org.apache.commons.math.util.ResizableDoubleArrayTest  org.apache.commons.math.complex.ComplexFormatTest  org.apache.commons.math.linear.RealMatrixImplTest  org.apache.commons.math.stat.descriptive.summary.SumTest  org.apache.commons.math.linear.SparseFieldVectorTest  org.apache.commons.math.genetics.ElitisticListPopulationTest  org.apache.commons.math.stat.descriptive.summary.SumSqTest  org.apache.commons.math.linear.SparseRealVectorTest  org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest  org.apache.commons.math.linear.EigenDecompositionImplTest  org.apache.commons.math.analysis.integration.SimpsonIntegratorTest  org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest  org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest  org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations  org.apache.commons.math.stat.descriptive.moment.KurtosisTest  org.apache.commons.math.transform.FastFourierTransformerTest  org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest  org.apache.commons.math.distribution.NormalDistributionTest  org.apache.commons.math.distribution.PoissonDistributionTest  org.apache.commons.math.geometry.Vector3DFormatTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest  org.apache.commons.math.genetics.TournamentSelectionTest  org.apache.commons.math.optimization.general.MinpackTest  org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest  org.apache.commons.math.analysis.solvers.BrentSolverTest  org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest  org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest  org.apache.commons.math.estimation.WeightedMeasurementTest  org.apache.commons.math.stat.inference.ChiSquareTestTest  org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest  org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest  org.apache.commons.math.linear.MatrixIndexExceptionTest  org.apache.commons.math.genetics.BinaryMutationTest  org.apache.commons.math.fraction.FractionFormatTest  org.apache.commons.math.distribution.PascalDistributionTest  org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest  org.apache.commons.math.util.MathUtilsTest  org.apache.commons.math.complex.ComplexUtilsTest  org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest  org.apache.commons.math.optimization.direct.MultiDirectionalTest  org.apache.commons.math.genetics.FitnessCachingTest  org.apache.commons.math.linear.BigMatrixImplTest  org.apache.commons.math.stat.inference.ChiSquareFactoryTest  org.apache.commons.math.fraction.FractionFieldTest  org.apache.commons.math.stat.descriptive.InteractionTest  org.apache.commons.math.stat.correlation.CovarianceTest  org.apache.commons.math.optimization.univariate.BrentMinimizerTest  org.apache.commons.math.linear.QRSolverTest  org.apache.commons.math.linear.RealVectorFormatTest  org.apache.commons.math.analysis.solvers.LaguerreSolverTest  org.apache.commons.math.linear.CholeskySolverTest  org.apache.commons.math.distribution.WeibullDistributionTest  org.apache.commons.math.stat.StatUtilsTest  org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest  org.apache.commons.math.analysis.solvers.MullerSolverTest  org.apache.commons.math.linear.TriDiagonalTransformerTest  org.apache.commons.math.distribution.ChiSquareDistributionTest  org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest  org.apache.commons.math.transform.FastSineTransformerTest  org.apache.commons.math.stat.inference.OneWayAnovaTest  org.apache.commons.math.transform.FastCosineTransformerTest  org.apache.commons.math.ArgumentOutsideDomainExceptionTest  org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest  org.apache.commons.math.ode.nonstiff.EulerIntegratorTest  org.apache.commons.math.stat.descriptive.rank.MaxTest  org.apache.commons.math.complex.ComplexFieldTest  org.apache.commons.math.stat.descriptive.ListUnivariateImplTest  org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest  org.apache.commons.math.MaxIterationsExceededExceptionTest  org.apache.commons.math.linear.MatrixUtilsTest  org.apache.commons.math.optimization.direct.NelderMeadTest  org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest  org.apache.commons.math.geometry.RotationTest  org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest  org.apache.commons.math.linear.SingularValueSolverTest  org.apache.commons.math.genetics.RandomKeyMutationTest  org.apache.commons.math.util.BigRealTest  org.apache.commons.math.distribution.ExponentialDistributionTest  org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest  org.apache.commons.math.geometry.FrenchVector3DFormatTest  org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest  org.apache.commons.math.stat.regression.SimpleRegressionTest  org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest  org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest  org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest  org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest  org.apache.commons.math.linear.LUSolverTest  org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest  org.apache.commons.math.MathConfigurationExceptionTest  org.apache.commons.math.estimation.GaussNewtonEstimatorTest  org.apache.commons.math.genetics.ListPopulationTest  org.apache.commons.math.MathExceptionTest  org.apache.commons.math.distribution.CauchyDistributionTest  org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest  org.apache.commons.math.linear.SparseFieldMatrixTest  org.apache.commons.math.stat.descriptive.summary.SumLogTest  org.apache.commons.math.stat.FrequencyTest  org.apache.commons.math.stat.descriptive.moment.SecondMomentTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 2103] ,[]
The original fitness is : 1.0
----------------------------
---Configuration properties
p:lastJUnitVersion= ./examples/libs/junit-4.11.jar
p:alternativecompliancelevel= 8
p:ignoredTestCases= 
p:workingDirectory= /Users/marekmazur/astor/./output_astor
p:manipulatesuper= false
p:validation= process
p:jvm4testexecution= /Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin
p:operatorspace= irr-statements
p:diffcontext= 0
p:binjavafolder= /target/classes/
p:synthesis_depth= 3
p:gzoltartestpackagetoexclude= junit.framework
p:skipfitnessinitialpopulation= false
p:evosuiteresultfolder= evosuite
p:flthreshold= 0
p:regressionforfaultlocalization= true
p:collectonlyusedmethod= false
p:folderDiff= ./diffSolutions
p:preservelinenumbers= true
p:tmax2= 702320
p:tmax1= 10000
p:probagenmutation= false
p:nomodificationconvergence= 100
p:diff_type= relative
p:nolog= False
p:targetelementprocessor= statements
p:srctestfolder= /src/test/
p:forceExecuteRegression= false
p:clusteringfilename= clustering.csv
p:failing= org.apache.commons.math.linear.EigenDecompositionImplTest
p:logtestexecution= false
p:evo_buggy_class= true
p:numberExecutions= 1
p:maxnumbersolutions= 1000000
p:evo_affected_by_op= true
p:population= 1
p:maxCombinationVariableLimit= false
p:savesolution= true
p:javacompliancelevel= 8
p:uniqueoptogen= false
p:gzoltarpackagetonotinstrument= junit.framework
p:projectIdentifier= 
p:modificationpointnavigation= weight
p:stopfirst= true
p:multipointmodification= false
p:elementsToMutate= 10
p:jsonoutputname= astor_output
p:evoDSE= false
p:bintestfolder= /target/test-classes/
p:testbystep= false
p:version-location= ./math-version/
p:gzoltarVersion= 1.7.3
p:locationGzoltarJar= ./lib/
p:reintroduce= PARENTS:ORIGINAL
p:executorjar= ./lib/jtestex7.jar
p:maxGeneration= 1000000
p:max_synthesis_step= 10000
p:projectinfocommand= com.github.tdurieux:project-config-maven-plugin:info
p:maxVarCombination= 1000
p:includeZeros= false
p:maxtime= 60
p:evosuitejar= ./lib/evosuite-master-1.0.4-SNAPSHOT.jar
p:jvmversion= 1.8.0_202
p:commandTrunk= 50000
p:faultlocalization= flacoco
p:resetmodel= true
p:maxsuspcandidates= 1000
p:mode= jgenprog
p:learningdir= 
p:jvm4evosuitetestexecution= /Users/marekmazur/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin
p:filterfaultlocalization= true
p:mutationrate= 1 
p:pathToMVNRepository= 
p:resourcesfolder= /src/main/resources:/src/test/resources:
p:timezone= America/Los_Angeles
p:runjava7code= false
p:evoRunOnBuggyClass= true
p:compiler= fr.inria.astor.core.manipulation.bytecode.compiler.SpoonClassCompiler
p:limitbysuspicious= true
p:logsattemps= true
p:dependenciespath= /Users/marekmazur/astor/examples/libs/junit-4.4.jar
p:packageToInstrument= org.apache.commons
p:skipfaultlocalization= false
p:scope= local
p:transformingredient= false
p:fitnessfunction= fr.inria.astor.core.solutionsearch.population.TestCaseFitnessFunction
p:maxnumvariablesperingredient= 10
p:parsesourcefromoriginal= true
p:pvariantfoldername= variant-
p:savespoonmodelondisk= false
p:srcjavafolder= /src/java/
p:populationcontroller= fr.inria.astor.core.solutionsearch.population.TestCaseBasedFitnessPopulationController
p:ignoreflakyinfl= false
p:cleantemplates= true
p:applyCrossover= false
p:maxmodificationpoints= 1000
p:duplicateingredientsinspace= false
p:metid= 0
p:continuewhenmodelfail= true
p:saveall= false
p:seed= 10
p:savecompletepatched= true
p:resetoperations= false
p:keepcomments= true
p:processoutputinfile= false
p:location= /Users/marekmazur/astor/defects4j/math-81
p:probabilistictransformation= true
p:overridemaxtime= true
p:outputjsonresult= true
p:allpoints= false
p:antipattern= false
p:bugId= 280
p:evosuitetimeout= 120
p:maxtimefactor= 10
p:nrPlaceholders= 1
p:forcesubprocesskilling= false
----------------------------
----Starting Solution Search
----------Running generation: 1, population size: 1

***** Generation 1 : 0
**Parent Variant: [Variant id: 1, #gens: 382, #ops: 0, parent:-]

--Child created id: 2
--Creating new operations for variant [Variant id: 2, #gens: 382, #ops: 0, parent:1]
---analyzing modificationPoint position: 276
---modifPoint 0 not mutation generated in  final double upper = dCurrent + radius
---analyzing modificationPoint position: 97
location: EigenDecompositionImpl.java992
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `g = 0.0 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 2, #gens: 381, #ops: 1, parent:1] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 2
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-2/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(1): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `g = 0.0 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (1(f=1.0), 2(f=1.0), )
Selected to next generation: IDs2--> (1(f=1.0), )
----------Running generation: 2, population size: 1

***** Generation 2 : 0
**Parent Variant: [Variant id: 3, #gens: 382, #ops: 0, parent:-]

--Child created id: 4
--Creating new operations for variant [Variant id: 4, #gens: 382, #ops: 0, parent:3]
---analyzing modificationPoint position: 341
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  for (int i = 0; i < rows; ++i) { 	final double[] rowI = data[i]; 	for (int j = 0; j < columns; ++j) [...]
---analyzing modificationPoint position: 182
location: EigenDecompositionImpl.java1284
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4 - 1] * tmp ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 4, #gens: 381, #ops: 1, parent:3] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 4
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-4/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(2): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4 - 1] * tmp ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (3(f=1.0), 4(f=8.0), )
Selected to next generation: IDs2--> (3(f=1.0), )
----------Running generation: 3, population size: 1

***** Generation 3 : 0
**Parent Variant: [Variant id: 5, #gens: 382, #ops: 0, parent:-]

--Child created id: 6
--Creating new operations for variant [Variant id: 6, #gens: 382, #ops: 0, parent:5]
---analyzing modificationPoint position: 307
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java620
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int begin = 0 ` -topatch--> `tType = -10` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 620, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int begin = 0 ` -topatch--> `tType = -10` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 6, #gens: 383, #ops: 1, parent:5] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 6, errors: [EigenDecompositionImpl.java:1636: error: illegal start of expression
	 * Compute splitting points.
	 ^, EigenDecompositionImpl.java:1636: error: ';' expected
	 * Compute splitting points.
	          ^, EigenDecompositionImpl.java:1636: error: ';' expected
	 * Compute splitting points.
	                           ^, EigenDecompositionImpl.java:1638: error: <identifier> expected
	 * @return list of indices after matrix can be split
	    ^, EigenDecompositionImpl.java:1638: error: ';' expected
	 * @return list of indices after matrix can be split
	               ^, EigenDecompositionImpl.java:1638: error: ';' expected
	 * @return list of indices after matrix can be split
	                          ^, EigenDecompositionImpl.java:1638: error: ';' expected
	 * @return list of indices after matrix can be split
	                                       ^, EigenDecompositionImpl.java:1638: error: ';' expected
	 * @return list of indices after matrix can be split
	                                              ^, EigenDecompositionImpl.java:1639: error: illegal start of expression
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	  ^, EigenDecompositionImpl.java:1639: error: illegal start of expression
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	^, EigenDecompositionImpl.java:1639: error: ';' expected
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	                                                       ^, EigenDecompositionImpl.java:1640: error: illegal start of expression
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:1640: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	       ^, EigenDecompositionImpl.java:1640: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	                     ^, EigenDecompositionImpl.java:1640: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	                             ^, EigenDecompositionImpl.java:1640: error: not a statement
	 * Find eigenvalue in a block with 1 row.
	                              ^, EigenDecompositionImpl.java:1640: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	                                  ^, EigenDecompositionImpl.java:1640: error: <identifier> expected
	 * Find eigenvalue in a block with 1 row.
	                                         ^, EigenDecompositionImpl.java:1641: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	      ^, EigenDecompositionImpl.java:1641: error: not a statement
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	 ^, EigenDecompositionImpl.java:1641: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                           ^, EigenDecompositionImpl.java:1641: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                        ^, EigenDecompositionImpl.java:1641: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                           ^, EigenDecompositionImpl.java:1641: error: illegal start of type
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                        ^, EigenDecompositionImpl.java:1641: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                          ^, EigenDecompositionImpl.java:1643: error: illegal start of expression
	 * @param index
	 ^, EigenDecompositionImpl.java:1643: error: illegal start of expression
	 * @param index
	   ^, EigenDecompositionImpl.java:1644: error: not a statement
	 * 		index of the first row of the block
	 ^, EigenDecompositionImpl.java:1644: error: ';' expected
	 * 		index of the first row of the block
	   		     ^, EigenDecompositionImpl.java:1644: error: ';' expected
	 * 		index of the first row of the block
	   		            ^, EigenDecompositionImpl.java:1644: error: ';' expected
	 * 		index of the first row of the block
	   		                      ^, EigenDecompositionImpl.java:1644: error: ';' expected
	 * 		index of the first row of the block
	   		                             ^, EigenDecompositionImpl.java:1645: error: illegal start of expression
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	  ^, EigenDecompositionImpl.java:1645: error: illegal start of expression
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	^, EigenDecompositionImpl.java:1645: error: illegal start of expression
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	        ^, EigenDecompositionImpl.java:1645: error: ';' expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                             ^, EigenDecompositionImpl.java:1645: error: ';' expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                             ^, EigenDecompositionImpl.java:1653: error: illegal start of expression
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	^, EigenDecompositionImpl.java:1653: error: illegal start of expression
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	        ^, EigenDecompositionImpl.java:1653: error: ';' expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                              ^, EigenDecompositionImpl.java:1653: error: ';' expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                              ^, EigenDecompositionImpl.java:1653: error: not a statement
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                                                                     ^, EigenDecompositionImpl.java:1653: error: ';' expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                                                                                            ^, EigenDecompositionImpl.java:1654: error: illegal start of expression
	 * Find realEigenvalues in a block with 3 rows.
	 ^, EigenDecompositionImpl.java:1654: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	       ^, EigenDecompositionImpl.java:1654: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                          ^, EigenDecompositionImpl.java:1654: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                                  ^, EigenDecompositionImpl.java:1654: error: not a statement
	 * Find realEigenvalues in a block with 3 rows.
	                                   ^, EigenDecompositionImpl.java:1654: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                                       ^, EigenDecompositionImpl.java:1654: error: <identifier> expected
	 * Find realEigenvalues in a block with 3 rows.
	                                               ^, EigenDecompositionImpl.java:1655: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	      ^, EigenDecompositionImpl.java:1655: error: not a statement
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	 ^, EigenDecompositionImpl.java:1655: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                           ^, EigenDecompositionImpl.java:1655: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                        ^, EigenDecompositionImpl.java:1655: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                           ^, EigenDecompositionImpl.java:1655: error: illegal start of type
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                        ^, EigenDecompositionImpl.java:1655: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                          ^, EigenDecompositionImpl.java:1657: error: illegal start of expression
	 * @param index
	 ^, EigenDecompositionImpl.java:1657: error: illegal start of expression
	 * @param index
	   ^, EigenDecompositionImpl.java:1658: error: not a statement
	 * 		index of the first row of the block
	 ^, EigenDecompositionImpl.java:1658: error: ';' expected
	 * 		index of the first row of the block
	   		     ^, EigenDecompositionImpl.java:1658: error: ';' expected
	 * 		index of the first row of the block
	   		            ^, EigenDecompositionImpl.java:1658: error: ';' expected
	 * 		index of the first row of the block
	   		                      ^, EigenDecompositionImpl.java:1658: error: ';' expected
	 * 		index of the first row of the block
	   		                             ^, EigenDecompositionImpl.java:1659: error: illegal start of expression
	 * @exception InvalidMatrixException
	   ^, EigenDecompositionImpl.java:1660: error: illegal start of expression
	 * 		if diagonal elements are not positive
	   		^, EigenDecompositionImpl.java:1660: error: not a statement
	 * 		if diagonal elements are not positive
	 ^, EigenDecompositionImpl.java:1660: error: ';' expected
	 * 		if diagonal elements are not positive
	   		                    ^, EigenDecompositionImpl.java:1660: error: ';' expected
	 * 		if diagonal elements are not positive
	   		                            ^, EigenDecompositionImpl.java:1661: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	  ^, EigenDecompositionImpl.java:1661: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	^, EigenDecompositionImpl.java:1661: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	        ^, EigenDecompositionImpl.java:1661: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                              ^, EigenDecompositionImpl.java:1661: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                              ^, EigenDecompositionImpl.java:1661: error: not a statement
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                                                                     ^, EigenDecompositionImpl.java:1661: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                                                                                            ^, EigenDecompositionImpl.java:1675: error: illegal start of expression
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	^, EigenDecompositionImpl.java:1675: error: illegal start of expression
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	        ^, EigenDecompositionImpl.java:1675: error: ';' expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                ^, EigenDecompositionImpl.java:1675: error: ';' expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                            ^, EigenDecompositionImpl.java:1675: error: not a statement
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                                                                   ^, EigenDecompositionImpl.java:1675: error: ';' expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                                                                                          ^, EigenDecompositionImpl.java:1678: error: illegal start of expression
	 * Perform two iterations with Li's tests for initial splits.
	 ^, EigenDecompositionImpl.java:1678: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	          ^, EigenDecompositionImpl.java:1678: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                         ^, EigenDecompositionImpl.java:1678: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1678: error: not a statement
	 * Perform two iterations with Li's tests for initial splits.
	                                    ^, EigenDecompositionImpl.java:1678: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                         ^, EigenDecompositionImpl.java:1678: error: '(' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                             ^, EigenDecompositionImpl.java:1678: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                                            ^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 * 		number of rows of the matrix to process
	   		      ^, EigenDecompositionImpl.java:1681: error: not a statement
	 * 		number of rows of the matrix to process
	   		       ^, EigenDecompositionImpl.java:1681: error: ')' expected
	 * 		number of rows of the matrix to process
	   		         ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                 ^, EigenDecompositionImpl.java:1681: error: variable declaration not allowed here
	 * 		number of rows of the matrix to process
	   		               ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                            ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                                       ^, EigenDecompositionImpl.java:1682: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	^]
Ingredient counter is Zero
---Undoing: gnrtn(3): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int begin = 0 ` -topatch--> `tType = -10` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (5(f=1.0), 6(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (5(f=1.0), )
----------Running generation: 4, population size: 1

***** Generation 4 : 0
**Parent Variant: [Variant id: 7, #gens: 382, #ops: 0, parent:-]

--Child created id: 8
--Creating new operations for variant [Variant id: 8, #gens: 382, #ops: 0, parent:7]
---analyzing modificationPoint position: 205
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 0 not mutation generated in  dMin = java.lang.Math.min(dMin, dN)
---analyzing modificationPoint position: 225
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 1 not mutation generated in  work[j4 - 2] = dN2 + work[j4p2]
---analyzing modificationPoint position: 243
location: EigenDecompositionImpl.java1419
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[((4 * end) - pingPong) - 1] = eMin ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 8, #gens: 381, #ops: 1, parent:7] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 8
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-8/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 2, was successful: false, cases executed: 17] ,[]
-Valid?: |false|2|17|[]|, fitness 2.0
Ingredient counter is Zero
---Undoing: gnrtn(4): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[((4 * end) - pingPong) - 1] = eMin ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (7(f=1.0), 8(f=2.0), )
Selected to next generation: IDs2--> (7(f=1.0), )
----------Running generation: 5, population size: 1

***** Generation 5 : 0
**Parent Variant: [Variant id: 9, #gens: 382, #ops: 0, parent:-]

--Child created id: 10
--Creating new operations for variant [Variant id: 10, #gens: 382, #ops: 0, parent:9]
---analyzing modificationPoint position: 358
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  for (int r = 1; r < nRows; r++) { 	if (d[r].length != nCols) { 		throw org.apache.commons.math.MathR[...]
---analyzing modificationPoint position: 373
location: Array2DRowRealMatrix.java336
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (subMatrix[i].length != nCols) { 	throw org.apache.commons.math.MathRuntimeException.createIllega[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 10, #gens: 381, #ops: 1, parent:9] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 10
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-10/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(5): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (subMatrix[i].length != nCols) { 	throw org.apache.commons.math.MathRuntimeException.createIllega[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (9(f=1.0), 10(f=1.0), )
Selected to next generation: IDs2--> (9(f=1.0), )
----------Running generation: 6, population size: 1

***** Generation 6 : 0
**Parent Variant: [Variant id: 11, #gens: 382, #ops: 0, parent:-]

--Child created id: 12
--Creating new operations for variant [Variant id: 12, #gens: 382, #ops: 0, parent:11]
---analyzing modificationPoint position: 140
location: EigenDecompositionImpl.java1187
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (countEigenValues(middle, index, n) >= 1) { 	right = middle; } else { 	left = middle; } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 12, #gens: 381, #ops: 1, parent:11] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 12
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-12/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(6): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (countEigenValues(middle, index, n) >= 1) { 	right = middle; } else { 	left = middle; } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (11(f=1.0), 12(f=1.0), )
Selected to next generation: IDs2--> (11(f=1.0), )
----------Running generation: 7, population size: 1

***** Generation 7 : 0
**Parent Variant: [Variant id: 13, #gens: 382, #ops: 0, parent:-]

--Child created id: 14
--Creating new operations for variant [Variant id: 14, #gens: 382, #ops: 0, parent:13]
---analyzing modificationPoint position: 304
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // compute splitting points java.util.List<java.lang.Integer> splitIndices = computeSplits()
---analyzing modificationPoint position: 333
Templates availables216
Attempts Base Ingredients  1 total 216
vars from patch []
location: AbstractRealMatrix.java605
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows) ` -topatch--> `return false` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.AbstractRealMatrix line: 605, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows) ` -topatch--> `return false` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 14, #gens: 383, #ops: 1, parent:13] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 14, errors: [AbstractRealMatrix.java:1032: error: incompatible types: boolean cannot be converted to org.apache.commons.math.linear.RealMatrix
		return false; 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows); 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
		       ^]
Ingredient counter is Zero
---Undoing: gnrtn(7): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows) ` -topatch--> `return false` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (13(f=1.0), 14(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (13(f=1.0), )
----------Running generation: 8, population size: 1

***** Generation 8 : 0
**Parent Variant: [Variant id: 15, #gens: 382, #ops: 0, parent:-]

--Child created id: 16
--Creating new operations for variant [Variant id: 16, #gens: 382, #ops: 0, parent:15]
---analyzing modificationPoint position: 178
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  work[j4 - 2] = d + work[j4 - 1]
---analyzing modificationPoint position: 322
location: Array2DRowRealMatrix.java277
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int row = 0; row < nRows; row++) { 	final double[] dataRow = data[row]; 	final double[] outData[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 16, #gens: 381, #ops: 1, parent:15] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 16
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-16/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 5, was successful: false, cases executed: 17] ,[]
-Valid?: |false|5|17|[]|, fitness 5.0
Ingredient counter is Zero
---Undoing: gnrtn(8): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int row = 0; row < nRows; row++) { 	final double[] dataRow = data[row]; 	final double[] outData[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (15(f=1.0), 16(f=5.0), )
Selected to next generation: IDs2--> (15(f=1.0), )
----------Running generation: 9, population size: 1

***** Generation 9 : 0
**Parent Variant: [Variant id: 17, #gens: 382, #ops: 0, parent:-]

--Child created id: 18
--Creating new operations for variant [Variant id: 18, #gens: 382, #ops: 0, parent:17]
---analyzing modificationPoint position: 211
location: EigenDecompositionImpl.java1334
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 		work[j4 - 2][...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 18, #gens: 381, #ops: 1, parent:17] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 18
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-18/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(9): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 		work[j4 - 2][...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (17(f=1.0), 18(f=8.0), )
Selected to next generation: IDs2--> (17(f=1.0), )
----------Running generation: 10, population size: 1

***** Generation 10 : 0
**Parent Variant: [Variant id: 19, #gens: 382, #ops: 0, parent:-]

--Child created id: 20
--Creating new operations for variant [Variant id: 20, #gens: 382, #ops: 0, parent:19]
---analyzing modificationPoint position: 379
Templates availables25
Attempts Base Ingredients  1 total 25
---modifPoint 0 not mutation generated in  if (columnDimension <= 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumen[...]
---analyzing modificationPoint position: 298
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  final double lower = dCurrent - eCurrent
---analyzing modificationPoint position: 95
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [sigma, sigmaLow]
--> var from patch: sigma spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: sigmaLow spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java970
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[((4 * n) - 3) - pingPong] = d ` -topatch--> `final double t = sigma + sigmaLow` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 970, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[((4 * n) - 3) - pingPong] = d ` -topatch--> `final double t = sigma + sigmaLow` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 20, #gens: 383, #ops: 1, parent:19] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 20, errors: [EigenDecompositionImpl.java:1686: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1686: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1686: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1686: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1686: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1686: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1686: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1687: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^, EigenDecompositionImpl.java:1687: error: not a statement
	 * <p>This implementation is based on Beresford N. Parlett
	 ^, EigenDecompositionImpl.java:1687: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                            ^, EigenDecompositionImpl.java:1687: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                     ^, EigenDecompositionImpl.java:1687: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                                 ^, EigenDecompositionImpl.java:1688: error: not a statement
	 * and Osni A. Marques paper <a
	 ^, EigenDecompositionImpl.java:1688: error: ';' expected
	 * and Osni A. Marques paper <a
	      ^, EigenDecompositionImpl.java:1688: error: ';' expected
	 * and Osni A. Marques paper <a
	             ^, EigenDecompositionImpl.java:1688: error: ';' expected
	 * and Osni A. Marques paper <a
	                            ^, EigenDecompositionImpl.java:1689: error: > expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	 ^, EigenDecompositionImpl.java:1689: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	  ^, EigenDecompositionImpl.java:1689: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	       ^, EigenDecompositionImpl.java:1689: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	        ^, EigenDecompositionImpl.java:1689: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                           ^, EigenDecompositionImpl.java:1689: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                              ^, EigenDecompositionImpl.java:1690: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                    ^, EigenDecompositionImpl.java:1690: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                             ^, EigenDecompositionImpl.java:1690: error: ')' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                 ^, EigenDecompositionImpl.java:1690: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                      ^, EigenDecompositionImpl.java:1690: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                        ^, EigenDecompositionImpl.java:1690: error: not a statement
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                          ^, EigenDecompositionImpl.java:1690: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                               ^, EigenDecompositionImpl.java:1690: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                                      ^, EigenDecompositionImpl.java:1691: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                       ^, EigenDecompositionImpl.java:1691: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                      ^, EigenDecompositionImpl.java:1691: error: illegal start of type
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                        ^, EigenDecompositionImpl.java:1691: error: illegal start of expression
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                         ^, EigenDecompositionImpl.java:1692: error: illegal start of expression
	 *
	 ^, EigenDecompositionImpl.java:1693: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1693: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1691: error: not a statement
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                          ^, EigenDecompositionImpl.java:1694: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1695: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1696: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1696: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1697: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1697: error: not a statement
	 * @return new end (maybe deflated)
	 ^, EigenDecompositionImpl.java:1697: error: ';' expected
	 * @return new end (maybe deflated)
	              ^, EigenDecompositionImpl.java:1697: error: -> expected
	 * @return new end (maybe deflated)
	                                   ^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	 ^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	^, EigenDecompositionImpl.java:1697: error: not a statement
	 * @return new end (maybe deflated)
	                   ^, EigenDecompositionImpl.java:1698: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                    ^, EigenDecompositionImpl.java:1698: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                     ^, EigenDecompositionImpl.java:1698: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                                   ^, EigenDecompositionImpl.java:1705: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1705: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1705: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1705: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1705: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1707: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1707: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1708: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1708: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1708: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1708: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1709: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1710: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1710: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1710: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1710: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1710: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1710: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1710: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1710: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1711: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1711: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1711: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1711: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1711: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1711: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1711: error: ';' expected
	 * 		only every other element)
	   		                        ^, EigenDecompositionImpl.java:1712: error: <identifier> expected
	 * @return true if qd array was flipped
	    ^, EigenDecompositionImpl.java:1712: error: <identifier> expected
	 * @return true if qd array was flipped
	          ^, EigenDecompositionImpl.java:1712: error: ';' expected
	 * @return true if qd array was flipped
	               ^, EigenDecompositionImpl.java:1712: error: ';' expected
	 * @return true if qd array was flipped
	                           ^, EigenDecompositionImpl.java:1712: error: ';' expected
	 * @return true if qd array was flipped
	                                       ^, EigenDecompositionImpl.java:1713: error: illegal start of expression
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	^, EigenDecompositionImpl.java:1713: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                               ^, EigenDecompositionImpl.java:1713: error: <identifier> expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                            ^, EigenDecompositionImpl.java:1713: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                                           ^, EigenDecompositionImpl.java:1714: error: illegal start of expression
	 * Compute an interval containing all realEigenvalues of a block.
	 ^, EigenDecompositionImpl.java:1714: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	          ^, EigenDecompositionImpl.java:1714: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                      ^, EigenDecompositionImpl.java:1714: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                                     ^, EigenDecompositionImpl.java:1714: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                                                        ^, EigenDecompositionImpl.java:1714: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                                                                ^, EigenDecompositionImpl.java:1716: error: <identifier> expected
	 * @param index
	               ^, EigenDecompositionImpl.java:1717: error: ';' expected
	 * 		index of the first row of the block
	   		        ^, EigenDecompositionImpl.java:1717: error: ';' expected
	 * 		index of the first row of the block
	   		                  ^, EigenDecompositionImpl.java:1717: error: ';' expected
	 * 		index of the first row of the block
	   		                         ^, EigenDecompositionImpl.java:1717: error: ';' expected
	 * 		index of the first row of the block
	   		                                   ^, EigenDecompositionImpl.java:1718: error: <identifier> expected
	 * @param n
	           ^]
Ingredient counter is Zero
---Undoing: gnrtn(10): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[((4 * n) - 3) - pingPong] = d ` -topatch--> `final double t = sigma + sigmaLow` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (19(f=1.0), 20(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (19(f=1.0), )
----------Running generation: 11, population size: 1

***** Generation 11 : 0
**Parent Variant: [Variant id: 21, #gens: 382, #ops: 0, parent:-]

--Child created id: 22
--Creating new operations for variant [Variant id: 22, #gens: 382, #ops: 0, parent:21]
---analyzing modificationPoint position: 216
---modifPoint 0 not mutation generated in  final double tmp = work[j4 + 1] / work[j4 - 2]
---analyzing modificationPoint position: 315
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  return list
---analyzing modificationPoint position: 183
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  eMin = java.lang.Math.min(work[j4], eMin)
---analyzing modificationPoint position: 142
location: EigenDecompositionImpl.java1190
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `left = middle ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 22, #gens: 381, #ops: 1, parent:21] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 22
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-22/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(11): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `left = middle ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (21(f=1.0), 22(f=1.0), )
Selected to next generation: IDs2--> (21(f=1.0), )
----------Running generation: 12, population size: 1

***** Generation 12 : 0
**Parent Variant: [Variant id: 23, #gens: 382, #ops: 0, parent:-]

--Child created id: 24
--Creating new operations for variant [Variant id: 24, #gens: 382, #ops: 0, parent:23]
---analyzing modificationPoint position: 83
location: EigenDecompositionImpl.java941
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 	if (work[i + 2] <= (org.apache.commons.mat[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 24, #gens: 381, #ops: 1, parent:23] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 24
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-24/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(12): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 	if (work[i + 2] <= (org.apache.commons.mat[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (23(f=1.0), 24(f=1.0), )
Selected to next generation: IDs2--> (23(f=1.0), )
----------Running generation: 13, population size: 1

***** Generation 13 : 0
**Parent Variant: [Variant id: 25, #gens: 382, #ops: 0, parent:-]

--Child created id: 26
--Creating new operations for variant [Variant id: 26, #gens: 382, #ops: 0, parent:25]
---analyzing modificationPoint position: 217
location: EigenDecompositionImpl.java1345
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4 - 1] * tmp ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 26, #gens: 381, #ops: 1, parent:25] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 26
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-26/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(13): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4 - 1] * tmp ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (25(f=1.0), 26(f=8.0), )
Selected to next generation: IDs2--> (25(f=1.0), )
----------Running generation: 14, population size: 1

***** Generation 14 : 0
**Parent Variant: [Variant id: 27, #gens: 382, #ops: 0, parent:-]

--Child created id: 28
--Creating new operations for variant [Variant id: 28, #gens: 382, #ops: 0, parent:27]
---analyzing modificationPoint position: 68
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2])
---analyzing modificationPoint position: 38
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  this.splitTolerance = splitTolerance
---analyzing modificationPoint position: 119
location: EigenDecompositionImpl.java1132
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 	// flip array 	int j = (4 * n) - 1; [...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 28, #gens: 381, #ops: 1, parent:27] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 28
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-28/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(14): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 	// flip array 	int j = (4 * n) - 1; [...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (27(f=1.0), 28(f=1.0), )
Selected to next generation: IDs2--> (27(f=1.0), )
----------Running generation: 15, population size: 1

***** Generation 15 : 0
**Parent Variant: [Variant id: 29, #gens: 382, #ops: 0, parent:-]

--Child created id: 30
--Creating new operations for variant [Variant id: 30, #gens: 382, #ops: 0, parent:29]
---analyzing modificationPoint position: 125
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [qMax, work, pingPong]
--> var from patch: qMax spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1161
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < n; ++i) { 	lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 	u[...] ` -topatch--> `qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]))` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1161, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < n; ++i) { 	lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 	u[...] ` -topatch--> `qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]))` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 30, #gens: 383, #ops: 1, parent:29] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 30
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-30/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(15): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < n; ++i) { 	lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 	u[...] ` -topatch--> `qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]))` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (29(f=1.0), 30(f=1.0), )
Selected to next generation: IDs2--> (29(f=1.0), )
----------Running generation: 16, population size: 1

***** Generation 16 : 0
**Parent Variant: [Variant id: 31, #gens: 382, #ops: 0, parent:-]

--Child created id: 32
--Creating new operations for variant [Variant id: 32, #gens: 382, #ops: 0, parent:31]
---analyzing modificationPoint position: 29
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dMin, dN1]
--> var from patch: dMin spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dN1 spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1521
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2) ` -topatch--> `dMin = dN1` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1521, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2) ` -topatch--> `dMin = dN1` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 32, #gens: 383, #ops: 1, parent:31] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 32
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-32/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(16): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2) ` -topatch--> `dMin = dN1` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (31(f=1.0), 32(f=1.0), )
Selected to next generation: IDs2--> (31(f=1.0), )
----------Running generation: 17, population size: 1

***** Generation 17 : 0
**Parent Variant: [Variant id: 33, #gens: 382, #ops: 0, parent:-]

--Child created id: 34
--Creating new operations for variant [Variant id: 34, #gens: 382, #ops: 0, parent:33]
---analyzing modificationPoint position: 341
location: Array2DRowRealMatrix.java485
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < rows; ++i) { 	final double[] rowI = data[i]; 	for (int j = 0; j < columns; ++j) [...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 34, #gens: 381, #ops: 1, parent:33] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 34
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-34/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 17] ,[]
-Valid?: |false|9|17|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(17): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < rows; ++i) { 	final double[] rowI = data[i]; 	for (int j = 0; j < columns; ++j) [...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (33(f=1.0), 34(f=9.0), )
Selected to next generation: IDs2--> (33(f=1.0), )
----------Running generation: 18, population size: 1

***** Generation 18 : 0
**Parent Variant: [Variant id: 35, #gens: 382, #ops: 0, parent:-]

--Child created id: 36
--Creating new operations for variant [Variant id: 36, #gens: 382, #ops: 0, parent:35]
---analyzing modificationPoint position: 22
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // case 4. tType = -4
---analyzing modificationPoint position: 137
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  if ((range < absoluteTolerance) ||  (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.[...]
---analyzing modificationPoint position: 69
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 2 not mutation generated in  diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2])
---analyzing modificationPoint position: 142
location: EigenDecompositionImpl.java1190
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `left = middle ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 36, #gens: 381, #ops: 1, parent:35] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 36
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-36/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(18): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `left = middle ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (35(f=1.0), 36(f=1.0), )
Selected to next generation: IDs2--> (35(f=1.0), )
----------Running generation: 19, population size: 1

***** Generation 19 : 0
**Parent Variant: [Variant id: 37, #gens: 382, #ops: 0, parent:-]

--Child created id: 38
--Creating new operations for variant [Variant id: 38, #gens: 382, #ops: 0, parent:37]
---analyzing modificationPoint position: 248
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1444
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int nn = ((4 * end) + pingPong) - 1 ` -topatch--> `return` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1444, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int nn = ((4 * end) + pingPong) - 1 ` -topatch--> `return` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 38, #gens: 383, #ops: 1, parent:37] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 38, errors: [EigenDecompositionImpl.java:1446: error: unreachable statement
		switch (deflated) {
		^]
Ingredient counter is Zero
---Undoing: gnrtn(19): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int nn = ((4 * end) + pingPong) - 1 ` -topatch--> `return` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (37(f=1.0), 38(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (37(f=1.0), )
----------Running generation: 20, population size: 1

***** Generation 20 : 0
**Parent Variant: [Variant id: 39, #gens: 382, #ops: 0, parent:-]

--Child created id: 40
--Creating new operations for variant [Variant id: 40, #gens: 382, #ops: 0, parent:39]
---analyzing modificationPoint position: 181
Templates availables595
Attempts Base Ingredients  1 total 595
Name Conflict [splitIndices, begin, tau, org.apache.commons.math.util.MathUtils.EPSILON, minPivot, realEigenvalues, work]
---modifPoint 0 not mutation generated in  dMin = java.lang.Math.min(dMin, d)
---analyzing modificationPoint position: 296
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  for (int i = 0; i < (m - 1); ++i) {  	final double dCurrent = main[i]; 	final double ePrevious = eCu[...]
---analyzing modificationPoint position: 297
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tau, g, dMin]
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: g spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java597
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double dCurrent = main[m - 1] ` -topatch--> `tau = g * dMin` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 597, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double dCurrent = main[m - 1] ` -topatch--> `tau = g * dMin` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 40, #gens: 383, #ops: 1, parent:39] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 40, errors: [EigenDecompositionImpl.java:1586: error: <identifier> expected
					if (chooseLeft) { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda + work[4 * i];}} else { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda - work[4 * i];}}} 			begin = end;} 		// sort the realEigenvalues in decreasing order 		java.util.Arrays.sort(realEigenvalues); 		int j = realEigenvalues.length - 1; 		for (int i = 0; i < j; ++i) { 			final double tmp = realEigenvalues[i]; 			realEigenvalues[i] = realEigenvalues[j]; 			realEigenvalues[j] = tmp; 			--j;}} 	/**
					                  						                              							                                                            						                              							                                                      			     ^, EigenDecompositionImpl.java:1587: error: class, interface, or enum expected
	 * Compute splitting points.
	 ^, EigenDecompositionImpl.java:1589: error: <identifier> expected
	 * @return list of indices after matrix can be split
	    ^, EigenDecompositionImpl.java:1589: error: class, interface, or enum expected
	 * @return list of indices after matrix can be split
	           ^, EigenDecompositionImpl.java:1590: error: class, interface, or enum expected
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	                                                            		      ^, EigenDecompositionImpl.java:1591: error: class, interface, or enum expected
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:1594: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1596: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                    ^, EigenDecompositionImpl.java:1596: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                                 		                                     ^, EigenDecompositionImpl.java:1604: error: class, interface, or enum expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1608: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1610: error: class, interface, or enum expected
	 * @exception InvalidMatrixException
	              ^, EigenDecompositionImpl.java:1612: error: class, interface, or enum expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                     ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                       ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		      ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		      ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		      ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		      ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			      ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			       ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		^, EigenDecompositionImpl.java:1613: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		                                ^, EigenDecompositionImpl.java:1626: error: class, interface, or enum expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                       ^, EigenDecompositionImpl.java:1627: error: class, interface, or enum expected
			return;} 		// initial checks for splits (see Parlett & Marques section 3.3) 		flipIfWarranted(n, 2); 		// two iterations with Li's test for initial splits 		initialSplits(n); 		// initialize parameters used by goodStep 		tType = 0; 		dMin1 = 0; 		dMin2 = 0; 		dN = 0; 		dN1 = 0; 		dN2 = 0; 		tau = 0; 		// process split segments 		int i0 = 0; 		int n0 = n; 		while (n0 > 0) { 			// retrieve shift that was temporarily stored as a negative off-diagonal element 			sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2]; 			sigmaLow = 0; 			// find start of a new split segment to process 			double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6]; 			double offDiagMax = 0; 			double diagMax = work[(4 * n0) - 4]; 			double diagMin = diagMax; 			i0 = 0; 			for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { 				if (work[i + 2] <= 0) { 					i0 = 1 + (i / 4); 					break;} 				if (diagMin >= (4 * offDiagMax)) { 					diagMin = java.lang.Math.min(diagMin, work[i + 4]); 					offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);} 				diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]); 				offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);} 			work[(4 * n0) - 2] = offDiagMin; 			// lower bound of Gershgorin disk 			dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax))); 			pingPong = 0; 			int maxIter = 30 * (n0 - i0); 			for (int k = 0; i0 < n0; ++k) { 				if (k >= maxIter) { 					throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));} 				// perform one step 				n0 = goodStep(i0, n0); 				pingPong = 1 - pingPong; 				// check for new splits after "ping" steps 				// when the last elements of qd array are very small
			       ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					                     ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					                                          ^, EigenDecompositionImpl.java:1629: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1631: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1633: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                 ^, EigenDecompositionImpl.java:1633: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		^, EigenDecompositionImpl.java:1633: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		                ^, EigenDecompositionImpl.java:1633: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		                       ^, EigenDecompositionImpl.java:1641: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1643: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1645: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1645: error: class, interface, or enum expected
	 * @return new end (maybe deflated)
	           ^, EigenDecompositionImpl.java:1645: error: class, interface, or enum expected
	 * @return new end (maybe deflated)
	               ^, EigenDecompositionImpl.java:1646: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                           ^, EigenDecompositionImpl.java:1646: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                            ^, EigenDecompositionImpl.java:1647: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				^, EigenDecompositionImpl.java:1647: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                   ^, EigenDecompositionImpl.java:1647: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                     			      ^, EigenDecompositionImpl.java:1647: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                     			                                                  			^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					      ^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                  ^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                               ^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                         ^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                ^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				                                                   				^, EigenDecompositionImpl.java:1648: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				                                                   				                 ^, EigenDecompositionImpl.java:1649: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				^, EigenDecompositionImpl.java:1649: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				^, EigenDecompositionImpl.java:1649: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				^, EigenDecompositionImpl.java:1649: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				                                                                                             				^, EigenDecompositionImpl.java:1649: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				                                                                                             				            ^, EigenDecompositionImpl.java:1650: error: class, interface, or enum expected
			for (boolean loop = true; loop;) { 				// perform one dqds step with the chosen shift 				dqds(start, deflatedEnd); 				// check result of the dqds step
			                          ^, EigenDecompositionImpl.java:1650: error: class, interface, or enum expected
			for (boolean loop = true; loop;) { 				// perform one dqds step with the chosen shift 				dqds(start, deflatedEnd); 				// check result of the dqds step
			                               ^, EigenDecompositionImpl.java:1655: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1657: error: class, interface, or enum expected
	 * @param step
	          ^, EigenDecompositionImpl.java:1660: error: <identifier> expected
	 * @return true if qd array was flipped
	    ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	           ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	                ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	                   ^, EigenDecompositionImpl.java:1661: error: class, interface, or enum expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1661: error: class, interface, or enum expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1664: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1666: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1668: error: <identifier> expected
	 * @return an interval containing the realEigenvalues
	    ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 * @return an interval containing the realEigenvalues
	           ^, EigenDecompositionImpl.java:1669: error: class, interface, or enum expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
	    	                                        ^, EigenDecompositionImpl.java:1669: error: class, interface, or enum expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
	    	                                                         ^, EigenDecompositionImpl.java:1670: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				      ^, EigenDecompositionImpl.java:1670: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			      ^, EigenDecompositionImpl.java:1670: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			^]
Ingredient counter is Zero
---Undoing: gnrtn(20): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double dCurrent = main[m - 1] ` -topatch--> `tau = g * dMin` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (39(f=1.0), 40(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (39(f=1.0), )
----------Running generation: 21, population size: 1

***** Generation 21 : 0
**Parent Variant: [Variant id: 41, #gens: 382, #ops: 0, parent:-]

--Child created id: 42
--Creating new operations for variant [Variant id: 42, #gens: 382, #ops: 0, parent:41]
---analyzing modificationPoint position: 27
location: EigenDecompositionImpl.java1517
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `a2 = cnst3 * a2 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 42, #gens: 381, #ops: 1, parent:41] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 42
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-42/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(21): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `a2 = cnst3 * a2 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (41(f=1.0), 42(f=1.0), )
Selected to next generation: IDs2--> (41(f=1.0), )
----------Running generation: 22, population size: 1

***** Generation 22 : 0
**Parent Variant: [Variant id: 43, #gens: 382, #ops: 0, parent:-]

--Child created id: 44
--Creating new operations for variant [Variant id: 44, #gens: 382, #ops: 0, parent:43]
---analyzing modificationPoint position: 0
---modifPoint 0 not mutation generated in  return
---analyzing modificationPoint position: 217
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  work[j4] = work[j4 - 1] * tmp
---analyzing modificationPoint position: 218
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  d *= tmp
---analyzing modificationPoint position: 54
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  // process split segments int i0 = 0
---analyzing modificationPoint position: 160
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 4 not mutation generated in  if (ratio <= 0) { 	++count; }
---analyzing modificationPoint position: 258
location: EigenDecompositionImpl.java1460
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `tType = -2 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 44, #gens: 381, #ops: 1, parent:43] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 44
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-44/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(22): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `tType = -2 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (43(f=1.0), 44(f=1.0), )
Selected to next generation: IDs2--> (43(f=1.0), )
----------Running generation: 23, population size: 1

***** Generation 23 : 0
**Parent Variant: [Variant id: 45, #gens: 382, #ops: 0, parent:-]

--Child created id: 46
--Creating new operations for variant [Variant id: 46, #gens: 382, #ops: 0, parent:45]
---analyzing modificationPoint position: 125
location: EigenDecompositionImpl.java1161
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < n; ++i) { 	lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 	u[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 46, #gens: 381, #ops: 1, parent:45] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 46
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-46/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 17] ,[]
-Valid?: |false|9|17|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(23): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < n; ++i) { 	lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 	u[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (45(f=1.0), 46(f=9.0), )
Selected to next generation: IDs2--> (45(f=1.0), )
----------Running generation: 24, population size: 1

***** Generation 24 : 0
**Parent Variant: [Variant id: 47, #gens: 382, #ops: 0, parent:-]

--Child created id: 48
--Creating new operations for variant [Variant id: 48, #gens: 382, #ops: 0, parent:47]
---analyzing modificationPoint position: 276
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  final double upper = dCurrent + radius
---analyzing modificationPoint position: 47
location: EigenDecompositionImpl.java845
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// initialize parameters used by goodStep tType = 0 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 48, #gens: 381, #ops: 1, parent:47] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 48
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-48/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(24): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// initialize parameters used by goodStep tType = 0 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (47(f=1.0), 48(f=1.0), )
Selected to next generation: IDs2--> (47(f=1.0), )
----------Running generation: 25, population size: 1

***** Generation 25 : 0
**Parent Variant: [Variant id: 49, #gens: 382, #ops: 0, parent:-]

--Child created id: 50
--Creating new operations for variant [Variant id: 50, #gens: 382, #ops: 0, parent:49]
---analyzing modificationPoint position: 155
---modifPoint 0 not mutation generated in  return new double[]{ lower, upper }
---analyzing modificationPoint position: 183
location: EigenDecompositionImpl.java1285
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `eMin = java.lang.Math.min(work[j4], eMin) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 50, #gens: 381, #ops: 1, parent:49] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 50
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-50/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(25): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `eMin = java.lang.Math.min(work[j4], eMin) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (49(f=1.0), 50(f=1.0), )
Selected to next generation: IDs2--> (49(f=1.0), )
----------Running generation: 26, population size: 1

***** Generation 26 : 0
**Parent Variant: [Variant id: 51, #gens: 382, #ops: 0, parent:-]

--Child created id: 52
--Creating new operations for variant [Variant id: 52, #gens: 382, #ops: 0, parent:51]
---analyzing modificationPoint position: 41
---modifPoint 0 not mutation generated in  final int fourI = 4 * i
---analyzing modificationPoint position: 139
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 1 not mutation generated in  final double middle = 0.5 * (left + right)
---analyzing modificationPoint position: 229
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  work[j4] = work[j4p2] * tmp
---analyzing modificationPoint position: 213
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [dN1]
--> var from patch: dN1 spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1336
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = d + work[j4 - 1] ` -topatch--> `dN1 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1336, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = d + work[j4 - 1] ` -topatch--> `dN1 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 52, #gens: 382, #ops: 1, parent:51] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 52
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-52/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(26): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = d + work[j4 - 1] ` -topatch--> `dN1 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (51(f=1.0), 52(f=8.0), )
Selected to next generation: IDs2--> (51(f=1.0), )
----------Running generation: 27, population size: 1

***** Generation 27 : 0
**Parent Variant: [Variant id: 53, #gens: 382, #ops: 0, parent:-]

--Child created id: 54
--Creating new operations for variant [Variant id: 54, #gens: 382, #ops: 0, parent:53]
---analyzing modificationPoint position: 348
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  return new org.apache.commons.math.linear.Array2DRowRealMatrix(rowDimension, columnDimension)
---analyzing modificationPoint position: 181
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 1 not mutation generated in  dMin = java.lang.Math.min(dMin, d)
---analyzing modificationPoint position: 132
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [main, index]
--> var from patch: main spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: index spoon.support.reflect.code.CtVariableReadImpl
location: EigenDecompositionImpl.java1172
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * min[...] ` -topatch--> `final double q2 = main[index + 2]` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1172, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * min[...] ` -topatch--> `final double q2 = main[index + 2]` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 54, #gens: 383, #ops: 1, parent:53] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 54
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-54/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(27): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * min[...] ` -topatch--> `final double q2 = main[index + 2]` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (53(f=1.0), 54(f=1.0), )
Selected to next generation: IDs2--> (53(f=1.0), )
----------Running generation: 28, population size: 1

***** Generation 28 : 0
**Parent Variant: [Variant id: 55, #gens: 382, #ops: 0, parent:-]

--Child created id: 56
--Creating new operations for variant [Variant id: 56, #gens: 382, #ops: 0, parent:55]
---analyzing modificationPoint position: 368
Templates availables120
Attempts Base Ingredients  1 total 120
vars from patch [row, column]
--> var from patch: row spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: column spoon.support.reflect.code.CtVariableReadImpl
location: Array2DRowRealMatrix.java326
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if (nRows == 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException[...] ` -topatch--> `throw new org.apache.commons.math.linear.MatrixIndexException( "no entry at indices ({0}, {1}) in a [...]` (spoon.support.reflect.code.CtThrowImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 326, pointed element: CtThrowImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if (nRows == 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException[...] ` -topatch--> `throw new org.apache.commons.math.linear.MatrixIndexException( "no entry at indices ({0}, {1}) in a [...]` (spoon.support.reflect.code.CtThrowImpl) 

--Summary Creation: for variant [Variant id: 56, #gens: 383, #ops: 1, parent:55] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 56, errors: [Array2DRowRealMatrix.java:359: error: unreachable statement
			row, column, getRowDimension(), getColumnDimension()); 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
			                                                       			          ^]
Ingredient counter is Zero
---Undoing: gnrtn(28): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if (nRows == 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException[...] ` -topatch--> `throw new org.apache.commons.math.linear.MatrixIndexException( "no entry at indices ({0}, {1}) in a [...]` (spoon.support.reflect.code.CtThrowImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (55(f=1.0), 56(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (55(f=1.0), )
----------Running generation: 29, population size: 1

***** Generation 29 : 0
**Parent Variant: [Variant id: 57, #gens: 382, #ops: 0, parent:-]

--Child created id: 58
--Creating new operations for variant [Variant id: 58, #gens: 382, #ops: 0, parent:57]
---analyzing modificationPoint position: 114
location: EigenDecompositionImpl.java1080
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `// check result of the dqds step if ((dMin >= 0) && (dMin1 > 0)) { 	// the shift was good 	updateSig[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 58, #gens: 381, #ops: 1, parent:57] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 58
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-58/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
-Killed id: pid->73927
The Process that runs JUnit test cases did not terminate within waitTime of 10 seconds
Killed the Process that runs JUnit test cases 73927
**The validation 1 have not finished well**
-Valid?: null, fitness 1.7976931348623157E308
Ingredient counter is Zero
---Undoing: gnrtn(29): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `// check result of the dqds step if ((dMin >= 0) && (dMin1 > 0)) { 	// the shift was good 	updateSig[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (57(f=1.0), 58(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (57(f=1.0), )
----------Running generation: 30, population size: 1

***** Generation 30 : 0
**Parent Variant: [Variant id: 59, #gens: 382, #ops: 0, parent:-]

--Child created id: 60
--Creating new operations for variant [Variant id: 60, #gens: 382, #ops: 0, parent:59]
---analyzing modificationPoint position: 85
Templates availables26
Attempts Base Ingredients  1 total 26
---modifPoint 0 not mutation generated in  d *= work[i] / (d + work[i + 2])
---analyzing modificationPoint position: 136
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  final double range = right - left
---analyzing modificationPoint position: 77
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 2 not mutation generated in  // perform one step n0 = goodStep(i0, n0)
---analyzing modificationPoint position: 313
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  for (int i = 0; i < secondary.length; ++i) { 	final double absDPrevious = absDCurrent; 	absDCurrent [...]
---analyzing modificationPoint position: 335
Templates availables37
Attempts Base Ingredients  1 total 37
---modifPoint 4 not mutation generated in  walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {  	/**[...]
---analyzing modificationPoint position: 248
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [end, pingPong]
--> var from patch: end spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1444
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int nn = ((4 * end) + pingPong) - 1 ` -topatch--> `int nn = ((4 * end) + pingPong) - 1` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1444, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int nn = ((4 * end) + pingPong) - 1 ` -topatch--> `int nn = ((4 * end) + pingPong) - 1` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 60, #gens: 383, #ops: 1, parent:59] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child does NOT compile: 60, errors: [EigenDecompositionImpl.java:1445: error: variable nn is already defined in method computeShiftIncrement(int,int,int)
		int nn = ((4 * end) + pingPong) - 1; 		int nn = ((4 * end) + pingPong) - 1;
		                                     		    ^]
Ingredient counter is Zero
---Undoing: gnrtn(30): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int nn = ((4 * end) + pingPong) - 1 ` -topatch--> `int nn = ((4 * end) + pingPong) - 1` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (59(f=1.0), 60(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (59(f=1.0), )
----------Running generation: 31, population size: 1

***** Generation 31 : 0
**Parent Variant: [Variant id: 61, #gens: 382, #ops: 0, parent:-]

--Child created id: 62
--Creating new operations for variant [Variant id: 62, #gens: 382, #ops: 0, parent:61]
---analyzing modificationPoint position: 189
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  work[j4 - 1] = work[j4] * tmp
---analyzing modificationPoint position: 286
location: EigenDecompositionImpl.java240
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work = new double[6 * main.length] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 62, #gens: 381, #ops: 1, parent:61] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 62
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-62/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 17, was successful: false, cases executed: 17] ,[]
-Valid?: |false|17|17|[]|, fitness 17.0
Ingredient counter is Zero
---Undoing: gnrtn(31): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work = new double[6 * main.length] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (61(f=1.0), 62(f=17.0), )
Selected to next generation: IDs2--> (61(f=1.0), )
----------Running generation: 32, population size: 1

***** Generation 32 : 0
**Parent Variant: [Variant id: 63, #gens: 382, #ops: 0, parent:-]

--Child created id: 64
--Creating new operations for variant [Variant id: 64, #gens: 382, #ops: 0, parent:63]
---analyzing modificationPoint position: 107
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  final int l = ((4 * deflatedEnd) + pingPong) - 1
---analyzing modificationPoint position: 250
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1450
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5]) ` -topatch--> `tType -= 12` (spoon.support.reflect.code.CtOperatorAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1450, pointed element: CtOperatorAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5]) ` -topatch--> `tType -= 12` (spoon.support.reflect.code.CtOperatorAssignmentImpl) 

--Summary Creation: for variant [Variant id: 64, #gens: 383, #ops: 1, parent:63] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 64
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-64/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(32): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5]) ` -topatch--> `tType -= 12` (spoon.support.reflect.code.CtOperatorAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (63(f=1.0), 64(f=1.0), )
Selected to next generation: IDs2--> (63(f=1.0), )
----------Running generation: 33, population size: 1

***** Generation 33 : 0
**Parent Variant: [Variant id: 65, #gens: 382, #ops: 0, parent:-]

--Child created id: 66
--Creating new operations for variant [Variant id: 66, #gens: 382, #ops: 0, parent:65]
---analyzing modificationPoint position: 256
location: EigenDecompositionImpl.java1458
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if ((gap1 > 0.0) && (gap1 > b1)) { 	tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin); 	[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 66, #gens: 381, #ops: 1, parent:65] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 66
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-66/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 2, was successful: false, cases executed: 17] ,[]
-Valid?: |false|2|17|[]|, fitness 2.0
Ingredient counter is Zero
---Undoing: gnrtn(33): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if ((gap1 > 0.0) && (gap1 > b1)) { 	tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin); 	[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (65(f=1.0), 66(f=2.0), )
Selected to next generation: IDs2--> (65(f=1.0), )
----------Running generation: 34, population size: 1

***** Generation 34 : 0
**Parent Variant: [Variant id: 67, #gens: 382, #ops: 0, parent:-]

--Child created id: 68
--Creating new operations for variant [Variant id: 68, #gens: 382, #ops: 0, parent:67]
---analyzing modificationPoint position: 335
Templates availables37
Attempts Base Ingredients  1 total 37
---modifPoint 0 not mutation generated in  walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {  	/**[...]
---analyzing modificationPoint position: 165
location: EigenDecompositionImpl.java1255
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 1; i < n; ++i) { 	final int fourI = 4 * i; 	final double eiM1 = secondary[(index + i) -[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 68, #gens: 381, #ops: 1, parent:67] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 68
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-68/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(34): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 1; i < n; ++i) { 	final int fourI = 4 * i; 	final double eiM1 = secondary[(index + i) -[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (67(f=1.0), 68(f=8.0), )
Selected to next generation: IDs2--> (67(f=1.0), )
----------Running generation: 35, population size: 1

***** Generation 35 : 0
**Parent Variant: [Variant id: 69, #gens: 382, #ops: 0, parent:-]

--Child created id: 70
--Creating new operations for variant [Variant id: 70, #gens: 382, #ops: 0, parent:69]
---analyzing modificationPoint position: 15
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 	break; }
---analyzing modificationPoint position: 292
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 1 not mutation generated in  lowerSpectra = java.lang.Double.POSITIVE_INFINITY
---analyzing modificationPoint position: 26
Templates availables42
Attempts Base Ingredients  1 total 42
---modifPoint 2 not mutation generated in  for (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 	if (b2 == 0.0) { 		break; 	} 	b1[...]
---analyzing modificationPoint position: 23
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 3 not mutation generated in  double s = 0.25 * dMin
---analyzing modificationPoint position: 380
Templates availables216
Attempts Base Ingredients  1 total 216
---modifPoint 4 not mutation generated in  lu = null
---analyzing modificationPoint position: 187
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 5 not mutation generated in  d = (d * tmp) - tau
---analyzing modificationPoint position: 20
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 6 not mutation generated in  // late failure. Gives excellent shift. tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.u[...]
---analyzing modificationPoint position: 18
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 7 not mutation generated in  // tau too big. Select new tau and try again. if (tType < (-22)) { 	// failed twice. Play it safe. 	[...]
---analyzing modificationPoint position: 251
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tau, dMin]
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1451
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double b2 = java.lang.Math.sqrt(work[nn - 7]) * java.lang.Math.sqrt(work[nn - 9]) ` -topatch--> `tau = -dMin` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1451, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double b2 = java.lang.Math.sqrt(work[nn - 7]) * java.lang.Math.sqrt(work[nn - 9]) ` -topatch--> `tau = -dMin` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 70, #gens: 383, #ops: 1, parent:69] gen mutated: 1 , gen not mut: 8, gen not applied  0
-The child compiles: id 70
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-70/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(35): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double b2 = java.lang.Math.sqrt(work[nn - 7]) * java.lang.Math.sqrt(work[nn - 9]) ` -topatch--> `tau = -dMin` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (69(f=1.0), 70(f=1.0), )
Selected to next generation: IDs2--> (69(f=1.0), )
----------Running generation: 36, population size: 1

***** Generation 36 : 0
**Parent Variant: [Variant id: 71, #gens: 382, #ops: 0, parent:-]

--Child created id: 72
--Creating new operations for variant [Variant id: 72, #gens: 382, #ops: 0, parent:71]
---analyzing modificationPoint position: 44
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  if (sumOffDiag == 0) { 	// matrix is already diagonal 	return; }
---analyzing modificationPoint position: 82
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 1 not mutation generated in  // apply Li's reverse test double d = work[(4 * (n - 1)) + pingPong]
---analyzing modificationPoint position: 338
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 2 not mutation generated in  final int rows = getRowDimension()
---analyzing modificationPoint position: 346
---modifPoint 3 not mutation generated in  return 0
---analyzing modificationPoint position: 54
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  // process split segments int i0 = 0
---analyzing modificationPoint position: 6
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 5 not mutation generated in  a2 = 0.0
---analyzing modificationPoint position: 303
location: EigenDecompositionImpl.java603
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `minPivot = org.apache.commons.math.util.MathUtils.SAFE_MIN * java.lang.Math.max(1.0, eMax * eMax) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 72, #gens: 381, #ops: 1, parent:71] gen mutated: 1 , gen not mut: 6, gen not applied  0
-The child compiles: id 72
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-72/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 17] ,[]
-Valid?: |false|3|17|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(36): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `minPivot = org.apache.commons.math.util.MathUtils.SAFE_MIN * java.lang.Math.max(1.0, eMax * eMax) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (71(f=1.0), 72(f=3.0), )
Selected to next generation: IDs2--> (71(f=1.0), )
----------Running generation: 37, population size: 1

***** Generation 37 : 0
**Parent Variant: [Variant id: 73, #gens: 382, #ops: 0, parent:-]

--Child created id: 74
--Creating new operations for variant [Variant id: 74, #gens: 382, #ops: 0, parent:73]
---analyzing modificationPoint position: 314
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  list.add(secondary.length + 1)
---analyzing modificationPoint position: 49
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tau, dMin, org.apache.commons.math.util.MathUtils.EPSILON]
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: org.apache.commons.math.util.MathUtils.EPSILON spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java847
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = 0 ` -topatch--> `// late failure. Gives excellent shift. tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.u[...]` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 847, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = 0 ` -topatch--> `// late failure. Gives excellent shift. tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.u[...]` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 74, #gens: 383, #ops: 1, parent:73] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 74, errors: [EigenDecompositionImpl.java:1103: error: illegal start of expression
	 * Perform two iterations with Li's tests for initial splits.
	 ^, EigenDecompositionImpl.java:1103: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	          ^, EigenDecompositionImpl.java:1103: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                         ^, EigenDecompositionImpl.java:1103: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1103: error: not a statement
	 * Perform two iterations with Li's tests for initial splits.
	                                    ^, EigenDecompositionImpl.java:1103: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                         ^, EigenDecompositionImpl.java:1103: error: '(' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                             ^, EigenDecompositionImpl.java:1103: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                                            ^, EigenDecompositionImpl.java:1105: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1105: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1106: error: ';' expected
	 * 		number of rows of the matrix to process
	   		      ^, EigenDecompositionImpl.java:1106: error: not a statement
	 * 		number of rows of the matrix to process
	   		       ^, EigenDecompositionImpl.java:1106: error: ')' expected
	 * 		number of rows of the matrix to process
	   		         ^, EigenDecompositionImpl.java:1106: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                 ^, EigenDecompositionImpl.java:1106: error: variable declaration not allowed here
	 * 		number of rows of the matrix to process
	   		               ^, EigenDecompositionImpl.java:1106: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                            ^, EigenDecompositionImpl.java:1106: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                                       ^, EigenDecompositionImpl.java:1107: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	^, EigenDecompositionImpl.java:1107: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	        ^, EigenDecompositionImpl.java:1107: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                          ^, EigenDecompositionImpl.java:1107: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1108: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1108: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1108: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1108: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1108: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1108: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1108: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1109: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^, EigenDecompositionImpl.java:1109: error: not a statement
	 * <p>This implementation is based on Beresford N. Parlett
	 ^, EigenDecompositionImpl.java:1109: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                            ^, EigenDecompositionImpl.java:1109: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                     ^, EigenDecompositionImpl.java:1109: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                                 ^, EigenDecompositionImpl.java:1110: error: not a statement
	 * and Osni A. Marques paper <a
	 ^, EigenDecompositionImpl.java:1110: error: ';' expected
	 * and Osni A. Marques paper <a
	      ^, EigenDecompositionImpl.java:1110: error: ';' expected
	 * and Osni A. Marques paper <a
	             ^, EigenDecompositionImpl.java:1110: error: ';' expected
	 * and Osni A. Marques paper <a
	                            ^, EigenDecompositionImpl.java:1111: error: > expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	 ^, EigenDecompositionImpl.java:1111: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	  ^, EigenDecompositionImpl.java:1111: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	       ^, EigenDecompositionImpl.java:1111: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	        ^, EigenDecompositionImpl.java:1111: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                           ^, EigenDecompositionImpl.java:1111: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                              ^, EigenDecompositionImpl.java:1112: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                    ^, EigenDecompositionImpl.java:1112: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                             ^, EigenDecompositionImpl.java:1112: error: ')' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                 ^, EigenDecompositionImpl.java:1112: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                      ^, EigenDecompositionImpl.java:1112: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                        ^, EigenDecompositionImpl.java:1112: error: not a statement
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                          ^, EigenDecompositionImpl.java:1112: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                               ^, EigenDecompositionImpl.java:1112: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                                      ^, EigenDecompositionImpl.java:1113: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                       ^, EigenDecompositionImpl.java:1113: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                      ^, EigenDecompositionImpl.java:1113: error: illegal start of type
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                        ^, EigenDecompositionImpl.java:1113: error: illegal start of expression
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                         ^, EigenDecompositionImpl.java:1114: error: illegal start of expression
	 *
	 ^, EigenDecompositionImpl.java:1115: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1115: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1113: error: not a statement
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                          ^, EigenDecompositionImpl.java:1116: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1117: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1118: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1118: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1119: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1119: error: not a statement
	 * @return new end (maybe deflated)
	 ^, EigenDecompositionImpl.java:1119: error: ';' expected
	 * @return new end (maybe deflated)
	              ^, EigenDecompositionImpl.java:1119: error: -> expected
	 * @return new end (maybe deflated)
	                                   ^, EigenDecompositionImpl.java:1120: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	 ^, EigenDecompositionImpl.java:1120: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	^, EigenDecompositionImpl.java:1119: error: not a statement
	 * @return new end (maybe deflated)
	                   ^, EigenDecompositionImpl.java:1120: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                    ^, EigenDecompositionImpl.java:1120: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                     ^, EigenDecompositionImpl.java:1120: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                                   ^, EigenDecompositionImpl.java:1127: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1127: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1127: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1127: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1127: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1129: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1129: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1130: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1130: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1130: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1130: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1131: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1132: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1132: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1132: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1132: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1132: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1132: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1132: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1132: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1133: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1133: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1133: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1133: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1133: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1133: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1133: error: ';' expected
	 * 		only every other element)
	   		                        ^]
Ingredient counter is Zero
---Undoing: gnrtn(37): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = 0 ` -topatch--> `// late failure. Gives excellent shift. tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.u[...]` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (73(f=1.0), 74(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (73(f=1.0), )
----------Running generation: 38, population size: 1

***** Generation 38 : 0
**Parent Variant: [Variant id: 75, #gens: 382, #ops: 0, parent:-]

--Child created id: 76
--Creating new operations for variant [Variant id: 76, #gens: 382, #ops: 0, parent:75]
---analyzing modificationPoint position: 375
Templates availables12
Attempts Base Ingredients  1 total 12
vars from patch [in]
--> var from patch: in spoon.support.reflect.code.CtVariableReadImpl
location: Array2DRowRealMatrix.java622
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `setSubMatrix(in, 0, 0) ` -topatch--> `setSubMatrix(in, 0, 0)` (spoon.support.reflect.code.CtInvocationImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 622, pointed element: CtInvocationImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `setSubMatrix(in, 0, 0) ` -topatch--> `setSubMatrix(in, 0, 0)` (spoon.support.reflect.code.CtInvocationImpl) 

--Summary Creation: for variant [Variant id: 76, #gens: 382, #ops: 1, parent:75] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 76
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-76/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(38): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `setSubMatrix(in, 0, 0) ` -topatch--> `setSubMatrix(in, 0, 0)` (spoon.support.reflect.code.CtInvocationImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (75(f=1.0), 76(f=1.0), )
Selected to next generation: IDs2--> (75(f=1.0), )
----------Running generation: 39, population size: 1

***** Generation 39 : 0
**Parent Variant: [Variant id: 77, #gens: 382, #ops: 0, parent:-]

--Child created id: 78
--Creating new operations for variant [Variant id: 78, #gens: 382, #ops: 0, parent:77]
---analyzing modificationPoint position: 59
---modifPoint 0 not mutation generated in  // find start of a new split segment to process double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) -[...]
---analyzing modificationPoint position: 14
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  a2 = a2 + b2
---analyzing modificationPoint position: 264
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  sigma = t
---analyzing modificationPoint position: 174
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [pingPong, start, j4, end, work, d, tmp, tau, dMin, eMin]
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: start spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: j4 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: end spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: d spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: tmp spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: tau spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: dMin spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: eMin spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1275
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = d ` -topatch--> `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 		work[j4 - 2[...]` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1275, pointed element: CtIfImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = d ` -topatch--> `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 		work[j4 - 2[...]` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 78, #gens: 383, #ops: 1, parent:77] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 78
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-78/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(39): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = d ` -topatch--> `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 		work[j4 - 2[...]` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (77(f=1.0), 78(f=8.0), )
Selected to next generation: IDs2--> (77(f=1.0), )
----------Running generation: 40, population size: 1

***** Generation 40 : 0
**Parent Variant: [Variant id: 79, #gens: 382, #ops: 0, parent:-]

--Child created id: 80
--Creating new operations for variant [Variant id: 80, #gens: 382, #ops: 0, parent:79]
---analyzing modificationPoint position: 17
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1093
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (dMin < 0.0) { 	// tau too big. Select new tau and try again. 	if (tType < (-22)) { 		// failed t[...] ` -topatch--> `int begin = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1093, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (dMin < 0.0) { 	// tau too big. Select new tau and try again. 	if (tType < (-22)) { 		// failed t[...] ` -topatch--> `int begin = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 80, #gens: 383, #ops: 1, parent:79] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 80
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-80/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(40): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (dMin < 0.0) { 	// tau too big. Select new tau and try again. 	if (tType < (-22)) { 		// failed t[...] ` -topatch--> `int begin = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (79(f=1.0), 80(f=1.0), )
Selected to next generation: IDs2--> (79(f=1.0), )
----------Running generation: 41, population size: 1

***** Generation 41 : 0
**Parent Variant: [Variant id: 81, #gens: 382, #ops: 0, parent:-]

--Child created id: 82
--Creating new operations for variant [Variant id: 82, #gens: 382, #ops: 0, parent:81]
---analyzing modificationPoint position: 313
Templates availables42
Attempts Base Ingredients  1 total 42
---modifPoint 0 not mutation generated in  for (int i = 0; i < secondary.length; ++i) { 	final double absDPrevious = absDCurrent; 	absDCurrent [...]
---analyzing modificationPoint position: 67
location: EigenDecompositionImpl.java874
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `diagMin = java.lang.Math.min(diagMin, work[i + 4]) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 82, #gens: 381, #ops: 1, parent:81] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 82
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-82/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(41): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `diagMin = java.lang.Math.min(diagMin, work[i + 4]) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (81(f=1.0), 82(f=1.0), )
Selected to next generation: IDs2--> (81(f=1.0), )
----------Running generation: 42, population size: 1

***** Generation 42 : 0
**Parent Variant: [Variant id: 83, #gens: 382, #ops: 0, parent:-]

--Child created id: 84
--Creating new operations for variant [Variant id: 84, #gens: 382, #ops: 0, parent:83]
---analyzing modificationPoint position: 206
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  work[j4 + 2] = dN
---analyzing modificationPoint position: 294
---modifPoint 1 not mutation generated in  double eMax = 0
---analyzing modificationPoint position: 158
location: EigenDecompositionImpl.java1232
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 1; i < n; ++i) { 	ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 84, #gens: 381, #ops: 1, parent:83] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 84
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-84/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 4, was successful: false, cases executed: 17] ,[]
-Valid?: |false|4|17|[]|, fitness 4.0
Ingredient counter is Zero
---Undoing: gnrtn(42): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 1; i < n; ++i) { 	ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (83(f=1.0), 84(f=4.0), )
Selected to next generation: IDs2--> (83(f=1.0), )
----------Running generation: 43, population size: 1

***** Generation 43 : 0
**Parent Variant: [Variant id: 85, #gens: 382, #ops: 0, parent:-]

--Child created id: 86
--Creating new operations for variant [Variant id: 86, #gens: 382, #ops: 0, parent:85]
---analyzing modificationPoint position: 271
location: EigenDecompositionImpl.java584
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `eMax = java.lang.Math.max(eMax, eCurrent) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 86, #gens: 381, #ops: 1, parent:85] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 86
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-86/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(43): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `eMax = java.lang.Math.max(eMax, eCurrent) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (85(f=1.0), 86(f=1.0), )
Selected to next generation: IDs2--> (85(f=1.0), )
----------Running generation: 44, population size: 1

***** Generation 44 : 0
**Parent Variant: [Variant id: 87, #gens: 382, #ops: 0, parent:-]

--Child created id: 88
--Creating new operations for variant [Variant id: 88, #gens: 382, #ops: 0, parent:87]
---analyzing modificationPoint position: 281
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent)
---analyzing modificationPoint position: 321
Templates availables23
Attempts Base Ingredients  1 total 23
vars from patch [nRows]
--> var from patch: nRows spoon.support.reflect.code.CtVariableReadImpl
location: Array2DRowRealMatrix.java276
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double[][] outData = new double[nRows][nCols] ` -topatch--> `final double[][] out = new double[nRows][this.getColumnDimension()]` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 276, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double[][] outData = new double[nRows][nCols] ` -topatch--> `final double[][] out = new double[nRows][this.getColumnDimension()]` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 88, #gens: 382, #ops: 1, parent:87] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 88, errors: [Array2DRowRealMatrix.java:604: error: cannot find symbol
		final double[][] out = new double[nRows][this.getColumnDimension()]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
		                                                                     		                                        			                                    			                            ^
  symbol:   variable outData
  location: class org.apache.commons.math.linear.Array2DRowRealMatrix, Array2DRowRealMatrix.java:604: error: cannot find symbol
		final double[][] out = new double[nRows][this.getColumnDimension()]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
		                                                                     		                                        			                                    			                                          			                                        				                				                                 					                                     				                         		                                                               ^
  symbol:   variable outData
  location: class org.apache.commons.math.linear.Array2DRowRealMatrix]
Ingredient counter is Zero
---Undoing: gnrtn(44): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double[][] outData = new double[nRows][nCols] ` -topatch--> `final double[][] out = new double[nRows][this.getColumnDimension()]` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (87(f=1.0), 88(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (87(f=1.0), )
----------Running generation: 45, population size: 1

***** Generation 45 : 0
**Parent Variant: [Variant id: 89, #gens: 382, #ops: 0, parent:-]

--Child created id: 90
--Creating new operations for variant [Variant id: 90, #gens: 382, #ops: 0, parent:89]
---analyzing modificationPoint position: 258
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  tType = -2
---analyzing modificationPoint position: 167
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 1 not mutation generated in  final double eiM1 = secondary[(index + i) - 1]
---analyzing modificationPoint position: 293
location: EigenDecompositionImpl.java575
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `upperSpectra = java.lang.Double.NEGATIVE_INFINITY ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 90, #gens: 381, #ops: 1, parent:89] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 90
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-90/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(45): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `upperSpectra = java.lang.Double.NEGATIVE_INFINITY ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (89(f=1.0), 90(f=1.0), )
Selected to next generation: IDs2--> (89(f=1.0), )
----------Running generation: 46, population size: 1

***** Generation 46 : 0
**Parent Variant: [Variant id: 91, #gens: 382, #ops: 0, parent:-]

--Child created id: 92
--Creating new operations for variant [Variant id: 92, #gens: 382, #ops: 0, parent:91]
---analyzing modificationPoint position: 68
location: EigenDecompositionImpl.java875
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 92, #gens: 381, #ops: 1, parent:91] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 92
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-92/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 17] ,[]
-Valid?: |false|3|17|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(46): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (91(f=1.0), 92(f=3.0), )
Selected to next generation: IDs2--> (91(f=1.0), )
----------Running generation: 47, population size: 1

***** Generation 47 : 0
**Parent Variant: [Variant id: 93, #gens: 382, #ops: 0, parent:-]

--Child created id: 94
--Creating new operations for variant [Variant id: 94, #gens: 382, #ops: 0, parent:93]
---analyzing modificationPoint position: 203
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2])
---analyzing modificationPoint position: 256
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tau]
--> var from patch: tau spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1458
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if ((gap1 > 0.0) && (gap1 > b1)) { 	tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin); 	[...] ` -topatch--> `// the shift was good updateSigma(tau)` (spoon.support.reflect.code.CtInvocationImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1458, pointed element: CtInvocationImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if ((gap1 > 0.0) && (gap1 > b1)) { 	tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin); 	[...] ` -topatch--> `// the shift was good updateSigma(tau)` (spoon.support.reflect.code.CtInvocationImpl) 

--Summary Creation: for variant [Variant id: 94, #gens: 383, #ops: 1, parent:93] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 94
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-94/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(47): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if ((gap1 > 0.0) && (gap1 > b1)) { 	tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin); 	[...] ` -topatch--> `// the shift was good updateSigma(tau)` (spoon.support.reflect.code.CtInvocationImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (93(f=1.0), 94(f=1.0), )
Selected to next generation: IDs2--> (93(f=1.0), )
----------Running generation: 48, population size: 1

***** Generation 48 : 0
**Parent Variant: [Variant id: 95, #gens: 382, #ops: 0, parent:-]

--Child created id: 96
--Creating new operations for variant [Variant id: 96, #gens: 382, #ops: 0, parent:95]
---analyzing modificationPoint position: 250
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 0 not mutation generated in  double b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5])
---analyzing modificationPoint position: 94
Templates availables26
Attempts Base Ingredients  1 total 26
---modifPoint 1 not mutation generated in  d *= tmp
---analyzing modificationPoint position: 151
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 2 not mutation generated in  if (countEigenValues(middle, index, n) >= n) { 	right = middle; } else { 	left = middle; }
---analyzing modificationPoint position: 340
location: Array2DRowRealMatrix.java484
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `visitor.start(rows, columns, 0, rows - 1, 0, columns - 1) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 96, #gens: 381, #ops: 1, parent:95] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 96
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-96/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(48): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `visitor.start(rows, columns, 0, rows - 1, 0, columns - 1) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (95(f=1.0), 96(f=1.0), )
Selected to next generation: IDs2--> (95(f=1.0), )
----------Running generation: 49, population size: 1

***** Generation 49 : 0
**Parent Variant: [Variant id: 97, #gens: 382, #ops: 0, parent:-]

--Child created id: 98
--Creating new operations for variant [Variant id: 98, #gens: 382, #ops: 0, parent:97]
---analyzing modificationPoint position: 96
location: EigenDecompositionImpl.java973
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// from ping to pong pingPong = 1 - pingPong ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 98, #gens: 381, #ops: 1, parent:97] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 98
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-98/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 17] ,[]
-Valid?: |false|3|17|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(49): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// from ping to pong pingPong = 1 - pingPong ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (97(f=1.0), 98(f=3.0), )
Selected to next generation: IDs2--> (97(f=1.0), )
----------Running generation: 50, population size: 1

***** Generation 50 : 0
**Parent Variant: [Variant id: 99, #gens: 382, #ops: 0, parent:-]

--Child created id: 100
--Creating new operations for variant [Variant id: 100, #gens: 382, #ops: 0, parent:99]
---analyzing modificationPoint position: 273
---modifPoint 0 not mutation generated in  final double lower = dCurrent - radius
---analyzing modificationPoint position: 142
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [transformer]
--> var from patch: transformer spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1190
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `left = middle ` -topatch--> `transformer = null` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1190, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `left = middle ` -topatch--> `transformer = null` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 100, #gens: 383, #ops: 1, parent:99] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 100
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-100/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 17] ,[]
-Valid?: |false|3|17|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(50): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `left = middle ` -topatch--> `transformer = null` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (99(f=1.0), 100(f=3.0), )
Selected to next generation: IDs2--> (99(f=1.0), )
----------Running generation: 51, population size: 1

***** Generation 51 : 0
**Parent Variant: [Variant id: 101, #gens: 382, #ops: 0, parent:-]

--Child created id: 102
--Creating new operations for variant [Variant id: 102, #gens: 382, #ops: 0, parent:101]
---analyzing modificationPoint position: 296
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  for (int i = 0; i < (m - 1); ++i) {  	final double dCurrent = main[i]; 	final double ePrevious = eCu[...]
---analyzing modificationPoint position: 208
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 1 not mutation generated in  eMin = work[((4 * start) + pingPong) + 4]
---analyzing modificationPoint position: 326
---modifPoint 2 not mutation generated in  double sum = 0
---analyzing modificationPoint position: 97
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 3 not mutation generated in  g = 0.0
---analyzing modificationPoint position: 276
---modifPoint 4 not mutation generated in  final double upper = dCurrent + radius
---analyzing modificationPoint position: 360
Templates availables281
Attempts Base Ingredients  1 total 281
---modifPoint 5 not mutation generated in  data = d.clone()
---analyzing modificationPoint position: 216
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 6 not mutation generated in  final double tmp = work[j4 + 1] / work[j4 - 2]
---analyzing modificationPoint position: 11
location: EigenDecompositionImpl.java1507
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `b1 = b2 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 102, #gens: 381, #ops: 1, parent:101] gen mutated: 1 , gen not mut: 7, gen not applied  0
-The child compiles: id 102
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-102/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(51): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `b1 = b2 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (101(f=1.0), 102(f=1.0), )
Selected to next generation: IDs2--> (101(f=1.0), )
----------Running generation: 52, population size: 1

***** Generation 52 : 0
**Parent Variant: [Variant id: 103, #gens: 382, #ops: 0, parent:-]

--Child created id: 104
--Creating new operations for variant [Variant id: 104, #gens: 382, #ops: 0, parent:103]
---analyzing modificationPoint position: 152
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1210
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `right = middle ` -topatch--> `// compute the Gershgorin circles computeGershgorinCircles()` (spoon.support.reflect.code.CtInvocationImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1210, pointed element: CtInvocationImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `right = middle ` -topatch--> `// compute the Gershgorin circles computeGershgorinCircles()` (spoon.support.reflect.code.CtInvocationImpl) 

--Summary Creation: for variant [Variant id: 104, #gens: 383, #ops: 1, parent:103] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 104
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-104/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(52): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `right = middle ` -topatch--> `// compute the Gershgorin circles computeGershgorinCircles()` (spoon.support.reflect.code.CtInvocationImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (103(f=1.0), 104(f=1.0), )
Selected to next generation: IDs2--> (103(f=1.0), )
----------Running generation: 53, population size: 1

***** Generation 53 : 0
**Parent Variant: [Variant id: 105, #gens: 382, #ops: 0, parent:-]

--Child created id: 106
--Creating new operations for variant [Variant id: 106, #gens: 382, #ops: 0, parent:105]
---analyzing modificationPoint position: 247
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 0 not mutation generated in  // a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...]
---analyzing modificationPoint position: 76
location: EigenDecompositionImpl.java888
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (k >= maxIter) { 	throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 106, #gens: 381, #ops: 1, parent:105] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 106
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-106/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(53): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (k >= maxIter) { 	throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (105(f=1.0), 106(f=1.0), )
Selected to next generation: IDs2--> (105(f=1.0), )
----------Running generation: 54, population size: 1

***** Generation 54 : 0
**Parent Variant: [Variant id: 107, #gens: 382, #ops: 0, parent:-]

--Child created id: 108
--Creating new operations for variant [Variant id: 108, #gens: 382, #ops: 0, parent:107]
---analyzing modificationPoint position: 235
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  work[j4 - 2] = dN1 + work[j4p2]
---analyzing modificationPoint position: 44
location: EigenDecompositionImpl.java833
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (sumOffDiag == 0) { 	// matrix is already diagonal 	return; } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 108, #gens: 381, #ops: 1, parent:107] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 108
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-108/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(54): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (sumOffDiag == 0) { 	// matrix is already diagonal 	return; } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (107(f=1.0), 108(f=1.0), )
Selected to next generation: IDs2--> (107(f=1.0), )
----------Running generation: 55, population size: 1

***** Generation 55 : 0
**Parent Variant: [Variant id: 109, #gens: 382, #ops: 0, parent:-]

--Child created id: 110
--Creating new operations for variant [Variant id: 110, #gens: 382, #ops: 0, parent:109]
---analyzing modificationPoint position: 270
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  eCurrent = java.lang.Math.abs(secondary[i])
---analyzing modificationPoint position: 287
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  // compute the Gershgorin circles computeGershgorinCircles()
---analyzing modificationPoint position: 181
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [g]
--> var from patch: g spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1283
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = java.lang.Math.min(dMin, d) ` -topatch--> `g = 0.25` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1283, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = java.lang.Math.min(dMin, d) ` -topatch--> `g = 0.25` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 110, #gens: 382, #ops: 1, parent:109] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 110, errors: [EigenDecompositionImpl.java:1579: error: illegal start of expression
	 * Perform a dqd step.
	 ^, EigenDecompositionImpl.java:1579: error: ';' expected
	 * Perform a dqd step.
	          ^, EigenDecompositionImpl.java:1579: error: ';' expected
	 * Perform a dqd step.
	                ^, EigenDecompositionImpl.java:1579: error: <identifier> expected
	 * Perform a dqd step.
	                      ^, EigenDecompositionImpl.java:1580: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	      ^, EigenDecompositionImpl.java:1580: error: not a statement
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	 ^, EigenDecompositionImpl.java:1580: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                            ^, EigenDecompositionImpl.java:1580: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                          ^, EigenDecompositionImpl.java:1580: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                 ^, EigenDecompositionImpl.java:1580: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                ^, EigenDecompositionImpl.java:1580: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                         ^, EigenDecompositionImpl.java:1580: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                           ^, EigenDecompositionImpl.java:1582: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1582: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1583: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1583: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1584: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1585: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1585: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1586: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	  ^, EigenDecompositionImpl.java:1586: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	^, EigenDecompositionImpl.java:1586: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	        ^, EigenDecompositionImpl.java:1586: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                ^, EigenDecompositionImpl.java:1586: error: <identifier> expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                 ^, EigenDecompositionImpl.java:1586: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                               ^, EigenDecompositionImpl.java:1587: error: illegal start of expression
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	 ^, EigenDecompositionImpl.java:1587: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	          ^, EigenDecompositionImpl.java:1587: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                    ^, EigenDecompositionImpl.java:1587: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                 ^, EigenDecompositionImpl.java:1587: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                             ^, EigenDecompositionImpl.java:1587: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                    ^, EigenDecompositionImpl.java:1587: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                                        ^, EigenDecompositionImpl.java:1588: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	      ^, EigenDecompositionImpl.java:1588: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                            ^, EigenDecompositionImpl.java:1588: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                          ^, EigenDecompositionImpl.java:1588: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                 ^, EigenDecompositionImpl.java:1588: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                ^, EigenDecompositionImpl.java:1588: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                         ^, EigenDecompositionImpl.java:1588: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                           ^, EigenDecompositionImpl.java:1590: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1590: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1591: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1591: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1592: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1593: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1593: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1594: error: illegal start of expression
	 * @param deflated
	   ^, EigenDecompositionImpl.java:1595: error: not a statement
	 * 		number of realEigenvalues just deflated
	 ^, EigenDecompositionImpl.java:1595: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		      ^, EigenDecompositionImpl.java:1595: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                         ^, EigenDecompositionImpl.java:1595: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                                       ^, EigenDecompositionImpl.java:1596: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	^, EigenDecompositionImpl.java:1596: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	        ^, EigenDecompositionImpl.java:1596: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                  ^, EigenDecompositionImpl.java:1596: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                   ^, EigenDecompositionImpl.java:1596: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                  ^, EigenDecompositionImpl.java:1596: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                                     ^, EigenDecompositionImpl.java:1619: error: 'else' without 'if'
				} else {
				  ^, EigenDecompositionImpl.java:1630: error: orphaned case
			case 2 : 				// two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.
			^]
Ingredient counter is Zero
---Undoing: gnrtn(55): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = java.lang.Math.min(dMin, d) ` -topatch--> `g = 0.25` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (109(f=1.0), 110(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (109(f=1.0), )
----------Running generation: 56, population size: 1

***** Generation 56 : 0
**Parent Variant: [Variant id: 111, #gens: 382, #ops: 0, parent:-]

--Child created id: 112
--Creating new operations for variant [Variant id: 112, #gens: 382, #ops: 0, parent:111]
---analyzing modificationPoint position: 164
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  work[0] = java.lang.Math.abs(di)
---analyzing modificationPoint position: 260
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 1 not mutation generated in  // BEWARE: do NOT attempt to simplify the following statements // the expressions below take care to[...]
---analyzing modificationPoint position: 90
Templates availables78
Attempts Base Ingredients  1 total 78
vars from patch [dMin1, tau, dMin, org.apache.commons.math.util.MathUtils.EPSILON, tType]
--> var from patch: dMin1 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: org.apache.commons.math.util.MathUtils.EPSILON spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java955
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 	work[i] =[...] ` -topatch--> `if (dMin1 > 0.0) { 	// late failure. Gives excellent shift. 	tau = (tau + dMin) * (1.0 - (2.0 * org.[...]` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 955, pointed element: CtIfImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 	work[i] =[...] ` -topatch--> `if (dMin1 > 0.0) { 	// late failure. Gives excellent shift. 	tau = (tau + dMin) * (1.0 - (2.0 * org.[...]` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 112, #gens: 382, #ops: 1, parent:111] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 112, errors: [EigenDecompositionImpl.java:1108: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1108: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1108: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1108: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1108: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1108: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1108: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1109: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^, EigenDecompositionImpl.java:1109: error: not a statement
	 * <p>This implementation is based on Beresford N. Parlett
	 ^, EigenDecompositionImpl.java:1109: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                            ^, EigenDecompositionImpl.java:1109: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                     ^, EigenDecompositionImpl.java:1109: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                                 ^, EigenDecompositionImpl.java:1110: error: not a statement
	 * and Osni A. Marques paper <a
	 ^, EigenDecompositionImpl.java:1110: error: ';' expected
	 * and Osni A. Marques paper <a
	      ^, EigenDecompositionImpl.java:1110: error: ';' expected
	 * and Osni A. Marques paper <a
	             ^, EigenDecompositionImpl.java:1110: error: ';' expected
	 * and Osni A. Marques paper <a
	                            ^, EigenDecompositionImpl.java:1111: error: > expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	 ^, EigenDecompositionImpl.java:1111: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	  ^, EigenDecompositionImpl.java:1111: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	       ^, EigenDecompositionImpl.java:1111: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	        ^, EigenDecompositionImpl.java:1111: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                           ^, EigenDecompositionImpl.java:1111: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                              ^, EigenDecompositionImpl.java:1112: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                    ^, EigenDecompositionImpl.java:1112: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                             ^, EigenDecompositionImpl.java:1112: error: ')' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                 ^, EigenDecompositionImpl.java:1112: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                      ^, EigenDecompositionImpl.java:1112: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                        ^, EigenDecompositionImpl.java:1112: error: not a statement
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                          ^, EigenDecompositionImpl.java:1112: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                               ^, EigenDecompositionImpl.java:1112: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                                      ^, EigenDecompositionImpl.java:1113: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                       ^, EigenDecompositionImpl.java:1113: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                      ^, EigenDecompositionImpl.java:1113: error: illegal start of type
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                        ^, EigenDecompositionImpl.java:1113: error: illegal start of expression
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                         ^, EigenDecompositionImpl.java:1114: error: illegal start of expression
	 *
	 ^, EigenDecompositionImpl.java:1115: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1115: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1113: error: not a statement
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                          ^, EigenDecompositionImpl.java:1116: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1117: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1118: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1118: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1119: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1119: error: not a statement
	 * @return new end (maybe deflated)
	 ^, EigenDecompositionImpl.java:1119: error: ';' expected
	 * @return new end (maybe deflated)
	              ^, EigenDecompositionImpl.java:1119: error: -> expected
	 * @return new end (maybe deflated)
	                                   ^, EigenDecompositionImpl.java:1120: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	 ^, EigenDecompositionImpl.java:1120: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	^, EigenDecompositionImpl.java:1119: error: not a statement
	 * @return new end (maybe deflated)
	                   ^, EigenDecompositionImpl.java:1120: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                    ^, EigenDecompositionImpl.java:1120: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                     ^, EigenDecompositionImpl.java:1120: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                                   ^, EigenDecompositionImpl.java:1127: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1127: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1127: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1127: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1127: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1129: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1129: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1130: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1130: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1130: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1130: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1131: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1132: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1132: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1132: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1132: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1132: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1132: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1132: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1132: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1133: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1133: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1133: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1133: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1133: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1133: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1133: error: ';' expected
	 * 		only every other element)
	   		                        ^, EigenDecompositionImpl.java:1134: error: <identifier> expected
	 * @return true if qd array was flipped
	    ^, EigenDecompositionImpl.java:1134: error: <identifier> expected
	 * @return true if qd array was flipped
	          ^, EigenDecompositionImpl.java:1134: error: ';' expected
	 * @return true if qd array was flipped
	               ^, EigenDecompositionImpl.java:1134: error: ';' expected
	 * @return true if qd array was flipped
	                           ^, EigenDecompositionImpl.java:1134: error: ';' expected
	 * @return true if qd array was flipped
	                                       ^, EigenDecompositionImpl.java:1135: error: illegal start of expression
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1;
	    	^, EigenDecompositionImpl.java:1135: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1;
	    	                               ^, EigenDecompositionImpl.java:1135: error: <identifier> expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1;
	    	                                            ^, EigenDecompositionImpl.java:1135: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1;
	    	                                                           ^, EigenDecompositionImpl.java:1157: error: illegal start of expression
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	^, EigenDecompositionImpl.java:1157: error: ';' expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                 ^, EigenDecompositionImpl.java:1157: error: <identifier> expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                                  ^, EigenDecompositionImpl.java:1157: error: ';' expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                                              ^, EigenDecompositionImpl.java:1233: error: illegal start of expression
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	^, EigenDecompositionImpl.java:1233: error: ';' expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                            ^, EigenDecompositionImpl.java:1233: error: <identifier> expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                            ^, EigenDecompositionImpl.java:1233: error: <identifier> expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                                             ^, EigenDecompositionImpl.java:1233: error: ';' expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                                                         ^, EigenDecompositionImpl.java:1256: error: illegal start of expression
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	^, EigenDecompositionImpl.java:1256: error: illegal start of expression
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	        ^, EigenDecompositionImpl.java:1256: error: ';' expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                              ^]
Ingredient counter is Zero
---Undoing: gnrtn(56): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 	work[i] =[...] ` -topatch--> `if (dMin1 > 0.0) { 	// late failure. Gives excellent shift. 	tau = (tau + dMin) * (1.0 - (2.0 * org.[...]` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (111(f=1.0), 112(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (111(f=1.0), )
----------Running generation: 57, population size: 1

***** Generation 57 : 0
**Parent Variant: [Variant id: 113, #gens: 382, #ops: 0, parent:-]

--Child created id: 114
--Creating new operations for variant [Variant id: 114, #gens: 382, #ops: 0, parent:113]
---analyzing modificationPoint position: 14
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [dMin, dN]
--> var from patch: dMin spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dN spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1512
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `a2 = a2 + b2 ` -topatch--> `dMin = java.lang.Math.min(dMin, dN)` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1512, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `a2 = a2 + b2 ` -topatch--> `dMin = java.lang.Math.min(dMin, dN)` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 114, #gens: 382, #ops: 1, parent:113] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 114
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-114/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(57): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `a2 = a2 + b2 ` -topatch--> `dMin = java.lang.Math.min(dMin, dN)` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (113(f=1.0), 114(f=1.0), )
Selected to next generation: IDs2--> (113(f=1.0), )
----------Running generation: 58, population size: 1

***** Generation 58 : 0
**Parent Variant: [Variant id: 115, #gens: 382, #ops: 0, parent:-]

--Child created id: 116
--Creating new operations for variant [Variant id: 116, #gens: 382, #ops: 0, parent:115]
---analyzing modificationPoint position: 36
---modifPoint 0 not mutation generated in  final double s = secondary[i]
---analyzing modificationPoint position: 232
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 1 not mutation generated in  dMin1 = dMin
---analyzing modificationPoint position: 215
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 2 not mutation generated in  if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) &&  ((org.apac[...]
---analyzing modificationPoint position: 10
location: EigenDecompositionImpl.java1504
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (b2 == 0.0) { 	break; } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 116, #gens: 381, #ops: 1, parent:115] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 116
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-116/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(58): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (b2 == 0.0) { 	break; } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (115(f=1.0), 116(f=1.0), )
Selected to next generation: IDs2--> (115(f=1.0), )
----------Running generation: 59, population size: 1

***** Generation 59 : 0
**Parent Variant: [Variant id: 117, #gens: 382, #ops: 0, parent:-]

--Child created id: 118
--Creating new operations for variant [Variant id: 118, #gens: 382, #ops: 0, parent:117]
---analyzing modificationPoint position: 78
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  pingPong = 1 - pingPong
---analyzing modificationPoint position: 134
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  double right = upper + margin
---analyzing modificationPoint position: 141
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  right = middle
---analyzing modificationPoint position: 218
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tau, dMin1]
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dMin1 spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1346
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `d *= tmp ` -topatch--> `// case 9. tau = 0.25 * dMin1` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1346, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `d *= tmp ` -topatch--> `// case 9. tau = 0.25 * dMin1` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 118, #gens: 383, #ops: 1, parent:117] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child does NOT compile: 118, errors: [EigenDecompositionImpl.java:1623: error: illegal start of expression
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	 ^, EigenDecompositionImpl.java:1623: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	          ^, EigenDecompositionImpl.java:1623: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                    ^, EigenDecompositionImpl.java:1623: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                 ^, EigenDecompositionImpl.java:1623: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                             ^, EigenDecompositionImpl.java:1623: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                    ^, EigenDecompositionImpl.java:1623: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                                        ^, EigenDecompositionImpl.java:1624: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	      ^, EigenDecompositionImpl.java:1624: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                            ^, EigenDecompositionImpl.java:1624: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                          ^, EigenDecompositionImpl.java:1624: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                 ^, EigenDecompositionImpl.java:1624: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                ^, EigenDecompositionImpl.java:1624: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                         ^, EigenDecompositionImpl.java:1624: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                           ^, EigenDecompositionImpl.java:1626: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1626: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1627: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1627: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1628: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1629: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1629: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1630: error: illegal start of expression
	 * @param deflated
	   ^, EigenDecompositionImpl.java:1631: error: not a statement
	 * 		number of realEigenvalues just deflated
	 ^, EigenDecompositionImpl.java:1631: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		      ^, EigenDecompositionImpl.java:1631: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                         ^, EigenDecompositionImpl.java:1631: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                                       ^, EigenDecompositionImpl.java:1632: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	^, EigenDecompositionImpl.java:1632: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	        ^, EigenDecompositionImpl.java:1632: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                  ^, EigenDecompositionImpl.java:1632: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                   ^, EigenDecompositionImpl.java:1632: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                  ^, EigenDecompositionImpl.java:1632: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                                     ^, EigenDecompositionImpl.java:1668: error: orphaned default
			default : 				// case 12, more than two realEigenvalues deflated. no information.
			^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                                           ^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	        ^, EigenDecompositionImpl.java:1698: error: ';' expected
	private void findEigenVectors() {
	                             ^, EigenDecompositionImpl.java:1736: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                      ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                               ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                  ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                    ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                      ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                                          ^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	        ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                   ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                     ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                       ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                                           ^, EigenDecompositionImpl.java:1843: error: reached end of file while parsing
}
 ^]
Ingredient counter is Zero
---Undoing: gnrtn(59): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `d *= tmp ` -topatch--> `// case 9. tau = 0.25 * dMin1` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (117(f=1.0), 118(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (117(f=1.0), )
----------Running generation: 60, population size: 1

***** Generation 60 : 0
**Parent Variant: [Variant id: 119, #gens: 382, #ops: 0, parent:-]

--Child created id: 120
--Creating new operations for variant [Variant id: 120, #gens: 382, #ops: 0, parent:119]
---analyzing modificationPoint position: 115
Templates availables19
Attempts Base Ingredients  1 total 19
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 0 not mutation generated in  // the shift was good updateSigma(tau)
---analyzing modificationPoint position: 333
Templates availables216
Attempts Base Ingredients  1 total 216
---modifPoint 1 not mutation generated in  final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows)
---analyzing modificationPoint position: 211
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 2 not mutation generated in  if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 		work[j4 - 2][...]
---analyzing modificationPoint position: 314
Templates availables19
Attempts Base Ingredients  1 total 19
vars from patch []
location: EigenDecompositionImpl.java707
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `list.add(secondary.length + 1) ` -topatch--> `// find all the realEigenvalues findEigenvalues()` (spoon.support.reflect.code.CtInvocationImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 707, pointed element: CtInvocationImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `list.add(secondary.length + 1) ` -topatch--> `// find all the realEigenvalues findEigenvalues()` (spoon.support.reflect.code.CtInvocationImpl) 

--Summary Creation: for variant [Variant id: 120, #gens: 382, #ops: 1, parent:119] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 120
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-120/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 16, was successful: false, cases executed: 17] ,[]
-Valid?: |false|16|17|[]|, fitness 16.0
Ingredient counter is Zero
---Undoing: gnrtn(60): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `list.add(secondary.length + 1) ` -topatch--> `// find all the realEigenvalues findEigenvalues()` (spoon.support.reflect.code.CtInvocationImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (119(f=1.0), 120(f=16.0), )
Selected to next generation: IDs2--> (119(f=1.0), )
----------Running generation: 61, population size: 1

***** Generation 61 : 0
**Parent Variant: [Variant id: 121, #gens: 382, #ops: 0, parent:-]

--Child created id: 122
--Creating new operations for variant [Variant id: 122, #gens: 382, #ops: 0, parent:121]
---analyzing modificationPoint position: 215
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [pingPong, start, j4, end, work, d, dMin, eMin, org.apache.commons.math.util.MathUtils.SAFE_MIN, tmp]
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: start spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: j4 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: end spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: d spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: dMin spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: eMin spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: org.apache.commons.math.util.MathUtils.SAFE_MIN spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: tmp spoon.support.reflect.code.CtVariableReadImpl
location: EigenDecompositionImpl.java1342
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) &&  ((org.apac[...] ` -topatch--> `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 		work[j4 - 2][...]` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1342, pointed element: CtIfImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) &&  ((org.apac[...] ` -topatch--> `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 		work[j4 - 2][...]` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 122, #gens: 383, #ops: 1, parent:121] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 122, errors: [EigenDecompositionImpl.java:1343: error: variable j4 is already defined in method dqd(int,int)
				} else { 					if (pingPong == 0) { 						for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 							work[j4 - 2] = d + work[j4 - 1]; 							if (work[j4 - 2] == 0.0) { 								work[j4] = 0.0; 								d = work[j4 + 1]; 								dMin = d; 								eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && 
				         					                     						         ^, EigenDecompositionImpl.java:1356: error: variable j4 is already defined in method dqd(int,int)
						for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) {
						         ^]
Ingredient counter is Zero
---Undoing: gnrtn(61): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) &&  ((org.apac[...] ` -topatch--> `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 		work[j4 - 2][...]` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (121(f=1.0), 122(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (121(f=1.0), )
----------Running generation: 62, population size: 1

***** Generation 62 : 0
**Parent Variant: [Variant id: 123, #gens: 382, #ops: 0, parent:-]

--Child created id: 124
--Creating new operations for variant [Variant id: 124, #gens: 382, #ops: 0, parent:123]
---analyzing modificationPoint position: 308
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java621
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForEachImpl) `for (final int end : splitIndices) { 	final int n = end - begin; 	switch (n) {  		case 1 : 			// app[...] ` -topatch--> `// process split segments int i0 = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 621, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForEachImpl) `for (final int end : splitIndices) { 	final int n = end - begin; 	switch (n) {  		case 1 : 			// app[...] ` -topatch--> `// process split segments int i0 = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 124, #gens: 383, #ops: 1, parent:123] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 124, errors: [EigenDecompositionImpl.java:857: error: illegal start of expression
	 * Compute splitting points.
	 ^, EigenDecompositionImpl.java:857: error: ';' expected
	 * Compute splitting points.
	          ^, EigenDecompositionImpl.java:857: error: ';' expected
	 * Compute splitting points.
	                           ^, EigenDecompositionImpl.java:859: error: <identifier> expected
	 * @return list of indices after matrix can be split
	    ^, EigenDecompositionImpl.java:859: error: ';' expected
	 * @return list of indices after matrix can be split
	               ^, EigenDecompositionImpl.java:859: error: ';' expected
	 * @return list of indices after matrix can be split
	                          ^, EigenDecompositionImpl.java:859: error: ';' expected
	 * @return list of indices after matrix can be split
	                                       ^, EigenDecompositionImpl.java:859: error: ';' expected
	 * @return list of indices after matrix can be split
	                                              ^, EigenDecompositionImpl.java:860: error: illegal start of expression
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	  ^, EigenDecompositionImpl.java:860: error: illegal start of expression
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	^, EigenDecompositionImpl.java:860: error: ';' expected
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	                                                       ^, EigenDecompositionImpl.java:861: error: illegal start of expression
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:861: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	       ^, EigenDecompositionImpl.java:861: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	                     ^, EigenDecompositionImpl.java:861: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	                             ^, EigenDecompositionImpl.java:861: error: not a statement
	 * Find eigenvalue in a block with 1 row.
	                              ^, EigenDecompositionImpl.java:861: error: ';' expected
	 * Find eigenvalue in a block with 1 row.
	                                  ^, EigenDecompositionImpl.java:861: error: <identifier> expected
	 * Find eigenvalue in a block with 1 row.
	                                         ^, EigenDecompositionImpl.java:862: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	      ^, EigenDecompositionImpl.java:862: error: not a statement
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	 ^, EigenDecompositionImpl.java:862: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                           ^, EigenDecompositionImpl.java:862: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                        ^, EigenDecompositionImpl.java:862: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                           ^, EigenDecompositionImpl.java:862: error: illegal start of type
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                        ^, EigenDecompositionImpl.java:862: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                          ^, EigenDecompositionImpl.java:864: error: illegal start of expression
	 * @param index
	 ^, EigenDecompositionImpl.java:864: error: illegal start of expression
	 * @param index
	   ^, EigenDecompositionImpl.java:865: error: not a statement
	 * 		index of the first row of the block
	 ^, EigenDecompositionImpl.java:865: error: ';' expected
	 * 		index of the first row of the block
	   		     ^, EigenDecompositionImpl.java:865: error: ';' expected
	 * 		index of the first row of the block
	   		            ^, EigenDecompositionImpl.java:865: error: ';' expected
	 * 		index of the first row of the block
	   		                      ^, EigenDecompositionImpl.java:865: error: ';' expected
	 * 		index of the first row of the block
	   		                             ^, EigenDecompositionImpl.java:866: error: illegal start of expression
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	  ^, EigenDecompositionImpl.java:866: error: illegal start of expression
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	^, EigenDecompositionImpl.java:866: error: illegal start of expression
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	        ^, EigenDecompositionImpl.java:866: error: ';' expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                             ^, EigenDecompositionImpl.java:866: error: ';' expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                             ^, EigenDecompositionImpl.java:874: error: illegal start of expression
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	^, EigenDecompositionImpl.java:874: error: illegal start of expression
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	        ^, EigenDecompositionImpl.java:874: error: ';' expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                              ^, EigenDecompositionImpl.java:874: error: ';' expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                              ^, EigenDecompositionImpl.java:874: error: not a statement
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                                                                     ^, EigenDecompositionImpl.java:874: error: ';' expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                                                                                            ^, EigenDecompositionImpl.java:875: error: illegal start of expression
	 * Find realEigenvalues in a block with 3 rows.
	 ^, EigenDecompositionImpl.java:875: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	       ^, EigenDecompositionImpl.java:875: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                          ^, EigenDecompositionImpl.java:875: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                                  ^, EigenDecompositionImpl.java:875: error: not a statement
	 * Find realEigenvalues in a block with 3 rows.
	                                   ^, EigenDecompositionImpl.java:875: error: ';' expected
	 * Find realEigenvalues in a block with 3 rows.
	                                       ^, EigenDecompositionImpl.java:875: error: <identifier> expected
	 * Find realEigenvalues in a block with 3 rows.
	                                               ^, EigenDecompositionImpl.java:876: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	      ^, EigenDecompositionImpl.java:876: error: not a statement
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	 ^, EigenDecompositionImpl.java:876: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                           ^, EigenDecompositionImpl.java:876: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                        ^, EigenDecompositionImpl.java:876: error: ';' expected
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                           ^, EigenDecompositionImpl.java:876: error: illegal start of type
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                        ^, EigenDecompositionImpl.java:876: error: illegal start of expression
	 * <p>In low dimensions, we simply solve the characteristic polynomial.</p>
	                                                                          ^, EigenDecompositionImpl.java:878: error: illegal start of expression
	 * @param index
	 ^, EigenDecompositionImpl.java:878: error: illegal start of expression
	 * @param index
	   ^, EigenDecompositionImpl.java:879: error: not a statement
	 * 		index of the first row of the block
	 ^, EigenDecompositionImpl.java:879: error: ';' expected
	 * 		index of the first row of the block
	   		     ^, EigenDecompositionImpl.java:879: error: ';' expected
	 * 		index of the first row of the block
	   		            ^, EigenDecompositionImpl.java:879: error: ';' expected
	 * 		index of the first row of the block
	   		                      ^, EigenDecompositionImpl.java:879: error: ';' expected
	 * 		index of the first row of the block
	   		                             ^, EigenDecompositionImpl.java:880: error: illegal start of expression
	 * @exception InvalidMatrixException
	   ^, EigenDecompositionImpl.java:881: error: illegal start of expression
	 * 		if diagonal elements are not positive
	   		^, EigenDecompositionImpl.java:881: error: not a statement
	 * 		if diagonal elements are not positive
	 ^, EigenDecompositionImpl.java:881: error: ';' expected
	 * 		if diagonal elements are not positive
	   		                    ^, EigenDecompositionImpl.java:881: error: ';' expected
	 * 		if diagonal elements are not positive
	   		                            ^, EigenDecompositionImpl.java:882: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	  ^, EigenDecompositionImpl.java:882: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	^, EigenDecompositionImpl.java:882: error: illegal start of expression
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	        ^, EigenDecompositionImpl.java:882: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                              ^, EigenDecompositionImpl.java:882: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                              ^, EigenDecompositionImpl.java:882: error: not a statement
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                                                                     ^, EigenDecompositionImpl.java:882: error: ';' expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                                                                                            ^, EigenDecompositionImpl.java:896: error: illegal start of expression
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	^, EigenDecompositionImpl.java:896: error: illegal start of expression
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	        ^, EigenDecompositionImpl.java:896: error: ';' expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                ^, EigenDecompositionImpl.java:896: error: ';' expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                            ^, EigenDecompositionImpl.java:896: error: not a statement
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                                                                   ^, EigenDecompositionImpl.java:896: error: ';' expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                                                                                          ^, EigenDecompositionImpl.java:936: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) {
	    	        ^, EigenDecompositionImpl.java:936: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) {
	    	                                 ^, EigenDecompositionImpl.java:938: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		^, EigenDecompositionImpl.java:938: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		                ^, EigenDecompositionImpl.java:938: error: class, interface, or enum expected
		for (int k = 0; k < 2; ++k) {
		                       ^, EigenDecompositionImpl.java:942: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			^, EigenDecompositionImpl.java:942: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			                                       ^, EigenDecompositionImpl.java:942: error: class, interface, or enum expected
			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {
			                                               ^, EigenDecompositionImpl.java:945: error: class, interface, or enum expected
					d = work[i];
					^, EigenDecompositionImpl.java:946: error: class, interface, or enum expected
				} else {
				^, EigenDecompositionImpl.java:948: error: class, interface, or enum expected
				}
				^, EigenDecompositionImpl.java:953: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			^, EigenDecompositionImpl.java:953: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			                           ^, EigenDecompositionImpl.java:953: error: class, interface, or enum expected
			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {
			                                              ^, EigenDecompositionImpl.java:954: error: class, interface, or enum expected
				final int j = (i - (2 * pingPong)) - 1;
				      ^, EigenDecompositionImpl.java:955: error: class, interface, or enum expected
				work[j] = d + work[i];
				^, EigenDecompositionImpl.java:956: error: class, interface, or enum expected
				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {
				^, EigenDecompositionImpl.java:958: error: class, interface, or enum expected
					work[j] = d;
					^]
Ingredient counter is Zero
---Undoing: gnrtn(62): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForEachImpl) `for (final int end : splitIndices) { 	final int n = end - begin; 	switch (n) {  		case 1 : 			// app[...] ` -topatch--> `// process split segments int i0 = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (123(f=1.0), 124(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (123(f=1.0), )
----------Running generation: 63, population size: 1

***** Generation 63 : 0
**Parent Variant: [Variant id: 125, #gens: 382, #ops: 0, parent:-]

--Child created id: 126
--Creating new operations for variant [Variant id: 126, #gens: 382, #ops: 0, parent:125]
---analyzing modificationPoint position: 106
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  // no more realEigenvalues found, we need to iterate deflating = false
---analyzing modificationPoint position: 372
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 1 not mutation generated in  for (int i = 0; i < data.length; ++i) { 	if (subMatrix[i].length != nCols) { 		throw org.apache.comm[...]
---analyzing modificationPoint position: 314
Templates availables19
Attempts Base Ingredients  1 total 19
---modifPoint 2 not mutation generated in  list.add(secondary.length + 1)
---analyzing modificationPoint position: 281
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 3 not mutation generated in  final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent)
---analyzing modificationPoint position: 161
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1235
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtUnaryOperatorImpl) `++count ` -topatch--> `final double cnst3 = 1.05` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1235, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtUnaryOperatorImpl) `++count ` -topatch--> `final double cnst3 = 1.05` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 126, #gens: 383, #ops: 1, parent:125] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child does NOT compile: 126, errors: [EigenDecompositionImpl.java:1458: error: illegal start of expression
	 * Perform a dqd step.
	 ^, EigenDecompositionImpl.java:1458: error: ';' expected
	 * Perform a dqd step.
	          ^, EigenDecompositionImpl.java:1458: error: ';' expected
	 * Perform a dqd step.
	                ^, EigenDecompositionImpl.java:1458: error: <identifier> expected
	 * Perform a dqd step.
	                      ^, EigenDecompositionImpl.java:1459: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	      ^, EigenDecompositionImpl.java:1459: error: not a statement
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	 ^, EigenDecompositionImpl.java:1459: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                            ^, EigenDecompositionImpl.java:1459: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                          ^, EigenDecompositionImpl.java:1459: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                 ^, EigenDecompositionImpl.java:1459: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                ^, EigenDecompositionImpl.java:1459: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                         ^, EigenDecompositionImpl.java:1459: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                           ^, EigenDecompositionImpl.java:1461: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1461: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1462: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1462: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1463: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1464: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1464: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1465: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	  ^, EigenDecompositionImpl.java:1465: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	^, EigenDecompositionImpl.java:1465: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	        ^, EigenDecompositionImpl.java:1465: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                ^, EigenDecompositionImpl.java:1465: error: <identifier> expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                 ^, EigenDecompositionImpl.java:1465: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                               ^, EigenDecompositionImpl.java:1466: error: illegal start of expression
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	 ^, EigenDecompositionImpl.java:1466: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	          ^, EigenDecompositionImpl.java:1466: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                    ^, EigenDecompositionImpl.java:1466: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                 ^, EigenDecompositionImpl.java:1466: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                             ^, EigenDecompositionImpl.java:1466: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                    ^, EigenDecompositionImpl.java:1466: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                                        ^, EigenDecompositionImpl.java:1467: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	      ^, EigenDecompositionImpl.java:1467: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                            ^, EigenDecompositionImpl.java:1467: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                          ^, EigenDecompositionImpl.java:1467: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                 ^, EigenDecompositionImpl.java:1467: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                ^, EigenDecompositionImpl.java:1467: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                         ^, EigenDecompositionImpl.java:1467: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                           ^, EigenDecompositionImpl.java:1469: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1469: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1470: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1470: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1471: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1472: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1472: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1473: error: illegal start of expression
	 * @param deflated
	   ^, EigenDecompositionImpl.java:1474: error: not a statement
	 * 		number of realEigenvalues just deflated
	 ^, EigenDecompositionImpl.java:1474: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		      ^, EigenDecompositionImpl.java:1474: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                         ^, EigenDecompositionImpl.java:1474: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                                       ^, EigenDecompositionImpl.java:1475: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	^, EigenDecompositionImpl.java:1475: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	        ^, EigenDecompositionImpl.java:1475: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                  ^, EigenDecompositionImpl.java:1475: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                   ^, EigenDecompositionImpl.java:1475: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                  ^, EigenDecompositionImpl.java:1475: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                                     ^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                                           ^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	        ^, EigenDecompositionImpl.java:1698: error: ';' expected
	private void findEigenVectors() {
	                             ^, EigenDecompositionImpl.java:1736: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                      ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                               ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                  ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                    ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                      ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                                          ^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	        ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                   ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                     ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                       ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                                           ^, EigenDecompositionImpl.java:1843: error: reached end of file while parsing
}
 ^]
Ingredient counter is Zero
---Undoing: gnrtn(63): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtUnaryOperatorImpl) `++count ` -topatch--> `final double cnst3 = 1.05` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (125(f=1.0), 126(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (125(f=1.0), )
----------Running generation: 64, population size: 1

***** Generation 64 : 0
**Parent Variant: [Variant id: 127, #gens: 382, #ops: 0, parent:-]

--Child created id: 128
--Creating new operations for variant [Variant id: 128, #gens: 382, #ops: 0, parent:127]
---analyzing modificationPoint position: 137
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  if ((range < absoluteTolerance) ||  (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.[...]
---analyzing modificationPoint position: 271
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 1 not mutation generated in  eMax = java.lang.Math.max(eMax, eCurrent)
---analyzing modificationPoint position: 274
Templates availables241
Attempts Base Ingredients  1 total 241
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [main, transformer]
--> var from patch: main spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: transformer spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java588
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[lowerStart + i] = lower ` -topatch--> `main = transformer.getMainDiagonalRef()` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 588, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[lowerStart + i] = lower ` -topatch--> `main = transformer.getMainDiagonalRef()` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 128, #gens: 382, #ops: 1, parent:127] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 128
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-128/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 17] ,[]
-Valid?: |false|3|17|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(64): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[lowerStart + i] = lower ` -topatch--> `main = transformer.getMainDiagonalRef()` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (127(f=1.0), 128(f=3.0), )
Selected to next generation: IDs2--> (127(f=1.0), )
----------Running generation: 65, population size: 1

***** Generation 65 : 0
**Parent Variant: [Variant id: 129, #gens: 382, #ops: 0, parent:-]

--Child created id: 130
--Creating new operations for variant [Variant id: 130, #gens: 382, #ops: 0, parent:129]
---analyzing modificationPoint position: 354
Templates availables23
Attempts Base Ingredients  1 total 23
---modifPoint 0 not mutation generated in  final int nRows = d.length
---analyzing modificationPoint position: 288
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  // find all the realEigenvalues findEigenvalues()
---analyzing modificationPoint position: 136
---modifPoint 2 not mutation generated in  final double range = right - left
---analyzing modificationPoint position: 230
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [secondary, transformer]
--> var from patch: secondary spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: transformer spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1391
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dN1 = dN2 * tmp ` -topatch--> `secondary = transformer.getSecondaryDiagonalRef()` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1391, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dN1 = dN2 * tmp ` -topatch--> `secondary = transformer.getSecondaryDiagonalRef()` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 130, #gens: 383, #ops: 1, parent:129] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 130
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-130/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 2, was successful: false, cases executed: 17] ,[]
-Valid?: |false|2|17|[]|, fitness 2.0
Ingredient counter is Zero
---Undoing: gnrtn(65): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `dN1 = dN2 * tmp ` -topatch--> `secondary = transformer.getSecondaryDiagonalRef()` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (129(f=1.0), 130(f=2.0), )
Selected to next generation: IDs2--> (129(f=1.0), )
----------Running generation: 66, population size: 1

***** Generation 66 : 0
**Parent Variant: [Variant id: 131, #gens: 382, #ops: 0, parent:-]

--Child created id: 132
--Creating new operations for variant [Variant id: 132, #gens: 382, #ops: 0, parent:131]
---analyzing modificationPoint position: 159
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 0 not mutation generated in  ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t
---analyzing modificationPoint position: 165
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  for (int i = 1; i < n; ++i) { 	final int fourI = 4 * i; 	final double eiM1 = secondary[(index + i) -[...]
---analyzing modificationPoint position: 324
Templates availables23
Attempts Base Ingredients  1 total 23
---modifPoint 2 not mutation generated in  final double[] outDataRow = outData[row]
---analyzing modificationPoint position: 186
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 3 not mutation generated in  final double tmp = work[j4 + 2] / work[j4 - 3]
---analyzing modificationPoint position: 181
location: EigenDecompositionImpl.java1283
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = java.lang.Math.min(dMin, d) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 132, #gens: 381, #ops: 1, parent:131] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child compiles: id 132
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-132/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
-Killed id: pid->73983
The Process that runs JUnit test cases did not terminate within waitTime of 10 seconds
Killed the Process that runs JUnit test cases 73983
**The validation 1 have not finished well**
-Valid?: null, fitness 1.7976931348623157E308
Ingredient counter is Zero
---Undoing: gnrtn(66): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = java.lang.Math.min(dMin, d) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (131(f=1.0), 132(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (131(f=1.0), )
----------Running generation: 67, population size: 1

***** Generation 67 : 0
**Parent Variant: [Variant id: 133, #gens: 382, #ops: 0, parent:-]

--Child created id: 134
--Creating new operations for variant [Variant id: 134, #gens: 382, #ops: 0, parent:133]
---analyzing modificationPoint position: 235
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  work[j4 - 2] = dN1 + work[j4p2]
---analyzing modificationPoint position: 292
Templates availables241
Attempts Base Ingredients  1 total 241
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [cachedV, m]
--> var from patch: cachedV spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: m spoon.support.reflect.code.CtVariableReadImpl
location: EigenDecompositionImpl.java574
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 574, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 134, #gens: 382, #ops: 1, parent:133] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 134
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-134/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 6, was successful: false, cases executed: 17] ,[]
-Valid?: |false|6|17|[]|, fitness 6.0
Ingredient counter is Zero
---Undoing: gnrtn(67): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (133(f=1.0), 134(f=6.0), )
Selected to next generation: IDs2--> (133(f=1.0), )
----------Running generation: 68, population size: 1

***** Generation 68 : 0
**Parent Variant: [Variant id: 135, #gens: 382, #ops: 0, parent:-]

--Child created id: 136
--Creating new operations for variant [Variant id: 136, #gens: 382, #ops: 0, parent:135]
---analyzing modificationPoint position: 50
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  dN = 0
---analyzing modificationPoint position: 59
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  // find start of a new split segment to process double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) -[...]
---analyzing modificationPoint position: 178
location: EigenDecompositionImpl.java1280
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = d + work[j4 - 1] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 136, #gens: 381, #ops: 1, parent:135] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 136
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-136/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
-Killed id: pid->73987
The Process that runs JUnit test cases did not terminate within waitTime of 10 seconds
Killed the Process that runs JUnit test cases 73987
**The validation 1 have not finished well**
-Valid?: null, fitness 1.7976931348623157E308
Ingredient counter is Zero
---Undoing: gnrtn(68): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = d + work[j4 - 1] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (135(f=1.0), 136(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (135(f=1.0), )
----------Running generation: 69, population size: 1

***** Generation 69 : 0
**Parent Variant: [Variant id: 137, #gens: 382, #ops: 0, parent:-]

--Child created id: 138
--Creating new operations for variant [Variant id: 138, #gens: 382, #ops: 0, parent:137]
---analyzing modificationPoint position: 307
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  int begin = 0
---analyzing modificationPoint position: 194
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  int j4p2 = (j4 + (2 * pingPong)) - 1
---analyzing modificationPoint position: 333
Templates availables33
Attempts Base Ingredients  1 total 33
vars from patch []
location: AbstractRealMatrix.java605
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows) ` -topatch--> `final int rows = getRowDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.AbstractRealMatrix line: 605, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows) ` -topatch--> `final int rows = getRowDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 138, #gens: 382, #ops: 1, parent:137] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 138, errors: [AbstractRealMatrix.java:784: error: cannot find symbol
			 */ 			@java.lang.Override 			public void visit(final int row, final int column, final double value) { 				out.setEntry(column, row, value);}}); 		return out;} 	/**
			    			                    			                                                                         				^
  symbol: variable out, AbstractRealMatrix.java:784: error: cannot find symbol
			 */ 			@java.lang.Override 			public void visit(final int row, final int column, final double value) { 				out.setEntry(column, row, value);}}); 		return out;} 	/**
			    			                    			                                                                         				                                      		       ^
  symbol:   variable out
  location: class org.apache.commons.math.linear.AbstractRealMatrix]
Ingredient counter is Zero
---Undoing: gnrtn(69): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows) ` -topatch--> `final int rows = getRowDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (137(f=1.0), 138(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (137(f=1.0), )
----------Running generation: 70, population size: 1

***** Generation 70 : 0
**Parent Variant: [Variant id: 139, #gens: 382, #ops: 0, parent:-]

--Child created id: 140
--Creating new operations for variant [Variant id: 140, #gens: 382, #ops: 0, parent:139]
---analyzing modificationPoint position: 361
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  data = new double[rowDimension][columnDimension]
---analyzing modificationPoint position: 380
Templates availables216
Attempts Base Ingredients  1 total 216
---modifPoint 1 not mutation generated in  lu = null
---analyzing modificationPoint position: 285
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  cachedVt = null
---analyzing modificationPoint position: 278
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 3 not mutation generated in  upperSpectra = java.lang.Math.max(upperSpectra, upper)
---analyzing modificationPoint position: 22
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  // case 4. tType = -4
---analyzing modificationPoint position: 298
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 5 not mutation generated in  final double lower = dCurrent - eCurrent
---analyzing modificationPoint position: 145
location: EigenDecompositionImpl.java1198
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `right = upper + margin ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 140, #gens: 381, #ops: 1, parent:139] gen mutated: 1 , gen not mut: 6, gen not applied  0
-The child compiles: id 140
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-140/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(70): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `right = upper + margin ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (139(f=1.0), 140(f=8.0), )
Selected to next generation: IDs2--> (139(f=1.0), )
----------Running generation: 71, population size: 1

***** Generation 71 : 0
**Parent Variant: [Variant id: 141, #gens: 382, #ops: 0, parent:-]

--Child created id: 142
--Creating new operations for variant [Variant id: 142, #gens: 382, #ops: 0, parent:141]
---analyzing modificationPoint position: 6
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dN]
--> var from patch: dN spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1480
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `a2 = 0.0 ` -topatch--> `dN = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1480, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `a2 = 0.0 ` -topatch--> `dN = 0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 142, #gens: 383, #ops: 1, parent:141] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 142
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-142/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(71): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `a2 = 0.0 ` -topatch--> `dN = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (141(f=1.0), 142(f=1.0), )
Selected to next generation: IDs2--> (141(f=1.0), )
----------Running generation: 72, population size: 1

***** Generation 72 : 0
**Parent Variant: [Variant id: 143, #gens: 382, #ops: 0, parent:-]

--Child created id: 144
--Creating new operations for variant [Variant id: 144, #gens: 382, #ops: 0, parent:143]
---analyzing modificationPoint position: 77
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [tau, dMin]
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java893
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// perform one step n0 = goodStep(i0, n0) ` -topatch--> `tau = -dMin` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 893, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// perform one step n0 = goodStep(i0, n0) ` -topatch--> `tau = -dMin` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 144, #gens: 382, #ops: 1, parent:143] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 144, errors: [EigenDecompositionImpl.java:1442: error: illegal start of expression
	 * Perform two iterations with Li's tests for initial splits.
	 ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	          ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                         ^, EigenDecompositionImpl.java:1442: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1442: error: not a statement
	 * Perform two iterations with Li's tests for initial splits.
	                                    ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                         ^, EigenDecompositionImpl.java:1442: error: '(' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                             ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                                            ^, EigenDecompositionImpl.java:1444: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1444: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * 		number of rows of the matrix to process
	   		      ^, EigenDecompositionImpl.java:1445: error: not a statement
	 * 		number of rows of the matrix to process
	   		       ^, EigenDecompositionImpl.java:1445: error: ')' expected
	 * 		number of rows of the matrix to process
	   		         ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                 ^, EigenDecompositionImpl.java:1445: error: variable declaration not allowed here
	 * 		number of rows of the matrix to process
	   		               ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                            ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                                       ^, EigenDecompositionImpl.java:1446: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	^, EigenDecompositionImpl.java:1446: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	        ^, EigenDecompositionImpl.java:1446: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                          ^, EigenDecompositionImpl.java:1446: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1447: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1447: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1447: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1447: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1447: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1447: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1447: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1448: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^, EigenDecompositionImpl.java:1448: error: not a statement
	 * <p>This implementation is based on Beresford N. Parlett
	 ^, EigenDecompositionImpl.java:1448: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                            ^, EigenDecompositionImpl.java:1448: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                     ^, EigenDecompositionImpl.java:1448: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                                 ^, EigenDecompositionImpl.java:1449: error: not a statement
	 * and Osni A. Marques paper <a
	 ^, EigenDecompositionImpl.java:1449: error: ';' expected
	 * and Osni A. Marques paper <a
	      ^, EigenDecompositionImpl.java:1449: error: ';' expected
	 * and Osni A. Marques paper <a
	             ^, EigenDecompositionImpl.java:1449: error: ';' expected
	 * and Osni A. Marques paper <a
	                            ^, EigenDecompositionImpl.java:1450: error: > expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	 ^, EigenDecompositionImpl.java:1450: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	  ^, EigenDecompositionImpl.java:1450: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	       ^, EigenDecompositionImpl.java:1450: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	        ^, EigenDecompositionImpl.java:1450: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                           ^, EigenDecompositionImpl.java:1450: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                              ^, EigenDecompositionImpl.java:1451: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                    ^, EigenDecompositionImpl.java:1451: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                             ^, EigenDecompositionImpl.java:1451: error: ')' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                 ^, EigenDecompositionImpl.java:1451: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                      ^, EigenDecompositionImpl.java:1451: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                        ^, EigenDecompositionImpl.java:1451: error: not a statement
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                          ^, EigenDecompositionImpl.java:1451: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                               ^, EigenDecompositionImpl.java:1451: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                                      ^, EigenDecompositionImpl.java:1452: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                       ^, EigenDecompositionImpl.java:1452: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                      ^, EigenDecompositionImpl.java:1452: error: illegal start of type
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                        ^, EigenDecompositionImpl.java:1452: error: illegal start of expression
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                         ^, EigenDecompositionImpl.java:1453: error: illegal start of expression
	 *
	 ^, EigenDecompositionImpl.java:1454: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1454: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1452: error: not a statement
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                          ^, EigenDecompositionImpl.java:1455: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1456: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1457: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1457: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1458: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1458: error: not a statement
	 * @return new end (maybe deflated)
	 ^, EigenDecompositionImpl.java:1458: error: ';' expected
	 * @return new end (maybe deflated)
	              ^, EigenDecompositionImpl.java:1458: error: -> expected
	 * @return new end (maybe deflated)
	                                   ^, EigenDecompositionImpl.java:1459: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	 ^, EigenDecompositionImpl.java:1459: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	^, EigenDecompositionImpl.java:1458: error: not a statement
	 * @return new end (maybe deflated)
	                   ^, EigenDecompositionImpl.java:1459: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                    ^, EigenDecompositionImpl.java:1459: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                     ^, EigenDecompositionImpl.java:1459: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                                   ^, EigenDecompositionImpl.java:1466: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1466: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1466: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1466: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1466: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1468: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1468: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1469: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1469: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1469: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1469: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1470: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1471: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1471: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1471: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1471: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1471: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1471: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1471: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1471: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1472: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1472: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1472: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1472: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1472: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1472: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1472: error: ';' expected
	 * 		only every other element)
	   		                        ^]
Ingredient counter is Zero
---Undoing: gnrtn(72): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// perform one step n0 = goodStep(i0, n0) ` -topatch--> `tau = -dMin` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (143(f=1.0), 144(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (143(f=1.0), )
----------Running generation: 73, population size: 1

***** Generation 73 : 0
**Parent Variant: [Variant id: 145, #gens: 382, #ops: 0, parent:-]

--Child created id: 146
--Creating new operations for variant [Variant id: 146, #gens: 382, #ops: 0, parent:145]
---analyzing modificationPoint position: 306
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  imagEigenvalues = new double[main.length]
---analyzing modificationPoint position: 149
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  // search has converged break
---analyzing modificationPoint position: 183
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  eMin = java.lang.Math.min(work[j4], eMin)
---analyzing modificationPoint position: 236
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  if (work[j4 - 2] == 0.0) { 	work[j4] = 0.0; 	dN = work[j4p2 + 2]; 	dMin = dN; 	eMin = 0.0; } else if[...]
---analyzing modificationPoint position: 2
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  // case 9. tau = 0.25 * dMin1
---analyzing modificationPoint position: 69
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 5 not mutation generated in  diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2])
---analyzing modificationPoint position: 58
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 6 not mutation generated in  sigmaLow = 0
---analyzing modificationPoint position: 224
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tType, g]
--> var from patch: tType spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: g spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1380
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int j4p2 = (j4 + (2 * pingPong)) - 1 ` -topatch--> `// case 6, no information to guide us. if (tType == (-6)) { 	g += 0.333 * (1 - g); } else if (tType [...]` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1380, pointed element: CtIfImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int j4p2 = (j4 + (2 * pingPong)) - 1 ` -topatch--> `// case 6, no information to guide us. if (tType == (-6)) { 	g += 0.333 * (1 - g); } else if (tType [...]` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 146, #gens: 383, #ops: 1, parent:145] gen mutated: 1 , gen not mut: 7, gen not applied  0
-The child does NOT compile: 146, errors: [EigenDecompositionImpl.java:1592: error: cannot find symbol
						if (a2 < cnst1) { 							s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} 						tau = s;}} else if (dMin == dN2) { 					// case 5. 					tType = -5; 					double s = 0.25 * dMin; 					// compute contribution to norm squared from i > nn-2. 					final int np = nn - (2 * pingPong); 					double b1 = work[np - 2]; 					double b2 = work[np - 6]; 					final double gam = dN2; 					if ((work[np - 8] > b2) || (work[np - 4] > b1)) { 						return;} 					double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1)); 					// approximate contribution to norm squared from i < nn-2.
						                  							^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1592: error: cannot find symbol
						if (a2 < cnst1) { 							s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} 						tau = s;}} else if (dMin == dN2) { 					// case 5. 					tType = -5; 					double s = 0.25 * dMin; 					// compute contribution to norm squared from i > nn-2. 					final int np = nn - (2 * pingPong); 					double b1 = work[np - 2]; 					double b2 = work[np - 6]; 					final double gam = dN2; 					if ((work[np - 8] > b2) || (work[np - 4] > b1)) { 						return;} 					double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1)); 					// approximate contribution to norm squared from i < nn-2.
						                  							     ^
  symbol:   variable gam
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1592: error: cannot find symbol
						if (a2 < cnst1) { 							s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} 						tau = s;}} else if (dMin == dN2) { 					// case 5. 					tType = -5; 					double s = 0.25 * dMin; 					// compute contribution to norm squared from i > nn-2. 					final int np = nn - (2 * pingPong); 					double b1 = work[np - 2]; 					double b2 = work[np - 6]; 					final double gam = dN2; 					if ((work[np - 8] > b2) || (work[np - 4] > b1)) { 						return;} 					double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1)); 					// approximate contribution to norm squared from i < nn-2.
						                  							                                                       						      ^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						     ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						          ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							    ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							^
  symbol:   variable b1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							     ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							     ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							     ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							          ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                               ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                   ^
  symbol:   variable b1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                          ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                          ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						             ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					    ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					                  						       ^
  symbol:   variable gam
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					                  						                                      ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					                  						                                                   ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1593: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					                  						                                                                						      ^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1596: error: cannot find symbol
					double b2 = b1;
					            ^
  symbol:   variable b1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1599: error: cannot find symbol
							final double oldB1 = b1;
							                     ^
  symbol:   variable b1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1603: error: cannot find symbol
							b1 = b1 * (work[i4] / work[i4 - 2]);
							^
  symbol:   variable b1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1603: error: cannot find symbol
							b1 = b1 * (work[i4] / work[i4 - 2]);
							     ^
  symbol:   variable b1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1604: error: cannot find symbol
							b2 = b2 + b1;
							          ^
  symbol:   variable b1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1605: error: cannot find symbol
							if ((100 * java.lang.Math.max(b1, oldB1)) < b2) {
							                              ^
  symbol:   variable b1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1614: error: cannot find symbol
						tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));
						                         ^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1616: error: cannot find symbol
						tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));
						                         ^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl]
Ingredient counter is Zero
---Undoing: gnrtn(73): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `int j4p2 = (j4 + (2 * pingPong)) - 1 ` -topatch--> `// case 6, no information to guide us. if (tType == (-6)) { 	g += 0.333 * (1 - g); } else if (tType [...]` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (145(f=1.0), 146(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (145(f=1.0), )
----------Running generation: 74, population size: 1

***** Generation 74 : 0
**Parent Variant: [Variant id: 147, #gens: 382, #ops: 0, parent:-]

--Child created id: 148
--Creating new operations for variant [Variant id: 148, #gens: 382, #ops: 0, parent:147]
---analyzing modificationPoint position: 254
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // cases 2 and 3. final double gap2 = (dMin2 - a2) - (dMin2 * 0.25)
---analyzing modificationPoint position: 8
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 1 not mutation generated in  b2 = work[nn - 5] / work[nn - 7]
---analyzing modificationPoint position: 206
location: EigenDecompositionImpl.java1316
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 + 2] = dN ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 148, #gens: 381, #ops: 1, parent:147] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 148
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-148/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 17] ,[]
-Valid?: |false|9|17|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(74): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 + 2] = dN ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (147(f=1.0), 148(f=9.0), )
Selected to next generation: IDs2--> (147(f=1.0), )
----------Running generation: 75, population size: 1

***** Generation 75 : 0
**Parent Variant: [Variant id: 149, #gens: 382, #ops: 0, parent:-]

--Child created id: 150
--Creating new operations for variant [Variant id: 150, #gens: 382, #ops: 0, parent:149]
---analyzing modificationPoint position: 179
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 0 not mutation generated in  final double tmp = work[j4 + 1] / work[j4 - 2]
---analyzing modificationPoint position: 280
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  absDCurrent = java.lang.Math.abs(main[i + 1])
---analyzing modificationPoint position: 349
location: MatrixUtils.java650
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (left.getColumnDimension() != right.getRowDimension()) { 	throw org.apache.commons.math.MathRunti[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 150, #gens: 381, #ops: 1, parent:149] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 150
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-150/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(75): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (left.getColumnDimension() != right.getRowDimension()) { 	throw org.apache.commons.math.MathRunti[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (149(f=1.0), 150(f=1.0), )
Selected to next generation: IDs2--> (149(f=1.0), )
----------Running generation: 76, population size: 1

***** Generation 76 : 0
**Parent Variant: [Variant id: 151, #gens: 382, #ops: 0, parent:-]

--Child created id: 152
--Creating new operations for variant [Variant id: 152, #gens: 382, #ops: 0, parent:151]
---analyzing modificationPoint position: 377
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  return data == null ? 0 : data.length
---analyzing modificationPoint position: 105
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  if (((start == (deflatedEnd - 2)) ||  (work[k - 9] <= (org.apache.commons.math.linear.EigenDecomposi[...]
---analyzing modificationPoint position: 126
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  lower = java.lang.Math.min(lower, work[(lowerStart + index) + i])
---analyzing modificationPoint position: 12
location: EigenDecompositionImpl.java1508
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (work[i4] > work[i4 - 2]) { 	return; } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 152, #gens: 381, #ops: 1, parent:151] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 152
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-152/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(76): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (work[i4] > work[i4 - 2]) { 	return; } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (151(f=1.0), 152(f=1.0), )
Selected to next generation: IDs2--> (151(f=1.0), )
----------Running generation: 77, population size: 1

***** Generation 77 : 0
**Parent Variant: [Variant id: 153, #gens: 382, #ops: 0, parent:-]

--Child created id: 154
--Creating new operations for variant [Variant id: 154, #gens: 382, #ops: 0, parent:153]
---analyzing modificationPoint position: 362
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  data[row][column] = value
---analyzing modificationPoint position: 347
---modifPoint 1 not mutation generated in  return walkInRowOrder(visitor)
---analyzing modificationPoint position: 151
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  if (countEigenValues(middle, index, n) >= n) { 	right = middle; } else { 	left = middle; }
---analyzing modificationPoint position: 278
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 3 not mutation generated in  upperSpectra = java.lang.Math.max(upperSpectra, upper)
---analyzing modificationPoint position: 29
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 4 not mutation generated in  s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2)
---analyzing modificationPoint position: 146
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 5 not mutation generated in  for (int i = 0; i < maxIter; ++i) {  	final double range = right - left; 	if ((range < absoluteToler[...]
---analyzing modificationPoint position: 331
Templates availables33
Attempts Base Ingredients  1 total 33
vars from patch []
location: AbstractRealMatrix.java603
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int nRows = getRowDimension() ` -topatch--> `double trace = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.AbstractRealMatrix line: 603, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int nRows = getRowDimension() ` -topatch--> `double trace = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 154, #gens: 382, #ops: 1, parent:153] gen mutated: 1 , gen not mut: 6, gen not applied  0
-The child does NOT compile: 154, errors: [AbstractRealMatrix.java:666: error: cannot find symbol
		double trace = 0; 		final int nCols = getColumnDimension(); 		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows); 		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() { 			/**
		                  		                                        		                                                                          ^
  symbol:   variable nRows
  location: class org.apache.commons.math.linear.AbstractRealMatrix]
Ingredient counter is Zero
---Undoing: gnrtn(77): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int nRows = getRowDimension() ` -topatch--> `double trace = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (153(f=1.0), 154(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (153(f=1.0), )
----------Running generation: 78, population size: 1

***** Generation 78 : 0
**Parent Variant: [Variant id: 155, #gens: 382, #ops: 0, parent:-]

--Child created id: 156
--Creating new operations for variant [Variant id: 156, #gens: 382, #ops: 0, parent:155]
---analyzing modificationPoint position: 304
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java615
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// compute splitting points java.util.List<java.lang.Integer> splitIndices = computeSplits() ` -topatch--> `tType = -2` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 615, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// compute splitting points java.util.List<java.lang.Integer> splitIndices = computeSplits() ` -topatch--> `tType = -2` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 156, #gens: 383, #ops: 1, parent:155] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 156, errors: [EigenDecompositionImpl.java:1462: error: <identifier> expected
					if (chooseLeft) { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda + work[4 * i];}} else { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda - work[4 * i];}}} 			begin = end;} 		// sort the realEigenvalues in decreasing order 		java.util.Arrays.sort(realEigenvalues); 		int j = realEigenvalues.length - 1; 		for (int i = 0; i < j; ++i) { 			final double tmp = realEigenvalues[i]; 			realEigenvalues[i] = realEigenvalues[j]; 			realEigenvalues[j] = tmp; 			--j;}} 	/**
					                  						                              							                                                            						                              							                                                      			     ^, EigenDecompositionImpl.java:1463: error: class, interface, or enum expected
	 * Compute splitting points.
	 ^, EigenDecompositionImpl.java:1465: error: <identifier> expected
	 * @return list of indices after matrix can be split
	    ^, EigenDecompositionImpl.java:1465: error: class, interface, or enum expected
	 * @return list of indices after matrix can be split
	           ^, EigenDecompositionImpl.java:1466: error: class, interface, or enum expected
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	                                                            		      ^, EigenDecompositionImpl.java:1467: error: class, interface, or enum expected
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:1470: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1472: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                    ^, EigenDecompositionImpl.java:1472: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                                 		                                     ^, EigenDecompositionImpl.java:1480: error: class, interface, or enum expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1484: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1486: error: class, interface, or enum expected
	 * @exception InvalidMatrixException
	              ^, EigenDecompositionImpl.java:1488: error: class, interface, or enum expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                     ^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                       ^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		      ^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		      ^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		      ^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		      ^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			      ^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			       ^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		^, EigenDecompositionImpl.java:1489: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		                                ^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                       ^, EigenDecompositionImpl.java:1503: error: class, interface, or enum expected
			return;} 		// initial checks for splits (see Parlett & Marques section 3.3) 		flipIfWarranted(n, 2); 		// two iterations with Li's test for initial splits 		initialSplits(n); 		// initialize parameters used by goodStep 		tType = 0; 		dMin1 = 0; 		dMin2 = 0; 		dN = 0; 		dN1 = 0; 		dN2 = 0; 		tau = 0; 		// process split segments 		int i0 = 0; 		int n0 = n; 		while (n0 > 0) { 			// retrieve shift that was temporarily stored as a negative off-diagonal element 			sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2]; 			sigmaLow = 0; 			// find start of a new split segment to process 			double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6]; 			double offDiagMax = 0; 			double diagMax = work[(4 * n0) - 4]; 			double diagMin = diagMax; 			i0 = 0; 			for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { 				if (work[i + 2] <= 0) { 					i0 = 1 + (i / 4); 					break;} 				if (diagMin >= (4 * offDiagMax)) { 					diagMin = java.lang.Math.min(diagMin, work[i + 4]); 					offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);} 				diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]); 				offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);} 			work[(4 * n0) - 2] = offDiagMin; 			// lower bound of Gershgorin disk 			dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax))); 			pingPong = 0; 			int maxIter = 30 * (n0 - i0); 			for (int k = 0; i0 < n0; ++k) { 				if (k >= maxIter) { 					throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));} 				// perform one step 				n0 = goodStep(i0, n0); 				pingPong = 1 - pingPong; 				// check for new splits after "ping" steps 				// when the last elements of qd array are very small
			       ^, EigenDecompositionImpl.java:1504: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					^, EigenDecompositionImpl.java:1504: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					^, EigenDecompositionImpl.java:1504: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					^, EigenDecompositionImpl.java:1504: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					^, EigenDecompositionImpl.java:1504: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					                     ^, EigenDecompositionImpl.java:1504: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					                                          ^, EigenDecompositionImpl.java:1505: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1507: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1509: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                 ^, EigenDecompositionImpl.java:1509: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		^, EigenDecompositionImpl.java:1509: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		                ^, EigenDecompositionImpl.java:1509: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		                       ^, EigenDecompositionImpl.java:1517: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1519: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1521: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1521: error: class, interface, or enum expected
	 * @return new end (maybe deflated)
	           ^, EigenDecompositionImpl.java:1521: error: class, interface, or enum expected
	 * @return new end (maybe deflated)
	               ^, EigenDecompositionImpl.java:1522: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                           ^, EigenDecompositionImpl.java:1522: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                            ^, EigenDecompositionImpl.java:1523: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				^, EigenDecompositionImpl.java:1523: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                   ^, EigenDecompositionImpl.java:1523: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                     			      ^, EigenDecompositionImpl.java:1523: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                     			                                                  			^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					      ^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                  ^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                               ^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                         ^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                ^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				                                                   				^, EigenDecompositionImpl.java:1524: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				                                                   				                 ^, EigenDecompositionImpl.java:1525: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				^, EigenDecompositionImpl.java:1525: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				^, EigenDecompositionImpl.java:1525: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				^, EigenDecompositionImpl.java:1525: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				                                                                                             				^, EigenDecompositionImpl.java:1525: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				                                                                                             				            ^, EigenDecompositionImpl.java:1526: error: class, interface, or enum expected
			for (boolean loop = true; loop;) { 				// perform one dqds step with the chosen shift 				dqds(start, deflatedEnd); 				// check result of the dqds step
			                          ^, EigenDecompositionImpl.java:1526: error: class, interface, or enum expected
			for (boolean loop = true; loop;) { 				// perform one dqds step with the chosen shift 				dqds(start, deflatedEnd); 				// check result of the dqds step
			                               ^, EigenDecompositionImpl.java:1531: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1533: error: class, interface, or enum expected
	 * @param step
	          ^, EigenDecompositionImpl.java:1536: error: <identifier> expected
	 * @return true if qd array was flipped
	    ^, EigenDecompositionImpl.java:1536: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	           ^, EigenDecompositionImpl.java:1536: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	                ^, EigenDecompositionImpl.java:1536: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	                   ^, EigenDecompositionImpl.java:1537: error: class, interface, or enum expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1537: error: class, interface, or enum expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1540: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1542: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1544: error: <identifier> expected
	 * @return an interval containing the realEigenvalues
	    ^, EigenDecompositionImpl.java:1544: error: class, interface, or enum expected
	 * @return an interval containing the realEigenvalues
	           ^, EigenDecompositionImpl.java:1545: error: class, interface, or enum expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
	    	                                        ^, EigenDecompositionImpl.java:1545: error: class, interface, or enum expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
	    	                                                         ^, EigenDecompositionImpl.java:1546: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				      ^, EigenDecompositionImpl.java:1546: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			      ^, EigenDecompositionImpl.java:1546: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			^]
Ingredient counter is Zero
---Undoing: gnrtn(78): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// compute splitting points java.util.List<java.lang.Integer> splitIndices = computeSplits() ` -topatch--> `tType = -2` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (155(f=1.0), 156(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (155(f=1.0), )
----------Running generation: 79, population size: 1

***** Generation 79 : 0
**Parent Variant: [Variant id: 157, #gens: 382, #ops: 0, parent:-]

--Child created id: 158
--Creating new operations for variant [Variant id: 158, #gens: 382, #ops: 0, parent:157]
---analyzing modificationPoint position: 202
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  work[j4 - 2] = dN1 + work[j4p2]
---analyzing modificationPoint position: 47
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  // initialize parameters used by goodStep tType = 0
---analyzing modificationPoint position: 22
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [pingPong]
--> var from patch: pingPong spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1474
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// case 4. tType = -4 ` -topatch--> `// from ping to pong pingPong = 1 - pingPong` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1474, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// case 4. tType = -4 ` -topatch--> `// from ping to pong pingPong = 1 - pingPong` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 158, #gens: 382, #ops: 1, parent:157] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 158
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-158/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(79): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// case 4. tType = -4 ` -topatch--> `// from ping to pong pingPong = 1 - pingPong` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (157(f=1.0), 158(f=1.0), )
Selected to next generation: IDs2--> (157(f=1.0), )
----------Running generation: 80, population size: 1

***** Generation 80 : 0
**Parent Variant: [Variant id: 159, #gens: 382, #ops: 0, parent:-]

--Child created id: 160
--Creating new operations for variant [Variant id: 160, #gens: 382, #ops: 0, parent:159]
---analyzing modificationPoint position: 285
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  cachedVt = null
---analyzing modificationPoint position: 95
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  work[((4 * n) - 3) - pingPong] = d
---analyzing modificationPoint position: 361
location: Array2DRowRealMatrix.java77
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `data = new double[rowDimension][columnDimension] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 160, #gens: 381, #ops: 1, parent:159] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 160
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-160/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 17, was successful: false, cases executed: 17] ,[]
-Valid?: |false|17|17|[]|, fitness 17.0
Ingredient counter is Zero
---Undoing: gnrtn(80): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `data = new double[rowDimension][columnDimension] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (159(f=1.0), 160(f=17.0), )
Selected to next generation: IDs2--> (159(f=1.0), )
----------Running generation: 81, population size: 1

***** Generation 81 : 0
**Parent Variant: [Variant id: 161, #gens: 382, #ops: 0, parent:-]

--Child created id: 162
--Creating new operations for variant [Variant id: 162, #gens: 382, #ops: 0, parent:161]
---analyzing modificationPoint position: 189
location: EigenDecompositionImpl.java1293
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 1] = work[j4] * tmp ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 162, #gens: 381, #ops: 1, parent:161] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 162
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-162/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(81): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 1] = work[j4] * tmp ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (161(f=1.0), 162(f=8.0), )
Selected to next generation: IDs2--> (161(f=1.0), )
----------Running generation: 82, population size: 1

***** Generation 82 : 0
**Parent Variant: [Variant id: 163, #gens: 382, #ops: 0, parent:-]

--Child created id: 164
--Creating new operations for variant [Variant id: 164, #gens: 382, #ops: 0, parent:163]
---analyzing modificationPoint position: 12
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  if (work[i4] > work[i4 - 2]) { 	return; }
---analyzing modificationPoint position: 47
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  // initialize parameters used by goodStep tType = 0
---analyzing modificationPoint position: 304
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 2 not mutation generated in  // compute splitting points java.util.List<java.lang.Integer> splitIndices = computeSplits()
---analyzing modificationPoint position: 86
location: EigenDecompositionImpl.java951
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// apply dqd plus Li's forward test. d = work[pingPong] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 164, #gens: 381, #ops: 1, parent:163] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 164
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-164/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(82): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// apply dqd plus Li's forward test. d = work[pingPong] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (163(f=1.0), 164(f=8.0), )
Selected to next generation: IDs2--> (163(f=1.0), )
----------Running generation: 83, population size: 1

***** Generation 83 : 0
**Parent Variant: [Variant id: 165, #gens: 382, #ops: 0, parent:-]

--Child created id: 166
--Creating new operations for variant [Variant id: 166, #gens: 382, #ops: 0, parent:165]
---analyzing modificationPoint position: 214
location: EigenDecompositionImpl.java1337
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (work[j4 - 2] == 0.0) { 	work[j4] = 0.0; 	d = work[j4 + 1]; 	dMin = d; 	eMin = 0.0; } else if ((([...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 166, #gens: 381, #ops: 1, parent:165] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 166
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-166/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(83): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (work[j4 - 2] == 0.0) { 	work[j4] = 0.0; 	d = work[j4 + 1]; 	dMin = d; 	eMin = 0.0; } else if ((([...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (165(f=1.0), 166(f=8.0), )
Selected to next generation: IDs2--> (165(f=1.0), )
----------Running generation: 84, population size: 1

***** Generation 84 : 0
**Parent Variant: [Variant id: 167, #gens: 382, #ops: 0, parent:-]

--Child created id: 168
--Creating new operations for variant [Variant id: 168, #gens: 382, #ops: 0, parent:167]
---analyzing modificationPoint position: 92
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  final double tmp = work[i + 2] / work[j]
---analyzing modificationPoint position: 79
location: EigenDecompositionImpl.java898
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `// check for new splits after "ping" steps // when the last elements of qd array are very small if ([...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 168, #gens: 381, #ops: 1, parent:167] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 168
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-168/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 2, was successful: false, cases executed: 17] ,[]
-Valid?: |false|2|17|[]|, fitness 2.0
Ingredient counter is Zero
---Undoing: gnrtn(84): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `// check for new splits after "ping" steps // when the last elements of qd array are very small if ([...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (167(f=1.0), 168(f=2.0), )
Selected to next generation: IDs2--> (167(f=1.0), )
----------Running generation: 85, population size: 1

***** Generation 85 : 0
**Parent Variant: [Variant id: 169, #gens: 382, #ops: 0, parent:-]

--Child created id: 170
--Creating new operations for variant [Variant id: 170, #gens: 382, #ops: 0, parent:169]
---analyzing modificationPoint position: 363
location: Array2DRowRealMatrix.java95
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `copyIn(d) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 170, #gens: 381, #ops: 1, parent:169] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 170
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-170/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 17, was successful: false, cases executed: 17] ,[]
-Valid?: |false|17|17|[]|, fitness 17.0
Ingredient counter is Zero
---Undoing: gnrtn(85): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `copyIn(d) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (169(f=1.0), 170(f=17.0), )
Selected to next generation: IDs2--> (169(f=1.0), )
----------Running generation: 86, population size: 1

***** Generation 86 : 0
**Parent Variant: [Variant id: 171, #gens: 382, #ops: 0, parent:-]

--Child created id: 172
--Creating new operations for variant [Variant id: 172, #gens: 382, #ops: 0, parent:171]
---analyzing modificationPoint position: 222
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  dMin2 = dMin
---analyzing modificationPoint position: 172
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  eMin = work[((4 * start) + pingPong) + 4]
---analyzing modificationPoint position: 342
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 2 not mutation generated in  final double[] rowI = data[i]
---analyzing modificationPoint position: 21
location: EigenDecompositionImpl.java1101
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `tType -= 11 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 172, #gens: 381, #ops: 1, parent:171] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 172
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-172/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(86): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `tType -= 11 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (171(f=1.0), 172(f=1.0), )
Selected to next generation: IDs2--> (171(f=1.0), )
----------Running generation: 87, population size: 1

***** Generation 87 : 0
**Parent Variant: [Variant id: 173, #gens: 382, #ops: 0, parent:-]

--Child created id: 174
--Creating new operations for variant [Variant id: 174, #gens: 382, #ops: 0, parent:173]
---analyzing modificationPoint position: 378
Templates availables216
Attempts Base Ingredients  1 total 216
---modifPoint 0 not mutation generated in  lu = null
---analyzing modificationPoint position: 331
Templates availables216
Attempts Base Ingredients  1 total 216
---modifPoint 1 not mutation generated in  final int nRows = getRowDimension()
---analyzing modificationPoint position: 30
location: EigenDecompositionImpl.java1523
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `tau = s ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 174, #gens: 381, #ops: 1, parent:173] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 174
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-174/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(87): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `tau = s ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (173(f=1.0), 174(f=1.0), )
Selected to next generation: IDs2--> (173(f=1.0), )
----------Running generation: 88, population size: 1

***** Generation 88 : 0
**Parent Variant: [Variant id: 175, #gens: 382, #ops: 0, parent:-]

--Child created id: 176
--Creating new operations for variant [Variant id: 176, #gens: 382, #ops: 0, parent:175]
---analyzing modificationPoint position: 239
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1410
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4p2] * tmp ` -topatch--> `tType = -1` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1410, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4p2] * tmp ` -topatch--> `tType = -1` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 176, #gens: 383, #ops: 1, parent:175] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 176
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-176/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(88): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4p2] * tmp ` -topatch--> `tType = -1` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (175(f=1.0), 176(f=1.0), )
Selected to next generation: IDs2--> (175(f=1.0), )
----------Running generation: 89, population size: 1

***** Generation 89 : 0
**Parent Variant: [Variant id: 177, #gens: 382, #ops: 0, parent:-]

--Child created id: 178
--Creating new operations for variant [Variant id: 178, #gens: 382, #ops: 0, parent:177]
---analyzing modificationPoint position: 21
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  tType -= 11
---analyzing modificationPoint position: 94
Templates availables26
Attempts Base Ingredients  1 total 26
---modifPoint 1 not mutation generated in  d *= tmp
---analyzing modificationPoint position: 207
location: EigenDecompositionImpl.java1317
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[((4 * end) - pingPong) - 1] = eMin ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 178, #gens: 381, #ops: 1, parent:177] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 178
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-178/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(89): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[((4 * end) - pingPong) - 1] = eMin ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (177(f=1.0), 178(f=1.0), )
Selected to next generation: IDs2--> (177(f=1.0), )
----------Running generation: 90, population size: 1

***** Generation 90 : 0
**Parent Variant: [Variant id: 179, #gens: 382, #ops: 0, parent:-]

--Child created id: 180
--Creating new operations for variant [Variant id: 180, #gens: 382, #ops: 0, parent:179]
---analyzing modificationPoint position: 366
Templates availables120
Attempts Base Ingredients  1 total 120
vars from patch [column]
--> var from patch: column spoon.support.reflect.code.CtVariableReadImpl
location: Array2DRowRealMatrix.java320
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (column > 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalStateException( 	[...] ` -topatch--> `throw org.apache.commons.math.MathRuntimeException.createIllegalStateException( "first {0} columns a[...]` (spoon.support.reflect.code.CtThrowImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 320, pointed element: CtThrowImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (column > 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalStateException( 	[...] ` -topatch--> `throw org.apache.commons.math.MathRuntimeException.createIllegalStateException( "first {0} columns a[...]` (spoon.support.reflect.code.CtThrowImpl) 

--Summary Creation: for variant [Variant id: 180, #gens: 383, #ops: 1, parent:179] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 180, errors: [Array2DRowRealMatrix.java:324: error: unreachable statement
			column); 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);
			         			^]
Ingredient counter is Zero
---Undoing: gnrtn(90): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (column > 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalStateException( 	[...] ` -topatch--> `throw org.apache.commons.math.MathRuntimeException.createIllegalStateException( "first {0} columns a[...]` (spoon.support.reflect.code.CtThrowImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (179(f=1.0), 180(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (179(f=1.0), )
----------Running generation: 91, population size: 1

***** Generation 91 : 0
**Parent Variant: [Variant id: 181, #gens: 382, #ops: 0, parent:-]

--Child created id: 182
--Creating new operations for variant [Variant id: 182, #gens: 382, #ops: 0, parent:181]
---analyzing modificationPoint position: 295
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  double eCurrent = 0
---analyzing modificationPoint position: 65
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  if (work[i + 2] <= 0) { 	i0 = 1 + (i / 4); 	break; }
---analyzing modificationPoint position: 45
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java839
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtInvocationImpl) `// initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2) ` -topatch--> `findEigenVectors()` (spoon.support.reflect.code.CtInvocationImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 839, pointed element: CtInvocationImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtInvocationImpl) `// initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2) ` -topatch--> `findEigenVectors()` (spoon.support.reflect.code.CtInvocationImpl) 

--Summary Creation: for variant [Variant id: 182, #gens: 383, #ops: 1, parent:181] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 182
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-182/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(91): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtInvocationImpl) `// initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2) ` -topatch--> `findEigenVectors()` (spoon.support.reflect.code.CtInvocationImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (181(f=1.0), 182(f=8.0), )
Selected to next generation: IDs2--> (181(f=1.0), )
----------Running generation: 92, population size: 1

***** Generation 92 : 0
**Parent Variant: [Variant id: 183, #gens: 382, #ops: 0, parent:-]

--Child created id: 184
--Creating new operations for variant [Variant id: 184, #gens: 382, #ops: 0, parent:183]
---analyzing modificationPoint position: 350
Templates availables115
Attempts Base Ingredients  1 total 115
---modifPoint 0 not mutation generated in  return (data.length * data[0].length) <= 4096 ?  new org.apache.commons.math.linear.Array2DRowRealMa[...]
---analyzing modificationPoint position: 36
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java200
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double s = secondary[i] ` -topatch--> `tType = -3` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 200, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double s = secondary[i] ` -topatch--> `tType = -3` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 184, #gens: 383, #ops: 1, parent:183] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 184, errors: [EigenDecompositionImpl.java:1483: error: illegal start of expression
	 * {@inheritDoc }
	 ^, EigenDecompositionImpl.java:1483: error: illegal start of expression
	 * {@inheritDoc }
	   ^, EigenDecompositionImpl.java:1483: error: illegal start of type
	 * {@inheritDoc }
	                ^, EigenDecompositionImpl.java:1483: error: ';' expected
	 * {@inheritDoc }
	                 ^, EigenDecompositionImpl.java:1484: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	  ^, EigenDecompositionImpl.java:1484: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	   ^, EigenDecompositionImpl.java:1484: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                     ^, EigenDecompositionImpl.java:1484: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                             ^, EigenDecompositionImpl.java:1484: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                                                    ^, EigenDecompositionImpl.java:1487: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	^, EigenDecompositionImpl.java:1487: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	                                                     ^, EigenDecompositionImpl.java:1487: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	                                                                                             ^, EigenDecompositionImpl.java:1487: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	                                                                                                                    ^, EigenDecompositionImpl.java:1488: error: illegal start of expression
	 * {@inheritDoc }
	 ^, EigenDecompositionImpl.java:1488: error: illegal start of expression
	 * {@inheritDoc }
	   ^, EigenDecompositionImpl.java:1488: error: illegal start of type
	 * {@inheritDoc }
	                ^, EigenDecompositionImpl.java:1488: error: ';' expected
	 * {@inheritDoc }
	                 ^, EigenDecompositionImpl.java:1489: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	  ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	   ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                      ^, EigenDecompositionImpl.java:1489: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                              ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                                                     ^, EigenDecompositionImpl.java:1492: error: illegal start of expression
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	^, EigenDecompositionImpl.java:1492: error: ';' expected
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	                                  ^, EigenDecompositionImpl.java:1492: error: not a statement
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	                                                                          ^, EigenDecompositionImpl.java:1492: error: ';' expected
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	                                                                                                 ^, EigenDecompositionImpl.java:1494: error: illegal start of expression
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	^, EigenDecompositionImpl.java:1494: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                               ^, EigenDecompositionImpl.java:1494: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                           ^, EigenDecompositionImpl.java:1494: error: not a statement
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                  ^, EigenDecompositionImpl.java:1494: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                                         ^, EigenDecompositionImpl.java:1494: error: not a statement
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                                                    ^, EigenDecompositionImpl.java:1494: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                                                                                   ^, EigenDecompositionImpl.java:1496: error: illegal start of expression
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	^, EigenDecompositionImpl.java:1496: error: ';' expected
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	                                  ^, EigenDecompositionImpl.java:1496: error: not a statement
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	                                                                          ^, EigenDecompositionImpl.java:1496: error: ';' expected
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	                                                                                                 ^, EigenDecompositionImpl.java:1498: error: illegal start of expression
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	^, EigenDecompositionImpl.java:1498: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                               ^, EigenDecompositionImpl.java:1498: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                           ^, EigenDecompositionImpl.java:1498: error: not a statement
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                  ^, EigenDecompositionImpl.java:1498: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                                         ^, EigenDecompositionImpl.java:1498: error: not a statement
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                                                    ^, EigenDecompositionImpl.java:1498: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                                                                                   ^, EigenDecompositionImpl.java:1500: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	^, EigenDecompositionImpl.java:1500: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                               ^, EigenDecompositionImpl.java:1500: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:1500: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                  ^, EigenDecompositionImpl.java:1500: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                                         ^, EigenDecompositionImpl.java:1500: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                                                    ^, EigenDecompositionImpl.java:1500: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                                                                                   ^, EigenDecompositionImpl.java:1504: error: illegal start of expression
	 */ 	public double getDeterminant() { 		double determinant = 1; 		for (double lambda : realEigenvalues) { 			determinant *= lambda;} 		return determinant;} 	/**
	    	^, EigenDecompositionImpl.java:1504: error: ';' expected
	 */ 	public double getDeterminant() { 		double determinant = 1; 		for (double lambda : realEigenvalues) { 			determinant *= lambda;} 		return determinant;} 	/**
	    	                            ^, EigenDecompositionImpl.java:1506: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.DecompositionSolver getSolver() { 		if (eigenvectors == null) { 			findEigenVectors();} 		return new org.apache.commons.math.linear.EigenDecompositionImpl.Solver(realEigenvalues, imagEigenvalues, eigenvectors);} 	/**
	    	^, EigenDecompositionImpl.java:1506: error: ';' expected
	 */ 	public org.apache.commons.math.linear.DecompositionSolver getSolver() { 		if (eigenvectors == null) { 			findEigenVectors();} 		return new org.apache.commons.math.linear.EigenDecompositionImpl.Solver(realEigenvalues, imagEigenvalues, eigenvectors);} 	/**
	    	                                                                   ^, EigenDecompositionImpl.java:1508: error: illegal start of expression
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	^, EigenDecompositionImpl.java:1508: error: illegal start of expression
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	        ^, EigenDecompositionImpl.java:1508: error: ';' expected
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	              ^, EigenDecompositionImpl.java:1508: error: not a statement
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                     ^, EigenDecompositionImpl.java:1508: error: ';' expected
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                           ^, EigenDecompositionImpl.java:1508: error: not a statement
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                                                                     ^, EigenDecompositionImpl.java:1508: error: ';' expected
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                                                                                         ^, EigenDecompositionImpl.java:1510: error: illegal start of expression
		 */ 		private double[] realEigenvalues; 		/**
		    		^, EigenDecompositionImpl.java:1512: error: illegal start of expression
		 */ 		private double[] imagEigenvalues; 		/**
		    		^, EigenDecompositionImpl.java:1514: error: illegal start of expression
		 */ 		private final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors; 		/**
		    		^, EigenDecompositionImpl.java:1523: error: illegal start of expression
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		^, EigenDecompositionImpl.java:1523: error: illegal start of expression
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		               ^, EigenDecompositionImpl.java:1523: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                    ^, EigenDecompositionImpl.java:1523: error: illegal start of expression
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                           ^, EigenDecompositionImpl.java:1523: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                            ^, EigenDecompositionImpl.java:1523: error: not a statement
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                              ^, EigenDecompositionImpl.java:1523: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                                             ^, EigenDecompositionImpl.java:1523: error: <identifier> expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                                                                              ^, EigenDecompositionImpl.java:1523: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                                                                                                                                                  ^, EigenDecompositionImpl.java:1535: error: illegal start of expression
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		^, EigenDecompositionImpl.java:1535: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                     ^, EigenDecompositionImpl.java:1535: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                      ^, EigenDecompositionImpl.java:1535: error: not a statement
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                        ^, EigenDecompositionImpl.java:1535: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                                                 ^, EigenDecompositionImpl.java:1535: error: not a statement
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                                                                                 ^, EigenDecompositionImpl.java:1535: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                                                                                                        ^, EigenDecompositionImpl.java:1547: error: illegal start of expression
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		^, EigenDecompositionImpl.java:1547: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                      ^, EigenDecompositionImpl.java:1547: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                        ^, EigenDecompositionImpl.java:1547: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                          ^, EigenDecompositionImpl.java:1547: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                                                   ^, EigenDecompositionImpl.java:1547: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                                                                                   ^, EigenDecompositionImpl.java:1547: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                                                                                                          ^, EigenDecompositionImpl.java:1559: error: illegal start of expression
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		^, EigenDecompositionImpl.java:1559: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                      ^, EigenDecompositionImpl.java:1559: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                        ^, EigenDecompositionImpl.java:1559: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                          ^, EigenDecompositionImpl.java:1559: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                                                   ^, EigenDecompositionImpl.java:1559: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                                                                                   ^, EigenDecompositionImpl.java:1559: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                                                                                                          ^, EigenDecompositionImpl.java:1563: error: illegal start of expression
		 */ 		public boolean isNonSingular() { 			for (int i = 0; i < realEigenvalues.length; ++i) { 				if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) { 					return false;}} 			return true;} 		/**
		    		^, EigenDecompositionImpl.java:1563: error: ';' expected
		 */ 		public boolean isNonSingular() { 			for (int i = 0; i < realEigenvalues.length; ++i) { 				if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) { 					return false;}} 			return true;} 		/**
		    		                            ^, EigenDecompositionImpl.java:1569: error: illegal start of expression
		 */ 		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			final double[][] invData = new double[m][m]; 			for (int i = 0; i < m; ++i) { 				final double[] invI = invData[i]; 				for (int j = 0; j < m; ++j) { 					double invIJ = 0; 					for (int k = 0; k < m; ++k) { 						final double[] vK = eigenvectors[k].getDataRef(); 						invIJ += (vK[i] * vK[j]) / realEigenvalues[k];} 					invI[j] = invIJ;}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);}} 	/**
		    		^, EigenDecompositionImpl.java:1569: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			final double[][] invData = new double[m][m]; 			for (int i = 0; i < m; ++i) { 				final double[] invI = invData[i]; 				for (int j = 0; j < m; ++j) { 					double invIJ = 0; 					for (int k = 0; k < m; ++k) { 						final double[] vK = eigenvectors[k].getDataRef(); 						invIJ += (vK[i] * vK[j]) / realEigenvalues[k];} 					invI[j] = invIJ;}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);}} 	/**
		    		                                                           ^, EigenDecompositionImpl.java:1569: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			final double[][] invData = new double[m][m]; 			for (int i = 0; i < m; ++i) { 				final double[] invI = invData[i]; 				for (int j = 0; j < m; ++j) { 					double invIJ = 0; 					for (int k = 0; k < m; ++k) { 						final double[] vK = eigenvectors[k].getDataRef(); 						invIJ += (vK[i] * vK[j]) / realEigenvalues[k];} 					invI[j] = invIJ;}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);}} 	/**
		    		                                                                                                   ^]
Ingredient counter is Zero
---Undoing: gnrtn(92): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double s = secondary[i] ` -topatch--> `tType = -3` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (183(f=1.0), 184(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (183(f=1.0), )
----------Running generation: 93, population size: 1

***** Generation 93 : 0
**Parent Variant: [Variant id: 185, #gens: 382, #ops: 0, parent:-]

--Child created id: 186
--Creating new operations for variant [Variant id: 186, #gens: 382, #ops: 0, parent:185]
---analyzing modificationPoint position: 114
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // check result of the dqds step if ((dMin >= 0) && (dMin1 > 0)) { 	// the shift was good 	updateSig[...]
---analyzing modificationPoint position: 147
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 1 not mutation generated in  final double range = right - left
---analyzing modificationPoint position: 344
Templates availables12
Attempts Base Ingredients  1 total 12
---modifPoint 2 not mutation generated in  visitor.visit(i, j, rowI[j])
---analyzing modificationPoint position: 330
---modifPoint 3 not mutation generated in  return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false)
---analyzing modificationPoint position: 94
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  d *= tmp
---analyzing modificationPoint position: 156
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 5 not mutation generated in  double ratio = main[index] - t
---analyzing modificationPoint position: 29
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 6 not mutation generated in  s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2)
---analyzing modificationPoint position: 155
---modifPoint 7 not mutation generated in  return new double[]{ lower, upper }
---analyzing modificationPoint position: 113
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 8 not mutation generated in  // perform one dqds step with the chosen shift dqds(start, deflatedEnd)
---analyzing modificationPoint position: 249
Templates availables2
Attempts Base Ingredients  1 total 2
vars from patch [deflated, dMin, dN, dN1, work, nn, dMin1, dMin2, a2, gap2, b2, b1, gap1, tau, tType, s, gam, np, pingPong, i4, start, cnst1, cnst3, dN2, end, g, oldB1, cnst2]
--> var from patch: deflated spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: dN spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: dN1 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: nn spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: dMin1 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: dMin2 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: a2 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: gap2 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: b2 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: b1 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: gap1 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: s spoon.support.reflect.code.CtVariableWriteImpl
--> var from patch: gam spoon.support.reflect.code.CtVariableWriteImpl
--> var from patch: np spoon.support.reflect.code.CtVariableWriteImpl
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: i4 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: start spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: cnst1 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: cnst3 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: dN2 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: end spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: g spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: oldB1 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: cnst2 spoon.support.reflect.code.CtVariableReadImpl
location: EigenDecompositionImpl.java1445
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtSwitchImpl) `switch (deflated) {  	case 0 : 		// no realEigenvalues deflated. 		if ((dMin == dN) || (dMin == dN1)[...] ` -topatch--> `switch (deflated) {  	case 0 : 		// no realEigenvalues deflated. 		if ((dMin == dN) || (dMin == dN1)[...]` (spoon.support.reflect.code.CtSwitchImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1445, pointed element: CtSwitchImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtSwitchImpl) `switch (deflated) {  	case 0 : 		// no realEigenvalues deflated. 		if ((dMin == dN) || (dMin == dN1)[...] ` -topatch--> `switch (deflated) {  	case 0 : 		// no realEigenvalues deflated. 		if ((dMin == dN) || (dMin == dN1)[...]` (spoon.support.reflect.code.CtSwitchImpl) 

--Summary Creation: for variant [Variant id: 186, #gens: 382, #ops: 1, parent:185] gen mutated: 1 , gen not mut: 9, gen not applied  0
-The child compiles: id 186
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-186/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(93): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtSwitchImpl) `switch (deflated) {  	case 0 : 		// no realEigenvalues deflated. 		if ((dMin == dN) || (dMin == dN1)[...] ` -topatch--> `switch (deflated) {  	case 0 : 		// no realEigenvalues deflated. 		if ((dMin == dN) || (dMin == dN1)[...]` (spoon.support.reflect.code.CtSwitchImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (185(f=1.0), 186(f=1.0), )
Selected to next generation: IDs2--> (185(f=1.0), )
----------Running generation: 94, population size: 1

***** Generation 94 : 0
**Parent Variant: [Variant id: 187, #gens: 382, #ops: 0, parent:-]

--Child created id: 188
--Creating new operations for variant [Variant id: 188, #gens: 382, #ops: 0, parent:187]
---analyzing modificationPoint position: 127
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  upper = java.lang.Math.max(upper, work[(upperStart + index) + i])
---analyzing modificationPoint position: 38
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java204
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `this.splitTolerance = splitTolerance ` -topatch--> `tType = -3` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 204, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `this.splitTolerance = splitTolerance ` -topatch--> `tType = -3` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 188, #gens: 383, #ops: 1, parent:187] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 188, errors: [EigenDecompositionImpl.java:1483: error: illegal start of expression
	 * {@inheritDoc }
	 ^, EigenDecompositionImpl.java:1483: error: illegal start of expression
	 * {@inheritDoc }
	   ^, EigenDecompositionImpl.java:1483: error: illegal start of type
	 * {@inheritDoc }
	                ^, EigenDecompositionImpl.java:1483: error: ';' expected
	 * {@inheritDoc }
	                 ^, EigenDecompositionImpl.java:1484: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	  ^, EigenDecompositionImpl.java:1484: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	   ^, EigenDecompositionImpl.java:1484: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                     ^, EigenDecompositionImpl.java:1484: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                             ^, EigenDecompositionImpl.java:1484: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                                                    ^, EigenDecompositionImpl.java:1487: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	^, EigenDecompositionImpl.java:1487: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	                                                     ^, EigenDecompositionImpl.java:1487: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	                                                                                             ^, EigenDecompositionImpl.java:1487: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	                                                                                                                    ^, EigenDecompositionImpl.java:1488: error: illegal start of expression
	 * {@inheritDoc }
	 ^, EigenDecompositionImpl.java:1488: error: illegal start of expression
	 * {@inheritDoc }
	   ^, EigenDecompositionImpl.java:1488: error: illegal start of type
	 * {@inheritDoc }
	                ^, EigenDecompositionImpl.java:1488: error: ';' expected
	 * {@inheritDoc }
	                 ^, EigenDecompositionImpl.java:1489: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	  ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	   ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                      ^, EigenDecompositionImpl.java:1489: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                              ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                                                     ^, EigenDecompositionImpl.java:1492: error: illegal start of expression
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	^, EigenDecompositionImpl.java:1492: error: ';' expected
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	                                  ^, EigenDecompositionImpl.java:1492: error: not a statement
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	                                                                          ^, EigenDecompositionImpl.java:1492: error: ';' expected
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	                                                                                                 ^, EigenDecompositionImpl.java:1494: error: illegal start of expression
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	^, EigenDecompositionImpl.java:1494: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                               ^, EigenDecompositionImpl.java:1494: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                           ^, EigenDecompositionImpl.java:1494: error: not a statement
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                  ^, EigenDecompositionImpl.java:1494: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                                         ^, EigenDecompositionImpl.java:1494: error: not a statement
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                                                    ^, EigenDecompositionImpl.java:1494: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                                                                                   ^, EigenDecompositionImpl.java:1496: error: illegal start of expression
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	^, EigenDecompositionImpl.java:1496: error: ';' expected
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	                                  ^, EigenDecompositionImpl.java:1496: error: not a statement
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	                                                                          ^, EigenDecompositionImpl.java:1496: error: ';' expected
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	                                                                                                 ^, EigenDecompositionImpl.java:1498: error: illegal start of expression
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	^, EigenDecompositionImpl.java:1498: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                               ^, EigenDecompositionImpl.java:1498: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                           ^, EigenDecompositionImpl.java:1498: error: not a statement
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                  ^, EigenDecompositionImpl.java:1498: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                                         ^, EigenDecompositionImpl.java:1498: error: not a statement
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                                                    ^, EigenDecompositionImpl.java:1498: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                                                                                   ^, EigenDecompositionImpl.java:1500: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	^, EigenDecompositionImpl.java:1500: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                               ^, EigenDecompositionImpl.java:1500: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:1500: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                  ^, EigenDecompositionImpl.java:1500: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                                         ^, EigenDecompositionImpl.java:1500: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                                                    ^, EigenDecompositionImpl.java:1500: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                                                                                   ^, EigenDecompositionImpl.java:1504: error: illegal start of expression
	 */ 	public double getDeterminant() { 		double determinant = 1; 		for (double lambda : realEigenvalues) { 			determinant *= lambda;} 		return determinant;} 	/**
	    	^, EigenDecompositionImpl.java:1504: error: ';' expected
	 */ 	public double getDeterminant() { 		double determinant = 1; 		for (double lambda : realEigenvalues) { 			determinant *= lambda;} 		return determinant;} 	/**
	    	                            ^, EigenDecompositionImpl.java:1506: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.DecompositionSolver getSolver() { 		if (eigenvectors == null) { 			findEigenVectors();} 		return new org.apache.commons.math.linear.EigenDecompositionImpl.Solver(realEigenvalues, imagEigenvalues, eigenvectors);} 	/**
	    	^, EigenDecompositionImpl.java:1506: error: ';' expected
	 */ 	public org.apache.commons.math.linear.DecompositionSolver getSolver() { 		if (eigenvectors == null) { 			findEigenVectors();} 		return new org.apache.commons.math.linear.EigenDecompositionImpl.Solver(realEigenvalues, imagEigenvalues, eigenvectors);} 	/**
	    	                                                                   ^, EigenDecompositionImpl.java:1508: error: illegal start of expression
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	^, EigenDecompositionImpl.java:1508: error: illegal start of expression
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	        ^, EigenDecompositionImpl.java:1508: error: ';' expected
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	              ^, EigenDecompositionImpl.java:1508: error: not a statement
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                     ^, EigenDecompositionImpl.java:1508: error: ';' expected
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                           ^, EigenDecompositionImpl.java:1508: error: not a statement
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                                                                     ^, EigenDecompositionImpl.java:1508: error: ';' expected
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                                                                                         ^, EigenDecompositionImpl.java:1510: error: illegal start of expression
		 */ 		private double[] realEigenvalues; 		/**
		    		^, EigenDecompositionImpl.java:1512: error: illegal start of expression
		 */ 		private double[] imagEigenvalues; 		/**
		    		^, EigenDecompositionImpl.java:1514: error: illegal start of expression
		 */ 		private final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors; 		/**
		    		^, EigenDecompositionImpl.java:1523: error: illegal start of expression
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		^, EigenDecompositionImpl.java:1523: error: illegal start of expression
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		               ^, EigenDecompositionImpl.java:1523: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                    ^, EigenDecompositionImpl.java:1523: error: illegal start of expression
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                           ^, EigenDecompositionImpl.java:1523: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                            ^, EigenDecompositionImpl.java:1523: error: not a statement
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                              ^, EigenDecompositionImpl.java:1523: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                                             ^, EigenDecompositionImpl.java:1523: error: <identifier> expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                                                                              ^, EigenDecompositionImpl.java:1523: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                                                                                                                                                  ^, EigenDecompositionImpl.java:1535: error: illegal start of expression
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		^, EigenDecompositionImpl.java:1535: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                     ^, EigenDecompositionImpl.java:1535: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                      ^, EigenDecompositionImpl.java:1535: error: not a statement
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                        ^, EigenDecompositionImpl.java:1535: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                                                 ^, EigenDecompositionImpl.java:1535: error: not a statement
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                                                                                 ^, EigenDecompositionImpl.java:1535: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                                                                                                        ^, EigenDecompositionImpl.java:1547: error: illegal start of expression
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		^, EigenDecompositionImpl.java:1547: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                      ^, EigenDecompositionImpl.java:1547: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                        ^, EigenDecompositionImpl.java:1547: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                          ^, EigenDecompositionImpl.java:1547: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                                                   ^, EigenDecompositionImpl.java:1547: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                                                                                   ^, EigenDecompositionImpl.java:1547: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                                                                                                          ^, EigenDecompositionImpl.java:1559: error: illegal start of expression
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		^, EigenDecompositionImpl.java:1559: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                      ^, EigenDecompositionImpl.java:1559: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                        ^, EigenDecompositionImpl.java:1559: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                          ^, EigenDecompositionImpl.java:1559: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                                                   ^, EigenDecompositionImpl.java:1559: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                                                                                   ^, EigenDecompositionImpl.java:1559: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                                                                                                          ^, EigenDecompositionImpl.java:1563: error: illegal start of expression
		 */ 		public boolean isNonSingular() { 			for (int i = 0; i < realEigenvalues.length; ++i) { 				if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) { 					return false;}} 			return true;} 		/**
		    		^, EigenDecompositionImpl.java:1563: error: ';' expected
		 */ 		public boolean isNonSingular() { 			for (int i = 0; i < realEigenvalues.length; ++i) { 				if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) { 					return false;}} 			return true;} 		/**
		    		                            ^, EigenDecompositionImpl.java:1569: error: illegal start of expression
		 */ 		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			final double[][] invData = new double[m][m]; 			for (int i = 0; i < m; ++i) { 				final double[] invI = invData[i]; 				for (int j = 0; j < m; ++j) { 					double invIJ = 0; 					for (int k = 0; k < m; ++k) { 						final double[] vK = eigenvectors[k].getDataRef(); 						invIJ += (vK[i] * vK[j]) / realEigenvalues[k];} 					invI[j] = invIJ;}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);}} 	/**
		    		^, EigenDecompositionImpl.java:1569: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			final double[][] invData = new double[m][m]; 			for (int i = 0; i < m; ++i) { 				final double[] invI = invData[i]; 				for (int j = 0; j < m; ++j) { 					double invIJ = 0; 					for (int k = 0; k < m; ++k) { 						final double[] vK = eigenvectors[k].getDataRef(); 						invIJ += (vK[i] * vK[j]) / realEigenvalues[k];} 					invI[j] = invIJ;}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);}} 	/**
		    		                                                           ^, EigenDecompositionImpl.java:1569: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			final double[][] invData = new double[m][m]; 			for (int i = 0; i < m; ++i) { 				final double[] invI = invData[i]; 				for (int j = 0; j < m; ++j) { 					double invIJ = 0; 					for (int k = 0; k < m; ++k) { 						final double[] vK = eigenvectors[k].getDataRef(); 						invIJ += (vK[i] * vK[j]) / realEigenvalues[k];} 					invI[j] = invIJ;}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);}} 	/**
		    		                                                                                                   ^]
Ingredient counter is Zero
---Undoing: gnrtn(94): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `this.splitTolerance = splitTolerance ` -topatch--> `tType = -3` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (187(f=1.0), 188(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (187(f=1.0), )
----------Running generation: 95, population size: 1

***** Generation 95 : 0
**Parent Variant: [Variant id: 189, #gens: 382, #ops: 0, parent:-]

--Child created id: 190
--Creating new operations for variant [Variant id: 190, #gens: 382, #ops: 0, parent:189]
---analyzing modificationPoint position: 235
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [imagEigenvalues]
--> var from patch: imagEigenvalues spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1401
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = dN1 + work[j4p2] ` -topatch--> `return imagEigenvalues.clone()` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1401, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = dN1 + work[j4p2] ` -topatch--> `return imagEigenvalues.clone()` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 190, #gens: 383, #ops: 1, parent:189] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 190, errors: [EigenDecompositionImpl.java:1401: error: incompatible types: unexpected return value
		j4p2 = (j4 + (2 * pingPong)) - 1; 		return imagEigenvalues.clone();
		                                  		                            ^]
Ingredient counter is Zero
---Undoing: gnrtn(95): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = dN1 + work[j4p2] ` -topatch--> `return imagEigenvalues.clone()` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (189(f=1.0), 190(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (189(f=1.0), )
----------Running generation: 96, population size: 1

***** Generation 96 : 0
**Parent Variant: [Variant id: 191, #gens: 382, #ops: 0, parent:-]

--Child created id: 192
--Creating new operations for variant [Variant id: 192, #gens: 382, #ops: 0, parent:191]
---analyzing modificationPoint position: 375
Templates availables12
Attempts Base Ingredients  1 total 12
---modifPoint 0 not mutation generated in  setSubMatrix(in, 0, 0)
---analyzing modificationPoint position: 47
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java845
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// initialize parameters used by goodStep tType = 0 ` -topatch--> `tType = -3` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 845, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// initialize parameters used by goodStep tType = 0 ` -topatch--> `tType = -3` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 192, #gens: 382, #ops: 1, parent:191] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 192, errors: [EigenDecompositionImpl.java:1473: error: illegal start of expression
	 * Perform two iterations with Li's tests for initial splits.
	 ^, EigenDecompositionImpl.java:1473: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	          ^, EigenDecompositionImpl.java:1473: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                         ^, EigenDecompositionImpl.java:1473: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1473: error: not a statement
	 * Perform two iterations with Li's tests for initial splits.
	                                    ^, EigenDecompositionImpl.java:1473: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                         ^, EigenDecompositionImpl.java:1473: error: '(' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                             ^, EigenDecompositionImpl.java:1473: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                                            ^, EigenDecompositionImpl.java:1475: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1475: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1476: error: ';' expected
	 * 		number of rows of the matrix to process
	   		      ^, EigenDecompositionImpl.java:1476: error: not a statement
	 * 		number of rows of the matrix to process
	   		       ^, EigenDecompositionImpl.java:1476: error: ')' expected
	 * 		number of rows of the matrix to process
	   		         ^, EigenDecompositionImpl.java:1476: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                 ^, EigenDecompositionImpl.java:1476: error: variable declaration not allowed here
	 * 		number of rows of the matrix to process
	   		               ^, EigenDecompositionImpl.java:1476: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                            ^, EigenDecompositionImpl.java:1476: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                                       ^, EigenDecompositionImpl.java:1477: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	^, EigenDecompositionImpl.java:1477: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	        ^, EigenDecompositionImpl.java:1477: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                          ^, EigenDecompositionImpl.java:1477: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1478: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1478: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1478: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1478: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1478: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1478: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1478: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1479: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^, EigenDecompositionImpl.java:1479: error: not a statement
	 * <p>This implementation is based on Beresford N. Parlett
	 ^, EigenDecompositionImpl.java:1479: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                            ^, EigenDecompositionImpl.java:1479: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                     ^, EigenDecompositionImpl.java:1479: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                                 ^, EigenDecompositionImpl.java:1480: error: not a statement
	 * and Osni A. Marques paper <a
	 ^, EigenDecompositionImpl.java:1480: error: ';' expected
	 * and Osni A. Marques paper <a
	      ^, EigenDecompositionImpl.java:1480: error: ';' expected
	 * and Osni A. Marques paper <a
	             ^, EigenDecompositionImpl.java:1480: error: ';' expected
	 * and Osni A. Marques paper <a
	                            ^, EigenDecompositionImpl.java:1481: error: > expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	 ^, EigenDecompositionImpl.java:1481: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	  ^, EigenDecompositionImpl.java:1481: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	       ^, EigenDecompositionImpl.java:1481: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	        ^, EigenDecompositionImpl.java:1481: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                           ^, EigenDecompositionImpl.java:1481: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                              ^, EigenDecompositionImpl.java:1482: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                    ^, EigenDecompositionImpl.java:1482: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                             ^, EigenDecompositionImpl.java:1482: error: ')' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                 ^, EigenDecompositionImpl.java:1482: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                      ^, EigenDecompositionImpl.java:1482: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                        ^, EigenDecompositionImpl.java:1482: error: not a statement
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                          ^, EigenDecompositionImpl.java:1482: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                               ^, EigenDecompositionImpl.java:1482: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                                      ^, EigenDecompositionImpl.java:1483: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                       ^, EigenDecompositionImpl.java:1483: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                      ^, EigenDecompositionImpl.java:1483: error: illegal start of type
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                        ^, EigenDecompositionImpl.java:1483: error: illegal start of expression
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                         ^, EigenDecompositionImpl.java:1484: error: illegal start of expression
	 *
	 ^, EigenDecompositionImpl.java:1485: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1485: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1483: error: not a statement
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                          ^, EigenDecompositionImpl.java:1486: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1487: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1488: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1488: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1489: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1489: error: not a statement
	 * @return new end (maybe deflated)
	 ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 * @return new end (maybe deflated)
	              ^, EigenDecompositionImpl.java:1489: error: -> expected
	 * @return new end (maybe deflated)
	                                   ^, EigenDecompositionImpl.java:1490: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	 ^, EigenDecompositionImpl.java:1490: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	^, EigenDecompositionImpl.java:1489: error: not a statement
	 * @return new end (maybe deflated)
	                   ^, EigenDecompositionImpl.java:1490: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                    ^, EigenDecompositionImpl.java:1490: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                     ^, EigenDecompositionImpl.java:1490: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                                   ^, EigenDecompositionImpl.java:1497: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1497: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1497: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1497: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1497: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1499: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1499: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1500: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1500: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1500: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1500: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1501: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1502: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1502: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1502: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1502: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1502: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1502: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1502: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1502: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1503: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1503: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1503: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1503: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1503: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1503: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1503: error: ';' expected
	 * 		only every other element)
	   		                        ^]
Ingredient counter is Zero
---Undoing: gnrtn(96): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// initialize parameters used by goodStep tType = 0 ` -topatch--> `tType = -3` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (191(f=1.0), 192(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (191(f=1.0), )
----------Running generation: 97, population size: 1

***** Generation 97 : 0
**Parent Variant: [Variant id: 193, #gens: 382, #ops: 0, parent:-]

--Child created id: 194
--Creating new operations for variant [Variant id: 194, #gens: 382, #ops: 0, parent:193]
---analyzing modificationPoint position: 293
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  upperSpectra = java.lang.Double.NEGATIVE_INFINITY
---analyzing modificationPoint position: 17
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [lowerSpectra, java.lang.Double.POSITIVE_INFINITY]
--> var from patch: lowerSpectra spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: java.lang.Double.POSITIVE_INFINITY spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1093
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (dMin < 0.0) { 	// tau too big. Select new tau and try again. 	if (tType < (-22)) { 		// failed t[...] ` -topatch--> `lowerSpectra = java.lang.Double.POSITIVE_INFINITY` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1093, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (dMin < 0.0) { 	// tau too big. Select new tau and try again. 	if (tType < (-22)) { 		// failed t[...] ` -topatch--> `lowerSpectra = java.lang.Double.POSITIVE_INFINITY` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 194, #gens: 383, #ops: 1, parent:193] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 194
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-194/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(97): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (dMin < 0.0) { 	// tau too big. Select new tau and try again. 	if (tType < (-22)) { 		// failed t[...] ` -topatch--> `lowerSpectra = java.lang.Double.POSITIVE_INFINITY` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (193(f=1.0), 194(f=1.0), )
Selected to next generation: IDs2--> (193(f=1.0), )
----------Running generation: 98, population size: 1

***** Generation 98 : 0
**Parent Variant: [Variant id: 195, #gens: 382, #ops: 0, parent:-]

--Child created id: 196
--Creating new operations for variant [Variant id: 196, #gens: 382, #ops: 0, parent:195]
---analyzing modificationPoint position: 356
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  final int nCols = d[0].length
---analyzing modificationPoint position: 274
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [tau]
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java588
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[lowerStart + i] = lower ` -topatch--> `// failed twice. Play it safe. tau = 0.0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 588, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[lowerStart + i] = lower ` -topatch--> `// failed twice. Play it safe. tau = 0.0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 196, #gens: 382, #ops: 1, parent:195] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 196, errors: [EigenDecompositionImpl.java:1104: error: <identifier> expected
					if (chooseLeft) { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda + work[4 * i];}} else { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda - work[4 * i];}}} 			begin = end;} 		// sort the realEigenvalues in decreasing order 		java.util.Arrays.sort(realEigenvalues); 		int j = realEigenvalues.length - 1; 		for (int i = 0; i < j; ++i) { 			final double tmp = realEigenvalues[i]; 			realEigenvalues[i] = realEigenvalues[j]; 			realEigenvalues[j] = tmp; 			--j;}} 	/**
					                  						                              							                                                            						                              							                                                      			     ^, EigenDecompositionImpl.java:1105: error: class, interface, or enum expected
	 * Compute splitting points.
	 ^, EigenDecompositionImpl.java:1107: error: <identifier> expected
	 * @return list of indices after matrix can be split
	    ^, EigenDecompositionImpl.java:1107: error: class, interface, or enum expected
	 * @return list of indices after matrix can be split
	           ^, EigenDecompositionImpl.java:1108: error: class, interface, or enum expected
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	                                                            		      ^, EigenDecompositionImpl.java:1109: error: class, interface, or enum expected
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:1112: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1114: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                    ^, EigenDecompositionImpl.java:1114: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                                 		                                     ^, EigenDecompositionImpl.java:1122: error: class, interface, or enum expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1126: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1128: error: class, interface, or enum expected
	 * @exception InvalidMatrixException
	              ^, EigenDecompositionImpl.java:1130: error: class, interface, or enum expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                     ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                       ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		      ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		      ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		      ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		      ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			      ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			       ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		                                ^, EigenDecompositionImpl.java:1144: error: class, interface, or enum expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                       ^, EigenDecompositionImpl.java:1145: error: class, interface, or enum expected
			return;} 		// initial checks for splits (see Parlett & Marques section 3.3) 		flipIfWarranted(n, 2); 		// two iterations with Li's test for initial splits 		initialSplits(n); 		// initialize parameters used by goodStep 		tType = 0; 		dMin1 = 0; 		dMin2 = 0; 		dN = 0; 		dN1 = 0; 		dN2 = 0; 		tau = 0; 		// process split segments 		int i0 = 0; 		int n0 = n; 		while (n0 > 0) { 			// retrieve shift that was temporarily stored as a negative off-diagonal element 			sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2]; 			sigmaLow = 0; 			// find start of a new split segment to process 			double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6]; 			double offDiagMax = 0; 			double diagMax = work[(4 * n0) - 4]; 			double diagMin = diagMax; 			i0 = 0; 			for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { 				if (work[i + 2] <= 0) { 					i0 = 1 + (i / 4); 					break;} 				if (diagMin >= (4 * offDiagMax)) { 					diagMin = java.lang.Math.min(diagMin, work[i + 4]); 					offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);} 				diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]); 				offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);} 			work[(4 * n0) - 2] = offDiagMin; 			// lower bound of Gershgorin disk 			dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax))); 			pingPong = 0; 			int maxIter = 30 * (n0 - i0); 			for (int k = 0; i0 < n0; ++k) { 				if (k >= maxIter) { 					throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));} 				// perform one step 				n0 = goodStep(i0, n0); 				pingPong = 1 - pingPong; 				// check for new splits after "ping" steps 				// when the last elements of qd array are very small
			       ^, EigenDecompositionImpl.java:1146: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					^, EigenDecompositionImpl.java:1146: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					^, EigenDecompositionImpl.java:1146: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					^, EigenDecompositionImpl.java:1146: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					^, EigenDecompositionImpl.java:1146: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					                     ^, EigenDecompositionImpl.java:1146: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					                                          ^, EigenDecompositionImpl.java:1147: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1149: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1151: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                 ^, EigenDecompositionImpl.java:1151: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		^, EigenDecompositionImpl.java:1151: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		                ^, EigenDecompositionImpl.java:1151: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		                       ^, EigenDecompositionImpl.java:1159: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1161: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1163: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1163: error: class, interface, or enum expected
	 * @return new end (maybe deflated)
	           ^, EigenDecompositionImpl.java:1163: error: class, interface, or enum expected
	 * @return new end (maybe deflated)
	               ^, EigenDecompositionImpl.java:1164: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                           ^, EigenDecompositionImpl.java:1164: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                            ^, EigenDecompositionImpl.java:1165: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				^, EigenDecompositionImpl.java:1165: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                   ^, EigenDecompositionImpl.java:1165: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                     			      ^, EigenDecompositionImpl.java:1165: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                     			                                                  			^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					      ^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                  ^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                               ^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                         ^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                ^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				                                                   				^, EigenDecompositionImpl.java:1166: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				                                                   				                 ^, EigenDecompositionImpl.java:1167: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				^, EigenDecompositionImpl.java:1167: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				^, EigenDecompositionImpl.java:1167: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				^, EigenDecompositionImpl.java:1167: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				                                                                                             				^, EigenDecompositionImpl.java:1167: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				                                                                                             				            ^, EigenDecompositionImpl.java:1168: error: class, interface, or enum expected
			for (boolean loop = true; loop;) { 				// perform one dqds step with the chosen shift 				dqds(start, deflatedEnd); 				// check result of the dqds step
			                          ^, EigenDecompositionImpl.java:1168: error: class, interface, or enum expected
			for (boolean loop = true; loop;) { 				// perform one dqds step with the chosen shift 				dqds(start, deflatedEnd); 				// check result of the dqds step
			                               ^, EigenDecompositionImpl.java:1173: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1175: error: class, interface, or enum expected
	 * @param step
	          ^, EigenDecompositionImpl.java:1178: error: <identifier> expected
	 * @return true if qd array was flipped
	    ^, EigenDecompositionImpl.java:1178: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	           ^, EigenDecompositionImpl.java:1178: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	                ^, EigenDecompositionImpl.java:1178: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	                   ^, EigenDecompositionImpl.java:1179: error: class, interface, or enum expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1179: error: class, interface, or enum expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1182: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1184: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1186: error: <identifier> expected
	 * @return an interval containing the realEigenvalues
	    ^, EigenDecompositionImpl.java:1186: error: class, interface, or enum expected
	 * @return an interval containing the realEigenvalues
	           ^, EigenDecompositionImpl.java:1187: error: class, interface, or enum expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
	    	                                        ^, EigenDecompositionImpl.java:1187: error: class, interface, or enum expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
	    	                                                         ^, EigenDecompositionImpl.java:1188: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) {
				      ^, EigenDecompositionImpl.java:1188: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) {
				        			      ^, EigenDecompositionImpl.java:1188: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) {
				        			                                            			^]
Ingredient counter is Zero
---Undoing: gnrtn(98): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[lowerStart + i] = lower ` -topatch--> `// failed twice. Play it safe. tau = 0.0` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (195(f=1.0), 196(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (195(f=1.0), )
----------Running generation: 99, population size: 1

***** Generation 99 : 0
**Parent Variant: [Variant id: 197, #gens: 382, #ops: 0, parent:-]

--Child created id: 198
--Creating new operations for variant [Variant id: 198, #gens: 382, #ops: 0, parent:197]
---analyzing modificationPoint position: 82
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 0 not mutation generated in  // apply Li's reverse test double d = work[(4 * (n - 1)) + pingPong]
---analyzing modificationPoint position: 267
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [dN]
--> var from patch: dN spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1690
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `sigma = t ` -topatch--> `dN = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1690, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `sigma = t ` -topatch--> `dN = 0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 198, #gens: 382, #ops: 1, parent:197] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 198
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-198/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(99): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `sigma = t ` -topatch--> `dN = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (197(f=1.0), 198(f=8.0), )
Selected to next generation: IDs2--> (197(f=1.0), )
----------Running generation: 100, population size: 1

***** Generation 100 : 0
**Parent Variant: [Variant id: 199, #gens: 382, #ops: 0, parent:-]

--Child created id: 200
--Creating new operations for variant [Variant id: 200, #gens: 382, #ops: 0, parent:199]
---analyzing modificationPoint position: 336
Templates availables1
Attempts Base Ingredients  1 total 1
vars from patch [out, column, row, value]
--> var from patch: out spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: column spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: row spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: value spoon.support.reflect.code.CtVariableReadImpl
location: AbstractRealMatrix.java611
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtInvocationImpl) `out.setEntry(column, row, value) ` -topatch--> `out.setEntry(column, row, value)` (spoon.support.reflect.code.CtInvocationImpl) 
---MP=org.apache.commons.math.linear.AbstractRealMatrix line: 611, pointed element: CtInvocationImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtInvocationImpl) `out.setEntry(column, row, value) ` -topatch--> `out.setEntry(column, row, value)` (spoon.support.reflect.code.CtInvocationImpl) 

--Summary Creation: for variant [Variant id: 200, #gens: 383, #ops: 1, parent:199] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 200
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-200/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(100): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtInvocationImpl) `out.setEntry(column, row, value) ` -topatch--> `out.setEntry(column, row, value)` (spoon.support.reflect.code.CtInvocationImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (199(f=1.0), 200(f=1.0), )
Selected to next generation: IDs2--> (199(f=1.0), )
----------Running generation: 101, population size: 1

***** Generation 101 : 0
**Parent Variant: [Variant id: 201, #gens: 382, #ops: 0, parent:-]

--Child created id: 202
--Creating new operations for variant [Variant id: 202, #gens: 382, #ops: 0, parent:201]
---analyzing modificationPoint position: 299
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  work[(lowerStart + m) - 1] = lower
---analyzing modificationPoint position: 312
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  // splitting preserving relative accuracy double absDCurrent = java.lang.Math.abs(main[0])
---analyzing modificationPoint position: 323
Templates availables23
Attempts Base Ingredients  1 total 23
vars from patch []
location: Array2DRowRealMatrix.java278
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double[] dataRow = data[row] ` -topatch--> `final int nCols = this.getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 278, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double[] dataRow = data[row] ` -topatch--> `final int nCols = this.getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 202, #gens: 382, #ops: 1, parent:201] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 202, errors: [Array2DRowRealMatrix.java:419: error: variable nCols is already defined in method multiply(org.apache.commons.math.linear.Array2DRowRealMatrix)
			final int nCols = this.getColumnDimension(); 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
			          ^, Array2DRowRealMatrix.java:419: error: cannot find symbol
			final int nCols = this.getColumnDimension(); 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
			                                             			                                          			                                        				                				                                 					       ^
  symbol:   variable dataRow
  location: class org.apache.commons.math.linear.Array2DRowRealMatrix]
Ingredient counter is Zero
---Undoing: gnrtn(101): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double[] dataRow = data[row] ` -topatch--> `final int nCols = this.getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (201(f=1.0), 202(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (201(f=1.0), )
----------Running generation: 102, population size: 1

***** Generation 102 : 0
**Parent Variant: [Variant id: 203, #gens: 382, #ops: 0, parent:-]

--Child created id: 204
--Creating new operations for variant [Variant id: 204, #gens: 382, #ops: 0, parent:203]
---analyzing modificationPoint position: 381
Templates availables216
Attempts Base Ingredients  1 total 216
---modifPoint 0 not mutation generated in  if (rowDimension <= 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentEx[...]
---analyzing modificationPoint position: 151
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  if (countEigenValues(middle, index, n) >= n) { 	right = middle; } else { 	left = middle; }
---analyzing modificationPoint position: 149
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  // search has converged break
---analyzing modificationPoint position: 31
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  this.main = main.clone()
---analyzing modificationPoint position: 238
---modifPoint 4 not mutation generated in  final double tmp = work[j4p2 + 2] / work[j4 - 2]
---analyzing modificationPoint position: 40
location: EigenDecompositionImpl.java827
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < (n - 1); ++i) { 	final int fourI = 4 * i; 	final double ei = work[fourI + 2]; 	s[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 204, #gens: 381, #ops: 1, parent:203] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 204
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-204/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(102): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < (n - 1); ++i) { 	final int fourI = 4 * i; 	final double ei = work[fourI + 2]; 	s[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (203(f=1.0), 204(f=8.0), )
Selected to next generation: IDs2--> (203(f=1.0), )
----------Running generation: 103, population size: 1

***** Generation 103 : 0
**Parent Variant: [Variant id: 205, #gens: 382, #ops: 0, parent:-]

--Child created id: 206
--Creating new operations for variant [Variant id: 206, #gens: 382, #ops: 0, parent:205]
---analyzing modificationPoint position: 94
location: EigenDecompositionImpl.java964
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `d *= tmp ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 206, #gens: 381, #ops: 1, parent:205] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 206
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-206/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(103): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `d *= tmp ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (205(f=1.0), 206(f=8.0), )
Selected to next generation: IDs2--> (205(f=1.0), )
----------Running generation: 104, population size: 1

***** Generation 104 : 0
**Parent Variant: [Variant id: 207, #gens: 382, #ops: 0, parent:-]

--Child created id: 208
--Creating new operations for variant [Variant id: 208, #gens: 382, #ops: 0, parent:207]
---analyzing modificationPoint position: 200
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dMin, tau, tType]
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1309
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `j4 = j4 + 4 ` -topatch--> `// a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...]` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1309, pointed element: CtIfImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `j4 = j4 + 4 ` -topatch--> `// a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...]` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 208, #gens: 383, #ops: 1, parent:207] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 208, errors: [EigenDecompositionImpl.java:1452: error: illegal start of expression
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	 ^, EigenDecompositionImpl.java:1452: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	          ^, EigenDecompositionImpl.java:1452: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                    ^, EigenDecompositionImpl.java:1452: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                 ^, EigenDecompositionImpl.java:1452: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                             ^, EigenDecompositionImpl.java:1452: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                    ^, EigenDecompositionImpl.java:1452: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                                        ^, EigenDecompositionImpl.java:1453: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	      ^, EigenDecompositionImpl.java:1453: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                            ^, EigenDecompositionImpl.java:1453: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                          ^, EigenDecompositionImpl.java:1453: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                 ^, EigenDecompositionImpl.java:1453: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                ^, EigenDecompositionImpl.java:1453: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                         ^, EigenDecompositionImpl.java:1453: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                           ^, EigenDecompositionImpl.java:1455: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1455: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1456: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1456: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1457: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1458: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1458: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1459: error: illegal start of expression
	 * @param deflated
	   ^, EigenDecompositionImpl.java:1460: error: not a statement
	 * 		number of realEigenvalues just deflated
	 ^, EigenDecompositionImpl.java:1460: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		      ^, EigenDecompositionImpl.java:1460: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                         ^, EigenDecompositionImpl.java:1460: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                                       ^, EigenDecompositionImpl.java:1461: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	^, EigenDecompositionImpl.java:1461: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	        ^, EigenDecompositionImpl.java:1461: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                  ^, EigenDecompositionImpl.java:1461: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                   ^, EigenDecompositionImpl.java:1461: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                  ^, EigenDecompositionImpl.java:1461: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                                     ^, EigenDecompositionImpl.java:1527: error: 'else' without 'if'
				} else if (dMin == dN2) {
				  ^, EigenDecompositionImpl.java:1586: error: orphaned case
			case 1 : 				// one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.
			^]
Ingredient counter is Zero
---Undoing: gnrtn(104): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `j4 = j4 + 4 ` -topatch--> `// a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...]` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (207(f=1.0), 208(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (207(f=1.0), )
----------Running generation: 105, population size: 1

***** Generation 105 : 0
**Parent Variant: [Variant id: 209, #gens: 382, #ops: 0, parent:-]

--Child created id: 210
--Creating new operations for variant [Variant id: 210, #gens: 382, #ops: 0, parent:209]
---analyzing modificationPoint position: 2
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // case 9. tau = 0.25 * dMin1
---analyzing modificationPoint position: 94
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [work, n, pingPong]
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: n spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java964
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `d *= tmp ` -topatch--> `// apply Li's reverse test double d = work[(4 * (n - 1)) + pingPong]` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 964, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `d *= tmp ` -topatch--> `// apply Li's reverse test double d = work[(4 * (n - 1)) + pingPong]` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 210, #gens: 383, #ops: 1, parent:209] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 210
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-210/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(105): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `d *= tmp ` -topatch--> `// apply Li's reverse test double d = work[(4 * (n - 1)) + pingPong]` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (209(f=1.0), 210(f=1.0), )
Selected to next generation: IDs2--> (209(f=1.0), )
----------Running generation: 106, population size: 1

***** Generation 106 : 0
**Parent Variant: [Variant id: 211, #gens: 382, #ops: 0, parent:-]

--Child created id: 212
--Creating new operations for variant [Variant id: 212, #gens: 382, #ops: 0, parent:211]
---analyzing modificationPoint position: 24
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  if (dMin == dN) { 	gam = dN; 	a2 = 0.0; 	if (work[nn - 5] > work[nn - 7]) { 		return; 	} 	b2 = work[[...]
---analyzing modificationPoint position: 174
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  dMin = d
---analyzing modificationPoint position: 6
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 2 not mutation generated in  a2 = 0.0
---analyzing modificationPoint position: 337
---modifPoint 3 not mutation generated in  return out
---analyzing modificationPoint position: 20
location: EigenDecompositionImpl.java1100
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// late failure. Gives excellent shift. tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.u[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 212, #gens: 381, #ops: 1, parent:211] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child compiles: id 212
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-212/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(106): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// late failure. Gives excellent shift. tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.u[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (211(f=1.0), 212(f=1.0), )
Selected to next generation: IDs2--> (211(f=1.0), )
----------Running generation: 107, population size: 1

***** Generation 107 : 0
**Parent Variant: [Variant id: 213, #gens: 382, #ops: 0, parent:-]

--Child created id: 214
--Creating new operations for variant [Variant id: 214, #gens: 382, #ops: 0, parent:213]
---analyzing modificationPoint position: 128
---modifPoint 0 not mutation generated in  // set thresholds final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.[...]
---analyzing modificationPoint position: 178
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 1 not mutation generated in  work[j4 - 2] = d + work[j4 - 1]
---analyzing modificationPoint position: 288
Templates availables19
Attempts Base Ingredients  1 total 19
---modifPoint 2 not mutation generated in  // find all the realEigenvalues findEigenvalues()
---analyzing modificationPoint position: 151
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  if (countEigenValues(middle, index, n) >= n) { 	right = middle; } else { 	left = middle; }
---analyzing modificationPoint position: 147
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  final double range = right - left
---analyzing modificationPoint position: 252
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 5 not mutation generated in  double a2 = work[nn - 7] + work[nn - 5]
---analyzing modificationPoint position: 38
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 6 not mutation generated in  this.splitTolerance = splitTolerance
---analyzing modificationPoint position: 182
location: EigenDecompositionImpl.java1284
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4 - 1] * tmp ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 214, #gens: 381, #ops: 1, parent:213] gen mutated: 1 , gen not mut: 7, gen not applied  0
-The child compiles: id 214
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-214/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(107): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4] = work[j4 - 1] * tmp ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (213(f=1.0), 214(f=8.0), )
Selected to next generation: IDs2--> (213(f=1.0), )
----------Running generation: 108, population size: 1

***** Generation 108 : 0
**Parent Variant: [Variant id: 215, #gens: 382, #ops: 0, parent:-]

--Child created id: 216
--Creating new operations for variant [Variant id: 216, #gens: 382, #ops: 0, parent:215]
---analyzing modificationPoint position: 198
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  dMin = java.lang.Math.min(dMin, dN1)
---analyzing modificationPoint position: 377
---modifPoint 1 not mutation generated in  return data == null ? 0 : data.length
---analyzing modificationPoint position: 268
Templates availables156
Attempts Base Ingredients  1 total 156
vars from patch []
location: EigenDecompositionImpl.java581
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double dCurrent = main[i] ` -topatch--> `double eMax = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 581, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double dCurrent = main[i] ` -topatch--> `double eMax = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 216, #gens: 382, #ops: 1, parent:215] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 216, errors: [EigenDecompositionImpl.java:580: error: variable eMax is already defined in method computeGershgorinCircles()
		for (int i = 0; i < (m - 1); ++i) { 			double eMax = 0;
		                                    			       ^, EigenDecompositionImpl.java:588: error: cannot find symbol
			final double lower = dCurrent - radius;
			                     ^
  symbol:   variable dCurrent
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:592: error: cannot find symbol
			final double upper = dCurrent + radius;
			                     ^
  symbol:   variable dCurrent
  location: class org.apache.commons.math.linear.EigenDecompositionImpl]
Ingredient counter is Zero
---Undoing: gnrtn(108): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double dCurrent = main[i] ` -topatch--> `double eMax = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (215(f=1.0), 216(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (215(f=1.0), )
----------Running generation: 109, population size: 1

***** Generation 109 : 0
**Parent Variant: [Variant id: 217, #gens: 382, #ops: 0, parent:-]

--Child created id: 218
--Creating new operations for variant [Variant id: 218, #gens: 382, #ops: 0, parent:217]
---analyzing modificationPoint position: 305
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // find realEigenvalues in each block realEigenvalues = new double[main.length]
---analyzing modificationPoint position: 194
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  int j4p2 = (j4 + (2 * pingPong)) - 1
---analyzing modificationPoint position: 26
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [cachedV]
--> var from patch: cachedV spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1503
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 	if (b2 == 0.0) { 		break; 	} 	b1[...] ` -topatch--> `cachedV = null` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1503, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 	if (b2 == 0.0) { 		break; 	} 	b1[...] ` -topatch--> `cachedV = null` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 218, #gens: 383, #ops: 1, parent:217] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 218
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-218/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(109): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 	if (b2 == 0.0) { 		break; 	} 	b1[...] ` -topatch--> `cachedV = null` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (217(f=1.0), 218(f=1.0), )
Selected to next generation: IDs2--> (217(f=1.0), )
----------Running generation: 110, population size: 1

***** Generation 110 : 0
**Parent Variant: [Variant id: 219, #gens: 382, #ops: 0, parent:-]

--Child created id: 220
--Creating new operations for variant [Variant id: 220, #gens: 382, #ops: 0, parent:219]
---analyzing modificationPoint position: 238
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  final double tmp = work[j4p2 + 2] / work[j4 - 2]
---analyzing modificationPoint position: 91
location: EigenDecompositionImpl.java960
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) &&  ((org.apache.com[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 220, #gens: 381, #ops: 1, parent:219] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 220
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-220/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(110): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) &&  ((org.apache.com[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (219(f=1.0), 220(f=8.0), )
Selected to next generation: IDs2--> (219(f=1.0), )
----------Running generation: 111, population size: 1

***** Generation 111 : 0
**Parent Variant: [Variant id: 221, #gens: 382, #ops: 0, parent:-]

--Child created id: 222
--Creating new operations for variant [Variant id: 222, #gens: 382, #ops: 0, parent:221]
---analyzing modificationPoint position: 177
location: EigenDecompositionImpl.java1279
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 	work[j4 - 2] = d + work[j4 - 1]; 	[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 222, #gens: 381, #ops: 1, parent:221] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 222
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-222/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(111): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 	work[j4 - 2] = d + work[j4 - 1]; 	[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (221(f=1.0), 222(f=8.0), )
Selected to next generation: IDs2--> (221(f=1.0), )
----------Running generation: 112, population size: 1

***** Generation 112 : 0
**Parent Variant: [Variant id: 223, #gens: 382, #ops: 0, parent:-]

--Child created id: 224
--Creating new operations for variant [Variant id: 224, #gens: 382, #ops: 0, parent:223]
---analyzing modificationPoint position: 241
location: EigenDecompositionImpl.java1416
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = java.lang.Math.min(dMin, dN) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 224, #gens: 381, #ops: 1, parent:223] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 224
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-224/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(112): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin = java.lang.Math.min(dMin, dN) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (223(f=1.0), 224(f=1.0), )
Selected to next generation: IDs2--> (223(f=1.0), )
----------Running generation: 113, population size: 1

***** Generation 113 : 0
**Parent Variant: [Variant id: 225, #gens: 382, #ops: 0, parent:-]

--Child created id: 226
--Creating new operations for variant [Variant id: 226, #gens: 382, #ops: 0, parent:225]
---analyzing modificationPoint position: 112
location: EigenDecompositionImpl.java1074
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `// step 4a: dqds for (boolean loop = true; loop;) {  	// perform one dqds step with the chosen shift[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 226, #gens: 381, #ops: 1, parent:225] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 226
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-226/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 4, was successful: false, cases executed: 17] ,[]
-Valid?: |false|4|17|[]|, fitness 4.0
Ingredient counter is Zero
---Undoing: gnrtn(113): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `// step 4a: dqds for (boolean loop = true; loop;) {  	// perform one dqds step with the chosen shift[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (225(f=1.0), 226(f=4.0), )
Selected to next generation: IDs2--> (225(f=1.0), )
----------Running generation: 114, population size: 1

***** Generation 114 : 0
**Parent Variant: [Variant id: 227, #gens: 382, #ops: 0, parent:-]

--Child created id: 228
--Creating new operations for variant [Variant id: 228, #gens: 382, #ops: 0, parent:227]
---analyzing modificationPoint position: 89
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  work[j] = d + work[i]
---analyzing modificationPoint position: 206
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  work[j4 + 2] = dN
---analyzing modificationPoint position: 216
---modifPoint 2 not mutation generated in  final double tmp = work[j4 + 1] / work[j4 - 2]
---analyzing modificationPoint position: 154
location: EigenDecompositionImpl.java1216
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * [...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 228, #gens: 381, #ops: 1, parent:227] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 228
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-228/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 17] ,[]
-Valid?: |false|3|17|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(114): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * [...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (227(f=1.0), 228(f=3.0), )
Selected to next generation: IDs2--> (227(f=1.0), )
----------Running generation: 115, population size: 1

***** Generation 115 : 0
**Parent Variant: [Variant id: 229, #gens: 382, #ops: 0, parent:-]

--Child created id: 230
--Creating new operations for variant [Variant id: 230, #gens: 382, #ops: 0, parent:229]
---analyzing modificationPoint position: 149
location: EigenDecompositionImpl.java1205
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtBreakImpl) `// search has converged break ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 230, #gens: 381, #ops: 1, parent:229] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 230
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-230/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 17] ,[]
-Valid?: |false|3|17|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(115): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtBreakImpl) `// search has converged break ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (229(f=1.0), 230(f=3.0), )
Selected to next generation: IDs2--> (229(f=1.0), )
----------Running generation: 116, population size: 1

***** Generation 116 : 0
**Parent Variant: [Variant id: 231, #gens: 382, #ops: 0, parent:-]

--Child created id: 232
--Creating new operations for variant [Variant id: 232, #gens: 382, #ops: 0, parent:231]
---analyzing modificationPoint position: 164
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  work[0] = java.lang.Math.abs(di)
---analyzing modificationPoint position: 131
---modifPoint 1 not mutation generated in  final int maxIter =  2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot[...]
---analyzing modificationPoint position: 190
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  eMin = java.lang.Math.min(work[j4 - 1], eMin)
---analyzing modificationPoint position: 370
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 3 not mutation generated in  if (nCols == 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException[...]
---analyzing modificationPoint position: 11
location: EigenDecompositionImpl.java1507
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `b1 = b2 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 232, #gens: 381, #ops: 1, parent:231] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child compiles: id 232
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-232/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(116): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `b1 = b2 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (231(f=1.0), 232(f=1.0), )
Selected to next generation: IDs2--> (231(f=1.0), )
----------Running generation: 117, population size: 1

***** Generation 117 : 0
**Parent Variant: [Variant id: 233, #gens: 382, #ops: 0, parent:-]

--Child created id: 234
--Creating new operations for variant [Variant id: 234, #gens: 382, #ops: 0, parent:233]
---analyzing modificationPoint position: 199
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  dMin1 = dMin
---analyzing modificationPoint position: 195
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  work[j4 - 2] = dN2 + work[j4p2]
---analyzing modificationPoint position: 256
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  if ((gap1 > 0.0) && (gap1 > b1)) { 	tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin); 	[...]
---analyzing modificationPoint position: 294
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  double eMax = 0
---analyzing modificationPoint position: 8
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1484
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `b2 = work[nn - 5] / work[nn - 7] ` -topatch--> `double n2 = 1` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1484, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `b2 = work[nn - 5] / work[nn - 7] ` -topatch--> `double n2 = 1` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 234, #gens: 383, #ops: 1, parent:233] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child does NOT compile: 234, errors: [EigenDecompositionImpl.java:1765: error: orphaned default
				if ((dMin2 == dN2) && ((2 * work[nn - 5]) < work[nn - 7])) { 					tType = -10; 					final double s = 0.333 * dMin2; 					if (work[nn - 5] > work[nn - 7]) { 						return;} 					double b1 = work[nn - 5] / work[nn - 7]; 					double b2 = b1; 					if (b2 != 0.0) { 						for (int i4 = ((4 * end) - 9) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (work[i4] > work[i4 - 2]) { 								return;} 							b1 *= work[i4] / work[i4 - 2]; 							b2 += b1; 							if ((100 * b1) < b2) { 								break;}}} 					b2 = java.lang.Math.sqrt(cnst3 * b2); 					final double a2 = dMin2 / (1 + (b2 * b2)); 					final double gap2 = ((work[nn - 7] + work[nn - 9]) - (java.lang.Math.sqrt(work[nn - 11]) * java.lang.Math.sqrt(work[nn - 9]))) - a2; 					if ((gap2 > 0.0) && (gap2 > (b2 * a2))) { 						tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));} else { 						tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));}} else { 					tau = 0.25 * dMin2; 					tType = -11;} 				break; 			default : 				// case 12, more than two realEigenvalues deflated. no information. 				tau = 0.0; 				tType = -12;}} 	/**
				                                                             					             					                                					                                   						         					                                         					                					                 						                                                                                           							                               								         							                               							          							                       								          					                                      					                                           					                                                                                                                                     					                                          						                                                                                     						                                                               					                    					              				       			^, EigenDecompositionImpl.java:1766: error: illegal start of expression
	 * Update sigma.
	 ^, EigenDecompositionImpl.java:1766: error: ';' expected
	 * Update sigma.
	         ^, EigenDecompositionImpl.java:1766: error: <identifier> expected
	 * Update sigma.
	                ^, EigenDecompositionImpl.java:1768: error: illegal start of expression
	 * @param shift
	 ^, EigenDecompositionImpl.java:1768: error: illegal start of expression
	 * @param shift
	   ^, EigenDecompositionImpl.java:1769: error: not a statement
	 * 		shift to apply to sigma
	 ^, EigenDecompositionImpl.java:1769: error: ';' expected
	 * 		shift to apply to sigma
	   		     ^, EigenDecompositionImpl.java:1769: error: ';' expected
	 * 		shift to apply to sigma
	   		              ^, EigenDecompositionImpl.java:1769: error: ';' expected
	 * 		shift to apply to sigma
	   		                       ^, EigenDecompositionImpl.java:1770: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements 		// the expressions below take care to accumulate the part of sigma 		// that does not fit within a double variable into sigmaLow
	    	^, EigenDecompositionImpl.java:1770: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements 		// the expressions below take care to accumulate the part of sigma 		// that does not fit within a double variable into sigmaLow
	    	        ^, EigenDecompositionImpl.java:1770: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements 		// the expressions below take care to accumulate the part of sigma 		// that does not fit within a double variable into sigmaLow
	    	                        ^, EigenDecompositionImpl.java:1770: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements 		// the expressions below take care to accumulate the part of sigma 		// that does not fit within a double variable into sigmaLow
	    	                                           ^, EigenDecompositionImpl.java:1773: error: illegal start of expression
	 */ 	private void findEigenVectors() { 		final int m = main.length; 		eigenvectors = new org.apache.commons.math.linear.ArrayRealVector[m]; 		// perform an initial non-shifted LDLt decomposition 		final double[] d = new double[m]; 		final double[] l = new double[m - 1]; 		// avoid zero divide on indefinite matrix 		final double mu = ((realEigenvalues[m - 1] <= 0) && (realEigenvalues[0] > 0)) ? 0.5 - realEigenvalues[m - 1] : 0; 		double di = main[0] + mu; 		d[0] = di; 		for (int i = 1; i < m; ++i) { 			final double eiM1 = secondary[i - 1]; 			final double ratio = eiM1 / di; 			di = (main[i] - (eiM1 * ratio)) + mu; 			l[i - 1] = ratio; 			d[i] = di;} 		// compute eigenvectors
	    	^, EigenDecompositionImpl.java:1773: error: illegal start of expression
	 */ 	private void findEigenVectors() { 		final int m = main.length; 		eigenvectors = new org.apache.commons.math.linear.ArrayRealVector[m]; 		// perform an initial non-shifted LDLt decomposition 		final double[] d = new double[m]; 		final double[] l = new double[m - 1]; 		// avoid zero divide on indefinite matrix 		final double mu = ((realEigenvalues[m - 1] <= 0) && (realEigenvalues[0] > 0)) ? 0.5 - realEigenvalues[m - 1] : 0; 		double di = main[0] + mu; 		d[0] = di; 		for (int i = 1; i < m; ++i) { 			final double eiM1 = secondary[i - 1]; 			final double ratio = eiM1 / di; 			di = (main[i] - (eiM1 * ratio)) + mu; 			l[i - 1] = ratio; 			d[i] = di;} 		// compute eigenvectors
	    	        ^, EigenDecompositionImpl.java:1773: error: ';' expected
	 */ 	private void findEigenVectors() { 		final int m = main.length; 		eigenvectors = new org.apache.commons.math.linear.ArrayRealVector[m]; 		// perform an initial non-shifted LDLt decomposition 		final double[] d = new double[m]; 		final double[] l = new double[m - 1]; 		// avoid zero divide on indefinite matrix 		final double mu = ((realEigenvalues[m - 1] <= 0) && (realEigenvalues[0] > 0)) ? 0.5 - realEigenvalues[m - 1] : 0; 		double di = main[0] + mu; 		d[0] = di; 		for (int i = 1; i < m; ++i) { 			final double eiM1 = secondary[i - 1]; 			final double ratio = eiM1 / di; 			di = (main[i] - (eiM1 * ratio)) + mu; 			l[i - 1] = ratio; 			d[i] = di;} 		// compute eigenvectors
	    	                             ^, EigenDecompositionImpl.java:1785: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) { 		// compute the LDLt and UDUt decompositions of the 		// perfectly shifted tridiagonal matrix 		final int m = main.length; 		stationaryQuotientDifferenceWithShift(d, l, eigenvalue); 		progressiveQuotientDifferenceWithShift(d, l, eigenvalue); 		// select the twist index leading to 		// the least diagonal element in the twisted factorization 		int r = m - 1; 		double minG = java.lang.Math.abs((work[6 * r] + work[(6 * r) + 3]) + eigenvalue); 		int sixI = 0; 		for (int i = 0; i < (m - 1); ++i) { 			final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10])); 			if (absG < minG) { 				r = i; 				minG = absG;} 			sixI += 6;} 		// solve the singular system by ignoring the equation 		// at twist index and propagating upwards and downwards 		double[] eigenvector = new double[m]; 		double n2 = 1; 		eigenvector[r] = 1; 		double z = 1; 		for (int i = r - 1; i >= 0; --i) { 			z *= -work[(6 * i) + 2]; 			eigenvector[i] = z; 			n2 += z * z;} 		z = 1; 		for (int i = r + 1; i < m; ++i) { 			z *= -work[(6 * i) - 1]; 			eigenvector[i] = z; 			n2 += z * z;} 		// normalize vector 		final double inv = 1.0 / java.lang.Math.sqrt(n2); 		for (int i = 0; i < m; ++i) { 			eigenvector[i] *= inv;} 		return transformer == null ? new org.apache.commons.math.linear.ArrayRealVector(eigenvector, false) : new org.apache.commons.math.linear.ArrayRealVector(transformer.getQ().operate(eigenvector), false);}
	    	^, EigenDecompositionImpl.java:1785: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) { 		// compute the LDLt and UDUt decompositions of the 		// perfectly shifted tridiagonal matrix 		final int m = main.length; 		stationaryQuotientDifferenceWithShift(d, l, eigenvalue); 		progressiveQuotientDifferenceWithShift(d, l, eigenvalue); 		// select the twist index leading to 		// the least diagonal element in the twisted factorization 		int r = m - 1; 		double minG = java.lang.Math.abs((work[6 * r] + work[(6 * r) + 3]) + eigenvalue); 		int sixI = 0; 		for (int i = 0; i < (m - 1); ++i) { 			final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10])); 			if (absG < minG) { 				r = i; 				minG = absG;} 			sixI += 6;} 		// solve the singular system by ignoring the equation 		// at twist index and propagating upwards and downwards 		double[] eigenvector = new double[m]; 		double n2 = 1; 		eigenvector[r] = 1; 		double z = 1; 		for (int i = r - 1; i >= 0; --i) { 			z *= -work[(6 * i) + 2]; 			eigenvector[i] = z; 			n2 += z * z;} 		z = 1; 		for (int i = r + 1; i < m; ++i) { 			z *= -work[(6 * i) - 1]; 			eigenvector[i] = z; 			n2 += z * z;} 		// normalize vector 		final double inv = 1.0 / java.lang.Math.sqrt(n2); 		for (int i = 0; i < m; ++i) { 			eigenvector[i] *= inv;} 		return transformer == null ? new org.apache.commons.math.linear.ArrayRealVector(eigenvector, false) : new org.apache.commons.math.linear.ArrayRealVector(transformer.getQ().operate(eigenvector), false);}
	    	                                                                      ^, EigenDecompositionImpl.java:1785: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) { 		// compute the LDLt and UDUt decompositions of the 		// perfectly shifted tridiagonal matrix 		final int m = main.length; 		stationaryQuotientDifferenceWithShift(d, l, eigenvalue); 		progressiveQuotientDifferenceWithShift(d, l, eigenvalue); 		// select the twist index leading to 		// the least diagonal element in the twisted factorization 		int r = m - 1; 		double minG = java.lang.Math.abs((work[6 * r] + work[(6 * r) + 3]) + eigenvalue); 		int sixI = 0; 		for (int i = 0; i < (m - 1); ++i) { 			final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10])); 			if (absG < minG) { 				r = i; 				minG = absG;} 			sixI += 6;} 		// solve the singular system by ignoring the equation 		// at twist index and propagating upwards and downwards 		double[] eigenvector = new double[m]; 		double n2 = 1; 		eigenvector[r] = 1; 		double z = 1; 		for (int i = r - 1; i >= 0; --i) { 			z *= -work[(6 * i) + 2]; 			eigenvector[i] = z; 			n2 += z * z;} 		z = 1; 		for (int i = r + 1; i < m; ++i) { 			z *= -work[(6 * i) - 1]; 			eigenvector[i] = z; 			n2 += z * z;} 		// normalize vector 		final double inv = 1.0 / java.lang.Math.sqrt(n2); 		for (int i = 0; i < m; ++i) { 			eigenvector[i] *= inv;} 		return transformer == null ? new org.apache.commons.math.linear.ArrayRealVector(eigenvector, false) : new org.apache.commons.math.linear.ArrayRealVector(transformer.getQ().operate(eigenvector), false);}
	    	                                                                                               ^, EigenDecompositionImpl.java:1785: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) { 		// compute the LDLt and UDUt decompositions of the 		// perfectly shifted tridiagonal matrix 		final int m = main.length; 		stationaryQuotientDifferenceWithShift(d, l, eigenvalue); 		progressiveQuotientDifferenceWithShift(d, l, eigenvalue); 		// select the twist index leading to 		// the least diagonal element in the twisted factorization 		int r = m - 1; 		double minG = java.lang.Math.abs((work[6 * r] + work[(6 * r) + 3]) + eigenvalue); 		int sixI = 0; 		for (int i = 0; i < (m - 1); ++i) { 			final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10])); 			if (absG < minG) { 				r = i; 				minG = absG;} 			sixI += 6;} 		// solve the singular system by ignoring the equation 		// at twist index and propagating upwards and downwards 		double[] eigenvector = new double[m]; 		double n2 = 1; 		eigenvector[r] = 1; 		double z = 1; 		for (int i = r - 1; i >= 0; --i) { 			z *= -work[(6 * i) + 2]; 			eigenvector[i] = z; 			n2 += z * z;} 		z = 1; 		for (int i = r + 1; i < m; ++i) { 			z *= -work[(6 * i) - 1]; 			eigenvector[i] = z; 			n2 += z * z;} 		// normalize vector 		final double inv = 1.0 / java.lang.Math.sqrt(n2); 		for (int i = 0; i < m; ++i) { 			eigenvector[i] *= inv;} 		return transformer == null ? new org.apache.commons.math.linear.ArrayRealVector(eigenvector, false) : new org.apache.commons.math.linear.ArrayRealVector(transformer.getQ().operate(eigenvector), false);}
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1785: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) { 		// compute the LDLt and UDUt decompositions of the 		// perfectly shifted tridiagonal matrix 		final int m = main.length; 		stationaryQuotientDifferenceWithShift(d, l, eigenvalue); 		progressiveQuotientDifferenceWithShift(d, l, eigenvalue); 		// select the twist index leading to 		// the least diagonal element in the twisted factorization 		int r = m - 1; 		double minG = java.lang.Math.abs((work[6 * r] + work[(6 * r) + 3]) + eigenvalue); 		int sixI = 0; 		for (int i = 0; i < (m - 1); ++i) { 			final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10])); 			if (absG < minG) { 				r = i; 				minG = absG;} 			sixI += 6;} 		// solve the singular system by ignoring the equation 		// at twist index and propagating upwards and downwards 		double[] eigenvector = new double[m]; 		double n2 = 1; 		eigenvector[r] = 1; 		double z = 1; 		for (int i = r - 1; i >= 0; --i) { 			z *= -work[(6 * i) + 2]; 			eigenvector[i] = z; 			n2 += z * z;} 		z = 1; 		for (int i = r + 1; i < m; ++i) { 			z *= -work[(6 * i) - 1]; 			eigenvector[i] = z; 			n2 += z * z;} 		// normalize vector 		final double inv = 1.0 / java.lang.Math.sqrt(n2); 		for (int i = 0; i < m; ++i) { 			eigenvector[i] *= inv;} 		return transformer == null ? new org.apache.commons.math.linear.ArrayRealVector(eigenvector, false) : new org.apache.commons.math.linear.ArrayRealVector(transformer.getQ().operate(eigenvector), false);}
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                  ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                    ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                      ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                                          ^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	        ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                   ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                     ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                       ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                                           ^, EigenDecompositionImpl.java:1843: error: reached end of file while parsing
}
 ^]
Ingredient counter is Zero
---Undoing: gnrtn(117): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `b2 = work[nn - 5] / work[nn - 7] ` -topatch--> `double n2 = 1` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (233(f=1.0), 234(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (233(f=1.0), )
----------Running generation: 118, population size: 1

***** Generation 118 : 0
**Parent Variant: [Variant id: 235, #gens: 382, #ops: 0, parent:-]

--Child created id: 236
--Creating new operations for variant [Variant id: 236, #gens: 382, #ops: 0, parent:235]
---analyzing modificationPoint position: 232
location: EigenDecompositionImpl.java1398
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin1 = dMin ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 236, #gens: 381, #ops: 1, parent:235] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 236
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-236/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 17] ,[]
-Valid?: |false|3|17|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(118): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin1 = dMin ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (235(f=1.0), 236(f=3.0), )
Selected to next generation: IDs2--> (235(f=1.0), )
----------Running generation: 119, population size: 1

***** Generation 119 : 0
**Parent Variant: [Variant id: 237, #gens: 382, #ops: 0, parent:-]

--Child created id: 238
--Creating new operations for variant [Variant id: 238, #gens: 382, #ops: 0, parent:237]
---analyzing modificationPoint position: 381
Templates availables25
Attempts Base Ingredients  1 total 25
---modifPoint 0 not mutation generated in  if (rowDimension <= 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentEx[...]
---analyzing modificationPoint position: 196
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2])
---analyzing modificationPoint position: 23
---modifPoint 2 not mutation generated in  double s = 0.25 * dMin
---analyzing modificationPoint position: 235
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  work[j4 - 2] = dN1 + work[j4p2]
---analyzing modificationPoint position: 34
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  // pre-compute some elements squaredSecondary = new double[secondary.length]
---analyzing modificationPoint position: 90
location: EigenDecompositionImpl.java955
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 	work[i] =[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 238, #gens: 381, #ops: 1, parent:237] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 238
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-238/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(119): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 	work[i] =[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (237(f=1.0), 238(f=8.0), )
Selected to next generation: IDs2--> (237(f=1.0), )
----------Running generation: 120, population size: 1

***** Generation 120 : 0
**Parent Variant: [Variant id: 239, #gens: 382, #ops: 0, parent:-]

--Child created id: 240
--Creating new operations for variant [Variant id: 240, #gens: 382, #ops: 0, parent:239]
---analyzing modificationPoint position: 372
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  for (int i = 0; i < data.length; ++i) { 	if (subMatrix[i].length != nCols) { 		throw org.apache.comm[...]
---analyzing modificationPoint position: 83
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 	if (work[i + 2] <= (org.apache.commons.mat[...]
---analyzing modificationPoint position: 30
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 2 not mutation generated in  tau = s
---analyzing modificationPoint position: 230
Templates availables595
Attempts Base Ingredients  1 total 595
Name Conflict [splitIndices, begin, tau, org.apache.commons.math.util.MathUtils.EPSILON, minPivot, realEigenvalues, work]
---modifPoint 3 not mutation generated in  dN1 = dN2 * tmp
---analyzing modificationPoint position: 292
location: EigenDecompositionImpl.java574
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 240, #gens: 381, #ops: 1, parent:239] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child compiles: id 240
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-240/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(120): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (239(f=1.0), 240(f=1.0), )
Selected to next generation: IDs2--> (239(f=1.0), )
----------Running generation: 121, population size: 1

***** Generation 121 : 0
**Parent Variant: [Variant id: 241, #gens: 382, #ops: 0, parent:-]

--Child created id: 242
--Creating new operations for variant [Variant id: 242, #gens: 382, #ops: 0, parent:241]
---analyzing modificationPoint position: 94
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  d *= tmp
---analyzing modificationPoint position: 37
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 1 not mutation generated in  squaredSecondary[i] = s * s
---analyzing modificationPoint position: 296
location: EigenDecompositionImpl.java579
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < (m - 1); ++i) {  	final double dCurrent = main[i]; 	final double ePrevious = eCu[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 242, #gens: 381, #ops: 1, parent:241] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 242
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-242/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(121): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < (m - 1); ++i) {  	final double dCurrent = main[i]; 	final double ePrevious = eCu[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (241(f=1.0), 242(f=8.0), )
Selected to next generation: IDs2--> (241(f=1.0), )
----------Running generation: 122, population size: 1

***** Generation 122 : 0
**Parent Variant: [Variant id: 243, #gens: 382, #ops: 0, parent:-]

--Child created id: 244
--Creating new operations for variant [Variant id: 244, #gens: 382, #ops: 0, parent:243]
---analyzing modificationPoint position: 60
Templates availables156
Attempts Base Ingredients  1 total 156
vars from patch []
location: EigenDecompositionImpl.java864
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double offDiagMax = 0 ` -topatch--> `double offDiagMax = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 864, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double offDiagMax = 0 ` -topatch--> `double offDiagMax = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 244, #gens: 382, #ops: 1, parent:243] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 244
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-244/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(122): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double offDiagMax = 0 ` -topatch--> `double offDiagMax = 0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (243(f=1.0), 244(f=1.0), )
Selected to next generation: IDs2--> (243(f=1.0), )
----------Running generation: 123, population size: 1

***** Generation 123 : 0
**Parent Variant: [Variant id: 245, #gens: 382, #ops: 0, parent:-]

--Child created id: 246
--Creating new operations for variant [Variant id: 246, #gens: 382, #ops: 0, parent:245]
---analyzing modificationPoint position: 89
location: EigenDecompositionImpl.java954
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j] = d + work[i] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 246, #gens: 381, #ops: 1, parent:245] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 246
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-246/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(123): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j] = d + work[i] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (245(f=1.0), 246(f=8.0), )
Selected to next generation: IDs2--> (245(f=1.0), )
----------Running generation: 124, population size: 1

***** Generation 124 : 0
**Parent Variant: [Variant id: 247, #gens: 382, #ops: 0, parent:-]

--Child created id: 248
--Creating new operations for variant [Variant id: 248, #gens: 382, #ops: 0, parent:247]
---analyzing modificationPoint position: 40
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  for (int i = 0; i < (n - 1); ++i) { 	final int fourI = 4 * i; 	final double ei = work[fourI + 2]; 	s[...]
---analyzing modificationPoint position: 156
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 1 not mutation generated in  double ratio = main[index] - t
---analyzing modificationPoint position: 77
location: EigenDecompositionImpl.java893
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// perform one step n0 = goodStep(i0, n0) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 248, #gens: 381, #ops: 1, parent:247] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 248
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-248/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 17] ,[]
-Valid?: |false|9|17|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(124): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// perform one step n0 = goodStep(i0, n0) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (247(f=1.0), 248(f=9.0), )
Selected to next generation: IDs2--> (247(f=1.0), )
----------Running generation: 125, population size: 1

***** Generation 125 : 0
**Parent Variant: [Variant id: 249, #gens: 382, #ops: 0, parent:-]

--Child created id: 250
--Creating new operations for variant [Variant id: 250, #gens: 382, #ops: 0, parent:249]
---analyzing modificationPoint position: 195
location: EigenDecompositionImpl.java1303
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = dN2 + work[j4p2] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 250, #gens: 381, #ops: 1, parent:249] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 250
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-250/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
-Killed id: pid->74071
The Process that runs JUnit test cases did not terminate within waitTime of 10 seconds
Killed the Process that runs JUnit test cases 74071
**The validation 1 have not finished well**
-Valid?: null, fitness 1.7976931348623157E308
Ingredient counter is Zero
---Undoing: gnrtn(125): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = dN2 + work[j4p2] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (249(f=1.0), 250(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (249(f=1.0), )
----------Running generation: 126, population size: 1

***** Generation 126 : 0
**Parent Variant: [Variant id: 251, #gens: 382, #ops: 0, parent:-]

--Child created id: 252
--Creating new operations for variant [Variant id: 252, #gens: 382, #ops: 0, parent:251]
---analyzing modificationPoint position: 202
location: EigenDecompositionImpl.java1311
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = dN1 + work[j4p2] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 252, #gens: 381, #ops: 1, parent:251] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 252
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-252/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
-Killed id: pid->74075
The Process that runs JUnit test cases did not terminate within waitTime of 10 seconds
Killed the Process that runs JUnit test cases 74075
**The validation 1 have not finished well**
-Valid?: null, fitness 1.7976931348623157E308
Ingredient counter is Zero
---Undoing: gnrtn(126): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = dN1 + work[j4p2] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (251(f=1.0), 252(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (251(f=1.0), )
----------Running generation: 127, population size: 1

***** Generation 127 : 0
**Parent Variant: [Variant id: 253, #gens: 382, #ops: 0, parent:-]

--Child created id: 254
--Creating new operations for variant [Variant id: 254, #gens: 382, #ops: 0, parent:253]
---analyzing modificationPoint position: 287
location: EigenDecompositionImpl.java243
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `// compute the Gershgorin circles computeGershgorinCircles() ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 254, #gens: 381, #ops: 1, parent:253] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 254
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-254/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(127): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `// compute the Gershgorin circles computeGershgorinCircles() ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (253(f=1.0), 254(f=8.0), )
Selected to next generation: IDs2--> (253(f=1.0), )
----------Running generation: 128, population size: 1

***** Generation 128 : 0
**Parent Variant: [Variant id: 255, #gens: 382, #ops: 0, parent:-]

--Child created id: 256
--Creating new operations for variant [Variant id: 256, #gens: 382, #ops: 0, parent:255]
---analyzing modificationPoint position: 112
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 0 not mutation generated in  // step 4a: dqds for (boolean loop = true; loop;) {  	// perform one dqds step with the chosen shift[...]
---analyzing modificationPoint position: 80
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  pingPong = 0
---analyzing modificationPoint position: 213
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  work[j4 - 2] = d + work[j4 - 1]
---analyzing modificationPoint position: 267
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 3 not mutation generated in  sigma = t
---analyzing modificationPoint position: 232
location: EigenDecompositionImpl.java1398
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin1 = dMin ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 256, #gens: 381, #ops: 1, parent:255] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child compiles: id 256
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-256/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 17] ,[]
-Valid?: |false|3|17|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(128): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin1 = dMin ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (255(f=1.0), 256(f=3.0), )
Selected to next generation: IDs2--> (255(f=1.0), )
----------Running generation: 129, population size: 1

***** Generation 129 : 0
**Parent Variant: [Variant id: 257, #gens: 382, #ops: 0, parent:-]

--Child created id: 258
--Creating new operations for variant [Variant id: 258, #gens: 382, #ops: 0, parent:257]
---analyzing modificationPoint position: 256
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 0 not mutation generated in  if ((gap1 > 0.0) && (gap1 > b1)) { 	tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin); 	[...]
---analyzing modificationPoint position: 230
Templates availables595
Attempts Base Ingredients  1 total 595
Name Conflict [start, end, work, d, dMin, eMin, org.apache.commons.math.util.MathUtils.SAFE_MIN]
---modifPoint 1 not mutation generated in  dN1 = dN2 * tmp
---analyzing modificationPoint position: 353
location: Array2DRowRealMatrix.java118
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (d == null) { 	throw new java.lang.NullPointerException(); } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 258, #gens: 381, #ops: 1, parent:257] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 258
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-258/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(129): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (d == null) { 	throw new java.lang.NullPointerException(); } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (257(f=1.0), 258(f=1.0), )
Selected to next generation: IDs2--> (257(f=1.0), )
----------Running generation: 130, population size: 1

***** Generation 130 : 0
**Parent Variant: [Variant id: 259, #gens: 382, #ops: 0, parent:-]

--Child created id: 260
--Creating new operations for variant [Variant id: 260, #gens: 382, #ops: 0, parent:259]
---analyzing modificationPoint position: 146
Templates availables42
Attempts Base Ingredients  1 total 42
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 0 not mutation generated in  for (int i = 0; i < maxIter; ++i) {  	final double range = right - left; 	if ((range < absoluteToler[...]
---analyzing modificationPoint position: 97
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  g = 0.0
---analyzing modificationPoint position: 291
---modifPoint 2 not mutation generated in  final int upperStart = 5 * m
---analyzing modificationPoint position: 163
---modifPoint 3 not mutation generated in  double di = main[index] - lambda
---analyzing modificationPoint position: 113
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  // perform one dqds step with the chosen shift dqds(start, deflatedEnd)
---analyzing modificationPoint position: 44
location: EigenDecompositionImpl.java833
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (sumOffDiag == 0) { 	// matrix is already diagonal 	return; } ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 260, #gens: 381, #ops: 1, parent:259] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 260
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-260/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(130): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (sumOffDiag == 0) { 	// matrix is already diagonal 	return; } ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (259(f=1.0), 260(f=1.0), )
Selected to next generation: IDs2--> (259(f=1.0), )
----------Running generation: 131, population size: 1

***** Generation 131 : 0
**Parent Variant: [Variant id: 261, #gens: 382, #ops: 0, parent:-]

--Child created id: 262
--Creating new operations for variant [Variant id: 262, #gens: 382, #ops: 0, parent:261]
---analyzing modificationPoint position: 61
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [cachedVt]
--> var from patch: cachedVt spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java865
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double diagMax = work[(4 * n0) - 4] ` -topatch--> `// return the cached matrix return cachedVt` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 865, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double diagMax = work[(4 * n0) - 4] ` -topatch--> `// return the cached matrix return cachedVt` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 262, #gens: 383, #ops: 1, parent:261] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 262, errors: [EigenDecompositionImpl.java:867: error: incompatible types: unexpected return value
			return cachedVt; 			double diagMin = diagMax;
			       ^]
Ingredient counter is Zero
---Undoing: gnrtn(131): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double diagMax = work[(4 * n0) - 4] ` -topatch--> `// return the cached matrix return cachedVt` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (261(f=1.0), 262(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (261(f=1.0), )
----------Running generation: 132, population size: 1

***** Generation 132 : 0
**Parent Variant: [Variant id: 263, #gens: 382, #ops: 0, parent:-]

--Child created id: 264
--Creating new operations for variant [Variant id: 264, #gens: 382, #ops: 0, parent:263]
---analyzing modificationPoint position: 99
location: EigenDecompositionImpl.java996
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (boolean deflating = true; deflating;) {  	if (start >= deflatedEnd) { 		// the array has been c[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 264, #gens: 381, #ops: 1, parent:263] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 264
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-264/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 17] ,[]
-Valid?: |false|9|17|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(132): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (boolean deflating = true; deflating;) {  	if (start >= deflatedEnd) { 		// the array has been c[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (263(f=1.0), 264(f=9.0), )
Selected to next generation: IDs2--> (263(f=1.0), )
----------Running generation: 133, population size: 1

***** Generation 133 : 0
**Parent Variant: [Variant id: 265, #gens: 382, #ops: 0, parent:-]

--Child created id: 266
--Creating new operations for variant [Variant id: 266, #gens: 382, #ops: 0, parent:265]
---analyzing modificationPoint position: 253
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  if ((dMin == dN) && (dMin1 == dN1)) { 	// cases 2 and 3. 	final double gap2 = (dMin2 - a2) - (dMin2 [...]
---analyzing modificationPoint position: 346
---modifPoint 1 not mutation generated in  return 0
---analyzing modificationPoint position: 99
location: EigenDecompositionImpl.java996
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (boolean deflating = true; deflating;) {  	if (start >= deflatedEnd) { 		// the array has been c[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 266, #gens: 381, #ops: 1, parent:265] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 266
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-266/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 17] ,[]
-Valid?: |false|9|17|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(133): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (boolean deflating = true; deflating;) {  	if (start >= deflatedEnd) { 		// the array has been c[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (265(f=1.0), 266(f=9.0), )
Selected to next generation: IDs2--> (265(f=1.0), )
----------Running generation: 134, population size: 1

***** Generation 134 : 0
**Parent Variant: [Variant id: 267, #gens: 382, #ops: 0, parent:-]

--Child created id: 268
--Creating new operations for variant [Variant id: 268, #gens: 382, #ops: 0, parent:267]
---analyzing modificationPoint position: 98
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 0 not mutation generated in  // step 1: accepting realEigenvalues int deflatedEnd = end
---analyzing modificationPoint position: 141
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 1 not mutation generated in  right = middle
---analyzing modificationPoint position: 128
Templates availables156
Attempts Base Ingredients  1 total 156
vars from patch [dMin]
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1167
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// set thresholds final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.[...] ` -topatch--> `double s = 0.25 * dMin` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1167, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// set thresholds final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.[...] ` -topatch--> `double s = 0.25 * dMin` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 268, #gens: 382, #ops: 1, parent:267] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 268, errors: [EigenDecompositionImpl.java:1477: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			^, EigenDecompositionImpl.java:1477: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                    ^, EigenDecompositionImpl.java:1477: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                     ^, EigenDecompositionImpl.java:1477: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                           ^, EigenDecompositionImpl.java:1477: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                     ^, EigenDecompositionImpl.java:1477: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                 ^, EigenDecompositionImpl.java:1477: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                     ^, EigenDecompositionImpl.java:1477: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				    ^, EigenDecompositionImpl.java:1477: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				               ^, EigenDecompositionImpl.java:1478: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				^, EigenDecompositionImpl.java:1478: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				      ^, EigenDecompositionImpl.java:1478: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			      ^, EigenDecompositionImpl.java:1478: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			^, EigenDecompositionImpl.java:1478: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				               ^, EigenDecompositionImpl.java:1478: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				              ^, EigenDecompositionImpl.java:1478: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		^, EigenDecompositionImpl.java:1478: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		                                    ^, EigenDecompositionImpl.java:1488: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                   ^, EigenDecompositionImpl.java:1488: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1488: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                    ^, EigenDecompositionImpl.java:1488: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		^, EigenDecompositionImpl.java:1488: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		^, EigenDecompositionImpl.java:1488: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                ^, EigenDecompositionImpl.java:1488: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                       ^, EigenDecompositionImpl.java:1488: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			^, EigenDecompositionImpl.java:1488: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				        ^, EigenDecompositionImpl.java:1488: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				           		             ^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                          ^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                ^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                       ^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			      ^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			      ^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			      ^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			^, EigenDecompositionImpl.java:1502: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			                                     ^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                        ^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                         ^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                               ^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                      ^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				      ^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                          ^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                               ^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                      ^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				      ^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1510: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				                                              ^, EigenDecompositionImpl.java:1514: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1516: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                       ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                        ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                               ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                     ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					           ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                          ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                               ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                     ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					           ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1518: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                              ^]
Ingredient counter is Zero
---Undoing: gnrtn(134): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `// set thresholds final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.[...] ` -topatch--> `double s = 0.25 * dMin` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (267(f=1.0), 268(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (267(f=1.0), )
----------Running generation: 135, population size: 1

***** Generation 135 : 0
**Parent Variant: [Variant id: 269, #gens: 382, #ops: 0, parent:-]

--Child created id: 270
--Creating new operations for variant [Variant id: 270, #gens: 382, #ops: 0, parent:269]
---analyzing modificationPoint position: 71
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  work[(4 * n0) - 2] = offDiagMin
---analyzing modificationPoint position: 101
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 1 not mutation generated in  final int k = ((4 * deflatedEnd) + pingPong) - 1
---analyzing modificationPoint position: 88
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  final int j = (i - (2 * pingPong)) - 1
---analyzing modificationPoint position: 359
location: Array2DRowRealMatrix.java136
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `data = d ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 270, #gens: 381, #ops: 1, parent:269] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 270
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-270/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 17, was successful: false, cases executed: 17] ,[]
-Valid?: |false|17|17|[]|, fitness 17.0
Ingredient counter is Zero
---Undoing: gnrtn(135): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `data = d ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (269(f=1.0), 270(f=17.0), )
Selected to next generation: IDs2--> (269(f=1.0), )
----------Running generation: 136, population size: 1

***** Generation 136 : 0
**Parent Variant: [Variant id: 271, #gens: 382, #ops: 0, parent:-]

--Child created id: 272
--Creating new operations for variant [Variant id: 272, #gens: 382, #ops: 0, parent:271]
---analyzing modificationPoint position: 347
---modifPoint 0 not mutation generated in  return walkInRowOrder(visitor)
---analyzing modificationPoint position: 268
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  final double dCurrent = main[i]
---analyzing modificationPoint position: 118
Templates availables20
Attempts Base Ingredients  1 total 20
vars from patch [realEigenvalues]
--> var from patch: realEigenvalues spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1120
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return deflatedEnd ` -topatch--> `return realEigenvalues.clone()` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1120, pointed element: CtReturnImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return deflatedEnd ` -topatch--> `return realEigenvalues.clone()` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 272, #gens: 382, #ops: 1, parent:271] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 272, errors: [EigenDecompositionImpl.java:1119: error: incompatible types: double[] cannot be converted to int
		dqd(start, deflatedEnd); 		return realEigenvalues.clone();
		                         		                            ^]
Ingredient counter is Zero
---Undoing: gnrtn(136): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtReturnImpl) `return deflatedEnd ` -topatch--> `return realEigenvalues.clone()` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (271(f=1.0), 272(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (271(f=1.0), )
----------Running generation: 137, population size: 1

***** Generation 137 : 0
**Parent Variant: [Variant id: 273, #gens: 382, #ops: 0, parent:-]

--Child created id: 274
--Creating new operations for variant [Variant id: 274, #gens: 382, #ops: 0, parent:273]
---analyzing modificationPoint position: 54
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 0 not mutation generated in  // process split segments int i0 = 0
---analyzing modificationPoint position: 280
location: EigenDecompositionImpl.java698
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `absDCurrent = java.lang.Math.abs(main[i + 1]) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 274, #gens: 381, #ops: 1, parent:273] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 274
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-274/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(137): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `absDCurrent = java.lang.Math.abs(main[i + 1]) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (273(f=1.0), 274(f=1.0), )
Selected to next generation: IDs2--> (273(f=1.0), )
----------Running generation: 138, population size: 1

***** Generation 138 : 0
**Parent Variant: [Variant id: 275, #gens: 382, #ops: 0, parent:-]

--Child created id: 276
--Creating new operations for variant [Variant id: 276, #gens: 382, #ops: 0, parent:275]
---analyzing modificationPoint position: 351
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  if (d[r].length != nCols) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumen[...]
---analyzing modificationPoint position: 361
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 1 not mutation generated in  data = new double[rowDimension][columnDimension]
---analyzing modificationPoint position: 108
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  // step 2: flip array if needed if ((dMin <= 0) || (deflatedEnd < end)) { 	if (flipIfWarranted(defla[...]
---analyzing modificationPoint position: 47
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  // initialize parameters used by goodStep tType = 0
---analyzing modificationPoint position: 233
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  j4 = j4 + 4
---analyzing modificationPoint position: 151
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [transformer]
--> var from patch: transformer spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1209
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (countEigenValues(middle, index, n) >= n) { 	right = middle; } else { 	left = middle; } ` -topatch--> `transformer = null` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1209, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (countEigenValues(middle, index, n) >= n) { 	right = middle; } else { 	left = middle; } ` -topatch--> `transformer = null` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 276, #gens: 383, #ops: 1, parent:275] gen mutated: 1 , gen not mut: 5, gen not applied  0
-The child compiles: id 276
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-276/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 17] ,[]
-Valid?: |false|3|17|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(138): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (countEigenValues(middle, index, n) >= n) { 	right = middle; } else { 	left = middle; } ` -topatch--> `transformer = null` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (275(f=1.0), 276(f=3.0), )
Selected to next generation: IDs2--> (275(f=1.0), )
----------Running generation: 139, population size: 1

***** Generation 139 : 0
**Parent Variant: [Variant id: 277, #gens: 382, #ops: 0, parent:-]

--Child created id: 278
--Creating new operations for variant [Variant id: 278, #gens: 382, #ops: 0, parent:277]
---analyzing modificationPoint position: 355
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  if (nRows == 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException[...]
---analyzing modificationPoint position: 103
location: EigenDecompositionImpl.java1011
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// one eigenvalue found, deflate array work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd)[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 278, #gens: 381, #ops: 1, parent:277] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 278
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-278/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(139): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// one eigenvalue found, deflate array work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd)[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (277(f=1.0), 278(f=8.0), )
Selected to next generation: IDs2--> (277(f=1.0), )
----------Running generation: 140, population size: 1

***** Generation 140 : 0
**Parent Variant: [Variant id: 279, #gens: 382, #ops: 0, parent:-]

--Child created id: 280
--Creating new operations for variant [Variant id: 280, #gens: 382, #ops: 0, parent:279]
---analyzing modificationPoint position: 93
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  work[j + 2] = work[i] * tmp
---analyzing modificationPoint position: 286
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  work = new double[6 * main.length]
---analyzing modificationPoint position: 81
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  for (int k = 0; k < 2; ++k) {  	// apply Li's reverse test 	double d = work[(4 * (n - 1)) + pingPong[...]
---analyzing modificationPoint position: 359
location: Array2DRowRealMatrix.java136
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `data = d ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 280, #gens: 381, #ops: 1, parent:279] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 280
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-280/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 17, was successful: false, cases executed: 17] ,[]
-Valid?: |false|17|17|[]|, fitness 17.0
Ingredient counter is Zero
---Undoing: gnrtn(140): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `data = d ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (279(f=1.0), 280(f=17.0), )
Selected to next generation: IDs2--> (279(f=1.0), )
----------Running generation: 141, population size: 1

***** Generation 141 : 0
**Parent Variant: [Variant id: 281, #gens: 382, #ops: 0, parent:-]

--Child created id: 282
--Creating new operations for variant [Variant id: 282, #gens: 382, #ops: 0, parent:281]
---analyzing modificationPoint position: 292
Templates availables241
Attempts Base Ingredients  1 total 241
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
vars from patch [cachedVt, m]
--> var from patch: cachedVt spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: m spoon.support.reflect.code.CtVariableReadImpl
location: EigenDecompositionImpl.java574
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 574, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 282, #gens: 382, #ops: 1, parent:281] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 282
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-282/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 2, was successful: false, cases executed: 17] ,[]
-Valid?: |false|2|17|[]|, fitness 2.0
Ingredient counter is Zero
---Undoing: gnrtn(141): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (281(f=1.0), 282(f=2.0), )
Selected to next generation: IDs2--> (281(f=1.0), )
----------Running generation: 142, population size: 1

***** Generation 142 : 0
**Parent Variant: [Variant id: 283, #gens: 382, #ops: 0, parent:-]

--Child created id: 284
--Creating new operations for variant [Variant id: 284, #gens: 382, #ops: 0, parent:283]
---analyzing modificationPoint position: 275
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  lowerSpectra = java.lang.Math.min(lowerSpectra, lower)
---analyzing modificationPoint position: 351
Templates availables11
Attempts Base Ingredients  1 total 11
---modifPoint 1 not mutation generated in  if (d[r].length != nCols) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumen[...]
---analyzing modificationPoint position: 310
Templates availables2
Attempts Base Ingredients  1 total 2
vars from patch [n, begin, range, oneFourth, threeFourth, oneFourthCount, threeFourthCount, chooseLeft, tau, org.apache.commons.math.util.MathUtils.EPSILON, minPivot, lambda, i, realEigenvalues, work]
--> var from patch: n spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: begin spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: range spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: oneFourth spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: threeFourth spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: oneFourthCount spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: threeFourthCount spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: chooseLeft spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: org.apache.commons.math.util.MathUtils.EPSILON spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: minPivot spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: lambda spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: i spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: realEigenvalues spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java623
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtSwitchImpl) `switch (n) {  	case 1 : 		// apply dedicated method for dimension 1 		process1RowBlock(begin); 		bre[...] ` -topatch--> `switch (n) {  	case 1 : 		// apply dedicated method for dimension 1 		process1RowBlock(begin); 		bre[...]` (spoon.support.reflect.code.CtSwitchImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 623, pointed element: CtSwitchImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtSwitchImpl) `switch (n) {  	case 1 : 		// apply dedicated method for dimension 1 		process1RowBlock(begin); 		bre[...] ` -topatch--> `switch (n) {  	case 1 : 		// apply dedicated method for dimension 1 		process1RowBlock(begin); 		bre[...]` (spoon.support.reflect.code.CtSwitchImpl) 

--Summary Creation: for variant [Variant id: 284, #gens: 382, #ops: 1, parent:283] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 284
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-284/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(142): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtSwitchImpl) `switch (n) {  	case 1 : 		// apply dedicated method for dimension 1 		process1RowBlock(begin); 		bre[...] ` -topatch--> `switch (n) {  	case 1 : 		// apply dedicated method for dimension 1 		process1RowBlock(begin); 		bre[...]` (spoon.support.reflect.code.CtSwitchImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (283(f=1.0), 284(f=1.0), )
Selected to next generation: IDs2--> (283(f=1.0), )
----------Running generation: 143, population size: 1

***** Generation 143 : 0
**Parent Variant: [Variant id: 285, #gens: 382, #ops: 0, parent:-]

--Child created id: 286
--Creating new operations for variant [Variant id: 286, #gens: 382, #ops: 0, parent:285]
---analyzing modificationPoint position: 255
---modifPoint 0 not mutation generated in  final double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 / gap2) * b2 : b1 + b2)
---analyzing modificationPoint position: 288
location: EigenDecompositionImpl.java246
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `// find all the realEigenvalues findEigenvalues() ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 286, #gens: 381, #ops: 1, parent:285] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 286
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-286/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 17, was successful: false, cases executed: 17] ,[]
-Valid?: |false|17|17|[]|, fitness 17.0
Ingredient counter is Zero
---Undoing: gnrtn(143): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `// find all the realEigenvalues findEigenvalues() ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (285(f=1.0), 286(f=17.0), )
Selected to next generation: IDs2--> (285(f=1.0), )
----------Running generation: 144, population size: 1

***** Generation 144 : 0
**Parent Variant: [Variant id: 287, #gens: 382, #ops: 0, parent:-]

--Child created id: 288
--Creating new operations for variant [Variant id: 288, #gens: 382, #ops: 0, parent:287]
---analyzing modificationPoint position: 34
location: EigenDecompositionImpl.java198
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// pre-compute some elements squaredSecondary = new double[secondary.length] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 288, #gens: 381, #ops: 1, parent:287] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 288
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-288/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 2, was successful: false, cases executed: 17] ,[]
-Valid?: |false|2|17|[]|, fitness 2.0
Ingredient counter is Zero
---Undoing: gnrtn(144): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// pre-compute some elements squaredSecondary = new double[secondary.length] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (287(f=1.0), 288(f=2.0), )
Selected to next generation: IDs2--> (287(f=1.0), )
----------Running generation: 145, population size: 1

***** Generation 145 : 0
**Parent Variant: [Variant id: 289, #gens: 382, #ops: 0, parent:-]

--Child created id: 290
--Creating new operations for variant [Variant id: 290, #gens: 382, #ops: 0, parent:289]
---analyzing modificationPoint position: 208
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1330
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `eMin = work[((4 * start) + pingPong) + 4] ` -topatch--> `return` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1330, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `eMin = work[((4 * start) + pingPong) + 4] ` -topatch--> `return` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 290, #gens: 383, #ops: 1, parent:289] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 290, errors: [EigenDecompositionImpl.java:1443: error: illegal start of expression
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	 ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	          ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                    ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                 ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                             ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                    ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                                        ^, EigenDecompositionImpl.java:1444: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	      ^, EigenDecompositionImpl.java:1444: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                            ^, EigenDecompositionImpl.java:1444: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                          ^, EigenDecompositionImpl.java:1444: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                 ^, EigenDecompositionImpl.java:1444: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                ^, EigenDecompositionImpl.java:1444: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                         ^, EigenDecompositionImpl.java:1444: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                           ^, EigenDecompositionImpl.java:1446: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1446: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1447: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1447: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1448: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1449: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1449: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1450: error: illegal start of expression
	 * @param deflated
	   ^, EigenDecompositionImpl.java:1451: error: not a statement
	 * 		number of realEigenvalues just deflated
	 ^, EigenDecompositionImpl.java:1451: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		      ^, EigenDecompositionImpl.java:1451: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                         ^, EigenDecompositionImpl.java:1451: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                                       ^, EigenDecompositionImpl.java:1452: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	^, EigenDecompositionImpl.java:1452: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	        ^, EigenDecompositionImpl.java:1452: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                  ^, EigenDecompositionImpl.java:1452: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                   ^, EigenDecompositionImpl.java:1452: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                  ^, EigenDecompositionImpl.java:1452: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                                     ^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                                           ^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	        ^, EigenDecompositionImpl.java:1698: error: ';' expected
	private void findEigenVectors() {
	                             ^, EigenDecompositionImpl.java:1736: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                      ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                               ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                  ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                    ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                      ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                                          ^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	        ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                   ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                     ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                       ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                                           ^, EigenDecompositionImpl.java:1843: error: reached end of file while parsing
}
 ^]
Ingredient counter is Zero
---Undoing: gnrtn(145): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `eMin = work[((4 * start) + pingPong) + 4] ` -topatch--> `return` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (289(f=1.0), 290(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (289(f=1.0), )
----------Running generation: 146, population size: 1

***** Generation 146 : 0
**Parent Variant: [Variant id: 291, #gens: 382, #ops: 0, parent:-]

--Child created id: 292
--Creating new operations for variant [Variant id: 292, #gens: 382, #ops: 0, parent:291]
---analyzing modificationPoint position: 29
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2)
---analyzing modificationPoint position: 53
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  tau = 0
---analyzing modificationPoint position: 176
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java1278
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 		work[j4 - 2[...] ` -topatch--> `final double cnst1 = 0.563` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1278, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 		work[j4 - 2[...] ` -topatch--> `final double cnst1 = 0.563` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 292, #gens: 383, #ops: 1, parent:291] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child does NOT compile: 292, errors: [EigenDecompositionImpl.java:1434: error: illegal start of expression
	 * Perform a dqd step.
	 ^, EigenDecompositionImpl.java:1434: error: ';' expected
	 * Perform a dqd step.
	          ^, EigenDecompositionImpl.java:1434: error: ';' expected
	 * Perform a dqd step.
	                ^, EigenDecompositionImpl.java:1434: error: <identifier> expected
	 * Perform a dqd step.
	                      ^, EigenDecompositionImpl.java:1435: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	      ^, EigenDecompositionImpl.java:1435: error: not a statement
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	 ^, EigenDecompositionImpl.java:1435: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                            ^, EigenDecompositionImpl.java:1435: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                          ^, EigenDecompositionImpl.java:1435: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                 ^, EigenDecompositionImpl.java:1435: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                ^, EigenDecompositionImpl.java:1435: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                         ^, EigenDecompositionImpl.java:1435: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                           ^, EigenDecompositionImpl.java:1437: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1437: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1438: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1438: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1439: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1440: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1440: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1441: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	  ^, EigenDecompositionImpl.java:1441: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	^, EigenDecompositionImpl.java:1441: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	        ^, EigenDecompositionImpl.java:1441: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                ^, EigenDecompositionImpl.java:1441: error: <identifier> expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                 ^, EigenDecompositionImpl.java:1441: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                               ^, EigenDecompositionImpl.java:1442: error: illegal start of expression
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	 ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	          ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                    ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                 ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                             ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                    ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                                        ^, EigenDecompositionImpl.java:1443: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	      ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                            ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                          ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                 ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                ^, EigenDecompositionImpl.java:1443: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                         ^, EigenDecompositionImpl.java:1443: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                           ^, EigenDecompositionImpl.java:1445: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1445: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1446: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1446: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1447: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1448: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1448: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1449: error: illegal start of expression
	 * @param deflated
	   ^, EigenDecompositionImpl.java:1450: error: not a statement
	 * 		number of realEigenvalues just deflated
	 ^, EigenDecompositionImpl.java:1450: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		      ^, EigenDecompositionImpl.java:1450: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                         ^, EigenDecompositionImpl.java:1450: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                                       ^, EigenDecompositionImpl.java:1451: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	^, EigenDecompositionImpl.java:1451: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	        ^, EigenDecompositionImpl.java:1451: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                  ^, EigenDecompositionImpl.java:1451: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                   ^, EigenDecompositionImpl.java:1451: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                  ^, EigenDecompositionImpl.java:1451: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                                     ^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                                           ^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	        ^, EigenDecompositionImpl.java:1698: error: ';' expected
	private void findEigenVectors() {
	                             ^, EigenDecompositionImpl.java:1736: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                      ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                               ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                  ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                    ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                      ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                                          ^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	        ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                   ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                     ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                       ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                                           ^, EigenDecompositionImpl.java:1843: error: reached end of file while parsing
}
 ^]
Ingredient counter is Zero
---Undoing: gnrtn(146): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtIfImpl) `if (pingPong == 0) { 	for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 		work[j4 - 2[...] ` -topatch--> `final double cnst1 = 0.563` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (291(f=1.0), 292(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (291(f=1.0), )
----------Running generation: 147, population size: 1

***** Generation 147 : 0
**Parent Variant: [Variant id: 293, #gens: 382, #ops: 0, parent:-]

--Child created id: 294
--Creating new operations for variant [Variant id: 294, #gens: 382, #ops: 0, parent:293]
---analyzing modificationPoint position: 75
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  for (int k = 0; i0 < n0; ++k) { 	if (k >= maxIter) { 		throw new org.apache.commons.math.linear.Inva[...]
---analyzing modificationPoint position: 158
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dMin, dN1]
--> var from patch: dMin spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dN1 spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1232
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 1; i < n; ++i) { 	ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio[...] ` -topatch--> `dMin = java.lang.Math.min(dMin, dN1)` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1232, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 1; i < n; ++i) { 	ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio[...] ` -topatch--> `dMin = java.lang.Math.min(dMin, dN1)` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 294, #gens: 383, #ops: 1, parent:293] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 294, errors: [EigenDecompositionImpl.java:1330: error: illegal start of expression
	 * Perform a dqd step.
	 ^, EigenDecompositionImpl.java:1330: error: ';' expected
	 * Perform a dqd step.
	          ^, EigenDecompositionImpl.java:1330: error: ';' expected
	 * Perform a dqd step.
	                ^, EigenDecompositionImpl.java:1330: error: <identifier> expected
	 * Perform a dqd step.
	                      ^, EigenDecompositionImpl.java:1331: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	      ^, EigenDecompositionImpl.java:1331: error: not a statement
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	 ^, EigenDecompositionImpl.java:1331: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                            ^, EigenDecompositionImpl.java:1331: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                          ^, EigenDecompositionImpl.java:1331: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                 ^, EigenDecompositionImpl.java:1331: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                ^, EigenDecompositionImpl.java:1331: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                         ^, EigenDecompositionImpl.java:1331: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                           ^, EigenDecompositionImpl.java:1333: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1333: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1334: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1334: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1335: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1336: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1336: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1337: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1];
	  ^, EigenDecompositionImpl.java:1337: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1];
	    	^, EigenDecompositionImpl.java:1337: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1];
	    	        ^, EigenDecompositionImpl.java:1337: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1];
	    	                ^, EigenDecompositionImpl.java:1337: error: <identifier> expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1];
	    	                                 ^, EigenDecompositionImpl.java:1337: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1];
	    	                                               ^, EigenDecompositionImpl.java:1434: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	^, EigenDecompositionImpl.java:1434: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	        ^, EigenDecompositionImpl.java:1434: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                  ^, EigenDecompositionImpl.java:1434: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                                   ^, EigenDecompositionImpl.java:1434: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                                                  ^, EigenDecompositionImpl.java:1434: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                                                                     ^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                                           ^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	        ^, EigenDecompositionImpl.java:1698: error: ';' expected
	private void findEigenVectors() {
	                             ^, EigenDecompositionImpl.java:1736: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                      ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                               ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                  ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                    ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                      ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                                          ^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	        ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                   ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                     ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                       ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                                           ^, EigenDecompositionImpl.java:1843: error: reached end of file while parsing
}
 ^]
Ingredient counter is Zero
---Undoing: gnrtn(147): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 1; i < n; ++i) { 	ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio[...] ` -topatch--> `dMin = java.lang.Math.min(dMin, dN1)` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (293(f=1.0), 294(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (293(f=1.0), )
----------Running generation: 148, population size: 1

***** Generation 148 : 0
**Parent Variant: [Variant id: 295, #gens: 382, #ops: 0, parent:-]

--Child created id: 296
--Creating new operations for variant [Variant id: 296, #gens: 382, #ops: 0, parent:295]
---analyzing modificationPoint position: 86
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java951
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// apply dqd plus Li's forward test. d = work[pingPong] ` -topatch--> `tType = -1` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 951, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// apply dqd plus Li's forward test. d = work[pingPong] ` -topatch--> `tType = -1` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 296, #gens: 382, #ops: 1, parent:295] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 296, errors: [EigenDecompositionImpl.java:1442: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1442: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1442: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1442: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1442: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1443: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^, EigenDecompositionImpl.java:1443: error: not a statement
	 * <p>This implementation is based on Beresford N. Parlett
	 ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                            ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                     ^, EigenDecompositionImpl.java:1443: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                                 ^, EigenDecompositionImpl.java:1444: error: not a statement
	 * and Osni A. Marques paper <a
	 ^, EigenDecompositionImpl.java:1444: error: ';' expected
	 * and Osni A. Marques paper <a
	      ^, EigenDecompositionImpl.java:1444: error: ';' expected
	 * and Osni A. Marques paper <a
	             ^, EigenDecompositionImpl.java:1444: error: ';' expected
	 * and Osni A. Marques paper <a
	                            ^, EigenDecompositionImpl.java:1445: error: > expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	 ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	  ^, EigenDecompositionImpl.java:1445: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	       ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	        ^, EigenDecompositionImpl.java:1445: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                           ^, EigenDecompositionImpl.java:1445: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                              ^, EigenDecompositionImpl.java:1446: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                    ^, EigenDecompositionImpl.java:1446: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                             ^, EigenDecompositionImpl.java:1446: error: ')' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                 ^, EigenDecompositionImpl.java:1446: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                      ^, EigenDecompositionImpl.java:1446: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                        ^, EigenDecompositionImpl.java:1446: error: not a statement
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                          ^, EigenDecompositionImpl.java:1446: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                               ^, EigenDecompositionImpl.java:1446: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                                      ^, EigenDecompositionImpl.java:1447: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                       ^, EigenDecompositionImpl.java:1447: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                      ^, EigenDecompositionImpl.java:1447: error: illegal start of type
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                        ^, EigenDecompositionImpl.java:1447: error: illegal start of expression
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                         ^, EigenDecompositionImpl.java:1448: error: illegal start of expression
	 *
	 ^, EigenDecompositionImpl.java:1449: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1449: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1447: error: not a statement
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                          ^, EigenDecompositionImpl.java:1450: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1451: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1452: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1452: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1453: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1453: error: not a statement
	 * @return new end (maybe deflated)
	 ^, EigenDecompositionImpl.java:1453: error: ';' expected
	 * @return new end (maybe deflated)
	              ^, EigenDecompositionImpl.java:1453: error: -> expected
	 * @return new end (maybe deflated)
	                                   ^, EigenDecompositionImpl.java:1454: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	 ^, EigenDecompositionImpl.java:1454: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	^, EigenDecompositionImpl.java:1453: error: not a statement
	 * @return new end (maybe deflated)
	                   ^, EigenDecompositionImpl.java:1454: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                    ^, EigenDecompositionImpl.java:1454: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                     ^, EigenDecompositionImpl.java:1454: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                                   ^, EigenDecompositionImpl.java:1461: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1461: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1461: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1461: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1461: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1463: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1463: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1464: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1464: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1464: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1464: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1465: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1466: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1466: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1466: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1466: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1466: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1466: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1466: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1466: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1467: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1467: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1467: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1467: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1467: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1467: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1467: error: ';' expected
	 * 		only every other element)
	   		                        ^, EigenDecompositionImpl.java:1468: error: <identifier> expected
	 * @return true if qd array was flipped
	    ^, EigenDecompositionImpl.java:1468: error: <identifier> expected
	 * @return true if qd array was flipped
	          ^, EigenDecompositionImpl.java:1468: error: ';' expected
	 * @return true if qd array was flipped
	               ^, EigenDecompositionImpl.java:1468: error: ';' expected
	 * @return true if qd array was flipped
	                           ^, EigenDecompositionImpl.java:1468: error: ';' expected
	 * @return true if qd array was flipped
	                                       ^, EigenDecompositionImpl.java:1469: error: illegal start of expression
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	^, EigenDecompositionImpl.java:1469: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                               ^, EigenDecompositionImpl.java:1469: error: <identifier> expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                            ^, EigenDecompositionImpl.java:1469: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                                           ^, EigenDecompositionImpl.java:1470: error: illegal start of expression
	 * Compute an interval containing all realEigenvalues of a block.
	 ^, EigenDecompositionImpl.java:1470: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	          ^, EigenDecompositionImpl.java:1470: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                      ^, EigenDecompositionImpl.java:1470: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                                     ^, EigenDecompositionImpl.java:1470: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                                                        ^, EigenDecompositionImpl.java:1470: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                                                                ^, EigenDecompositionImpl.java:1472: error: <identifier> expected
	 * @param index
	               ^, EigenDecompositionImpl.java:1473: error: ';' expected
	 * 		index of the first row of the block
	   		        ^, EigenDecompositionImpl.java:1473: error: ';' expected
	 * 		index of the first row of the block
	   		                  ^, EigenDecompositionImpl.java:1473: error: ';' expected
	 * 		index of the first row of the block
	   		                         ^, EigenDecompositionImpl.java:1473: error: ';' expected
	 * 		index of the first row of the block
	   		                                   ^, EigenDecompositionImpl.java:1474: error: <identifier> expected
	 * @param n
	           ^]
Ingredient counter is Zero
---Undoing: gnrtn(148): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// apply dqd plus Li's forward test. d = work[pingPong] ` -topatch--> `tType = -1` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (295(f=1.0), 296(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (295(f=1.0), )
----------Running generation: 149, population size: 1

***** Generation 149 : 0
**Parent Variant: [Variant id: 297, #gens: 382, #ops: 0, parent:-]

--Child created id: 298
--Creating new operations for variant [Variant id: 298, #gens: 382, #ops: 0, parent:297]
---analyzing modificationPoint position: 173
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 0 not mutation generated in  double d = work[(4 * start) + pingPong] - tau
---analyzing modificationPoint position: 339
---modifPoint 1 not mutation generated in  final int columns = getColumnDimension()
---analyzing modificationPoint position: 378
location: AbstractRealMatrix.java44
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `lu = null ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 298, #gens: 381, #ops: 1, parent:297] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 298
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-298/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(149): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `lu = null ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (297(f=1.0), 298(f=1.0), )
Selected to next generation: IDs2--> (297(f=1.0), )
----------Running generation: 150, population size: 1

***** Generation 150 : 0
**Parent Variant: [Variant id: 299, #gens: 382, #ops: 0, parent:-]

--Child created id: 300
--Creating new operations for variant [Variant id: 300, #gens: 382, #ops: 0, parent:299]
---analyzing modificationPoint position: 270
location: EigenDecompositionImpl.java583
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `eCurrent = java.lang.Math.abs(secondary[i]) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 300, #gens: 381, #ops: 1, parent:299] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 300
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-300/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
-Killed id: pid->74109
The Process that runs JUnit test cases did not terminate within waitTime of 10 seconds
Killed the Process that runs JUnit test cases 74109
**The validation 1 have not finished well**
-Valid?: null, fitness 1.7976931348623157E308
Ingredient counter is Zero
---Undoing: gnrtn(150): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `eCurrent = java.lang.Math.abs(secondary[i]) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (299(f=1.0), 300(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (299(f=1.0), )
----------Running generation: 151, population size: 1

***** Generation 151 : 0
**Parent Variant: [Variant id: 301, #gens: 382, #ops: 0, parent:-]

--Child created id: 302
--Creating new operations for variant [Variant id: 302, #gens: 382, #ops: 0, parent:301]
---analyzing modificationPoint position: 221
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [d, work, pingPong]
--> var from patch: d spoon.support.reflect.code.CtVariableWriteImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1377
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `// Unroll last two steps dN2 = d ` -topatch--> `// apply dqd plus Li's forward test. d = work[pingPong]` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1377, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `// Unroll last two steps dN2 = d ` -topatch--> `// apply dqd plus Li's forward test. d = work[pingPong]` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 302, #gens: 383, #ops: 1, parent:301] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 302
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-302/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(151): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `// Unroll last two steps dN2 = d ` -topatch--> `// apply dqd plus Li's forward test. d = work[pingPong]` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (301(f=1.0), 302(f=1.0), )
Selected to next generation: IDs2--> (301(f=1.0), )
----------Running generation: 152, population size: 1

***** Generation 152 : 0
**Parent Variant: [Variant id: 303, #gens: 382, #ops: 0, parent:-]

--Child created id: 304
--Creating new operations for variant [Variant id: 304, #gens: 382, #ops: 0, parent:303]
---analyzing modificationPoint position: 51
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  dN1 = 0
---analyzing modificationPoint position: 257
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tType, g]
--> var from patch: tType spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: g spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1459
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin) ` -topatch--> `if (tType == (-18)) { 	g = 0.25 * 0.333; } else { 	g = 0.25; }` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1459, pointed element: CtIfImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin) ` -topatch--> `if (tType == (-18)) { 	g = 0.25 * 0.333; } else { 	g = 0.25; }` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 304, #gens: 383, #ops: 1, parent:303] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 304, errors: [EigenDecompositionImpl.java:1580: error: cannot find symbol
						if (a2 < cnst1) { 							s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} 						tau = s;}} else if (dMin == dN2) { 					// case 5. 					tType = -5; 					double s = 0.25 * dMin; 					// compute contribution to norm squared from i > nn-2. 					final int np = nn - (2 * pingPong); 					double b1 = work[np - 2]; 					double b2 = work[np - 6]; 					final double gam = dN2; 					if ((work[np - 8] > b2) || (work[np - 4] > b1)) { 						return;} 					double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1)); 					// approximate contribution to norm squared from i < nn-2.
						                  							^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1580: error: cannot find symbol
						if (a2 < cnst1) { 							s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} 						tau = s;}} else if (dMin == dN2) { 					// case 5. 					tType = -5; 					double s = 0.25 * dMin; 					// compute contribution to norm squared from i > nn-2. 					final int np = nn - (2 * pingPong); 					double b1 = work[np - 2]; 					double b2 = work[np - 6]; 					final double gam = dN2; 					if ((work[np - 8] > b2) || (work[np - 4] > b1)) { 						return;} 					double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1)); 					// approximate contribution to norm squared from i < nn-2.
						                  							     ^
  symbol:   variable gam
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1580: error: cannot find symbol
						if (a2 < cnst1) { 							s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} 						tau = s;}} else if (dMin == dN2) { 					// case 5. 					tType = -5; 					double s = 0.25 * dMin; 					// compute contribution to norm squared from i > nn-2. 					final int np = nn - (2 * pingPong); 					double b1 = work[np - 2]; 					double b2 = work[np - 6]; 					final double gam = dN2; 					if ((work[np - 8] > b2) || (work[np - 4] > b1)) { 						return;} 					double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1)); 					// approximate contribution to norm squared from i < nn-2.
						                  							                                                       						      ^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						     ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						          ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							    ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							^
  symbol:   variable b1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							     ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							     ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							     ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							          ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                               ^
  symbol:   variable b2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                   ^
  symbol:   variable b1
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                          ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                          ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						             ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					    ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					                  						       ^
  symbol:   variable gam
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					                  						                                      ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					                  						                                                   ^
  symbol:   variable a2
  location: class org.apache.commons.math.linear.EigenDecompositionImpl, EigenDecompositionImpl.java:1581: error: cannot find symbol
					if ((end - start) > 2) { 						b2 = work[nn - 13] / work[nn - 15]; 						a2 = a2 + b2; 						for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (b2 == 0.0) { 								break;} 							b1 = b2; 							if (work[i4] > work[i4 - 2]) { 								return;} 							b2 = b2 * (work[i4] / work[i4 - 2]); 							a2 = a2 + b2; 							if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) { 								break;}} 						a2 = cnst3 * a2;} 					if (a2 < cnst1) { 						tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);} else { 						tau = s;}} else { 					// case 6, no information to guide us.
					                         						                                    						              						                                                                        							                 								        							         							                               								         							                                     							              							                                                                 								         						                  					                  						                                                                						      ^
  symbol:   variable s
  location: class org.apache.commons.math.linear.EigenDecompositionImpl]
Ingredient counter is Zero
---Undoing: gnrtn(152): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtAssignmentImpl) `tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin) ` -topatch--> `if (tType == (-18)) { 	g = 0.25 * 0.333; } else { 	g = 0.25; }` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (303(f=1.0), 304(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (303(f=1.0), )
----------Running generation: 153, population size: 1

***** Generation 153 : 0
**Parent Variant: [Variant id: 305, #gens: 382, #ops: 0, parent:-]

--Child created id: 306
--Creating new operations for variant [Variant id: 306, #gens: 382, #ops: 0, parent:305]
---analyzing modificationPoint position: 142
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  left = middle
---analyzing modificationPoint position: 65
Templates availables78
Attempts Base Ingredients  1 total 78
vars from patch [pingPong, n0, i0, work, org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2, diagMax, sigma, offDiagMin, i, split, previousEMin]
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: n0 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: i0 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: diagMax spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: sigma spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: offDiagMin spoon.support.reflect.code.CtVariableWriteImpl
--> var from patch: i spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: split spoon.support.reflect.code.CtVariableWriteImpl
--> var from patch: previousEMin spoon.support.reflect.code.CtVariableWriteImpl
location: EigenDecompositionImpl.java869
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (work[i + 2] <= 0) { 	i0 = 1 + (i / 4); 	break; } ` -topatch--> `// check for new splits after "ping" steps // when the last elements of qd array are very small if ([...]` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 869, pointed element: CtIfImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (work[i + 2] <= 0) { 	i0 = 1 + (i / 4); 	break; } ` -topatch--> `// check for new splits after "ping" steps // when the last elements of qd array are very small if ([...]` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 306, #gens: 382, #ops: 1, parent:305] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 306, errors: [EigenDecompositionImpl.java:936: error: illegal start of expression
	 */ 	private void initialSplits(final int n) {
	    	^, EigenDecompositionImpl.java:936: error: illegal start of expression
	 */ 	private void initialSplits(final int n) {
	    	        ^, EigenDecompositionImpl.java:936: error: ';' expected
	 */ 	private void initialSplits(final int n) {
	    	                          ^, EigenDecompositionImpl.java:936: error: ';' expected
	 */ 	private void initialSplits(final int n) {
	    	                                      ^, EigenDecompositionImpl.java:993: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0;
	    	^, EigenDecompositionImpl.java:993: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0;
	    	                    ^, EigenDecompositionImpl.java:993: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0;
	    	                                     ^, EigenDecompositionImpl.java:993: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0;
	    	                                                   ^, EigenDecompositionImpl.java:1134: error: illegal start of expression
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array
	    	^, EigenDecompositionImpl.java:1134: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array
	    	                               ^, EigenDecompositionImpl.java:1134: error: <identifier> expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array
	    	                                            ^, EigenDecompositionImpl.java:1134: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array
	    	                                                           ^, EigenDecompositionImpl.java:1157: error: illegal start of expression
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	^, EigenDecompositionImpl.java:1157: error: ';' expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                 ^, EigenDecompositionImpl.java:1157: error: <identifier> expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                                  ^, EigenDecompositionImpl.java:1157: error: ';' expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                                              ^, EigenDecompositionImpl.java:1233: error: illegal start of expression
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	^, EigenDecompositionImpl.java:1233: error: ';' expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                            ^, EigenDecompositionImpl.java:1233: error: <identifier> expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                            ^, EigenDecompositionImpl.java:1233: error: <identifier> expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                                             ^, EigenDecompositionImpl.java:1233: error: ';' expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                                                         ^, EigenDecompositionImpl.java:1256: error: illegal start of expression
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	^, EigenDecompositionImpl.java:1256: error: illegal start of expression
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	        ^, EigenDecompositionImpl.java:1256: error: ';' expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                              ^, EigenDecompositionImpl.java:1256: error: <identifier> expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                   ^, EigenDecompositionImpl.java:1256: error: <identifier> expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                                    ^, EigenDecompositionImpl.java:1256: error: ';' expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                                                ^, EigenDecompositionImpl.java:1274: error: illegal start of expression
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	^, EigenDecompositionImpl.java:1274: error: illegal start of expression
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	        ^, EigenDecompositionImpl.java:1274: error: ';' expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                 ^, EigenDecompositionImpl.java:1274: error: <identifier> expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                  ^, EigenDecompositionImpl.java:1274: error: ';' expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                                ^, EigenDecompositionImpl.java:1331: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	^, EigenDecompositionImpl.java:1331: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	        ^, EigenDecompositionImpl.java:1331: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                ^, EigenDecompositionImpl.java:1331: error: <identifier> expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                 ^, EigenDecompositionImpl.java:1331: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                               ^, EigenDecompositionImpl.java:1434: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	^, EigenDecompositionImpl.java:1434: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	        ^, EigenDecompositionImpl.java:1434: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                  ^, EigenDecompositionImpl.java:1434: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                                   ^, EigenDecompositionImpl.java:1434: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                                                  ^, EigenDecompositionImpl.java:1434: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                                                                     ^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                                           ^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	        ^, EigenDecompositionImpl.java:1698: error: ';' expected
	private void findEigenVectors() {
	                             ^, EigenDecompositionImpl.java:1736: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                      ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                               ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                  ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                    ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                      ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                                          ^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	        ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                   ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                     ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                       ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                                           ^, EigenDecompositionImpl.java:1843: error: reached end of file while parsing
}
 ^]
Ingredient counter is Zero
---Undoing: gnrtn(153): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (work[i + 2] <= 0) { 	i0 = 1 + (i / 4); 	break; } ` -topatch--> `// check for new splits after "ping" steps // when the last elements of qd array are very small if ([...]` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (305(f=1.0), 306(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (305(f=1.0), )
----------Running generation: 154, population size: 1

***** Generation 154 : 0
**Parent Variant: [Variant id: 307, #gens: 382, #ops: 0, parent:-]

--Child created id: 308
--Creating new operations for variant [Variant id: 308, #gens: 382, #ops: 0, parent:307]
---analyzing modificationPoint position: 155
---modifPoint 0 not mutation generated in  return new double[]{ lower, upper }
---analyzing modificationPoint position: 344
Templates availables12
Attempts Base Ingredients  1 total 12
---modifPoint 1 not mutation generated in  visitor.visit(i, j, rowI[j])
---analyzing modificationPoint position: 55
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  int n0 = n
---analyzing modificationPoint position: 19
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 3 not mutation generated in  if (dMin1 > 0.0) { 	// late failure. Gives excellent shift. 	tau = (tau + dMin) * (1.0 - (2.0 * org.[...]
---analyzing modificationPoint position: 45
Templates availables19
Attempts Base Ingredients  1 total 19
vars from patch [tau]
--> var from patch: tau spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java839
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `// initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2) ` -topatch--> `updateSigma(tau)` (spoon.support.reflect.code.CtInvocationImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 839, pointed element: CtInvocationImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `// initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2) ` -topatch--> `updateSigma(tau)` (spoon.support.reflect.code.CtInvocationImpl) 

--Summary Creation: for variant [Variant id: 308, #gens: 382, #ops: 1, parent:307] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child does NOT compile: 308, errors: [EigenDecompositionImpl.java:1094: error: illegal start of expression
	 * Perform two iterations with Li's tests for initial splits.
	 ^, EigenDecompositionImpl.java:1094: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	          ^, EigenDecompositionImpl.java:1094: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                         ^, EigenDecompositionImpl.java:1094: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1094: error: not a statement
	 * Perform two iterations with Li's tests for initial splits.
	                                    ^, EigenDecompositionImpl.java:1094: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                         ^, EigenDecompositionImpl.java:1094: error: '(' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                             ^, EigenDecompositionImpl.java:1094: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                                            ^, EigenDecompositionImpl.java:1096: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1096: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1097: error: ';' expected
	 * 		number of rows of the matrix to process
	   		      ^, EigenDecompositionImpl.java:1097: error: not a statement
	 * 		number of rows of the matrix to process
	   		       ^, EigenDecompositionImpl.java:1097: error: ')' expected
	 * 		number of rows of the matrix to process
	   		         ^, EigenDecompositionImpl.java:1097: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                 ^, EigenDecompositionImpl.java:1097: error: variable declaration not allowed here
	 * 		number of rows of the matrix to process
	   		               ^, EigenDecompositionImpl.java:1097: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                            ^, EigenDecompositionImpl.java:1097: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                                       ^, EigenDecompositionImpl.java:1098: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	^, EigenDecompositionImpl.java:1098: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	        ^, EigenDecompositionImpl.java:1098: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                          ^, EigenDecompositionImpl.java:1098: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1099: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1099: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1099: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1099: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1099: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1099: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1099: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1100: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^, EigenDecompositionImpl.java:1100: error: not a statement
	 * <p>This implementation is based on Beresford N. Parlett
	 ^, EigenDecompositionImpl.java:1100: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                            ^, EigenDecompositionImpl.java:1100: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                     ^, EigenDecompositionImpl.java:1100: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                                 ^, EigenDecompositionImpl.java:1101: error: not a statement
	 * and Osni A. Marques paper <a
	 ^, EigenDecompositionImpl.java:1101: error: ';' expected
	 * and Osni A. Marques paper <a
	      ^, EigenDecompositionImpl.java:1101: error: ';' expected
	 * and Osni A. Marques paper <a
	             ^, EigenDecompositionImpl.java:1101: error: ';' expected
	 * and Osni A. Marques paper <a
	                            ^, EigenDecompositionImpl.java:1102: error: > expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	 ^, EigenDecompositionImpl.java:1102: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	  ^, EigenDecompositionImpl.java:1102: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	       ^, EigenDecompositionImpl.java:1102: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	        ^, EigenDecompositionImpl.java:1102: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                           ^, EigenDecompositionImpl.java:1102: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                              ^, EigenDecompositionImpl.java:1103: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                    ^, EigenDecompositionImpl.java:1103: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                             ^, EigenDecompositionImpl.java:1103: error: ')' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                 ^, EigenDecompositionImpl.java:1103: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                      ^, EigenDecompositionImpl.java:1103: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                        ^, EigenDecompositionImpl.java:1103: error: not a statement
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                          ^, EigenDecompositionImpl.java:1103: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                               ^, EigenDecompositionImpl.java:1103: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                                      ^, EigenDecompositionImpl.java:1104: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                       ^, EigenDecompositionImpl.java:1104: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                      ^, EigenDecompositionImpl.java:1104: error: illegal start of type
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                        ^, EigenDecompositionImpl.java:1104: error: illegal start of expression
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                         ^, EigenDecompositionImpl.java:1105: error: illegal start of expression
	 *
	 ^, EigenDecompositionImpl.java:1106: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1106: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1104: error: not a statement
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                          ^, EigenDecompositionImpl.java:1107: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1108: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1109: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1109: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1110: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1110: error: not a statement
	 * @return new end (maybe deflated)
	 ^, EigenDecompositionImpl.java:1110: error: ';' expected
	 * @return new end (maybe deflated)
	              ^, EigenDecompositionImpl.java:1110: error: -> expected
	 * @return new end (maybe deflated)
	                                   ^, EigenDecompositionImpl.java:1111: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	 ^, EigenDecompositionImpl.java:1111: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	^, EigenDecompositionImpl.java:1110: error: not a statement
	 * @return new end (maybe deflated)
	                   ^, EigenDecompositionImpl.java:1111: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                    ^, EigenDecompositionImpl.java:1111: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                     ^, EigenDecompositionImpl.java:1111: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                                   ^, EigenDecompositionImpl.java:1134: error: illegal start of expression
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array
	    	^, EigenDecompositionImpl.java:1134: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array
	    	                               ^, EigenDecompositionImpl.java:1134: error: <identifier> expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array
	    	                                            ^, EigenDecompositionImpl.java:1134: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array
	    	                                                           ^, EigenDecompositionImpl.java:1157: error: illegal start of expression
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	^, EigenDecompositionImpl.java:1157: error: ';' expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                 ^, EigenDecompositionImpl.java:1157: error: <identifier> expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                                  ^, EigenDecompositionImpl.java:1157: error: ';' expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                                              ^, EigenDecompositionImpl.java:1233: error: illegal start of expression
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	^, EigenDecompositionImpl.java:1233: error: ';' expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                            ^, EigenDecompositionImpl.java:1233: error: <identifier> expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                            ^, EigenDecompositionImpl.java:1233: error: <identifier> expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                                             ^, EigenDecompositionImpl.java:1233: error: ';' expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                                                         ^, EigenDecompositionImpl.java:1256: error: illegal start of expression
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	^, EigenDecompositionImpl.java:1256: error: illegal start of expression
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	        ^, EigenDecompositionImpl.java:1256: error: ';' expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                              ^, EigenDecompositionImpl.java:1256: error: <identifier> expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                   ^, EigenDecompositionImpl.java:1256: error: <identifier> expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                                    ^, EigenDecompositionImpl.java:1256: error: ';' expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                                                ^, EigenDecompositionImpl.java:1274: error: illegal start of expression
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	^, EigenDecompositionImpl.java:1274: error: illegal start of expression
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	        ^, EigenDecompositionImpl.java:1274: error: ';' expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                 ^, EigenDecompositionImpl.java:1274: error: <identifier> expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                  ^, EigenDecompositionImpl.java:1274: error: ';' expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                                ^, EigenDecompositionImpl.java:1331: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	^, EigenDecompositionImpl.java:1331: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	        ^, EigenDecompositionImpl.java:1331: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                ^]
Ingredient counter is Zero
---Undoing: gnrtn(154): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `// initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2) ` -topatch--> `updateSigma(tau)` (spoon.support.reflect.code.CtInvocationImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (307(f=1.0), 308(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (307(f=1.0), )
----------Running generation: 155, population size: 1

***** Generation 155 : 0
**Parent Variant: [Variant id: 309, #gens: 382, #ops: 0, parent:-]

--Child created id: 310
--Creating new operations for variant [Variant id: 310, #gens: 382, #ops: 0, parent:309]
---analyzing modificationPoint position: 327
Templates availables31
Attempts Base Ingredients  1 total 31
---modifPoint 0 not mutation generated in  for (int i = 0; i < nSum; i++) { 	sum += dataRow[i] * m.data[i][col]; }
---analyzing modificationPoint position: 306
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  imagEigenvalues = new double[main.length]
---analyzing modificationPoint position: 372
location: Array2DRowRealMatrix.java335
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < data.length; ++i) { 	if (subMatrix[i].length != nCols) { 		throw org.apache.comm[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 310, #gens: 381, #ops: 1, parent:309] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 310
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-310/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 15, was successful: false, cases executed: 17] ,[]
-Valid?: |false|15|17|[]|, fitness 15.0
Ingredient counter is Zero
---Undoing: gnrtn(155): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < data.length; ++i) { 	if (subMatrix[i].length != nCols) { 		throw org.apache.comm[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (309(f=1.0), 310(f=15.0), )
Selected to next generation: IDs2--> (309(f=1.0), )
----------Running generation: 156, population size: 1

***** Generation 156 : 0
**Parent Variant: [Variant id: 311, #gens: 382, #ops: 0, parent:-]

--Child created id: 312
--Creating new operations for variant [Variant id: 312, #gens: 382, #ops: 0, parent:311]
---analyzing modificationPoint position: 266
location: EigenDecompositionImpl.java1689
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `sigmaLow += sigma - (t - shift) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 312, #gens: 381, #ops: 1, parent:311] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 312
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-312/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(156): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtOperatorAssignmentImpl) `sigmaLow += sigma - (t - shift) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (311(f=1.0), 312(f=1.0), )
Selected to next generation: IDs2--> (311(f=1.0), )
----------Running generation: 157, population size: 1

***** Generation 157 : 0
**Parent Variant: [Variant id: 313, #gens: 382, #ops: 0, parent:-]

--Child created id: 314
--Creating new operations for variant [Variant id: 314, #gens: 382, #ops: 0, parent:313]
---analyzing modificationPoint position: 230
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  dN1 = dN2 * tmp
---analyzing modificationPoint position: 48
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  dMin1 = 0
---analyzing modificationPoint position: 290
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 2 not mutation generated in  final int lowerStart = 4 * m
---analyzing modificationPoint position: 256
location: EigenDecompositionImpl.java1458
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if ((gap1 > 0.0) && (gap1 > b1)) { 	tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin); 	[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 314, #gens: 381, #ops: 1, parent:313] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child compiles: id 314
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-314/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 2, was successful: false, cases executed: 17] ,[]
-Valid?: |false|2|17|[]|, fitness 2.0
Ingredient counter is Zero
---Undoing: gnrtn(157): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if ((gap1 > 0.0) && (gap1 > b1)) { 	tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin); 	[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (313(f=1.0), 314(f=2.0), )
Selected to next generation: IDs2--> (313(f=1.0), )
----------Running generation: 158, population size: 1

***** Generation 158 : 0
**Parent Variant: [Variant id: 315, #gens: 382, #ops: 0, parent:-]

--Child created id: 316
--Creating new operations for variant [Variant id: 316, #gens: 382, #ops: 0, parent:315]
---analyzing modificationPoint position: 289
---modifPoint 0 not mutation generated in  final int m = main.length
---analyzing modificationPoint position: 219
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  dMin = java.lang.Math.min(dMin, d)
---analyzing modificationPoint position: 336
location: AbstractRealMatrix.java611
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `out.setEntry(column, row, value) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 316, #gens: 381, #ops: 1, parent:315] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 316
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-316/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 17] ,[]
-Valid?: |false|9|17|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(158): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `out.setEntry(column, row, value) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (315(f=1.0), 316(f=9.0), )
Selected to next generation: IDs2--> (315(f=1.0), )
----------Running generation: 159, population size: 1

***** Generation 159 : 0
**Parent Variant: [Variant id: 317, #gens: 382, #ops: 0, parent:-]

--Child created id: 318
--Creating new operations for variant [Variant id: 318, #gens: 382, #ops: 0, parent:317]
---analyzing modificationPoint position: 132
---modifPoint 0 not mutation generated in  final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * min[...]
---analyzing modificationPoint position: 192
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [dN]
--> var from patch: dN spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1300
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = dMin ` -topatch--> `dN = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1300, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = dMin ` -topatch--> `dN = 0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 318, #gens: 382, #ops: 1, parent:317] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 318
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-318/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 17] ,[]
-Valid?: |false|3|17|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(159): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = dMin ` -topatch--> `dN = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (317(f=1.0), 318(f=3.0), )
Selected to next generation: IDs2--> (317(f=1.0), )
----------Running generation: 160, population size: 1

***** Generation 160 : 0
**Parent Variant: [Variant id: 319, #gens: 382, #ops: 0, parent:-]

--Child created id: 320
--Creating new operations for variant [Variant id: 320, #gens: 382, #ops: 0, parent:319]
---analyzing modificationPoint position: 68
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 0 not mutation generated in  offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2])
---analyzing modificationPoint position: 195
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [end]
--> var from patch: end spoon.support.reflect.code.CtVariableReadImpl
location: EigenDecompositionImpl.java1303
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = dN2 + work[j4p2] ` -topatch--> `// step 1: accepting realEigenvalues int deflatedEnd = end` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1303, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = dN2 + work[j4p2] ` -topatch--> `// step 1: accepting realEigenvalues int deflatedEnd = end` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 320, #gens: 383, #ops: 1, parent:319] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 320
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-320/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(160): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = dN2 + work[j4p2] ` -topatch--> `// step 1: accepting realEigenvalues int deflatedEnd = end` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (319(f=1.0), 320(f=1.0), )
Selected to next generation: IDs2--> (319(f=1.0), )
----------Running generation: 161, population size: 1

***** Generation 161 : 0
**Parent Variant: [Variant id: 321, #gens: 382, #ops: 0, parent:-]

--Child created id: 322
--Creating new operations for variant [Variant id: 322, #gens: 382, #ops: 0, parent:321]
---analyzing modificationPoint position: 234
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [dMin, dN]
--> var from patch: dMin spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dN spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1400
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `j4p2 = (j4 + (2 * pingPong)) - 1 ` -topatch--> `dMin = java.lang.Math.min(dMin, dN)` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1400, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `j4p2 = (j4 + (2 * pingPong)) - 1 ` -topatch--> `dMin = java.lang.Math.min(dMin, dN)` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 322, #gens: 382, #ops: 1, parent:321] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 322
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-322/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(161): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `j4p2 = (j4 + (2 * pingPong)) - 1 ` -topatch--> `dMin = java.lang.Math.min(dMin, dN)` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (321(f=1.0), 322(f=8.0), )
Selected to next generation: IDs2--> (321(f=1.0), )
----------Running generation: 162, population size: 1

***** Generation 162 : 0
**Parent Variant: [Variant id: 323, #gens: 382, #ops: 0, parent:-]

--Child created id: 324
--Creating new operations for variant [Variant id: 324, #gens: 382, #ops: 0, parent:323]
---analyzing modificationPoint position: 325
Templates availables120
Attempts Base Ingredients  1 total 120
vars from patch [nRows]
--> var from patch: nRows spoon.support.reflect.code.CtVariableReadImpl
location: Array2DRowRealMatrix.java280
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int col = 0; col < nCols; col++) { 	double sum = 0; 	for (int i = 0; i < nSum; i++) { 		sum += [...] ` -topatch--> `final double[][] out = new double[nRows][this.getColumnDimension()]` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 280, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int col = 0; col < nCols; col++) { 	double sum = 0; 	for (int i = 0; i < nSum; i++) { 		sum += [...] ` -topatch--> `final double[][] out = new double[nRows][this.getColumnDimension()]` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 324, #gens: 383, #ops: 1, parent:323] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 324
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-324/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(162): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtForImpl) `for (int col = 0; col < nCols; col++) { 	double sum = 0; 	for (int i = 0; i < nSum; i++) { 		sum += [...] ` -topatch--> `final double[][] out = new double[nRows][this.getColumnDimension()]` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (323(f=1.0), 324(f=1.0), )
Selected to next generation: IDs2--> (323(f=1.0), )
----------Running generation: 163, population size: 1

***** Generation 163 : 0
**Parent Variant: [Variant id: 325, #gens: 382, #ops: 0, parent:-]

--Child created id: 326
--Creating new operations for variant [Variant id: 326, #gens: 382, #ops: 0, parent:325]
---analyzing modificationPoint position: 52
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  dN2 = 0
---analyzing modificationPoint position: 153
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  left = middle
---analyzing modificationPoint position: 320
---modifPoint 2 not mutation generated in  final int nSum = this.getColumnDimension()
---analyzing modificationPoint position: 192
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 3 not mutation generated in  dMin2 = dMin
---analyzing modificationPoint position: 202
location: EigenDecompositionImpl.java1311
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = dN1 + work[j4p2] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 326, #gens: 381, #ops: 1, parent:325] gen mutated: 1 , gen not mut: 4, gen not applied  0
-The child compiles: id 326
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-326/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
-Killed id: pid->74130
The Process that runs JUnit test cases did not terminate within waitTime of 10 seconds
Killed the Process that runs JUnit test cases 74130
**The validation 1 have not finished well**
-Valid?: null, fitness 1.7976931348623157E308
Ingredient counter is Zero
---Undoing: gnrtn(163): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = dN1 + work[j4p2] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (325(f=1.0), 326(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (325(f=1.0), )
----------Running generation: 164, population size: 1

***** Generation 164 : 0
**Parent Variant: [Variant id: 327, #gens: 382, #ops: 0, parent:-]

--Child created id: 328
--Creating new operations for variant [Variant id: 328, #gens: 382, #ops: 0, parent:327]
---analyzing modificationPoint position: 52
location: EigenDecompositionImpl.java850
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dN2 = 0 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 328, #gens: 381, #ops: 1, parent:327] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 328
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-328/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(164): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dN2 = 0 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (327(f=1.0), 328(f=1.0), )
Selected to next generation: IDs2--> (327(f=1.0), )
----------Running generation: 165, population size: 1

***** Generation 165 : 0
**Parent Variant: [Variant id: 329, #gens: 382, #ops: 0, parent:-]

--Child created id: 330
--Creating new operations for variant [Variant id: 330, #gens: 382, #ops: 0, parent:329]
---analyzing modificationPoint position: 267
location: EigenDecompositionImpl.java1690
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `sigma = t ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 330, #gens: 381, #ops: 1, parent:329] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 330
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-330/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(165): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `sigma = t ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (329(f=1.0), 330(f=8.0), )
Selected to next generation: IDs2--> (329(f=1.0), )
----------Running generation: 166, population size: 1

***** Generation 166 : 0
**Parent Variant: [Variant id: 331, #gens: 382, #ops: 0, parent:-]

--Child created id: 332
--Creating new operations for variant [Variant id: 332, #gens: 382, #ops: 0, parent:331]
---analyzing modificationPoint position: 66
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  if (diagMin >= (4 * offDiagMax)) { 	diagMin = java.lang.Math.min(diagMin, work[i + 4]); 	offDiagMax [...]
---analyzing modificationPoint position: 239
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  work[j4] = work[j4p2] * tmp
---analyzing modificationPoint position: 156
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 2 not mutation generated in  double ratio = main[index] - t
---analyzing modificationPoint position: 323
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 3 not mutation generated in  final double[] dataRow = data[row]
---analyzing modificationPoint position: 243
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  work[((4 * end) - pingPong) - 1] = eMin
---analyzing modificationPoint position: 281
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 5 not mutation generated in  final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent)
---analyzing modificationPoint position: 89
location: EigenDecompositionImpl.java954
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j] = d + work[i] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 332, #gens: 381, #ops: 1, parent:331] gen mutated: 1 , gen not mut: 6, gen not applied  0
-The child compiles: id 332
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-332/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(166): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j] = d + work[i] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (331(f=1.0), 332(f=8.0), )
Selected to next generation: IDs2--> (331(f=1.0), )
----------Running generation: 167, population size: 1

***** Generation 167 : 0
**Parent Variant: [Variant id: 333, #gens: 382, #ops: 0, parent:-]

--Child created id: 334
--Creating new operations for variant [Variant id: 334, #gens: 382, #ops: 0, parent:333]
---analyzing modificationPoint position: 73
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  pingPong = 0
---analyzing modificationPoint position: 213
location: EigenDecompositionImpl.java1336
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = d + work[j4 - 1] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 334, #gens: 381, #ops: 1, parent:333] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 334
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-334/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(167): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[j4 - 2] = d + work[j4 - 1] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (333(f=1.0), 334(f=8.0), )
Selected to next generation: IDs2--> (333(f=1.0), )
----------Running generation: 168, population size: 1

***** Generation 168 : 0
**Parent Variant: [Variant id: 335, #gens: 382, #ops: 0, parent:-]

--Child created id: 336
--Creating new operations for variant [Variant id: 336, #gens: 382, #ops: 0, parent:335]
---analyzing modificationPoint position: 187
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  d = (d * tmp) - tau
---analyzing modificationPoint position: 41
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 1 not mutation generated in  final int fourI = 4 * i
---analyzing modificationPoint position: 362
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 2 not mutation generated in  data[row][column] = value
---analyzing modificationPoint position: 56
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch []
location: EigenDecompositionImpl.java856
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtWhileImpl) `while (n0 > 0) {  	// retrieve shift that was temporarily stored as a negative off-diagonal element [...] ` -topatch--> `double s = 0.0` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 856, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtWhileImpl) `while (n0 > 0) {  	// retrieve shift that was temporarily stored as a negative off-diagonal element [...] ` -topatch--> `double s = 0.0` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 336, #gens: 383, #ops: 1, parent:335] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child does NOT compile: 336, errors: [EigenDecompositionImpl.java:1465: error: illegal start of expression
	 * Perform two iterations with Li's tests for initial splits.
	 ^, EigenDecompositionImpl.java:1465: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	          ^, EigenDecompositionImpl.java:1465: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                         ^, EigenDecompositionImpl.java:1465: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1465: error: not a statement
	 * Perform two iterations with Li's tests for initial splits.
	                                    ^, EigenDecompositionImpl.java:1465: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                         ^, EigenDecompositionImpl.java:1465: error: '(' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                             ^, EigenDecompositionImpl.java:1465: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                                            ^, EigenDecompositionImpl.java:1467: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1467: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1468: error: ';' expected
	 * 		number of rows of the matrix to process
	   		      ^, EigenDecompositionImpl.java:1468: error: not a statement
	 * 		number of rows of the matrix to process
	   		       ^, EigenDecompositionImpl.java:1468: error: ')' expected
	 * 		number of rows of the matrix to process
	   		         ^, EigenDecompositionImpl.java:1468: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                 ^, EigenDecompositionImpl.java:1468: error: variable declaration not allowed here
	 * 		number of rows of the matrix to process
	   		               ^, EigenDecompositionImpl.java:1468: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                            ^, EigenDecompositionImpl.java:1468: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                                       ^, EigenDecompositionImpl.java:1469: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	^, EigenDecompositionImpl.java:1469: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	        ^, EigenDecompositionImpl.java:1469: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                          ^, EigenDecompositionImpl.java:1469: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1470: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1470: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1470: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1470: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1470: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1470: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1470: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1471: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^, EigenDecompositionImpl.java:1471: error: not a statement
	 * <p>This implementation is based on Beresford N. Parlett
	 ^, EigenDecompositionImpl.java:1471: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                            ^, EigenDecompositionImpl.java:1471: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                     ^, EigenDecompositionImpl.java:1471: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                                 ^, EigenDecompositionImpl.java:1472: error: not a statement
	 * and Osni A. Marques paper <a
	 ^, EigenDecompositionImpl.java:1472: error: ';' expected
	 * and Osni A. Marques paper <a
	      ^, EigenDecompositionImpl.java:1472: error: ';' expected
	 * and Osni A. Marques paper <a
	             ^, EigenDecompositionImpl.java:1472: error: ';' expected
	 * and Osni A. Marques paper <a
	                            ^, EigenDecompositionImpl.java:1473: error: > expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	 ^, EigenDecompositionImpl.java:1473: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	  ^, EigenDecompositionImpl.java:1473: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	       ^, EigenDecompositionImpl.java:1473: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	        ^, EigenDecompositionImpl.java:1473: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                           ^, EigenDecompositionImpl.java:1473: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                              ^, EigenDecompositionImpl.java:1474: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                    ^, EigenDecompositionImpl.java:1474: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                             ^, EigenDecompositionImpl.java:1474: error: ')' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                 ^, EigenDecompositionImpl.java:1474: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                      ^, EigenDecompositionImpl.java:1474: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                        ^, EigenDecompositionImpl.java:1474: error: not a statement
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                          ^, EigenDecompositionImpl.java:1474: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                               ^, EigenDecompositionImpl.java:1474: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                                      ^, EigenDecompositionImpl.java:1475: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                       ^, EigenDecompositionImpl.java:1475: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                      ^, EigenDecompositionImpl.java:1475: error: illegal start of type
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                        ^, EigenDecompositionImpl.java:1475: error: illegal start of expression
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                         ^, EigenDecompositionImpl.java:1476: error: illegal start of expression
	 *
	 ^, EigenDecompositionImpl.java:1477: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1477: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1475: error: not a statement
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                          ^, EigenDecompositionImpl.java:1478: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1479: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1480: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1480: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1481: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1481: error: not a statement
	 * @return new end (maybe deflated)
	 ^, EigenDecompositionImpl.java:1481: error: ';' expected
	 * @return new end (maybe deflated)
	              ^, EigenDecompositionImpl.java:1481: error: -> expected
	 * @return new end (maybe deflated)
	                                   ^, EigenDecompositionImpl.java:1482: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	 ^, EigenDecompositionImpl.java:1482: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	^, EigenDecompositionImpl.java:1481: error: not a statement
	 * @return new end (maybe deflated)
	                   ^, EigenDecompositionImpl.java:1482: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                    ^, EigenDecompositionImpl.java:1482: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                     ^, EigenDecompositionImpl.java:1482: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                                   ^, EigenDecompositionImpl.java:1489: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1489: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1489: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1489: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1491: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1491: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1492: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1492: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1492: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1492: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1493: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1494: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1494: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1494: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1494: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1494: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1494: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1494: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1494: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1495: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1495: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1495: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1495: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1495: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1495: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1495: error: ';' expected
	 * 		only every other element)
	   		                        ^]
Ingredient counter is Zero
---Undoing: gnrtn(168): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtWhileImpl) `while (n0 > 0) {  	// retrieve shift that was temporarily stored as a negative off-diagonal element [...] ` -topatch--> `double s = 0.0` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (335(f=1.0), 336(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (335(f=1.0), )
----------Running generation: 169, population size: 1

***** Generation 169 : 0
**Parent Variant: [Variant id: 337, #gens: 382, #ops: 0, parent:-]

--Child created id: 338
--Creating new operations for variant [Variant id: 338, #gens: 382, #ops: 0, parent:337]
---analyzing modificationPoint position: 142
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  left = middle
---analyzing modificationPoint position: 300
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  lowerSpectra = java.lang.Math.min(lowerSpectra, lower)
---analyzing modificationPoint position: 168
---modifPoint 2 not mutation generated in  final double ratio = eiM1 / di
---analyzing modificationPoint position: 250
---modifPoint 3 not mutation generated in  double b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5])
---analyzing modificationPoint position: 254
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  // cases 2 and 3. final double gap2 = (dMin2 - a2) - (dMin2 * 0.25)
---analyzing modificationPoint position: 178
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 5 not mutation generated in  work[j4 - 2] = d + work[j4 - 1]
---analyzing modificationPoint position: 74
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 6 not mutation generated in  int maxIter = 30 * (n0 - i0)
---analyzing modificationPoint position: 365
Templates availables11
Attempts Base Ingredients  1 total 11
---modifPoint 7 not mutation generated in  if (row > 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalStateException( 	"fi[...]
---analyzing modificationPoint position: 160
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 8 not mutation generated in  if (ratio <= 0) { 	++count; }
---analyzing modificationPoint position: 69
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 9 not mutation generated in  diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2])
---analyzing modificationPoint position: 17
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 10 not mutation generated in  if (dMin < 0.0) { 	// tau too big. Select new tau and try again. 	if (tType < (-22)) { 		// failed t[...]
---analyzing modificationPoint position: 235
Templates availables595
Attempts Base Ingredients  1 total 595
Cannot load class: org.apache.commons.math.linear.ArrayRealVector[] with class loader sun.misc.Launcher$AppClassLoader@4e25154f
---modifPoint 11 not mutation generated in  work[j4 - 2] = dN1 + work[j4p2]
---analyzing modificationPoint position: 333
Templates availables33
Attempts Base Ingredients  1 total 33
Attempts Base Ingredients  2 total 33
---modifPoint 12 not mutation generated in  final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows)
---analyzing modificationPoint position: 212
Templates availables42
Attempts Base Ingredients  1 total 42
---modifPoint 13 not mutation generated in  for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 	work[j4 - 2] = d + work[j4 - 1]; 	i[...]
---analyzing modificationPoint position: 87
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 14 not mutation generated in  for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 	final int j = (i - (2 * pingPong)) - 1; 	wo[...]
---analyzing modificationPoint position: 321
Templates availables23
Attempts Base Ingredients  1 total 23
vars from patch [nRows]
--> var from patch: nRows spoon.support.reflect.code.CtVariableReadImpl
location: Array2DRowRealMatrix.java276
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double[][] outData = new double[nRows][nCols] ` -topatch--> `final double[] out = new double[nRows]` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 276, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double[][] outData = new double[nRows][nCols] ` -topatch--> `final double[] out = new double[nRows]` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 338, #gens: 382, #ops: 1, parent:337] gen mutated: 1 , gen not mut: 15, gen not applied  0
-The child does NOT compile: 338, errors: [Array2DRowRealMatrix.java:425: error: cannot find symbol
		final double[] out = new double[nRows]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
		                                        		                                        			                                    			                            ^
  symbol:   variable outData
  location: class org.apache.commons.math.linear.Array2DRowRealMatrix, Array2DRowRealMatrix.java:425: error: cannot find symbol
		final double[] out = new double[nRows]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
		                                        		                                        			                                    			                                          			                                        				                				                                 					                                     				                         		                                                               ^
  symbol:   variable outData
  location: class org.apache.commons.math.linear.Array2DRowRealMatrix]
Ingredient counter is Zero
---Undoing: gnrtn(169): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double[][] outData = new double[nRows][nCols] ` -topatch--> `final double[] out = new double[nRows]` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (337(f=1.0), 338(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (337(f=1.0), )
----------Running generation: 170, population size: 1

***** Generation 170 : 0
**Parent Variant: [Variant id: 339, #gens: 382, #ops: 0, parent:-]

--Child created id: 340
--Creating new operations for variant [Variant id: 340, #gens: 382, #ops: 0, parent:339]
---analyzing modificationPoint position: 304
---modifPoint 0 not mutation generated in  // compute splitting points java.util.List<java.lang.Integer> splitIndices = computeSplits()
---analyzing modificationPoint position: 45
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  // initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2)
---analyzing modificationPoint position: 206
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 2 not mutation generated in  work[j4 + 2] = dN
---analyzing modificationPoint position: 153
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1212
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `left = middle ` -topatch--> `tType = -10` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1212, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `left = middle ` -topatch--> `tType = -10` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 340, #gens: 382, #ops: 1, parent:339] gen mutated: 1 , gen not mut: 3, gen not applied  0
-The child does NOT compile: 340, errors: [EigenDecompositionImpl.java:1667: error: illegal start of expression
	 * Perform a dqd step.
	 ^, EigenDecompositionImpl.java:1667: error: ';' expected
	 * Perform a dqd step.
	          ^, EigenDecompositionImpl.java:1667: error: ';' expected
	 * Perform a dqd step.
	                ^, EigenDecompositionImpl.java:1667: error: <identifier> expected
	 * Perform a dqd step.
	                      ^, EigenDecompositionImpl.java:1668: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	      ^, EigenDecompositionImpl.java:1668: error: not a statement
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	 ^, EigenDecompositionImpl.java:1668: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                            ^, EigenDecompositionImpl.java:1668: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                          ^, EigenDecompositionImpl.java:1668: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                 ^, EigenDecompositionImpl.java:1668: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                ^, EigenDecompositionImpl.java:1668: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                         ^, EigenDecompositionImpl.java:1668: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>
	                                                                           ^, EigenDecompositionImpl.java:1670: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1670: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1671: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1671: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1672: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1673: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1673: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1674: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	  ^, EigenDecompositionImpl.java:1674: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	^, EigenDecompositionImpl.java:1674: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	        ^, EigenDecompositionImpl.java:1674: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                ^, EigenDecompositionImpl.java:1674: error: <identifier> expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                 ^, EigenDecompositionImpl.java:1674: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                               ^, EigenDecompositionImpl.java:1675: error: illegal start of expression
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	 ^, EigenDecompositionImpl.java:1675: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	          ^, EigenDecompositionImpl.java:1675: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                    ^, EigenDecompositionImpl.java:1675: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                 ^, EigenDecompositionImpl.java:1675: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                             ^, EigenDecompositionImpl.java:1675: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                    ^, EigenDecompositionImpl.java:1675: error: ';' expected
	 * Compute the shift increment as an estimate of the smallest eigenvalue.
	                                                                        ^, EigenDecompositionImpl.java:1676: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	      ^, EigenDecompositionImpl.java:1676: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                            ^, EigenDecompositionImpl.java:1676: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                          ^, EigenDecompositionImpl.java:1676: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                 ^, EigenDecompositionImpl.java:1676: error: ';' expected
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                ^, EigenDecompositionImpl.java:1676: error: illegal start of type
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                         ^, EigenDecompositionImpl.java:1676: error: illegal start of expression
	 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
	                                                                           ^, EigenDecompositionImpl.java:1678: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1678: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1679: error: not a statement
	 * 		start index
	 ^, EigenDecompositionImpl.java:1679: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1681: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1681: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1682: error: illegal start of expression
	 * @param deflated
	   ^, EigenDecompositionImpl.java:1683: error: not a statement
	 * 		number of realEigenvalues just deflated
	 ^, EigenDecompositionImpl.java:1683: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		      ^, EigenDecompositionImpl.java:1683: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                         ^, EigenDecompositionImpl.java:1683: error: ';' expected
	 * 		number of realEigenvalues just deflated
	   		                                       ^, EigenDecompositionImpl.java:1684: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	^, EigenDecompositionImpl.java:1684: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	        ^, EigenDecompositionImpl.java:1684: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                  ^, EigenDecompositionImpl.java:1684: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                   ^, EigenDecompositionImpl.java:1684: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                  ^, EigenDecompositionImpl.java:1684: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01; 		final double cnst3 = 1.05; 		// a negative dMin forces the shift to take that absolute value 		// tType records the type of shift.
	    	                                                                                     ^, EigenDecompositionImpl.java:1691: error: orphaned default
				if ((dMin2 == dN2) && ((2 * work[nn - 5]) < work[nn - 7])) { 					tType = -10; 					final double s = 0.333 * dMin2; 					if (work[nn - 5] > work[nn - 7]) { 						return;} 					double b1 = work[nn - 5] / work[nn - 7]; 					double b2 = b1; 					if (b2 != 0.0) { 						for (int i4 = ((4 * end) - 9) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) { 							if (work[i4] > work[i4 - 2]) { 								return;} 							b1 *= work[i4] / work[i4 - 2]; 							b2 += b1; 							if ((100 * b1) < b2) { 								break;}}} 					b2 = java.lang.Math.sqrt(cnst3 * b2); 					final double a2 = dMin2 / (1 + (b2 * b2)); 					final double gap2 = ((work[nn - 7] + work[nn - 9]) - (java.lang.Math.sqrt(work[nn - 11]) * java.lang.Math.sqrt(work[nn - 9]))) - a2; 					if ((gap2 > 0.0) && (gap2 > (b2 * a2))) { 						tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));} else { 						tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));}} else { 					tau = 0.25 * dMin2; 					tType = -11;} 				break; 			default : 				// case 12, more than two realEigenvalues deflated. no information. 				tau = 0.0; 				tType = -12;}} 	/**
				                                                             					             					                                					                                   						         					                                         					                					                 						                                                                                           							                               								         							                               							          							                       								          					                                      					                                           					                                                                                                                                     					                                          						                                                                                     						                                                               					                    					              				       			^, EigenDecompositionImpl.java:1692: error: illegal start of expression
	 * Update sigma.
	 ^, EigenDecompositionImpl.java:1692: error: ';' expected
	 * Update sigma.
	         ^, EigenDecompositionImpl.java:1692: error: <identifier> expected
	 * Update sigma.
	                ^, EigenDecompositionImpl.java:1694: error: illegal start of expression
	 * @param shift
	 ^, EigenDecompositionImpl.java:1694: error: illegal start of expression
	 * @param shift
	   ^, EigenDecompositionImpl.java:1695: error: not a statement
	 * 		shift to apply to sigma
	 ^, EigenDecompositionImpl.java:1695: error: ';' expected
	 * 		shift to apply to sigma
	   		     ^, EigenDecompositionImpl.java:1695: error: ';' expected
	 * 		shift to apply to sigma
	   		              ^, EigenDecompositionImpl.java:1695: error: ';' expected
	 * 		shift to apply to sigma
	   		                       ^, EigenDecompositionImpl.java:1696: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements 		// the expressions below take care to accumulate the part of sigma 		// that does not fit within a double variable into sigmaLow
	    	^, EigenDecompositionImpl.java:1696: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements 		// the expressions below take care to accumulate the part of sigma 		// that does not fit within a double variable into sigmaLow
	    	        ^, EigenDecompositionImpl.java:1696: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements 		// the expressions below take care to accumulate the part of sigma 		// that does not fit within a double variable into sigmaLow
	    	                        ^, EigenDecompositionImpl.java:1696: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements 		// the expressions below take care to accumulate the part of sigma 		// that does not fit within a double variable into sigmaLow
	    	                                           ^, EigenDecompositionImpl.java:1699: error: illegal start of expression
	 */ 	private void findEigenVectors() {
	    	^, EigenDecompositionImpl.java:1699: error: illegal start of expression
	 */ 	private void findEigenVectors() {
	    	        ^, EigenDecompositionImpl.java:1699: error: ';' expected
	 */ 	private void findEigenVectors() {
	    	                             ^, EigenDecompositionImpl.java:1736: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                      ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                               ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                  ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                    ^, EigenDecompositionImpl.java:1798: error: <identifier> expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                      ^, EigenDecompositionImpl.java:1798: error: ';' expected
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	                                                                                                          ^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	^, EigenDecompositionImpl.java:1826: error: illegal start of expression
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	        ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                   ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                     ^, EigenDecompositionImpl.java:1826: error: <identifier> expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                       ^, EigenDecompositionImpl.java:1826: error: ';' expected
	 */ 	private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double pi = d[nM1] - lambda;
	    	                                                                                                           ^, EigenDecompositionImpl.java:1843: error: reached end of file while parsing
}
 ^]
Ingredient counter is Zero
---Undoing: gnrtn(170): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `left = middle ` -topatch--> `tType = -10` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (339(f=1.0), 340(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (339(f=1.0), )
----------Running generation: 171, population size: 1

***** Generation 171 : 0
**Parent Variant: [Variant id: 341, #gens: 382, #ops: 0, parent:-]

--Child created id: 342
--Creating new operations for variant [Variant id: 342, #gens: 382, #ops: 0, parent:341]
---analyzing modificationPoint position: 34
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  // pre-compute some elements squaredSecondary = new double[secondary.length]
---analyzing modificationPoint position: 146
location: EigenDecompositionImpl.java1199
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < maxIter; ++i) {  	final double range = right - left; 	if ((range < absoluteToler[...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 342, #gens: 381, #ops: 1, parent:341] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 342
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-342/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 3, was successful: false, cases executed: 17] ,[]
-Valid?: |false|3|17|[]|, fitness 3.0
Ingredient counter is Zero
---Undoing: gnrtn(171): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtForImpl) `for (int i = 0; i < maxIter; ++i) {  	final double range = right - left; 	if ((range < absoluteToler[...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (341(f=1.0), 342(f=3.0), )
Selected to next generation: IDs2--> (341(f=1.0), )
----------Running generation: 172, population size: 1

***** Generation 172 : 0
**Parent Variant: [Variant id: 343, #gens: 382, #ops: 0, parent:-]

--Child created id: 344
--Creating new operations for variant [Variant id: 344, #gens: 382, #ops: 0, parent:343]
---analyzing modificationPoint position: 354
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  final int nRows = d.length
---analyzing modificationPoint position: 356
Templates availables120
Attempts Base Ingredients  1 total 120
vars from patch []
location: Array2DRowRealMatrix.java125
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int nCols = d[0].length ` -topatch--> `final int nCols = this.getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 125, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int nCols = d[0].length ` -topatch--> `final int nCols = this.getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 344, #gens: 383, #ops: 1, parent:343] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 344, errors: [Array2DRowRealMatrix.java:442: error: illegal start of expression
	 * {@inheritDoc }
	 ^, Array2DRowRealMatrix.java:442: error: illegal start of expression
	 * {@inheritDoc }
	   ^, Array2DRowRealMatrix.java:442: error: illegal start of type
	 * {@inheritDoc }
	                ^, Array2DRowRealMatrix.java:442: error: ';' expected
	 * {@inheritDoc }
	                 ^, Array2DRowRealMatrix.java:443: error: illegal start of expression
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	  ^, Array2DRowRealMatrix.java:443: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	   ^, Array2DRowRealMatrix.java:443: error: not a statement
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	          ^, Array2DRowRealMatrix.java:443: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                   ^, Array2DRowRealMatrix.java:443: error: illegal start of expression
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	^, Array2DRowRealMatrix.java:443: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	          ^, Array2DRowRealMatrix.java:443: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	                                                         ^, Array2DRowRealMatrix.java:443: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	                                                                                                           ^, Array2DRowRealMatrix.java:443: error: not a statement
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	                                                                                                                             ^, Array2DRowRealMatrix.java:443: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	                                                                                                                                                      ^, Array2DRowRealMatrix.java:451: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	^, Array2DRowRealMatrix.java:451: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                   ^, Array2DRowRealMatrix.java:451: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                               ^, Array2DRowRealMatrix.java:451: error: not a statement
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                                                 ^, Array2DRowRealMatrix.java:451: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                                                                          ^, Array2DRowRealMatrix.java:452: error: illegal start of expression
	 * {@inheritDoc }
	 ^, Array2DRowRealMatrix.java:452: error: illegal start of expression
	 * {@inheritDoc }
	   ^, Array2DRowRealMatrix.java:452: error: illegal start of type
	 * {@inheritDoc }
	                ^, Array2DRowRealMatrix.java:452: error: ';' expected
	 * {@inheritDoc }
	                 ^, Array2DRowRealMatrix.java:453: error: illegal start of expression
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	  ^, Array2DRowRealMatrix.java:453: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	   ^, Array2DRowRealMatrix.java:453: error: not a statement
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	          ^, Array2DRowRealMatrix.java:453: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                   ^, Array2DRowRealMatrix.java:453: error: illegal start of expression
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	^, Array2DRowRealMatrix.java:453: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	          ^, Array2DRowRealMatrix.java:453: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	                                                         ^, Array2DRowRealMatrix.java:453: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	                                                                                                           ^, Array2DRowRealMatrix.java:453: error: not a statement
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	                                                                                                                             ^, Array2DRowRealMatrix.java:453: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	                                                                                                                                                      ^, Array2DRowRealMatrix.java:461: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	^, Array2DRowRealMatrix.java:461: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                   ^, Array2DRowRealMatrix.java:461: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                               ^, Array2DRowRealMatrix.java:461: error: not a statement
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                                                 ^, Array2DRowRealMatrix.java:461: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                                                                          ^, Array2DRowRealMatrix.java:462: error: illegal start of expression
	 * {@inheritDoc }
	 ^, Array2DRowRealMatrix.java:462: error: illegal start of expression
	 * {@inheritDoc }
	   ^, Array2DRowRealMatrix.java:462: error: illegal start of type
	 * {@inheritDoc }
	                ^, Array2DRowRealMatrix.java:462: error: ';' expected
	 * {@inheritDoc }
	                 ^, Array2DRowRealMatrix.java:463: error: illegal start of expression
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	  ^, Array2DRowRealMatrix.java:463: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	   ^, Array2DRowRealMatrix.java:463: error: not a statement
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	          ^, Array2DRowRealMatrix.java:463: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                   ^, Array2DRowRealMatrix.java:463: error: illegal start of expression
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	^, Array2DRowRealMatrix.java:463: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	      ^, Array2DRowRealMatrix.java:463: error: illegal start of expression
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	             ^, Array2DRowRealMatrix.java:463: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	              ^, Array2DRowRealMatrix.java:463: error: illegal start of expression
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	               ^, Array2DRowRealMatrix.java:463: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	                ^, Array2DRowRealMatrix.java:463: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	                           ^, Array2DRowRealMatrix.java:469: error: illegal start of expression
	 */ 	public double[][] getDataRef() { 		return data;} 	/**
	    	^, Array2DRowRealMatrix.java:469: error: ';' expected
	 */ 	public double[][] getDataRef() { 		return data;} 	/**
	    	                            ^, Array2DRowRealMatrix.java:471: error: ';' expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
	    	                    	                        ^, Array2DRowRealMatrix.java:471: error: <identifier> expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
	    	                    	                                                    ^, Array2DRowRealMatrix.java:471: error: <identifier> expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
	    	                    	                                                                   ^, Array2DRowRealMatrix.java:471: error: ';' expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
	    	                    	                                                                                    ^, Array2DRowRealMatrix.java:471: error: not a statement
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
	    	                    	                                                                                                                           ^, Array2DRowRealMatrix.java:471: error: ';' expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}} 	/**
	    	                    	                                                                                                                                                ^, Array2DRowRealMatrix.java:473: error: ';' expected
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			return data[row][column];} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                      ^, Array2DRowRealMatrix.java:473: error: <identifier> expected
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			return data[row][column];} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                     ^, Array2DRowRealMatrix.java:473: error: ';' expected
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			return data[row][column];} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                      ^, Array2DRowRealMatrix.java:473: error: not a statement
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			return data[row][column];} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                             ^, Array2DRowRealMatrix.java:473: error: ';' expected
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			return data[row][column];} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                                  ^, Array2DRowRealMatrix.java:475: error: ';' expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] = value;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                    ^, Array2DRowRealMatrix.java:475: error: <identifier> expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] = value;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                   ^, Array2DRowRealMatrix.java:475: error: <identifier> expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] = value;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                     ^, Array2DRowRealMatrix.java:475: error: ';' expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] = value;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                        ^, Array2DRowRealMatrix.java:475: error: not a statement
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] = value;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                               ^, Array2DRowRealMatrix.java:475: error: ';' expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] = value;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                                                    ^, Array2DRowRealMatrix.java:477: error: ';' expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] += increment;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                      ^, Array2DRowRealMatrix.java:477: error: <identifier> expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] += increment;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                     ^, Array2DRowRealMatrix.java:477: error: <identifier> expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] += increment;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                       ^, Array2DRowRealMatrix.java:477: error: ';' expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] += increment;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                              ^, Array2DRowRealMatrix.java:477: error: not a statement
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] += increment;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                                     ^, Array2DRowRealMatrix.java:477: error: ';' expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] += increment;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                                                          ^, Array2DRowRealMatrix.java:479: error: ';' expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] *= factor;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                         ^, Array2DRowRealMatrix.java:479: error: <identifier> expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] *= factor;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                        ^, Array2DRowRealMatrix.java:479: error: <identifier> expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] *= factor;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                          ^, Array2DRowRealMatrix.java:479: error: ';' expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] *= factor;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                              ^, Array2DRowRealMatrix.java:479: error: not a statement
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] *= factor;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                                     ^, Array2DRowRealMatrix.java:479: error: ';' expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException { 		try { 			data[row][column] *= factor;} catch (java.lang.ArrayIndexOutOfBoundsException e) { 			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());}} 	/**
	    	                    	                                                                                                                                          ^, Array2DRowRealMatrix.java:481: error: ';' expected
	 */ 	@java.lang.Override 	public int getRowDimension() { 		return data == null ? 0 : data.length;} 	/**
	    	                    	                          ^, Array2DRowRealMatrix.java:483: error: ';' expected
	 */ 	@java.lang.Override 	public int getColumnDimension() { 		return (data == null) || (data[0] == null) ? 0 : data[0].length;} 	/**
	    	                    	                             ^, Array2DRowRealMatrix.java:485: error: ';' expected
	 */ 	@java.lang.Override 	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = this.getRowDimension(); 		final int nCols = this.getColumnDimension(); 		if (v.length != nCols) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);} 		final double[] out = new double[nRows]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			double sum = 0; 			for (int i = 0; i < nCols; i++) { 				sum += dataRow[i] * v[i];} 			out[row] = sum;} 		return out;} 	/**
	    	                    	                       ^, Array2DRowRealMatrix.java:485: error: ';' expected
	 */ 	@java.lang.Override 	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = this.getRowDimension(); 		final int nCols = this.getColumnDimension(); 		if (v.length != nCols) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);} 		final double[] out = new double[nRows]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			double sum = 0; 			for (int i = 0; i < nCols; i++) { 				sum += dataRow[i] * v[i];} 			out[row] = sum;} 		return out;} 	/**
	    	                    	                                        ^, Array2DRowRealMatrix.java:485: error: not a statement
	 */ 	@java.lang.Override 	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = this.getRowDimension(); 		final int nCols = this.getColumnDimension(); 		if (v.length != nCols) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);} 		final double[] out = new double[nRows]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			double sum = 0; 			for (int i = 0; i < nCols; i++) { 				sum += dataRow[i] * v[i];} 			out[row] = sum;} 		return out;} 	/**
	    	                    	                                                          ^, Array2DRowRealMatrix.java:485: error: ';' expected
	 */ 	@java.lang.Override 	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = this.getRowDimension(); 		final int nCols = this.getColumnDimension(); 		if (v.length != nCols) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);} 		final double[] out = new double[nRows]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			double sum = 0; 			for (int i = 0; i < nCols; i++) { 				sum += dataRow[i] * v[i];} 			out[row] = sum;} 		return out;} 	/**
	    	                    	                                                                                   ^, Array2DRowRealMatrix.java:487: error: ';' expected
	 */ 	@java.lang.Override 	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = getRowDimension(); 		final int nCols = getColumnDimension(); 		if (v.length != nRows) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);} 		final double[] out = new double[nCols]; 		for (int col = 0; col < nCols; ++col) { 			double sum = 0; 			for (int i = 0; i < nRows; ++i) { 				sum += data[i][col] * v[i];} 			out[col] = sum;} 		return out;} 	/**
	    	                    	                           ^, Array2DRowRealMatrix.java:487: error: ';' expected
	 */ 	@java.lang.Override 	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = getRowDimension(); 		final int nCols = getColumnDimension(); 		if (v.length != nRows) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);} 		final double[] out = new double[nCols]; 		for (int col = 0; col < nCols; ++col) { 			double sum = 0; 			for (int i = 0; i < nRows; ++i) { 				sum += data[i][col] * v[i];} 			out[col] = sum;} 		return out;} 	/**
	    	                    	                                            ^, Array2DRowRealMatrix.java:487: error: not a statement
	 */ 	@java.lang.Override 	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = getRowDimension(); 		final int nCols = getColumnDimension(); 		if (v.length != nRows) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);} 		final double[] out = new double[nCols]; 		for (int col = 0; col < nCols; ++col) { 			double sum = 0; 			for (int i = 0; i < nRows; ++i) { 				sum += data[i][col] * v[i];} 			out[col] = sum;} 		return out;} 	/**
	    	                    	                                                              ^, Array2DRowRealMatrix.java:487: error: ';' expected
	 */ 	@java.lang.Override 	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException { 		final int nRows = getRowDimension(); 		final int nCols = getColumnDimension(); 		if (v.length != nRows) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);} 		final double[] out = new double[nCols]; 		for (int col = 0; col < nCols; ++col) { 			double sum = 0; 			for (int i = 0; i < nRows; ++i) { 				sum += data[i][col] * v[i];} 			out[col] = sum;} 		return out;} 	/**
	    	                    	                                                                                       ^, Array2DRowRealMatrix.java:489: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException { 		final int rows = getRowDimension(); 		final int columns = getColumnDimension(); 		visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); 		for (int i = 0; i < rows; ++i) { 			final double[] rowI = data[i]; 			for (int j = 0; j < columns; ++j) { 				rowI[j] = visitor.visit(i, j, rowI[j]);}} 		return visitor.end();} 	/**
	    	                    	                            ^, Array2DRowRealMatrix.java:489: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException { 		final int rows = getRowDimension(); 		final int columns = getColumnDimension(); 		visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); 		for (int i = 0; i < rows; ++i) { 			final double[] rowI = data[i]; 			for (int j = 0; j < columns; ++j) { 				rowI[j] = visitor.visit(i, j, rowI[j]);}} 		return visitor.end();} 	/**
	    	                    	                                                                                                   ^, Array2DRowRealMatrix.java:489: error: not a statement
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException { 		final int rows = getRowDimension(); 		final int columns = getColumnDimension(); 		visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); 		for (int i = 0; i < rows; ++i) { 			final double[] rowI = data[i]; 			for (int j = 0; j < columns; ++j) { 				rowI[j] = visitor.visit(i, j, rowI[j]);}} 		return visitor.end();} 	/**
	    	                    	                                                                                                                                          ^, Array2DRowRealMatrix.java:489: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException { 		final int rows = getRowDimension(); 		final int columns = getColumnDimension(); 		visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); 		for (int i = 0; i < rows; ++i) { 			final double[] rowI = data[i]; 			for (int j = 0; j < columns; ++j) { 				rowI[j] = visitor.visit(i, j, rowI[j]);}} 		return visitor.end();} 	/**
	    	                    	                                                                                                                                                                 ^, Array2DRowRealMatrix.java:491: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException { 		final int rows = getRowDimension(); 		final int columns = getColumnDimension(); 		visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); 		for (int i = 0; i < rows; ++i) { 			final double[] rowI = data[i]; 			for (int j = 0; j < columns; ++j) { 				visitor.visit(i, j, rowI[j]);}}
	    	                    	                            ^, Array2DRowRealMatrix.java:491: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException { 		final int rows = getRowDimension(); 		final int columns = getColumnDimension(); 		visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); 		for (int i = 0; i < rows; ++i) { 			final double[] rowI = data[i]; 			for (int j = 0; j < columns; ++j) { 				visitor.visit(i, j, rowI[j]);}}
	    	                    	                                                                                                     ^]
Ingredient counter is Zero
---Undoing: gnrtn(172): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int nCols = d[0].length ` -topatch--> `final int nCols = this.getColumnDimension()` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (343(f=1.0), 344(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (343(f=1.0), )
----------Running generation: 173, population size: 1

***** Generation 173 : 0
**Parent Variant: [Variant id: 345, #gens: 382, #ops: 0, parent:-]

--Child created id: 346
--Creating new operations for variant [Variant id: 346, #gens: 382, #ops: 0, parent:345]
---analyzing modificationPoint position: 132
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tType]
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1172
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * min[...] ` -topatch--> `tType = -9` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1172, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * min[...] ` -topatch--> `tType = -9` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 346, #gens: 383, #ops: 1, parent:345] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 346, errors: [EigenDecompositionImpl.java:1627: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			^, EigenDecompositionImpl.java:1627: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                    ^, EigenDecompositionImpl.java:1627: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                     ^, EigenDecompositionImpl.java:1627: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                           ^, EigenDecompositionImpl.java:1627: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                     ^, EigenDecompositionImpl.java:1627: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                 ^, EigenDecompositionImpl.java:1627: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                     ^, EigenDecompositionImpl.java:1627: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				    ^, EigenDecompositionImpl.java:1627: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				               ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				      ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			      ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				               ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				              ^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		^, EigenDecompositionImpl.java:1628: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		                                    ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                   ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                    ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                       ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				        ^, EigenDecompositionImpl.java:1638: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				           		             ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                          ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                       ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			      ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			      ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			      ^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			^, EigenDecompositionImpl.java:1652: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			                                     ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                        ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                         ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                               ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                      ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				      ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                          ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                               ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                      ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				      ^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1660: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				                                              ^, EigenDecompositionImpl.java:1664: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1666: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                       ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                        ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                               ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                     ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					           ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                          ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                               ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                     ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					           ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1668: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                              ^]
Ingredient counter is Zero
---Undoing: gnrtn(173): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * min[...] ` -topatch--> `tType = -9` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (345(f=1.0), 346(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (345(f=1.0), )
----------Running generation: 174, population size: 1

***** Generation 174 : 0
**Parent Variant: [Variant id: 347, #gens: 382, #ops: 0, parent:-]

--Child created id: 348
--Creating new operations for variant [Variant id: 348, #gens: 382, #ops: 0, parent:347]
---analyzing modificationPoint position: 354
Templates availables120
Attempts Base Ingredients  1 total 120
vars from patch []
location: Array2DRowRealMatrix.java121
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int nRows = d.length ` -topatch--> `return copyOut()` (spoon.support.reflect.code.CtReturnImpl) 
---MP=org.apache.commons.math.linear.Array2DRowRealMatrix line: 121, pointed element: CtReturnImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int nRows = d.length ` -topatch--> `return copyOut()` (spoon.support.reflect.code.CtReturnImpl) 

--Summary Creation: for variant [Variant id: 348, #gens: 383, #ops: 1, parent:347] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 348, errors: [Array2DRowRealMatrix.java:320: error: illegal start of expression
	 * {@inheritDoc }
	 ^, Array2DRowRealMatrix.java:320: error: illegal start of expression
	 * {@inheritDoc }
	   ^, Array2DRowRealMatrix.java:320: error: illegal start of type
	 * {@inheritDoc }
	                ^, Array2DRowRealMatrix.java:320: error: ';' expected
	 * {@inheritDoc }
	                 ^, Array2DRowRealMatrix.java:321: error: illegal start of expression
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	  ^, Array2DRowRealMatrix.java:321: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	   ^, Array2DRowRealMatrix.java:321: error: not a statement
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	          ^, Array2DRowRealMatrix.java:321: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                   ^, Array2DRowRealMatrix.java:321: error: illegal start of expression
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	^, Array2DRowRealMatrix.java:321: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	          ^, Array2DRowRealMatrix.java:321: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	                                                         ^, Array2DRowRealMatrix.java:321: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	                                                                                                           ^, Array2DRowRealMatrix.java:321: error: not a statement
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	                                                                                                                             ^, Array2DRowRealMatrix.java:321: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return subtract(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.subtract(m);}} 	/**
	    	                    	                                                                                                                                                      ^, Array2DRowRealMatrix.java:329: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	^, Array2DRowRealMatrix.java:329: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                   ^, Array2DRowRealMatrix.java:329: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                               ^, Array2DRowRealMatrix.java:329: error: not a statement
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                                                 ^, Array2DRowRealMatrix.java:329: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix subtract(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m); 		final int rowCount = getRowDimension(); 		final int columnCount = getColumnDimension(); 		final double[][] outData = new double[rowCount][columnCount]; 		for (int row = 0; row < rowCount; row++) { 			final double[] dataRow = data[row]; 			final double[] mRow = m.data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < columnCount; col++) { 				outDataRow[col] = dataRow[col] - mRow[col];}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                                                                          ^, Array2DRowRealMatrix.java:330: error: illegal start of expression
	 * {@inheritDoc }
	 ^, Array2DRowRealMatrix.java:330: error: illegal start of expression
	 * {@inheritDoc }
	   ^, Array2DRowRealMatrix.java:330: error: illegal start of type
	 * {@inheritDoc }
	                ^, Array2DRowRealMatrix.java:330: error: ';' expected
	 * {@inheritDoc }
	                 ^, Array2DRowRealMatrix.java:331: error: illegal start of expression
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	  ^, Array2DRowRealMatrix.java:331: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	   ^, Array2DRowRealMatrix.java:331: error: not a statement
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	          ^, Array2DRowRealMatrix.java:331: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                   ^, Array2DRowRealMatrix.java:331: error: illegal start of expression
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	^, Array2DRowRealMatrix.java:331: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	          ^, Array2DRowRealMatrix.java:331: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	                                                         ^, Array2DRowRealMatrix.java:331: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	                                                                                                           ^, Array2DRowRealMatrix.java:331: error: not a statement
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	                                                                                                                             ^, Array2DRowRealMatrix.java:331: error: ';' expected
	 */ 	@java.lang.Override 	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException { 		try { 			return multiply(((org.apache.commons.math.linear.Array2DRowRealMatrix) (m)));} catch (java.lang.ClassCastException cce) { 			return super.multiply(m);}} 	/**
	    	                    	                                                                                                                                                      ^, Array2DRowRealMatrix.java:339: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	^, Array2DRowRealMatrix.java:339: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                   ^, Array2DRowRealMatrix.java:339: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                               ^, Array2DRowRealMatrix.java:339: error: not a statement
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                                                 ^, Array2DRowRealMatrix.java:339: error: ';' expected
	 */ 	public org.apache.commons.math.linear.Array2DRowRealMatrix multiply(final org.apache.commons.math.linear.Array2DRowRealMatrix m) throws java.lang.IllegalArgumentException { 		// safety check 		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m); 		final int nRows = this.getRowDimension(); 		final int nCols = m.getColumnDimension(); 		final int nSum = this.getColumnDimension(); 		final double[][] outData = new double[nRows][nCols]; 		for (int row = 0; row < nRows; row++) { 			final double[] dataRow = data[row]; 			final double[] outDataRow = outData[row]; 			for (int col = 0; col < nCols; col++) { 				double sum = 0; 				for (int i = 0; i < nSum; i++) { 					sum += dataRow[i] * m.data[i][col];} 				outDataRow[col] = sum;}} 		return new org.apache.commons.math.linear.Array2DRowRealMatrix(outData, false);} 	/**
	    	                                                                                                                                                                          ^, Array2DRowRealMatrix.java:340: error: illegal start of expression
	 * {@inheritDoc }
	 ^, Array2DRowRealMatrix.java:340: error: illegal start of expression
	 * {@inheritDoc }
	   ^, Array2DRowRealMatrix.java:340: error: illegal start of type
	 * {@inheritDoc }
	                ^, Array2DRowRealMatrix.java:340: error: ';' expected
	 * {@inheritDoc }
	                 ^, Array2DRowRealMatrix.java:341: error: illegal start of expression
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	  ^, Array2DRowRealMatrix.java:341: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	   ^, Array2DRowRealMatrix.java:341: error: not a statement
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	          ^, Array2DRowRealMatrix.java:341: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                   ^, Array2DRowRealMatrix.java:341: error: illegal start of expression
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	^, Array2DRowRealMatrix.java:341: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	      ^, Array2DRowRealMatrix.java:341: error: illegal start of expression
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	             ^, Array2DRowRealMatrix.java:341: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	              ^, Array2DRowRealMatrix.java:341: error: illegal start of expression
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	               ^, Array2DRowRealMatrix.java:341: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	                ^, Array2DRowRealMatrix.java:341: error: ';' expected
	 */ 	@java.lang.Override 	public double[][] getData() { 		return copyOut();} 	/**
	    	                    	                           ^, Array2DRowRealMatrix.java:347: error: illegal start of expression
	 */ 	public double[][] getDataRef() { 		return data;} 	/**
	    	^, Array2DRowRealMatrix.java:347: error: ';' expected
	 */ 	public double[][] getDataRef() { 		return data;} 	/**
	    	                            ^, Array2DRowRealMatrix.java:349: error: ';' expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}}
	    	                    	                        ^, Array2DRowRealMatrix.java:349: error: <identifier> expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}}
	    	                    	                                                    ^, Array2DRowRealMatrix.java:349: error: <identifier> expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}}
	    	                    	                                                                   ^, Array2DRowRealMatrix.java:349: error: ';' expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}}
	    	                    	                                                                                    ^, Array2DRowRealMatrix.java:349: error: not a statement
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}}
	    	                    	                                                                                                                           ^, Array2DRowRealMatrix.java:349: error: ';' expected
	 */ 	@java.lang.Override 	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException { 		if (data == null) { 			if (row > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet", row);} 			if (column > 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet", column);} 			final int nRows = subMatrix.length; 			if (nRows == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");} 			final int nCols = subMatrix[0].length; 			if (nCols == 0) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");} 			data = new double[subMatrix.length][nCols]; 			for (int i = 0; i < data.length; ++i) { 				if (subMatrix[i].length != nCols) { 					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[i].length);} 				java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);}} else { 			super.setSubMatrix(subMatrix, row, column);}}
	    	                    	                                                                                                                                                ^, Array2DRowRealMatrix.java:352: error: ';' expected
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws 
	    	                    	                      ^, Array2DRowRealMatrix.java:352: error: <identifier> expected
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws 
	    	                    	                                     ^, Array2DRowRealMatrix.java:352: error: ';' expected
	 */ 	@java.lang.Override 	public double getEntry(final int row, final int column) throws 
	    	                    	                                                      ^, Array2DRowRealMatrix.java:353: error: not a statement
	org.apache.commons.math.linear.MatrixIndexException {
	                              ^, Array2DRowRealMatrix.java:353: error: ';' expected
	org.apache.commons.math.linear.MatrixIndexException {
	                                                   ^, Array2DRowRealMatrix.java:365: error: ';' expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws 
	    	                    	                    ^, Array2DRowRealMatrix.java:365: error: <identifier> expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws 
	    	                    	                                   ^, Array2DRowRealMatrix.java:365: error: <identifier> expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws 
	    	                    	                                                     ^, Array2DRowRealMatrix.java:365: error: ';' expected
	 */ 	@java.lang.Override 	public void setEntry(final int row, final int column, final double value) throws 
	    	                    	                                                                        ^, Array2DRowRealMatrix.java:366: error: not a statement
	org.apache.commons.math.linear.MatrixIndexException {
	                              ^, Array2DRowRealMatrix.java:366: error: ';' expected
	org.apache.commons.math.linear.MatrixIndexException {
	                                                   ^, Array2DRowRealMatrix.java:378: error: ';' expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws 
	    	                    	                      ^, Array2DRowRealMatrix.java:378: error: <identifier> expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws 
	    	                    	                                     ^, Array2DRowRealMatrix.java:378: error: <identifier> expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws 
	    	                    	                                                       ^, Array2DRowRealMatrix.java:378: error: ';' expected
	 */ 	@java.lang.Override 	public void addToEntry(final int row, final int column, final double increment) throws 
	    	                    	                                                                              ^, Array2DRowRealMatrix.java:379: error: not a statement
	org.apache.commons.math.linear.MatrixIndexException {
	                              ^, Array2DRowRealMatrix.java:379: error: ';' expected
	org.apache.commons.math.linear.MatrixIndexException {
	                                                   ^, Array2DRowRealMatrix.java:391: error: ';' expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws 
	    	                    	                         ^, Array2DRowRealMatrix.java:391: error: <identifier> expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws 
	    	                    	                                        ^, Array2DRowRealMatrix.java:391: error: <identifier> expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws 
	    	                    	                                                          ^, Array2DRowRealMatrix.java:391: error: ';' expected
	 */ 	@java.lang.Override 	public void multiplyEntry(final int row, final int column, final double factor) throws 
	    	                    	                                                                              ^, Array2DRowRealMatrix.java:392: error: not a statement
	org.apache.commons.math.linear.MatrixIndexException {
	                              ^, Array2DRowRealMatrix.java:392: error: ';' expected
	org.apache.commons.math.linear.MatrixIndexException {
	                                                   ^, Array2DRowRealMatrix.java:404: error: ';' expected
	 */ 	@java.lang.Override 	public int getRowDimension() {
	    	                    	                          ^, Array2DRowRealMatrix.java:410: error: ';' expected
	 */ 	@java.lang.Override 	public int getColumnDimension() {
	    	                    	                             ^, Array2DRowRealMatrix.java:416: error: ';' expected
	 */ 	@java.lang.Override 	public double[] operate(final double[] v) throws 
	    	                    	                       ^, Array2DRowRealMatrix.java:416: error: ';' expected
	 */ 	@java.lang.Override 	public double[] operate(final double[] v) throws 
	    	                    	                                        ^, Array2DRowRealMatrix.java:417: error: not a statement
	java.lang.IllegalArgumentException {
	         ^, Array2DRowRealMatrix.java:417: error: ';' expected
	java.lang.IllegalArgumentException {
	                                  ^, Array2DRowRealMatrix.java:439: error: ';' expected
	 */ 	@java.lang.Override 	public double[] preMultiply(final double[] v) throws 
	    	                    	                           ^, Array2DRowRealMatrix.java:439: error: ';' expected
	 */ 	@java.lang.Override 	public double[] preMultiply(final double[] v) throws 
	    	                    	                                            ^, Array2DRowRealMatrix.java:440: error: not a statement
	java.lang.IllegalArgumentException {
	         ^, Array2DRowRealMatrix.java:440: error: ';' expected
	java.lang.IllegalArgumentException {
	                                  ^, Array2DRowRealMatrix.java:465: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws 
	    	                    	                            ^, Array2DRowRealMatrix.java:465: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws 
	    	                    	                                                                                                   ^, Array2DRowRealMatrix.java:466: error: not a statement
	org.apache.commons.math.linear.MatrixVisitorException {
	                              ^, Array2DRowRealMatrix.java:466: error: ';' expected
	org.apache.commons.math.linear.MatrixVisitorException {
	                                                     ^, Array2DRowRealMatrix.java:481: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws 
	    	                    	                            ^, Array2DRowRealMatrix.java:481: error: ';' expected
	 */ 	@java.lang.Override 	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws 
	    	                    	                                                                                                     ^]
Ingredient counter is Zero
---Undoing: gnrtn(174): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtLocalVariableImpl) `final int nRows = d.length ` -topatch--> `return copyOut()` (spoon.support.reflect.code.CtReturnImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (347(f=1.0), 348(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (347(f=1.0), )
----------Running generation: 175, population size: 1

***** Generation 175 : 0
**Parent Variant: [Variant id: 349, #gens: 382, #ops: 0, parent:-]

--Child created id: 350
--Creating new operations for variant [Variant id: 350, #gens: 382, #ops: 0, parent:349]
---analyzing modificationPoint position: 286
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dMin]
--> var from patch: dMin spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java240
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `work = new double[6 * main.length] ` -topatch--> `dMin = -0.0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 240, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `work = new double[6 * main.length] ` -topatch--> `dMin = -0.0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 350, #gens: 383, #ops: 1, parent:349] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child does NOT compile: 350, errors: [EigenDecompositionImpl.java:1064: error: illegal start of expression
	 * {@inheritDoc }
	 ^, EigenDecompositionImpl.java:1064: error: illegal start of expression
	 * {@inheritDoc }
	   ^, EigenDecompositionImpl.java:1064: error: illegal start of type
	 * {@inheritDoc }
	                ^, EigenDecompositionImpl.java:1064: error: ';' expected
	 * {@inheritDoc }
	                 ^, EigenDecompositionImpl.java:1065: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	  ^, EigenDecompositionImpl.java:1065: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	   ^, EigenDecompositionImpl.java:1065: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                     ^, EigenDecompositionImpl.java:1065: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                             ^, EigenDecompositionImpl.java:1065: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedV == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedV.setColumnVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                                                    ^, EigenDecompositionImpl.java:1068: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	^, EigenDecompositionImpl.java:1068: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	                                                     ^, EigenDecompositionImpl.java:1068: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	                                                                                             ^, EigenDecompositionImpl.java:1068: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedD == null) { 			// cache the matrix for subsequent calls 			cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);} 		return cachedD;} 	/**
	    	                                                                                                                    ^, EigenDecompositionImpl.java:1069: error: illegal start of expression
	 * {@inheritDoc }
	 ^, EigenDecompositionImpl.java:1069: error: illegal start of expression
	 * {@inheritDoc }
	   ^, EigenDecompositionImpl.java:1069: error: illegal start of type
	 * {@inheritDoc }
	                ^, EigenDecompositionImpl.java:1069: error: ';' expected
	 * {@inheritDoc }
	                 ^, EigenDecompositionImpl.java:1070: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	  ^, EigenDecompositionImpl.java:1070: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	   ^, EigenDecompositionImpl.java:1070: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                      ^, EigenDecompositionImpl.java:1070: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                              ^, EigenDecompositionImpl.java:1070: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException { 		if (cachedVt == null) { 			if (eigenvectors == null) { 				findEigenVectors();} 			final int m = eigenvectors.length; 			cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m); 			for (int k = 0; k < m; ++k) { 				cachedVt.setRowVector(k, eigenvectors[k]);}} 		// return the cached matrix
	    	                                                                                                                     ^, EigenDecompositionImpl.java:1073: error: illegal start of expression
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	^, EigenDecompositionImpl.java:1073: error: ';' expected
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	                                  ^, EigenDecompositionImpl.java:1073: error: not a statement
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	                                                                          ^, EigenDecompositionImpl.java:1073: error: ';' expected
	 */ 	public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return realEigenvalues.clone();} 	/**
	    	                                                                                                 ^, EigenDecompositionImpl.java:1075: error: illegal start of expression
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	^, EigenDecompositionImpl.java:1075: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                               ^, EigenDecompositionImpl.java:1075: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                           ^, EigenDecompositionImpl.java:1075: error: not a statement
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                  ^, EigenDecompositionImpl.java:1075: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                                         ^, EigenDecompositionImpl.java:1075: error: not a statement
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                                                    ^, EigenDecompositionImpl.java:1075: error: ';' expected
	 */ 	public double getRealEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return realEigenvalues[i];} 	/**
	    	                                                                                                                                                   ^, EigenDecompositionImpl.java:1077: error: illegal start of expression
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	^, EigenDecompositionImpl.java:1077: error: ';' expected
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	                                  ^, EigenDecompositionImpl.java:1077: error: not a statement
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	                                                                          ^, EigenDecompositionImpl.java:1077: error: ';' expected
	 */ 	public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException { 		return imagEigenvalues.clone();} 	/**
	    	                                                                                                 ^, EigenDecompositionImpl.java:1079: error: illegal start of expression
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	^, EigenDecompositionImpl.java:1079: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                               ^, EigenDecompositionImpl.java:1079: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                           ^, EigenDecompositionImpl.java:1079: error: not a statement
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                  ^, EigenDecompositionImpl.java:1079: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                                         ^, EigenDecompositionImpl.java:1079: error: not a statement
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                                                    ^, EigenDecompositionImpl.java:1079: error: ';' expected
	 */ 	public double getImagEigenvalue(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		return imagEigenvalues[i];} 	/**
	    	                                                                                                                                                   ^, EigenDecompositionImpl.java:1081: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	^, EigenDecompositionImpl.java:1081: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                               ^, EigenDecompositionImpl.java:1081: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:1081: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                  ^, EigenDecompositionImpl.java:1081: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                                         ^, EigenDecompositionImpl.java:1081: error: not a statement
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                                                    ^, EigenDecompositionImpl.java:1081: error: ';' expected
	 */ 	public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws org.apache.commons.math.linear.InvalidMatrixException, java.lang.ArrayIndexOutOfBoundsException { 		if (eigenvectors == null) { 			findEigenVectors();} 		return eigenvectors[i].copy();} 	/**
	    	                                                                                                                                                                                   ^, EigenDecompositionImpl.java:1085: error: illegal start of expression
	 */ 	public double getDeterminant() { 		double determinant = 1; 		for (double lambda : realEigenvalues) { 			determinant *= lambda;} 		return determinant;} 	/**
	    	^, EigenDecompositionImpl.java:1085: error: ';' expected
	 */ 	public double getDeterminant() { 		double determinant = 1; 		for (double lambda : realEigenvalues) { 			determinant *= lambda;} 		return determinant;} 	/**
	    	                            ^, EigenDecompositionImpl.java:1087: error: illegal start of expression
	 */ 	public org.apache.commons.math.linear.DecompositionSolver getSolver() { 		if (eigenvectors == null) { 			findEigenVectors();} 		return new org.apache.commons.math.linear.EigenDecompositionImpl.Solver(realEigenvalues, imagEigenvalues, eigenvectors);} 	/**
	    	^, EigenDecompositionImpl.java:1087: error: ';' expected
	 */ 	public org.apache.commons.math.linear.DecompositionSolver getSolver() { 		if (eigenvectors == null) { 			findEigenVectors();} 		return new org.apache.commons.math.linear.EigenDecompositionImpl.Solver(realEigenvalues, imagEigenvalues, eigenvectors);} 	/**
	    	                                                                   ^, EigenDecompositionImpl.java:1089: error: illegal start of expression
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	^, EigenDecompositionImpl.java:1089: error: illegal start of expression
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	        ^, EigenDecompositionImpl.java:1089: error: ';' expected
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	              ^, EigenDecompositionImpl.java:1089: error: not a statement
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                     ^, EigenDecompositionImpl.java:1089: error: ';' expected
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                           ^, EigenDecompositionImpl.java:1089: error: not a statement
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                                                                     ^, EigenDecompositionImpl.java:1089: error: ';' expected
	 */ 	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver { 		/**
	    	                                                                                         ^, EigenDecompositionImpl.java:1091: error: illegal start of expression
		 */ 		private double[] realEigenvalues; 		/**
		    		^, EigenDecompositionImpl.java:1093: error: illegal start of expression
		 */ 		private double[] imagEigenvalues; 		/**
		    		^, EigenDecompositionImpl.java:1095: error: illegal start of expression
		 */ 		private final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors; 		/**
		    		^, EigenDecompositionImpl.java:1104: error: illegal start of expression
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		^, EigenDecompositionImpl.java:1104: error: illegal start of expression
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		               ^, EigenDecompositionImpl.java:1104: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                    ^, EigenDecompositionImpl.java:1104: error: illegal start of expression
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                           ^, EigenDecompositionImpl.java:1104: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                            ^, EigenDecompositionImpl.java:1104: error: not a statement
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                              ^, EigenDecompositionImpl.java:1104: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                                             ^, EigenDecompositionImpl.java:1104: error: <identifier> expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                                                                              ^, EigenDecompositionImpl.java:1104: error: ';' expected
		 */ 		private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) { 			this.realEigenvalues = realEigenvalues; 			this.imagEigenvalues = imagEigenvalues; 			this.eigenvectors = eigenvectors;} 		/**
		    		                                                                                                                                                  ^, EigenDecompositionImpl.java:1116: error: illegal start of expression
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		^, EigenDecompositionImpl.java:1116: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                     ^, EigenDecompositionImpl.java:1116: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                      ^, EigenDecompositionImpl.java:1116: error: not a statement
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                        ^, EigenDecompositionImpl.java:1116: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                                                 ^, EigenDecompositionImpl.java:1116: error: not a statement
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                                                                                 ^, EigenDecompositionImpl.java:1116: error: ';' expected
		 */ 		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.length != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return bp;} 		/**
		    		                                                                                                                                        ^, EigenDecompositionImpl.java:1128: error: illegal start of expression
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		^, EigenDecompositionImpl.java:1128: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                      ^, EigenDecompositionImpl.java:1128: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                        ^, EigenDecompositionImpl.java:1128: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                          ^, EigenDecompositionImpl.java:1128: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                                                   ^, EigenDecompositionImpl.java:1128: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                                                                                   ^, EigenDecompositionImpl.java:1128: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);} 			final double[] bp = new double[m]; 			for (int i = 0; i < m; ++i) { 				final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 				final double[] vData = v.getDataRef(); 				final double s = v.dotProduct(b) / realEigenvalues[i]; 				for (int j = 0; j < m; ++j) { 					bp[j] += s * vData[j];}} 			return new org.apache.commons.math.linear.ArrayRealVector(bp, false);} 		/**
		    		                                                                                                                                                                                                          ^, EigenDecompositionImpl.java:1140: error: illegal start of expression
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		^, EigenDecompositionImpl.java:1140: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                      ^, EigenDecompositionImpl.java:1140: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                        ^, EigenDecompositionImpl.java:1140: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                          ^, EigenDecompositionImpl.java:1140: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                                                   ^, EigenDecompositionImpl.java:1140: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                                                                                   ^, EigenDecompositionImpl.java:1140: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			if (b.getRowDimension() != m) { 				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");} 			final int nColB = b.getColumnDimension(); 			final double[][] bp = new double[m][nColB]; 			for (int k = 0; k < nColB; ++k) { 				for (int i = 0; i < m; ++i) { 					final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i]; 					final double[] vData = v.getDataRef(); 					double s = 0; 					for (int j = 0; j < m; ++j) { 						s += v.getEntry(j) * b.getEntry(j, k);} 					s /= realEigenvalues[i]; 					for (int j = 0; j < m; ++j) { 						bp[j][k] += s * vData[j];}}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);} 		/**
		    		                                                                                                                                                                                                          ^, EigenDecompositionImpl.java:1144: error: illegal start of expression
		 */ 		public boolean isNonSingular() { 			for (int i = 0; i < realEigenvalues.length; ++i) { 				if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) { 					return false;}} 			return true;} 		/**
		    		^, EigenDecompositionImpl.java:1144: error: ';' expected
		 */ 		public boolean isNonSingular() { 			for (int i = 0; i < realEigenvalues.length; ++i) { 				if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) { 					return false;}} 			return true;} 		/**
		    		                            ^, EigenDecompositionImpl.java:1150: error: illegal start of expression
		 */ 		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			final double[][] invData = new double[m][m]; 			for (int i = 0; i < m; ++i) { 				final double[] invI = invData[i]; 				for (int j = 0; j < m; ++j) { 					double invIJ = 0; 					for (int k = 0; k < m; ++k) { 						final double[] vK = eigenvectors[k].getDataRef(); 						invIJ += (vK[i] * vK[j]) / realEigenvalues[k];} 					invI[j] = invIJ;}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);}} 	/**
		    		^, EigenDecompositionImpl.java:1150: error: ';' expected
		 */ 		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			final double[][] invData = new double[m][m]; 			for (int i = 0; i < m; ++i) { 				final double[] invI = invData[i]; 				for (int j = 0; j < m; ++j) { 					double invIJ = 0; 					for (int k = 0; k < m; ++k) { 						final double[] vK = eigenvectors[k].getDataRef(); 						invIJ += (vK[i] * vK[j]) / realEigenvalues[k];} 					invI[j] = invIJ;}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);}} 	/**
		    		                                                           ^, EigenDecompositionImpl.java:1150: error: not a statement
		 */ 		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException { 			if (!isNonSingular()) { 				throw new org.apache.commons.math.linear.SingularMatrixException();} 			final int m = realEigenvalues.length; 			final double[][] invData = new double[m][m]; 			for (int i = 0; i < m; ++i) { 				final double[] invI = invData[i]; 				for (int j = 0; j < m; ++j) { 					double invIJ = 0; 					for (int k = 0; k < m; ++k) { 						final double[] vK = eigenvectors[k].getDataRef(); 						invIJ += (vK[i] * vK[j]) / realEigenvalues[k];} 					invI[j] = invIJ;}} 			return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);}} 	/**
		    		                                                                                                   ^]
Ingredient counter is Zero
---Undoing: gnrtn(175): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtAssignmentImpl) `work = new double[6 * main.length] ` -topatch--> `dMin = -0.0` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (349(f=1.0), 350(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (349(f=1.0), )
----------Running generation: 176, population size: 1

***** Generation 176 : 0
**Parent Variant: [Variant id: 351, #gens: 382, #ops: 0, parent:-]

--Child created id: 352
--Creating new operations for variant [Variant id: 352, #gens: 382, #ops: 0, parent:351]
---analyzing modificationPoint position: 247
location: EigenDecompositionImpl.java1438
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `// a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 352, #gens: 381, #ops: 1, parent:351] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 352
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-352/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(176): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `// a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (351(f=1.0), 352(f=1.0), )
Selected to next generation: IDs2--> (351(f=1.0), )
----------Running generation: 177, population size: 1

***** Generation 177 : 0
**Parent Variant: [Variant id: 353, #gens: 382, #ops: 0, parent:-]

--Child created id: 354
--Creating new operations for variant [Variant id: 354, #gens: 382, #ops: 0, parent:353]
---analyzing modificationPoint position: 164
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [qMax, work, pingPong]
--> var from patch: qMax spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1254
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[0] = java.lang.Math.abs(di) ` -topatch--> `qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]))` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1254, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[0] = java.lang.Math.abs(di) ` -topatch--> `qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]))` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 354, #gens: 382, #ops: 1, parent:353] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 354
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-354/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(177): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `work[0] = java.lang.Math.abs(di) ` -topatch--> `qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]))` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (353(f=1.0), 354(f=8.0), )
Selected to next generation: IDs2--> (353(f=1.0), )
----------Running generation: 178, population size: 1

***** Generation 178 : 0
**Parent Variant: [Variant id: 355, #gens: 382, #ops: 0, parent:-]

--Child created id: 356
--Creating new operations for variant [Variant id: 356, #gens: 382, #ops: 0, parent:355]
---analyzing modificationPoint position: 354
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  final int nRows = d.length
---analyzing modificationPoint position: 175
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  dMin1 = -work[(4 * start) + pingPong]
---analyzing modificationPoint position: 264
location: EigenDecompositionImpl.java1686
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `sigma = t ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 356, #gens: 381, #ops: 1, parent:355] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 356
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-356/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(178): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `sigma = t ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (355(f=1.0), 356(f=8.0), )
Selected to next generation: IDs2--> (355(f=1.0), )
----------Running generation: 179, population size: 1

***** Generation 179 : 0
**Parent Variant: [Variant id: 357, #gens: 382, #ops: 0, parent:-]

--Child created id: 358
--Creating new operations for variant [Variant id: 358, #gens: 382, #ops: 0, parent:357]
---analyzing modificationPoint position: 226
location: EigenDecompositionImpl.java1382
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (work[j4 - 2] == 0.0) { 	work[j4] = 0.0; 	dN1 = work[j4p2 + 2]; 	dMin = dN1; 	eMin = 0.0; } else [...] ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 358, #gens: 381, #ops: 1, parent:357] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 358
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-358/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(179): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtIfImpl) `if (work[j4 - 2] == 0.0) { 	work[j4] = 0.0; 	dN1 = work[j4p2 + 2]; 	dMin = dN1; 	eMin = 0.0; } else [...] ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (357(f=1.0), 358(f=8.0), )
Selected to next generation: IDs2--> (357(f=1.0), )
----------Running generation: 180, population size: 1

***** Generation 180 : 0
**Parent Variant: [Variant id: 359, #gens: 382, #ops: 0, parent:-]

--Child created id: 360
--Creating new operations for variant [Variant id: 360, #gens: 382, #ops: 0, parent:359]
---analyzing modificationPoint position: 4
Templates availables241
Attempts Base Ingredients  1 total 241
---modifPoint 0 not mutation generated in  tType = -9
---analyzing modificationPoint position: 77
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [dMin2, dMin]
--> var from patch: dMin2 spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java893
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// perform one step n0 = goodStep(i0, n0) ` -topatch--> `dMin2 = dMin` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 893, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// perform one step n0 = goodStep(i0, n0) ` -topatch--> `dMin2 = dMin` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 360, #gens: 382, #ops: 1, parent:359] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 360, errors: [EigenDecompositionImpl.java:1303: error: illegal start of expression
	 * Perform two iterations with Li's tests for initial splits.
	 ^, EigenDecompositionImpl.java:1303: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	          ^, EigenDecompositionImpl.java:1303: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                         ^, EigenDecompositionImpl.java:1303: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1303: error: not a statement
	 * Perform two iterations with Li's tests for initial splits.
	                                    ^, EigenDecompositionImpl.java:1303: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                         ^, EigenDecompositionImpl.java:1303: error: '(' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                             ^, EigenDecompositionImpl.java:1303: error: ';' expected
	 * Perform two iterations with Li's tests for initial splits.
	                                                            ^, EigenDecompositionImpl.java:1305: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1305: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1306: error: ';' expected
	 * 		number of rows of the matrix to process
	   		      ^, EigenDecompositionImpl.java:1306: error: not a statement
	 * 		number of rows of the matrix to process
	   		       ^, EigenDecompositionImpl.java:1306: error: ')' expected
	 * 		number of rows of the matrix to process
	   		         ^, EigenDecompositionImpl.java:1306: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                 ^, EigenDecompositionImpl.java:1306: error: variable declaration not allowed here
	 * 		number of rows of the matrix to process
	   		               ^, EigenDecompositionImpl.java:1306: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                            ^, EigenDecompositionImpl.java:1306: error: ';' expected
	 * 		number of rows of the matrix to process
	   		                                       ^, EigenDecompositionImpl.java:1307: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	^, EigenDecompositionImpl.java:1307: error: illegal start of expression
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	        ^, EigenDecompositionImpl.java:1307: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                          ^, EigenDecompositionImpl.java:1307: error: ';' expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                      ^, EigenDecompositionImpl.java:1308: error: illegal start of expression
	 * Perform one "good" dqd/dqds step.
	 ^, EigenDecompositionImpl.java:1308: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	          ^, EigenDecompositionImpl.java:1308: error: not a statement
	 * Perform one "good" dqd/dqds step.
	           ^, EigenDecompositionImpl.java:1308: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	              ^, EigenDecompositionImpl.java:1308: error: not a statement
	 * Perform one "good" dqd/dqds step.
	                         ^, EigenDecompositionImpl.java:1308: error: ';' expected
	 * Perform one "good" dqd/dqds step.
	                              ^, EigenDecompositionImpl.java:1308: error: <identifier> expected
	 * Perform one "good" dqd/dqds step.
	                                    ^, EigenDecompositionImpl.java:1309: error: illegal start of expression
	 * <p>This implementation is based on Beresford N. Parlett
	      ^, EigenDecompositionImpl.java:1309: error: not a statement
	 * <p>This implementation is based on Beresford N. Parlett
	 ^, EigenDecompositionImpl.java:1309: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                            ^, EigenDecompositionImpl.java:1309: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                     ^, EigenDecompositionImpl.java:1309: error: ';' expected
	 * <p>This implementation is based on Beresford N. Parlett
	                                                 ^, EigenDecompositionImpl.java:1310: error: not a statement
	 * and Osni A. Marques paper <a
	 ^, EigenDecompositionImpl.java:1310: error: ';' expected
	 * and Osni A. Marques paper <a
	      ^, EigenDecompositionImpl.java:1310: error: ';' expected
	 * and Osni A. Marques paper <a
	             ^, EigenDecompositionImpl.java:1310: error: ';' expected
	 * and Osni A. Marques paper <a
	                            ^, EigenDecompositionImpl.java:1311: error: > expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	 ^, EigenDecompositionImpl.java:1311: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	  ^, EigenDecompositionImpl.java:1311: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	       ^, EigenDecompositionImpl.java:1311: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	        ^, EigenDecompositionImpl.java:1311: error: illegal start of expression
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                           ^, EigenDecompositionImpl.java:1311: error: ';' expected
	 * href="http://www.netlib.org/lapack/lawnspdf/lawn155.pdf">An
	                                                              ^, EigenDecompositionImpl.java:1312: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                    ^, EigenDecompositionImpl.java:1312: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                             ^, EigenDecompositionImpl.java:1312: error: ')' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                 ^, EigenDecompositionImpl.java:1312: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                      ^, EigenDecompositionImpl.java:1312: error: illegal start of expression
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                        ^, EigenDecompositionImpl.java:1312: error: not a statement
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                          ^, EigenDecompositionImpl.java:1312: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                               ^, EigenDecompositionImpl.java:1312: error: ';' expected
	 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
	                                                                      ^, EigenDecompositionImpl.java:1313: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                       ^, EigenDecompositionImpl.java:1313: error: ';' expected
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                      ^, EigenDecompositionImpl.java:1313: error: illegal start of type
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                        ^, EigenDecompositionImpl.java:1313: error: illegal start of expression
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                         ^, EigenDecompositionImpl.java:1314: error: illegal start of expression
	 *
	 ^, EigenDecompositionImpl.java:1315: error: illegal start of expression
	 * @param start
	 ^, EigenDecompositionImpl.java:1315: error: illegal start of expression
	 * @param start
	   ^, EigenDecompositionImpl.java:1313: error: not a statement
	 * corresponding LAPACK routine DLAZQ3.</p>
	                                          ^, EigenDecompositionImpl.java:1316: error: ';' expected
	 * 		start index
	   		     ^, EigenDecompositionImpl.java:1317: error: illegal start of expression
	 * @param end
	   ^, EigenDecompositionImpl.java:1318: error: not a statement
	 * 		end index
	 ^, EigenDecompositionImpl.java:1318: error: ';' expected
	 * 		end index
	   		   ^, EigenDecompositionImpl.java:1319: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1319: error: not a statement
	 * @return new end (maybe deflated)
	 ^, EigenDecompositionImpl.java:1319: error: ';' expected
	 * @return new end (maybe deflated)
	              ^, EigenDecompositionImpl.java:1319: error: -> expected
	 * @return new end (maybe deflated)
	                                   ^, EigenDecompositionImpl.java:1320: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	 ^, EigenDecompositionImpl.java:1320: error: illegal start of expression
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	^, EigenDecompositionImpl.java:1319: error: not a statement
	 * @return new end (maybe deflated)
	                   ^, EigenDecompositionImpl.java:1320: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                    ^, EigenDecompositionImpl.java:1320: error: <identifier> expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                     ^, EigenDecompositionImpl.java:1320: error: ';' expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                                   ^, EigenDecompositionImpl.java:1327: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1327: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1327: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1327: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1327: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1329: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1329: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1330: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1330: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1330: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1330: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1331: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1332: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1332: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1332: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1332: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1332: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1332: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1332: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1332: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1333: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1333: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1333: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1333: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1333: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1333: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1333: error: ';' expected
	 * 		only every other element)
	   		                        ^]
Ingredient counter is Zero
---Undoing: gnrtn(180): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `// perform one step n0 = goodStep(i0, n0) ` -topatch--> `dMin2 = dMin` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (359(f=1.0), 360(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (359(f=1.0), )
----------Running generation: 181, population size: 1

***** Generation 181 : 0
**Parent Variant: [Variant id: 361, #gens: 382, #ops: 0, parent:-]

--Child created id: 362
--Creating new operations for variant [Variant id: 362, #gens: 382, #ops: 0, parent:361]
---analyzing modificationPoint position: 374
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  java.lang.System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols)
---analyzing modificationPoint position: 123
Templates availables156
Attempts Base Ingredients  1 total 156
vars from patch []
location: EigenDecompositionImpl.java1159
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double lower = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `double z = 1` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1159, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double lower = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `double z = 1` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 362, #gens: 382, #ops: 1, parent:361] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 362, errors: [EigenDecompositionImpl.java:1763: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			^, EigenDecompositionImpl.java:1763: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                    ^, EigenDecompositionImpl.java:1763: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                     ^, EigenDecompositionImpl.java:1763: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                           ^, EigenDecompositionImpl.java:1763: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                     ^, EigenDecompositionImpl.java:1763: error: illegal start of type
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                 ^, EigenDecompositionImpl.java:1763: error: ';' expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                     ^, EigenDecompositionImpl.java:1763: error: <identifier> expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				    ^, EigenDecompositionImpl.java:1763: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		// search upper eigenvalue 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				// search has converged
				        			                                            			                                               				                        				               ^, EigenDecompositionImpl.java:1764: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				^, EigenDecompositionImpl.java:1764: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				      ^, EigenDecompositionImpl.java:1764: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			      ^, EigenDecompositionImpl.java:1764: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			^, EigenDecompositionImpl.java:1764: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				               ^, EigenDecompositionImpl.java:1764: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				              ^, EigenDecompositionImpl.java:1764: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		^, EigenDecompositionImpl.java:1764: error: class, interface, or enum expected
				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	/**
				        			                                            			                                               				                        				                 		                                                                                                                                 		                                    ^, EigenDecompositionImpl.java:1774: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                   ^, EigenDecompositionImpl.java:1774: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                   ^, EigenDecompositionImpl.java:1774: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                    ^, EigenDecompositionImpl.java:1774: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		^, EigenDecompositionImpl.java:1774: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		^, EigenDecompositionImpl.java:1774: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                ^, EigenDecompositionImpl.java:1774: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                       ^, EigenDecompositionImpl.java:1774: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			^, EigenDecompositionImpl.java:1774: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				        ^, EigenDecompositionImpl.java:1774: error: class, interface, or enum expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	/**
	    	                                                                             		                                		                                 		                              			                                                                             			                  				           		             ^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                          ^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                           ^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                ^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                       ^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			      ^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			      ^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			      ^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			^, EigenDecompositionImpl.java:1788: error: class, interface, or enum expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	/**
	    	                                                                                    		                                  		                                  		                              			                         			                                                			                                			                                                            			                                                  			                                     ^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                        ^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                         ^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                               ^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                      ^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				      ^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                          ^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                               ^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                      ^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				      ^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				^, EigenDecompositionImpl.java:1796: error: class, interface, or enum expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		// unroll last two steps. 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                    		                                           		                                               		          		                                       		                     			                                                                 				                                 				                                                				                     				                                    				                               				                                                    			                                                                 				                             				                                                				                     				                                    				                               				                                              ^, EigenDecompositionImpl.java:1800: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1802: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                       ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                        ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                               ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                     ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					           ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                          ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                               ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                     ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					           ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					      ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					         ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                 ^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				^, EigenDecompositionImpl.java:1804: error: class, interface, or enum expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) { 					final double tmp = work[j4 + 1] / work[j4 - 2]; 					work[j4] = work[j4 - 1] * tmp; 					d *= tmp;} else { 					work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); 					d *= work[j4 + 1] / work[j4 - 2];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4]);}} else { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				if (work[j4 - 3] == 0.0) { 					work[j4 - 1] = 0.0; 					d = work[j4 + 2]; 					dMin = d; 					eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) { 					final double tmp = work[j4 + 2] / work[j4 - 3]; 					work[j4 - 1] = work[j4] * tmp; 					d *= tmp;} else { 					work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); 					d *= work[j4 + 2] / work[j4 - 3];} 				dMin = java.lang.Math.min(dMin, d); 				eMin = java.lang.Math.min(eMin, work[j4 - 1]);}} 		// Unroll last two steps 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN1 = work[j4p2 + 2]; 			dMin = dN1; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN1 = dN2 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		if (work[j4 - 2] == 0.0) { 			work[j4] = 0.0; 			dN = work[j4p2 + 2]; 			dMin = dN; 			eMin = 0.0;} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) { 			final double tmp = work[j4p2 + 2] / work[j4 - 2]; 			work[j4] = work[j4p2] * tmp; 			dN = dN1 * tmp;} else { 			work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 			dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);} 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	/**
	    	                                                   		                                           		                                         		          		                     			                                                                				                                 				                           					                					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                                    			                                                                				                             				                           					                    					                  					          					                                                                                                                                                                                                					                                                					                               					                  					                                                         					                                   				                                    				                                              ^]
Ingredient counter is Zero
---Undoing: gnrtn(181): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtLocalVariableImpl) `double lower = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `double z = 1` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (361(f=1.0), 362(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (361(f=1.0), )
----------Running generation: 182, population size: 1

***** Generation 182 : 0
**Parent Variant: [Variant id: 363, #gens: 382, #ops: 0, parent:-]

--Child created id: 364
--Creating new operations for variant [Variant id: 364, #gens: 382, #ops: 0, parent:363]
---analyzing modificationPoint position: 357
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 0 not mutation generated in  if (nCols == 0) { 	throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException[...]
---analyzing modificationPoint position: 292
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [dMin]
--> var from patch: dMin spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java574
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `dMin = -0.0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 574, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `dMin = -0.0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 364, #gens: 382, #ops: 1, parent:363] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child does NOT compile: 364, errors: [EigenDecompositionImpl.java:1069: error: <identifier> expected
					if (chooseLeft) { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda + work[4 * i];}} else { 						for (int i = 0; i < n; ++i) { 							realEigenvalues[begin + i] = lambda - work[4 * i];}}} 			begin = end;} 		// sort the realEigenvalues in decreasing order 		java.util.Arrays.sort(realEigenvalues); 		int j = realEigenvalues.length - 1; 		for (int i = 0; i < j; ++i) { 			final double tmp = realEigenvalues[i]; 			realEigenvalues[i] = realEigenvalues[j]; 			realEigenvalues[j] = tmp; 			--j;}} 	/**
					                  						                              							                                                            						                              							                                                      			     ^, EigenDecompositionImpl.java:1070: error: class, interface, or enum expected
	 * Compute splitting points.
	 ^, EigenDecompositionImpl.java:1072: error: <identifier> expected
	 * @return list of indices after matrix can be split
	    ^, EigenDecompositionImpl.java:1072: error: class, interface, or enum expected
	 * @return list of indices after matrix can be split
	           ^, EigenDecompositionImpl.java:1073: error: class, interface, or enum expected
	 */ 	private java.util.List<java.lang.Integer> computeSplits() { 		final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>(); 		// splitting preserving relative accuracy 		double absDCurrent = java.lang.Math.abs(main[0]); 		for (int i = 0; i < secondary.length; ++i) { 			final double absDPrevious = absDCurrent; 			absDCurrent = java.lang.Math.abs(main[i + 1]); 			final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent); 			if (java.lang.Math.abs(secondary[i]) <= max) { 				list.add(i + 1); 				secondary[i] = 0; 				squaredSecondary[i] = 0;}} 		list.add(secondary.length + 1); 		return list;} 	/**
	    	                                                            		      ^, EigenDecompositionImpl.java:1074: error: class, interface, or enum expected
	 * Find eigenvalue in a block with 1 row.
	 ^, EigenDecompositionImpl.java:1077: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1079: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                    ^, EigenDecompositionImpl.java:1079: error: class, interface, or enum expected
	 */ 	private void process1RowBlock(final int index) { 		realEigenvalues[index] = main[index];} 	/**
	    	                                                 		                                     ^, EigenDecompositionImpl.java:1087: error: class, interface, or enum expected
	 */ 	private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^2 - (q0 + q1) X + q0 q1 - e1^2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double e12 = squaredSecondary[index]; 		final double s = q0 + q1; 		final double p = (q0 * q1) - e12; 		final double delta = (s * s) - (4 * p); 		if (delta < 0) { 			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 2);} 		final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta)); 		realEigenvalues[index] = largestRoot; 		realEigenvalues[index + 1] = p / largestRoot;} 	/**
	    	                                     ^, EigenDecompositionImpl.java:1091: error: class, interface, or enum expected
	 * @param index
	          ^, EigenDecompositionImpl.java:1093: error: class, interface, or enum expected
	 * @exception InvalidMatrixException
	              ^, EigenDecompositionImpl.java:1095: error: class, interface, or enum expected
	 */ 	private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException { 		// the characteristic polynomial is 		// X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2 		final double q0 = main[index]; 		final double q1 = main[index + 1]; 		final double q2 = main[index + 2]; 		final double e12 = squaredSecondary[index]; 		final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1]; 		// compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0 		final double b = -((q0 + q1) + q2); 		final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12; 		final double d = (q2 * e12) - (q0 * q1q2Me22); 		// solve cubic equation 		final double b2 = b * b; 		final double q = ((3 * c) - b2) / 9; 		final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54; 		final double delta = ((q * q) * q) + (r * r); 		if (delta >= 0) { 			// in fact, there are solutions to the equation, but in the context 			// of symmetric realEigenvalues problem, there should be three distinct 			// real roots, so we throw an error if this condition is not met
	    	                                     ^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                       ^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		      ^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		      ^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		      ^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		      ^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			      ^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			       ^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			      ^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			       ^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		^, EigenDecompositionImpl.java:1096: error: class, interface, or enum expected
			throw new org.apache.commons.math.linear.InvalidMatrixException("cannot solve degree {0} equation", 3);} 		final double sqrtMq = java.lang.Math.sqrt(-q); 		final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq)); 		final double alpha = 2 * sqrtMq; 		final double beta = b / 3; 		double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta; 		double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta; 		double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta; 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		if (z1 < z2) { 			final double t = z1; 			z1 = z2; 			z2 = t;} 		if (z0 < z1) { 			final double t = z0; 			z0 = z1; 			z1 = t;} 		realEigenvalues[index] = z0; 		realEigenvalues[index + 1] = z1; 		realEigenvalues[index + 2] = z2;} 	/**
			                                                                                                         		                                               		                                                               		                                 		                           		                                                            		                                                                                        		                                                                                        		               			                     			         			         		               			                     			         			         		               			                     			         			         		                             		                                 		                                ^, EigenDecompositionImpl.java:1109: error: class, interface, or enum expected
	 */ 	private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException { 		// check decomposed matrix data range 		double sumOffDiag = 0; 		for (int i = 0; i < (n - 1); ++i) { 			final int fourI = 4 * i; 			final double ei = work[fourI + 2]; 			sumOffDiag += ei;} 		if (sumOffDiag == 0) { 			// matrix is already diagonal
	    	                                       ^, EigenDecompositionImpl.java:1110: error: class, interface, or enum expected
			return;} 		// initial checks for splits (see Parlett & Marques section 3.3) 		flipIfWarranted(n, 2); 		// two iterations with Li's test for initial splits 		initialSplits(n); 		// initialize parameters used by goodStep 		tType = 0; 		dMin1 = 0; 		dMin2 = 0; 		dN = 0; 		dN1 = 0; 		dN2 = 0; 		tau = 0; 		// process split segments 		int i0 = 0; 		int n0 = n; 		while (n0 > 0) { 			// retrieve shift that was temporarily stored as a negative off-diagonal element 			sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2]; 			sigmaLow = 0; 			// find start of a new split segment to process 			double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6]; 			double offDiagMax = 0; 			double diagMax = work[(4 * n0) - 4]; 			double diagMin = diagMax; 			i0 = 0; 			for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { 				if (work[i + 2] <= 0) { 					i0 = 1 + (i / 4); 					break;} 				if (diagMin >= (4 * offDiagMax)) { 					diagMin = java.lang.Math.min(diagMin, work[i + 4]); 					offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);} 				diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]); 				offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);} 			work[(4 * n0) - 2] = offDiagMin; 			// lower bound of Gershgorin disk 			dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax))); 			pingPong = 0; 			int maxIter = 30 * (n0 - i0); 			for (int k = 0; i0 < n0; ++k) { 				if (k >= maxIter) { 					throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));} 				// perform one step 				n0 = goodStep(i0, n0); 				pingPong = 1 - pingPong; 				// check for new splits after "ping" steps 				// when the last elements of qd array are very small
			       ^, EigenDecompositionImpl.java:1111: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					^, EigenDecompositionImpl.java:1111: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					^, EigenDecompositionImpl.java:1111: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					^, EigenDecompositionImpl.java:1111: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					^, EigenDecompositionImpl.java:1111: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					                     ^, EigenDecompositionImpl.java:1111: error: class, interface, or enum expected
				if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 					int split = i0 - 1; 					diagMax = work[4 * i0]; 					offDiagMin = work[(4 * i0) + 2]; 					double previousEMin = work[(4 * i0) + 3]; 					for (int i = 4 * i0; i < ((4 * n0) - 11); i += 4) { 						if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) && (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) { 							// insert a split 							work[i + 2] = -sigma; 							split = i / 4; 							diagMax = 0; 							offDiagMin = work[i + 6]; 							previousEMin = work[i + 7];} else { 							diagMax = java.lang.Math.max(diagMax, work[i + 4]); 							offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]); 							previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);}} 					work[(4 * n0) - 2] = offDiagMin; 					work[(4 * n0) - 1] = previousEMin; 					i0 = split + 1;}}} } 	/**
				                                                                                                                                                                                                                                                              					                    					                        					                                 					                                          					                                          ^, EigenDecompositionImpl.java:1112: error: unclosed character literal
	 * Perform two iterations with Li's tests for initial splits.
	                                 ^, EigenDecompositionImpl.java:1114: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1116: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                 ^, EigenDecompositionImpl.java:1116: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		^, EigenDecompositionImpl.java:1116: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		                ^, EigenDecompositionImpl.java:1116: error: class, interface, or enum expected
	 */ 	private void initialSplits(final int n) { 		pingPong = 0; 		for (int k = 0; k < 2; ++k) { 			// apply Li's reverse test 			double d = work[(4 * (n - 1)) + pingPong]; 			for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) { 				if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i + 2] = -0.0; 					d = work[i];} else { 					d *= work[i] / (d + work[i + 2]);}} 			// apply dqd plus Li's forward test. 			d = work[pingPong]; 			for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) { 				final int j = (i - (2 * pingPong)) - 1; 				work[j] = d + work[i]; 				if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) { 					work[i] = -0.0; 					work[j] = d; 					work[j + 2] = 0.0; 					d = work[i + 2];} else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) { 					final double tmp = work[i + 2] / work[j]; 					work[j + 2] = work[i] * tmp; 					d *= tmp;} else { 					work[j + 2] = work[i + 2] * (work[i] / work[j]); 					d *= work[i + 2] / work[j];}} 			work[((4 * n) - 3) - pingPong] = d; 			// from ping to pong 			pingPong = 1 - pingPong;}} 	/**
	    	                                          		              		                       ^, EigenDecompositionImpl.java:1124: error: class, interface, or enum expected
	 * @param start
	          ^, EigenDecompositionImpl.java:1126: error: class, interface, or enum expected
	 * @param end
	          ^, EigenDecompositionImpl.java:1128: error: <identifier> expected
	 * @return new end (maybe deflated)
	    ^, EigenDecompositionImpl.java:1128: error: class, interface, or enum expected
	 * @return new end (maybe deflated)
	           ^, EigenDecompositionImpl.java:1128: error: class, interface, or enum expected
	 * @return new end (maybe deflated)
	               ^, EigenDecompositionImpl.java:1129: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                           ^, EigenDecompositionImpl.java:1129: error: class, interface, or enum expected
	 */ 	private int goodStep(final int start, final int end) { 		g = 0.0; 		// step 1: accepting realEigenvalues 		int deflatedEnd = end; 		for (boolean deflating = true; deflating;) { 			if (start >= deflatedEnd) { 				// the array has been completely deflated
	    	                                            ^, EigenDecompositionImpl.java:1130: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				^, EigenDecompositionImpl.java:1130: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                   ^, EigenDecompositionImpl.java:1130: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                     			      ^, EigenDecompositionImpl.java:1130: error: class, interface, or enum expected
				return deflatedEnd;} 			final int k = ((4 * deflatedEnd) + pingPong) - 1; 			if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) { 				// one eigenvalue found, deflate array 				work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong]; 				deflatedEnd -= 1;} else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) { 				// two realEigenvalues found, deflate array
				                     			                                                  			^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					      ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                  ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                               ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                         ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                ^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				                                                   				^, EigenDecompositionImpl.java:1131: error: class, interface, or enum expected
				if (work[k - 3] > work[k - 7]) { 					final double tmp = work[k - 3]; 					work[k - 3] = work[k - 7]; 					work[k - 7] = tmp;} 				if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) { 					double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]); 					double s = work[k - 3] * (work[k - 5] / t); 					if (s <= t) { 						s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));} else { 						s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));} 					t = work[k - 7] + (s + work[k - 5]); 					work[k - 3] *= work[k - 7] / t; 					work[k - 7] = t;} 				work[(4 * deflatedEnd) - 8] = sigma + work[k - 7]; 				work[(4 * deflatedEnd) - 4] = sigma + work[k - 3]; 				deflatedEnd -= 2;} else { 				// no more realEigenvalues found, we need to iterate 				deflating = false;}} 		final int l = ((4 * deflatedEnd) + pingPong) - 1; 		// step 2: flip array if needed
				                                 					                                					                           					                    				                                                                                                       					                                                              					                                            					              						                                                                                        						                                                                           					                                     					                                					                  				                                                   				                                                   				                 ^, EigenDecompositionImpl.java:1132: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				^, EigenDecompositionImpl.java:1132: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				^, EigenDecompositionImpl.java:1132: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				^, EigenDecompositionImpl.java:1132: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				                                                                                             				^, EigenDecompositionImpl.java:1132: error: class, interface, or enum expected
		if ((dMin <= 0) || (deflatedEnd < end)) { 			if (flipIfWarranted(deflatedEnd, 1)) { 				dMin2 = java.lang.Math.min(dMin2, work[l - 1]); 				work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong])); 				work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong])); 				qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong])); 				dMin = -0.0;}} 		if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) { 			// step 3: choose a shift 			computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); 			// step 4a: dqds
		                                          			                                       				                                                				                                                                                                           				                                                                                                                                     				                                                                                             				            ^, EigenDecompositionImpl.java:1133: error: class, interface, or enum expected
			for (boolean loop = true; loop;) { 				// perform one dqds step with the chosen shift 				dqds(start, deflatedEnd); 				// check result of the dqds step
			                          ^, EigenDecompositionImpl.java:1133: error: class, interface, or enum expected
			for (boolean loop = true; loop;) { 				// perform one dqds step with the chosen shift 				dqds(start, deflatedEnd); 				// check result of the dqds step
			                               ^, EigenDecompositionImpl.java:1138: error: class, interface, or enum expected
	 * @param n
	          ^, EigenDecompositionImpl.java:1140: error: class, interface, or enum expected
	 * @param step
	          ^, EigenDecompositionImpl.java:1143: error: <identifier> expected
	 * @return true if qd array was flipped
	    ^, EigenDecompositionImpl.java:1143: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	           ^, EigenDecompositionImpl.java:1143: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	                ^, EigenDecompositionImpl.java:1143: error: class, interface, or enum expected
	 * @return true if qd array was flipped
	                   ^, EigenDecompositionImpl.java:1144: error: class, interface, or enum expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;
	    	                                      ^, EigenDecompositionImpl.java:1144: error: class, interface, or enum expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;
	    	                                                   ^, EigenDecompositionImpl.java:1147: error: class, interface, or enum expected
	}
	^, EigenDecompositionImpl.java:1157: error: class, interface, or enum expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                        ^, EigenDecompositionImpl.java:1157: error: class, interface, or enum expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block
	    	                                                         ^, EigenDecompositionImpl.java:1158: error: class, interface, or enum expected
		final int lowerStart = 4 * main.length;
		      ^, EigenDecompositionImpl.java:1159: error: class, interface, or enum expected
		final int upperStart = 5 * main.length;
		      ^, EigenDecompositionImpl.java:1160: error: class, interface, or enum expected
		double lower = java.lang.Double.POSITIVE_INFINITY;
		^, EigenDecompositionImpl.java:1161: error: class, interface, or enum expected
		double upper = java.lang.Double.NEGATIVE_INFINITY;
		^, EigenDecompositionImpl.java:1162: error: class, interface, or enum expected
		for (int i = 0; i < n; ++i) {
		^, EigenDecompositionImpl.java:1162: error: class, interface, or enum expected
		for (int i = 0; i < n; ++i) {
		                ^]
Ingredient counter is Zero
---Undoing: gnrtn(182): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `lowerSpectra = java.lang.Double.POSITIVE_INFINITY ` -topatch--> `dMin = -0.0` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (363(f=1.0), 364(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (363(f=1.0), )
----------Running generation: 183, population size: 1

***** Generation 183 : 0
**Parent Variant: [Variant id: 365, #gens: 382, #ops: 0, parent:-]

--Child created id: 366
--Creating new operations for variant [Variant id: 366, #gens: 382, #ops: 0, parent:365]
---analyzing modificationPoint position: 222
location: EigenDecompositionImpl.java1378
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = dMin ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 366, #gens: 381, #ops: 1, parent:365] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 366
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-366/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(183): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = dMin ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (365(f=1.0), 366(f=1.0), )
Selected to next generation: IDs2--> (365(f=1.0), )
----------Running generation: 184, population size: 1

***** Generation 184 : 0
**Parent Variant: [Variant id: 367, #gens: 382, #ops: 0, parent:-]

--Child created id: 368
--Creating new operations for variant [Variant id: 368, #gens: 382, #ops: 0, parent:367]
---analyzing modificationPoint position: 22
location: EigenDecompositionImpl.java1474
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// case 4. tType = -4 ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 368, #gens: 381, #ops: 1, parent:367] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 368
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-368/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(184): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtAssignmentImpl) `// case 4. tType = -4 ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (367(f=1.0), 368(f=1.0), )
Selected to next generation: IDs2--> (367(f=1.0), )
----------Running generation: 185, population size: 1

***** Generation 185 : 0
**Parent Variant: [Variant id: 369, #gens: 382, #ops: 0, parent:-]

--Child created id: 370
--Creating new operations for variant [Variant id: 370, #gens: 382, #ops: 0, parent:369]
---analyzing modificationPoint position: 348
Templates availables16
Attempts Base Ingredients  1 total 16
---modifPoint 0 not mutation generated in  return new org.apache.commons.math.linear.Array2DRowRealMatrix(rowDimension, columnDimension)
---analyzing modificationPoint position: 117
location: EigenDecompositionImpl.java1118
operation: OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `// perform a dqd step (i.e. no shift) dqd(start, deflatedEnd) ` -topatch--> `-` (null) 

--Summary Creation: for variant [Variant id: 370, #gens: 381, #ops: 1, parent:369] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 370
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-370/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 9, was successful: false, cases executed: 17] ,[]
-Valid?: |false|9|17|[]|, fitness 9.0
Ingredient counter is Zero
---Undoing: gnrtn(185): OP_INSTANCE:
RemoveOp:(spoon.support.reflect.code.CtInvocationImpl) `// perform a dqd step (i.e. no shift) dqd(start, deflatedEnd) ` -topatch--> `-` (null) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (369(f=1.0), 370(f=9.0), )
Selected to next generation: IDs2--> (369(f=1.0), )
----------Running generation: 186, population size: 1

***** Generation 186 : 0
**Parent Variant: [Variant id: 371, #gens: 382, #ops: 0, parent:-]

--Child created id: 372
--Creating new operations for variant [Variant id: 372, #gens: 382, #ops: 0, parent:371]
---analyzing modificationPoint position: 236
Templates availables78
Attempts Base Ingredients  1 total 78
vars from patch [work, j4, dN, j4p2, dMin, eMin, org.apache.commons.math.util.MathUtils.SAFE_MIN, tmp, dN1]
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: j4 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: dN spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: j4p2 spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: dMin spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: eMin spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: org.apache.commons.math.util.MathUtils.SAFE_MIN spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: tmp spoon.support.reflect.code.CtVariableReadImpl
--> var from patch: dN1 spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1402
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (work[j4 - 2] == 0.0) { 	work[j4] = 0.0; 	dN = work[j4p2 + 2]; 	dMin = dN; 	eMin = 0.0; } else if[...] ` -topatch--> `if (work[j4 - 2] == 0.0) { 	work[j4] = 0.0; 	dN = work[j4p2 + 2]; 	dMin = dN; 	eMin = 0.0; } else if[...]` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1402, pointed element: CtIfImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (work[j4 - 2] == 0.0) { 	work[j4] = 0.0; 	dN = work[j4p2 + 2]; 	dMin = dN; 	eMin = 0.0; } else if[...] ` -topatch--> `if (work[j4 - 2] == 0.0) { 	work[j4] = 0.0; 	dN = work[j4p2 + 2]; 	dMin = dN; 	eMin = 0.0; } else if[...]` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 372, #gens: 382, #ops: 1, parent:371] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 372
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-372/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(186): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (work[j4 - 2] == 0.0) { 	work[j4] = 0.0; 	dN = work[j4p2 + 2]; 	dMin = dN; 	eMin = 0.0; } else if[...] ` -topatch--> `if (work[j4 - 2] == 0.0) { 	work[j4] = 0.0; 	dN = work[j4p2 + 2]; 	dMin = dN; 	eMin = 0.0; } else if[...]` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (371(f=1.0), 372(f=1.0), )
Selected to next generation: IDs2--> (371(f=1.0), )
----------Running generation: 187, population size: 1

***** Generation 187 : 0
**Parent Variant: [Variant id: 373, #gens: 382, #ops: 0, parent:-]

--Child created id: 374
--Creating new operations for variant [Variant id: 374, #gens: 382, #ops: 0, parent:373]
---analyzing modificationPoint position: 188
Templates availables595
Attempts Base Ingredients  1 total 595
Name Conflict [work, pingPong, n, step]
---modifPoint 0 not mutation generated in  dMin = java.lang.Math.min(dMin, d)
---analyzing modificationPoint position: 341
Templates availables120
Attempts Base Ingredients  1 total 120
---modifPoint 1 not mutation generated in  for (int i = 0; i < rows; ++i) { 	final double[] rowI = data[i]; 	for (int j = 0; j < columns; ++j) [...]
---analyzing modificationPoint position: 24
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [tau, dMin, org.apache.commons.math.util.MathUtils.EPSILON]
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: org.apache.commons.math.util.MathUtils.EPSILON spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1478
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if (dMin == dN) { 	gam = dN; 	a2 = 0.0; 	if (work[nn - 5] > work[nn - 7]) { 		return; 	} 	b2 = work[[...] ` -topatch--> `// late failure. Gives excellent shift. tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.u[...]` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1478, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if (dMin == dN) { 	gam = dN; 	a2 = 0.0; 	if (work[nn - 5] > work[nn - 7]) { 		return; 	} 	b2 = work[[...] ` -topatch--> `// late failure. Gives excellent shift. tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.u[...]` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 374, #gens: 383, #ops: 1, parent:373] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 374
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-374/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(187): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtIfImpl) `if (dMin == dN) { 	gam = dN; 	a2 = 0.0; 	if (work[nn - 5] > work[nn - 7]) { 		return; 	} 	b2 = work[[...] ` -topatch--> `// late failure. Gives excellent shift. tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.u[...]` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (373(f=1.0), 374(f=1.0), )
Selected to next generation: IDs2--> (373(f=1.0), )
----------Running generation: 188, population size: 1

***** Generation 188 : 0
**Parent Variant: [Variant id: 375, #gens: 382, #ops: 0, parent:-]

--Child created id: 376
--Creating new operations for variant [Variant id: 376, #gens: 382, #ops: 0, parent:375]
---analyzing modificationPoint position: 65
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  if (work[i + 2] <= 0) { 	i0 = 1 + (i / 4); 	break; }
---analyzing modificationPoint position: 222
Templates availables241
Attempts Base Ingredients  1 total 241
vars from patch [qMax, work, pingPong]
--> var from patch: qMax spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: work spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: pingPong spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1378
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = dMin ` -topatch--> `qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]))` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1378, pointed element: CtAssignmentImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = dMin ` -topatch--> `qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]))` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 376, #gens: 382, #ops: 1, parent:375] gen mutated: 1 , gen not mut: 1, gen not applied  0
-The child compiles: id 376
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-376/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 1, was successful: false, cases executed: 17] ,[]
-Valid?: |false|1|17|[]|, fitness 1.0
Ingredient counter is Zero
---Undoing: gnrtn(188): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtAssignmentImpl) `dMin2 = dMin ` -topatch--> `qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]))` (spoon.support.reflect.code.CtAssignmentImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (375(f=1.0), 376(f=1.0), )
Selected to next generation: IDs2--> (375(f=1.0), )
----------Running generation: 189, population size: 1

***** Generation 189 : 0
**Parent Variant: [Variant id: 377, #gens: 382, #ops: 0, parent:-]

--Child created id: 378
--Creating new operations for variant [Variant id: 378, #gens: 382, #ops: 0, parent:377]
---analyzing modificationPoint position: 45
Templates availables19
Attempts Base Ingredients  1 total 19
vars from patch []
location: EigenDecompositionImpl.java839
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `// initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2) ` -topatch--> `findEigenVectors()` (spoon.support.reflect.code.CtInvocationImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 839, pointed element: CtInvocationImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `// initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2) ` -topatch--> `findEigenVectors()` (spoon.support.reflect.code.CtInvocationImpl) 

--Summary Creation: for variant [Variant id: 378, #gens: 382, #ops: 1, parent:377] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 378
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-378/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(189): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtInvocationImpl) `// initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2) ` -topatch--> `findEigenVectors()` (spoon.support.reflect.code.CtInvocationImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (377(f=1.0), 378(f=8.0), )
Selected to next generation: IDs2--> (377(f=1.0), )
----------Running generation: 190, population size: 1

***** Generation 190 : 0
**Parent Variant: [Variant id: 379, #gens: 382, #ops: 0, parent:-]

--Child created id: 380
--Creating new operations for variant [Variant id: 380, #gens: 382, #ops: 0, parent:379]
---analyzing modificationPoint position: 16
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 0 not mutation generated in  if ((((dMin < 0.0) &&  (dMin1 > 0.0)) &&  (work[((4 * deflatedEnd) - 5) - pingPong] < (org.apache.co[...]
---analyzing modificationPoint position: 372
Templates availables31
Attempts Base Ingredients  1 total 31
---modifPoint 1 not mutation generated in  for (int i = 0; i < data.length; ++i) { 	if (subMatrix[i].length != nCols) { 		throw org.apache.comm[...]
---analyzing modificationPoint position: 254
---modifPoint 2 not mutation generated in  // cases 2 and 3. final double gap2 = (dMin2 - a2) - (dMin2 * 0.25)
---analyzing modificationPoint position: 311
Templates availables156
Attempts Base Ingredients  1 total 156
---modifPoint 3 not mutation generated in  final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>()
---analyzing modificationPoint position: 159
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 4 not mutation generated in  ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t
---analyzing modificationPoint position: 108
Templates availables78
Attempts Base Ingredients  1 total 78
---modifPoint 5 not mutation generated in  // step 2: flip array if needed if ((dMin <= 0) || (deflatedEnd < end)) { 	if (flipIfWarranted(defla[...]
---analyzing modificationPoint position: 172
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 6 not mutation generated in  eMin = work[((4 * start) + pingPong) + 4]
---analyzing modificationPoint position: 273
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 7 not mutation generated in  final double lower = dCurrent - radius
---analyzing modificationPoint position: 291
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 8 not mutation generated in  final int upperStart = 5 * m
---analyzing modificationPoint position: 112
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [java.lang.Double.NEGATIVE_INFINITY]
--> var from patch: java.lang.Double.NEGATIVE_INFINITY spoon.support.reflect.code.CtFieldReadImpl
location: EigenDecompositionImpl.java1074
operation: OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `// step 4a: dqds for (boolean loop = true; loop;) {  	// perform one dqds step with the chosen shift[...] ` -topatch--> `double upper = java.lang.Double.NEGATIVE_INFINITY` (spoon.support.reflect.code.CtLocalVariableImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1074, pointed element: CtLocalVariableImpl
---OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `// step 4a: dqds for (boolean loop = true; loop;) {  	// perform one dqds step with the chosen shift[...] ` -topatch--> `double upper = java.lang.Double.NEGATIVE_INFINITY` (spoon.support.reflect.code.CtLocalVariableImpl) 

--Summary Creation: for variant [Variant id: 380, #gens: 383, #ops: 1, parent:379] gen mutated: 1 , gen not mut: 9, gen not applied  0
-The child does NOT compile: 380, errors: [EigenDecompositionImpl.java:1162: error: illegal start of expression
	 * Flip qd array if warranted.
	 ^, EigenDecompositionImpl.java:1162: error: ';' expected
	 * Flip qd array if warranted.
	       ^, EigenDecompositionImpl.java:1162: error: ';' expected
	 * Flip qd array if warranted.
	                ^, EigenDecompositionImpl.java:1162: error: '(' expected
	 * Flip qd array if warranted.
	                   ^, EigenDecompositionImpl.java:1162: error: <identifier> expected
	 * Flip qd array if warranted.
	                              ^, EigenDecompositionImpl.java:1164: error: illegal start of expression
	 * @param n
	 ^, EigenDecompositionImpl.java:1164: error: illegal start of expression
	 * @param n
	   ^, EigenDecompositionImpl.java:1165: error: ')' expected
	 * 		number of rows in the block
	   		      ^, EigenDecompositionImpl.java:1165: error: ';' expected
	 * 		number of rows in the block
	   		              ^, EigenDecompositionImpl.java:1165: error: variable declaration not allowed here
	 * 		number of rows in the block
	   		          ^, EigenDecompositionImpl.java:1165: error: ';' expected
	 * 		number of rows in the block
	   		                     ^, EigenDecompositionImpl.java:1166: error: illegal start of expression
	 * @param step
	   ^, EigenDecompositionImpl.java:1167: error: not a statement
	 * 		within the array (1 for flipping all elements, 2 for flipping
	 ^, EigenDecompositionImpl.java:1167: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		      ^, EigenDecompositionImpl.java:1167: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                ^, EigenDecompositionImpl.java:1167: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                       ^, EigenDecompositionImpl.java:1167: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                    ^, EigenDecompositionImpl.java:1167: error: ';' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                             ^, EigenDecompositionImpl.java:1167: error: ')' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                              ^, EigenDecompositionImpl.java:1167: error: '(' expected
	 * 		within the array (1 for flipping all elements, 2 for flipping
	   		                                                    ^, EigenDecompositionImpl.java:1168: error: not a statement
	 * 		only every other element)
	 ^, EigenDecompositionImpl.java:1168: error: ';' expected
	 * 		only every other element)
	   		    ^, EigenDecompositionImpl.java:1168: error: ';' expected
	 * 		only every other element)
	   		          ^, EigenDecompositionImpl.java:1168: error: not a statement
	 * 		only every other element)
	   		           ^, EigenDecompositionImpl.java:1168: error: ')' expected
	 * 		only every other element)
	   		                ^, EigenDecompositionImpl.java:1168: error: not a statement
	 * 		only every other element)
	   		                 ^, EigenDecompositionImpl.java:1168: error: ';' expected
	 * 		only every other element)
	   		                        ^, EigenDecompositionImpl.java:1169: error: <identifier> expected
	 * @return true if qd array was flipped
	    ^, EigenDecompositionImpl.java:1169: error: <identifier> expected
	 * @return true if qd array was flipped
	          ^, EigenDecompositionImpl.java:1169: error: ';' expected
	 * @return true if qd array was flipped
	               ^, EigenDecompositionImpl.java:1169: error: ';' expected
	 * @return true if qd array was flipped
	                           ^, EigenDecompositionImpl.java:1169: error: ';' expected
	 * @return true if qd array was flipped
	                                       ^, EigenDecompositionImpl.java:1170: error: illegal start of expression
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	^, EigenDecompositionImpl.java:1170: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                               ^, EigenDecompositionImpl.java:1170: error: <identifier> expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                            ^, EigenDecompositionImpl.java:1170: error: ';' expected
	 */ 	private boolean flipIfWarranted(final int n, final int step) { 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { 			// flip array 			int j = (4 * n) - 1; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k]; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	/**
	    	                                                           ^, EigenDecompositionImpl.java:1171: error: illegal start of expression
	 * Compute an interval containing all realEigenvalues of a block.
	 ^, EigenDecompositionImpl.java:1171: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	          ^, EigenDecompositionImpl.java:1171: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                      ^, EigenDecompositionImpl.java:1171: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                                     ^, EigenDecompositionImpl.java:1171: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                                                        ^, EigenDecompositionImpl.java:1171: error: ';' expected
	 * Compute an interval containing all realEigenvalues of a block.
	                                                                ^, EigenDecompositionImpl.java:1173: error: <identifier> expected
	 * @param index
	               ^, EigenDecompositionImpl.java:1174: error: ';' expected
	 * 		index of the first row of the block
	   		        ^, EigenDecompositionImpl.java:1174: error: ';' expected
	 * 		index of the first row of the block
	   		                  ^, EigenDecompositionImpl.java:1174: error: ';' expected
	 * 		index of the first row of the block
	   		                         ^, EigenDecompositionImpl.java:1174: error: ';' expected
	 * 		index of the first row of the block
	   		                                   ^, EigenDecompositionImpl.java:1175: error: <identifier> expected
	 * @param n
	           ^, EigenDecompositionImpl.java:1176: error: ';' expected
	 * 		number of rows of the block
	   		         ^, EigenDecompositionImpl.java:1176: error: ';' expected
	 * 		number of rows of the block
	   		                 ^, EigenDecompositionImpl.java:1176: error: ';' expected
	 * 		number of rows of the block
	   		                           ^, EigenDecompositionImpl.java:1177: error: <identifier> expected
	 * @return an interval containing the realEigenvalues
	    ^, EigenDecompositionImpl.java:1177: error: ';' expected
	 * @return an interval containing the realEigenvalues
	             ^, EigenDecompositionImpl.java:1177: error: ';' expected
	 * @return an interval containing the realEigenvalues
	                                 ^, EigenDecompositionImpl.java:1177: error: ';' expected
	 * @return an interval containing the realEigenvalues
	                                                     ^, EigenDecompositionImpl.java:1178: error: illegal start of expression
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) {
	    	^, EigenDecompositionImpl.java:1178: error: ';' expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) {
	    	                                 ^, EigenDecompositionImpl.java:1178: error: <identifier> expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) {
	    	                                                  ^, EigenDecompositionImpl.java:1178: error: ';' expected
	 */ 	private double[] eigenvaluesRange(final int index, final int n) { 		// find the bounds of the spectra of the local block 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		// set thresholds 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		// search lower eigenvalue 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) {
	    	                                                              ^, EigenDecompositionImpl.java:1233: error: illegal start of expression
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	^, EigenDecompositionImpl.java:1233: error: ';' expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                            ^, EigenDecompositionImpl.java:1233: error: <identifier> expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                            ^, EigenDecompositionImpl.java:1233: error: <identifier> expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                                             ^, EigenDecompositionImpl.java:1233: error: ';' expected
	 */ 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) {
	    	                                                                         ^, EigenDecompositionImpl.java:1256: error: illegal start of expression
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	^, EigenDecompositionImpl.java:1256: error: illegal start of expression
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	        ^, EigenDecompositionImpl.java:1256: error: ';' expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                              ^, EigenDecompositionImpl.java:1256: error: <identifier> expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                   ^, EigenDecompositionImpl.java:1256: error: <identifier> expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                                    ^, EigenDecompositionImpl.java:1256: error: ';' expected
	 */ 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) {
	    	                                                                                ^, EigenDecompositionImpl.java:1274: error: illegal start of expression
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	^, EigenDecompositionImpl.java:1274: error: illegal start of expression
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	        ^, EigenDecompositionImpl.java:1274: error: ';' expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                 ^, EigenDecompositionImpl.java:1274: error: <identifier> expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                  ^, EigenDecompositionImpl.java:1274: error: ';' expected
	 */ 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                                ^, EigenDecompositionImpl.java:1331: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	^, EigenDecompositionImpl.java:1331: error: illegal start of expression
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	        ^, EigenDecompositionImpl.java:1331: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                ^, EigenDecompositionImpl.java:1331: error: <identifier> expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                 ^, EigenDecompositionImpl.java:1331: error: ';' expected
	 */ 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4];
	    	                                               ^, EigenDecompositionImpl.java:1434: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	^, EigenDecompositionImpl.java:1434: error: illegal start of expression
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	        ^, EigenDecompositionImpl.java:1434: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                  ^, EigenDecompositionImpl.java:1434: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                                   ^, EigenDecompositionImpl.java:1434: error: <identifier> expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                                                  ^, EigenDecompositionImpl.java:1434: error: ';' expected
	 */ 	private void computeShiftIncrement(final int start, final int end, final int deflated) { 		final double cnst1 = 0.563; 		final double cnst2 = 1.01;
	    	                                                                                     ^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	^, EigenDecompositionImpl.java:1680: error: illegal start of expression
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                        ^, EigenDecompositionImpl.java:1680: error: ';' expected
	 */ 	private void updateSigma(final double shift) { 		// BEWARE: do NOT attempt to simplify the following statements
	    	                                           ^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	^, EigenDecompositionImpl.java:1698: error: illegal start of expression
	private void findEigenVectors() {
	        ^, EigenDecompositionImpl.java:1698: error: ';' expected
	private void findEigenVectors() {
	                             ^, EigenDecompositionImpl.java:1736: error: illegal start of expression
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                      ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                               ^, EigenDecompositionImpl.java:1736: error: <identifier> expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                 ^, EigenDecompositionImpl.java:1736: error: ';' expected
	 */ 	private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {
	    	                                                                                                                                  ^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	^, EigenDecompositionImpl.java:1798: error: illegal start of expression
	 */ 	private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) { 		final int nM1 = d.length - 1; 		double si = -lambda;
	    	        ^]
Ingredient counter is Zero
---Undoing: gnrtn(190): OP_INSTANCE:
InsertAfterOp:(spoon.support.reflect.code.CtForImpl) `// step 4a: dqds for (boolean loop = true; loop;) {  	// perform one dqds step with the chosen shift[...] ` -topatch--> `double upper = java.lang.Double.NEGATIVE_INFINITY` (spoon.support.reflect.code.CtLocalVariableImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (379(f=1.0), 380(f=1.7976931348623157E308), )
Selected to next generation: IDs2--> (379(f=1.0), )
----------Running generation: 191, population size: 1

***** Generation 191 : 0
**Parent Variant: [Variant id: 381, #gens: 382, #ops: 0, parent:-]

--Child created id: 382
--Creating new operations for variant [Variant id: 382, #gens: 382, #ops: 0, parent:381]
---analyzing modificationPoint position: 227
Templates availables78
Attempts Base Ingredients  1 total 78
vars from patch [dMin, tau, tType]
--> var from patch: dMin spoon.support.reflect.code.CtFieldReadImpl
--> var from patch: tau spoon.support.reflect.code.CtFieldWriteImpl
--> var from patch: tType spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1387
operation: OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) &&  ((org.ap[...] ` -topatch--> `// a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...]` (spoon.support.reflect.code.CtIfImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1387, pointed element: CtIfImpl
---OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) &&  ((org.ap[...] ` -topatch--> `// a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...]` (spoon.support.reflect.code.CtIfImpl) 

--Summary Creation: for variant [Variant id: 382, #gens: 382, #ops: 1, parent:381] gen mutated: 1 , gen not mut: 0, gen not applied  0
-The child compiles: id 382
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-382/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: false, failTest= 8, was successful: false, cases executed: 17] ,[]
-Valid?: |false|8|17|[]|, fitness 8.0
Ingredient counter is Zero
---Undoing: gnrtn(191): OP_INSTANCE:
ReplaceOp:(spoon.support.reflect.code.CtIfImpl) `if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) &&  ((org.ap[...] ` -topatch--> `// a negative dMin forces the shift to take that absolute value // tType records the type of shift. [...]` (spoon.support.reflect.code.CtIfImpl) 
End analysis generation - Solutions found:--> ()
Variants to next generation from: 2-->IDs: (381(f=1.0), 382(f=8.0), )
Selected to next generation: IDs2--> (381(f=1.0), )
----------Running generation: 192, population size: 1

***** Generation 192 : 0
**Parent Variant: [Variant id: 383, #gens: 382, #ops: 0, parent:-]

--Child created id: 384
--Creating new operations for variant [Variant id: 384, #gens: 382, #ops: 0, parent:383]
---analyzing modificationPoint position: 31
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 0 not mutation generated in  this.main = main.clone()
---analyzing modificationPoint position: 58
Templates availables595
Attempts Base Ingredients  1 total 595
---modifPoint 1 not mutation generated in  sigmaLow = 0
---analyzing modificationPoint position: 249
Templates availables595
Attempts Base Ingredients  1 total 595
vars from patch [dN2]
--> var from patch: dN2 spoon.support.reflect.code.CtFieldWriteImpl
location: EigenDecompositionImpl.java1445
operation: OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtSwitchImpl) `switch (deflated) {  	case 0 : 		// no realEigenvalues deflated. 		if ((dMin == dN) || (dMin == dN1)[...] ` -topatch--> `dN2 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
---MP=org.apache.commons.math.linear.EigenDecompositionImpl line: 1445, pointed element: CtAssignmentImpl
---OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtSwitchImpl) `switch (deflated) {  	case 0 : 		// no realEigenvalues deflated. 		if ((dMin == dN) || (dMin == dN1)[...] ` -topatch--> `dN2 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 

--Summary Creation: for variant [Variant id: 384, #gens: 383, #ops: 1, parent:383] gen mutated: 1 , gen not mut: 2, gen not applied  0
-The child compiles: id 384
-Running first validation
Executing process: (timeout10secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-384/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.linear.EigenDecompositionImplTest
Analyzing output from process
TR: Success: true, failTest= 0, was successful: true, cases executed: 17] ,[]
-Test Failing is passing, Executing regression
Executing process: (timeout702secs) 
/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/bin/java  -Xmx2048m  -Dmutnumber_0=null  -cp  "/Users/marekmazur/astor/./lib/com.gzoltar-0.1.1-jar-with-dependencies.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/variant-384/":"/Users/marekmazur/astor/examples/libs/junit-4.4.jar":"/Users/marekmazur/astor/./output_astor/AstorMain-math-81/bin/default/":"/Users/marekmazur/astor/target/astor-2.0.0-jar-with-dependencies.jar":  fr.inria.astor.core.validation.junit.JUnitNologExternalExecutor  org.apache.commons.math.stat.data.LotteryTest  org.apache.commons.math.linear.FieldMatrixImplTest  org.apache.commons.math.ode.sampling.StepNormalizerTest  org.apache.commons.math.stat.descriptive.AggregateSummaryStatisticsTest  org.apache.commons.math.geometry.RotationOrderTest  org.apache.commons.math.analysis.solvers.NewtonSolverTest  org.apache.commons.math.estimation.EstimatedParameterTest  org.apache.commons.math.linear.CholeskyDecompositionImplTest  org.apache.commons.math.linear.Array2DRowRealMatrixTest  org.apache.commons.math.linear.SparseRealMatrixTest  org.apache.commons.math.util.OpenIntToFieldTest  org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest  org.apache.commons.math.optimization.fitting.PolynomialFitterTest  org.apache.commons.math.linear.ArrayRealVectorTest  org.apache.commons.math.distribution.HypergeometricDistributionTest  org.apache.commons.math.random.RandomAdaptorTest  org.apache.commons.math.ode.FirstOrderConverterTest  org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest  org.apache.commons.math.stat.inference.TestUtilsTest  org.apache.commons.math.stat.data.LewTest  org.apache.commons.math.distribution.GammaDistributionTest  org.apache.commons.math.stat.descriptive.rank.MedianTest  org.apache.commons.math.distribution.ZipfDistributionTest  org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest  org.apache.commons.math.stat.CertifiedDataTest  org.apache.commons.math.ode.nonstiff.HighamHall54IntegratorTest  org.apache.commons.math.complex.FrenchComplexFormatTest  org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest  org.apache.commons.math.analysis.polynomials.PolynomialsUtilsTest  org.apache.commons.math.DuplicateSampleAbscissaExceptionTest  org.apache.commons.math.estimation.MinpackTest  org.apache.commons.math.genetics.FixedGenerationCountTest  org.apache.commons.math.optimization.general.GaussNewtonOptimizerTest  org.apache.commons.math.fraction.BigFractionFormatTest  org.apache.commons.math.stat.descriptive.MixedListUnivariateImplTest  org.apache.commons.math.random.RandomDataTest  org.apache.commons.math.distribution.FDistributionTest  org.apache.commons.math.FunctionEvaluationExceptionTest  org.apache.commons.math.ode.sampling.NordsieckStepInterpolatorTest  org.apache.commons.math.stat.inference.TTestFactoryTest  org.apache.commons.math.stat.descriptive.moment.SkewnessTest  org.apache.commons.math.special.GammaTest  org.apache.commons.math.ode.nonstiff.EulerStepInterpolatorTest  org.apache.commons.math.analysis.integration.RombergIntegratorTest  org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest  org.apache.commons.math.analysis.integration.LegendreGaussIntegratorTest  org.apache.commons.math.stat.descriptive.SummaryStatisticsTest  org.apache.commons.math.ode.nonstiff.MidpointIntegratorTest  org.apache.commons.math.stat.descriptive.moment.FirstMomentTest  org.apache.commons.math.stat.descriptive.moment.StandardDeviationTest  org.apache.commons.math.complex.ComplexTest  org.apache.commons.math.distribution.BetaDistributionTest  org.apache.commons.math.special.ErfTest  org.apache.commons.math.special.BetaTest  org.apache.commons.math.ode.nonstiff.GillIntegratorTest  org.apache.commons.math.random.EmpiricalDistributionTest  org.apache.commons.math.stat.descriptive.MultivariateSummaryStatisticsTest  org.apache.commons.math.stat.descriptive.StatisticalSummaryValuesTest  org.apache.commons.math.stat.regression.OLSMultipleLinearRegressionTest  org.apache.commons.math.estimation.LevenbergMarquardtEstimatorTest  org.apache.commons.math.random.AbstractRandomGeneratorTest  org.apache.commons.math.fraction.BigFractionFieldTest  org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolatorTest  org.apache.commons.math.genetics.GeneticAlgorithmTestBinary  org.apache.commons.math.linear.BiDiagonalTransformerTest  org.apache.commons.math.util.DefaultTransformerTest  org.apache.commons.math.linear.LUDecompositionImplTest  org.apache.commons.math.random.ValueServerTest  org.apache.commons.math.stat.descriptive.moment.MeanTest  org.apache.commons.math.util.BigRealFieldTest  org.apache.commons.math.linear.QRDecompositionImplTest  org.apache.commons.math.analysis.interpolation.NevilleInterpolatorTest  org.apache.commons.math.stat.descriptive.moment.VarianceTest  org.apache.commons.math.genetics.OnePointCrossoverTest  org.apache.commons.math.stat.ranking.NaturalRankingTest  org.apache.commons.math.optimization.linear.SimplexSolverTest  org.apache.commons.math.stat.descriptive.moment.FourthMomentTest  org.apache.commons.math.linear.BlockRealMatrixTest  org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest  org.apache.commons.math.random.MersenneTwisterTest  org.apache.commons.math.genetics.RandomKeyTest  org.apache.commons.math.stat.descriptive.summary.ProductTest  org.apache.commons.math.fraction.FractionTest  org.apache.commons.math.util.OpenIntToDoubleHashMapTest  org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest  org.apache.commons.math.ode.nonstiff.DormandPrince54IntegratorTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionTest  org.apache.commons.math.genetics.ChromosomeTest  org.apache.commons.math.stat.descriptive.moment.GeometricMeanTest  org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizerTest  org.apache.commons.math.random.CorrelatedRandomVectorGeneratorTest  org.apache.commons.math.geometry.Vector3DTest  org.apache.commons.math.stat.descriptive.rank.MinTest  org.apache.commons.math.stat.clustering.EuclideanIntegerPointTest  org.apache.commons.math.linear.FieldLUDecompositionImplTest  org.apache.commons.math.analysis.integration.TrapezoidIntegratorTest  org.apache.commons.math.stat.descriptive.moment.VectorialCovarianceTest  org.apache.commons.math.transform.FastHadamardTransformerTest  org.apache.commons.math.optimization.fitting.HarmonicFitterTest  org.apache.commons.math.stat.correlation.PearsonsCorrelationTest  org.apache.commons.math.random.GaussianRandomGeneratorTest  org.apache.commons.math.stat.descriptive.moment.ThirdMomentTest  org.apache.commons.math.linear.FrenchRealVectorFormatTest  org.apache.commons.math.fraction.BigFractionTest  org.apache.commons.math.util.ContinuedFractionTest  org.apache.commons.math.util.TransformerMapTest  org.apache.commons.math.analysis.solvers.BisectionSolverTest  org.apache.commons.math.genetics.BinaryChromosomeTest  org.apache.commons.math.linear.BlockFieldMatrixTest  org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest  org.apache.commons.math.linear.SingularValueDecompositionImplTest  org.apache.commons.math.distribution.TDistributionTest  org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest  org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest  org.apache.commons.math.linear.InvalidMatrixExceptionTest  org.apache.commons.math.distribution.BinomialDistributionTest  org.apache.commons.math.linear.EigenSolverTest  org.apache.commons.math.stat.inference.TTestTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonFormTest  org.apache.commons.math.random.UniformRandomGeneratorTest  org.apache.commons.math.stat.descriptive.rank.PercentileTest  org.apache.commons.math.analysis.solvers.RiddersSolverTest  org.apache.commons.math.linear.ArrayFieldVectorTest  org.apache.commons.math.ode.ContinuousOutputModelTest  org.apache.commons.math.random.UncorrelatedRandomVectorGeneratorTest  org.apache.commons.math.optimization.linear.SimplexTableauTest  org.apache.commons.math.ConvergenceExceptionTest  org.apache.commons.math.util.ResizableDoubleArrayTest  org.apache.commons.math.complex.ComplexFormatTest  org.apache.commons.math.linear.RealMatrixImplTest  org.apache.commons.math.stat.descriptive.summary.SumTest  org.apache.commons.math.linear.SparseFieldVectorTest  org.apache.commons.math.genetics.ElitisticListPopulationTest  org.apache.commons.math.stat.descriptive.summary.SumSqTest  org.apache.commons.math.linear.SparseRealVectorTest  org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolatorTest  org.apache.commons.math.linear.EigenDecompositionImplTest  org.apache.commons.math.analysis.integration.SimpsonIntegratorTest  org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatorTest  org.apache.commons.math.analysis.polynomials.PolynomialSplineFunctionTest  org.apache.commons.math.genetics.GeneticAlgorithmTestPermutations  org.apache.commons.math.stat.descriptive.moment.KurtosisTest  org.apache.commons.math.transform.FastFourierTransformerTest  org.apache.commons.math.stat.descriptive.moment.VectorialMeanTest  org.apache.commons.math.distribution.NormalDistributionTest  org.apache.commons.math.distribution.PoissonDistributionTest  org.apache.commons.math.geometry.Vector3DFormatTest  org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeFormTest  org.apache.commons.math.genetics.TournamentSelectionTest  org.apache.commons.math.optimization.general.MinpackTest  org.apache.commons.math.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest  org.apache.commons.math.analysis.solvers.BrentSolverTest  org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegratorTest  org.apache.commons.math.stat.descriptive.AbstractUnivariateStatisticTest  org.apache.commons.math.estimation.WeightedMeasurementTest  org.apache.commons.math.stat.inference.ChiSquareTestTest  org.apache.commons.math.analysis.interpolation.LoessInterpolatorTest  org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest  org.apache.commons.math.linear.MatrixIndexExceptionTest  org.apache.commons.math.genetics.BinaryMutationTest  org.apache.commons.math.fraction.FractionFormatTest  org.apache.commons.math.distribution.PascalDistributionTest  org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizerTest  org.apache.commons.math.util.MathUtilsTest  org.apache.commons.math.complex.ComplexUtilsTest  org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImplTest  org.apache.commons.math.optimization.direct.MultiDirectionalTest  org.apache.commons.math.genetics.FitnessCachingTest  org.apache.commons.math.linear.BigMatrixImplTest  org.apache.commons.math.stat.inference.ChiSquareFactoryTest  org.apache.commons.math.fraction.FractionFieldTest  org.apache.commons.math.stat.descriptive.InteractionTest  org.apache.commons.math.stat.correlation.CovarianceTest  org.apache.commons.math.optimization.univariate.BrentMinimizerTest  org.apache.commons.math.linear.QRSolverTest  org.apache.commons.math.linear.RealVectorFormatTest  org.apache.commons.math.analysis.solvers.LaguerreSolverTest  org.apache.commons.math.linear.CholeskySolverTest  org.apache.commons.math.distribution.WeibullDistributionTest  org.apache.commons.math.stat.StatUtilsTest  org.apache.commons.math.analysis.interpolation.SplineInterpolatorTest  org.apache.commons.math.analysis.solvers.MullerSolverTest  org.apache.commons.math.linear.TriDiagonalTransformerTest  org.apache.commons.math.distribution.ChiSquareDistributionTest  org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtilsTest  org.apache.commons.math.transform.FastSineTransformerTest  org.apache.commons.math.stat.inference.OneWayAnovaTest  org.apache.commons.math.transform.FastCosineTransformerTest  org.apache.commons.math.ArgumentOutsideDomainExceptionTest  org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest  org.apache.commons.math.ode.nonstiff.EulerIntegratorTest  org.apache.commons.math.stat.descriptive.rank.MaxTest  org.apache.commons.math.complex.ComplexFieldTest  org.apache.commons.math.stat.descriptive.ListUnivariateImplTest  org.apache.commons.math.stat.descriptive.DescriptiveStatisticsTest  org.apache.commons.math.MaxIterationsExceededExceptionTest  org.apache.commons.math.linear.MatrixUtilsTest  org.apache.commons.math.optimization.direct.NelderMeadTest  org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizerTest  org.apache.commons.math.geometry.RotationTest  org.apache.commons.math.ode.sampling.DummyStepInterpolatorTest  org.apache.commons.math.linear.SingularValueSolverTest  org.apache.commons.math.genetics.RandomKeyMutationTest  org.apache.commons.math.util.BigRealTest  org.apache.commons.math.distribution.ExponentialDistributionTest  org.apache.commons.math.stat.descriptive.SynchronizedDescriptiveStatisticsTest  org.apache.commons.math.geometry.FrenchVector3DFormatTest  org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest  org.apache.commons.math.stat.regression.SimpleRegressionTest  org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizerTest  org.apache.commons.math.stat.regression.GLSMultipleLinearRegressionTest  org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegratorTest  org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest  org.apache.commons.math.linear.LUSolverTest  org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest  org.apache.commons.math.MathConfigurationExceptionTest  org.apache.commons.math.estimation.GaussNewtonEstimatorTest  org.apache.commons.math.genetics.ListPopulationTest  org.apache.commons.math.MathExceptionTest  org.apache.commons.math.distribution.CauchyDistributionTest  org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest  org.apache.commons.math.linear.SparseFieldMatrixTest  org.apache.commons.math.stat.descriptive.summary.SumLogTest  org.apache.commons.math.stat.FrequencyTest  org.apache.commons.math.stat.descriptive.moment.SecondMomentTest
Analyzing output from process
TR: Success: true, failTest= 0, was successful: true, cases executed: 2103] ,[]
-Valid?: |true|0|2103|[]|, fitness 0.0
-Found Solution, child variant #384
Ingredient counter is Zero

Attempts to find patch Id 384: 0, successful 0, failing 0

-Saving child on disk variant #384 at /Users/marekmazur/astor/./output_astor/AstorMain-math-81//src//variant-384

-Saving child on disk variant #384 at /Users/marekmazur/astor/./output_astor/AstorMain-math-81//src//variant-384_f
---Undoing: gnrtn(192): OP_INSTANCE:
InsertBeforeOp:(spoon.support.reflect.code.CtSwitchImpl) `switch (deflated) { 	case 0 : 		// no realEigenvalues deflated. 		if ((dMin == dN) || (dMin == dN1))[...] ` -topatch--> `dN2 = 0` (spoon.support.reflect.code.CtAssignmentImpl) 
/Users/marekmazur/astor/./output_astor/AstorMain-math-81/src/default_f/org/apache/commons/math/linear/EigenDecompositionImpl.java
/Users/marekmazur/astor/./output_astor/AstorMain-math-81/src/variant-384_f/org/apache/commons/math/linear/EigenDecompositionImpl.java
diff command : diff -w -b  --label=/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java --label=/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java /Users/marekmazur/astor/./output_astor/AstorMain-math-81/src/default_f/org/apache/commons/math/linear/EigenDecompositionImpl.java /Users/marekmazur/astor/./output_astor/AstorMain-math-81/src/variant-384_f/org/apache/commons/math/linear/EigenDecompositionImpl.java --unified=0
/Users/marekmazur/astor/./output_astor/AstorMain-math-81/src/default/org/apache/commons/math/linear/EigenDecompositionImpl.java
/Users/marekmazur/astor/./output_astor/AstorMain-math-81/src/variant-384/org/apache/commons/math/linear/EigenDecompositionImpl.java
diff command : diff -w -b  --label=/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java --label=/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java /Users/marekmazur/astor/./output_astor/AstorMain-math-81/src/default/org/apache/commons/math/linear/EigenDecompositionImpl.java /Users/marekmazur/astor/./output_astor/AstorMain-math-81/src/variant-384/org/apache/commons/math/linear/EigenDecompositionImpl.java --unified=0
Generation 1
Generation 2
Generation 3
Generation 4
Generation 5
Generation 6
Generation 7
Generation 8
Generation 9
Generation 10
Generation 11
Generation 12
Generation 13
Generation 14
Generation 15
Generation 16
Generation 17
Generation 18
Generation 19
Generation 20
Generation 21
Generation 22
Generation 23
Generation 24
Generation 25
Generation 26
Generation 27
Generation 28
Generation 29
Generation 30
Generation 31
Generation 32
Generation 33
Generation 34
Generation 35
Generation 36
Generation 37
Generation 38
Generation 39
Generation 40
Generation 41
Generation 42
Generation 43
Generation 44
Generation 45
Generation 46
Generation 47
Generation 48
Generation 49
Generation 50
Generation 51
Generation 52
Generation 53
Generation 54
Generation 55
Generation 56
Generation 57
Generation 58
Generation 59
Generation 60
Generation 61
Generation 62
Generation 63
Generation 64
Generation 65
Generation 66
Generation 67
Generation 68
Generation 69
Generation 70
Generation 71
Generation 72
Generation 73
Generation 74
Generation 75
Generation 76
Generation 77
Generation 78
Generation 79
Generation 80
Generation 81
Generation 82
Generation 83
Generation 84
Generation 85
Generation 86
Generation 87
Generation 88
Generation 89
Generation 90
Generation 91
Generation 92
Generation 93
Generation 94
Generation 95
Generation 96
Generation 97
Generation 98
Generation 99
Generation 100
Generation 101
Generation 102
Generation 103
Generation 104
Generation 105
Generation 106
Generation 107
Generation 108
Generation 109
Generation 110
Generation 111
Generation 112
Generation 113
Generation 114
Generation 115
Generation 116
Generation 117
Generation 118
Generation 119
Generation 120
Generation 121
Generation 122
Generation 123
Generation 124
Generation 125
Generation 126
Generation 127
Generation 128
Generation 129
Generation 130
Generation 131
Generation 132
Generation 133
Generation 134
Generation 135
Generation 136
Generation 137
Generation 138
Generation 139
Generation 140
Generation 141
Generation 142
Generation 143
Generation 144
Generation 145
Generation 146
Generation 147
Generation 148
Generation 149
Generation 150
Generation 151
Generation 152
Generation 153
Generation 154
Generation 155
Generation 156
Generation 157
Generation 158
Generation 159
Generation 160
Generation 161
Generation 162
Generation 163
Generation 164
Generation 165
Generation 166
Generation 167
Generation 168
Generation 169
Generation 170
Generation 171
Generation 172
Generation 173
Generation 174
Generation 175
Generation 176
Generation 177
Generation 178
Generation 179
Generation 180
Generation 181
Generation 182
Generation 183
Generation 184
Generation 185
Generation 186
Generation 187
Generation 188
Generation 189
Generation 190
Generation 191
Generation 192
Storing ing JSON at ./diffSolutions/patchinfo_384.json
./diffSolutions/patchinfo_384.json:
{"VARIANT_ID":"384","VALIDATION":"|true|0|2103|[]|","patchhunks":[{"LOCATION":"org.apache.commons.math.linear.EigenDecompositionImpl","PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/defects4j\\\/math-81\\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","INGREDIENT_SCOPE":"LOCAL","SUSPICIOUNESS":"0,993","INGREDIENT_PARENT":"dN2 = 0","PATCH_HUNK_TYPE":"CtAssignmentImpl|CtBlockImpl","ORIGINAL_CODE":"switch (deflated) {\\n\\n\\tcase 0 : \\t\\t\\\/\\\/ no realEigenvalues deflated.\\n\\t\\tif ((dMin == dN) || (dMin == dN1)) {\\n\\n\\t\\t\\tdouble b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5]);\\n\\t\\t\\tdouble b2 = java.lang.Math.sqrt(work[nn - 7]) * java.lang.Math.sqrt(work[nn - 9]);\\n\\t\\t\\tdouble a2 = work[nn - 7] + work[nn - 5];\\n\\n\\t\\t\\tif ((dMin == dN) && (dMin1 == dN1)) {\\n\\t\\t\\t\\t\\\/\\\/ cases 2 and 3.\\n\\t\\t\\t\\tfinal double gap2 = (dMin2 - a2) - (dMin2 * 0.25);\\n\\t\\t\\t\\tfinal double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 \\\/ gap2) * b2 : b1 + b2);\\n\\t\\t\\t\\tif ((gap1 > 0.0) && (gap1 > b1)) {\\n\\t\\t\\t\\t\\ttau = java.lang.Math.max(dN - ((b1 \\\/ gap1) * b1), 0.5 * dMin);\\n\\t\\t\\t\\t\\ttType = -2;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdouble s = 0.0;\\n\\t\\t\\t\\t\\tif (dN > b1) {\\n\\t\\t\\t\\t\\t\\ts = dN - b1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (a2 > (b1 + b2)) {\\n\\t\\t\\t\\t\\t\\ts = java.lang.Math.min(s, a2 - (b1 + b2));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttau = java.lang.Math.max(s, 0.333 * dMin);\\n\\t\\t\\t\\t\\ttType = -3;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\\/\\\/ case 4.\\n\\t\\t\\t\\ttType = -4;\\n\\t\\t\\t\\tdouble s = 0.25 * dMin;\\n\\t\\t\\t\\tdouble gam;\\n\\t\\t\\t\\tint np;\\n\\t\\t\\t\\tif (dMin == dN) {\\n\\t\\t\\t\\t\\tgam = dN;\\n\\t\\t\\t\\t\\ta2 = 0.0;\\n\\t\\t\\t\\t\\tif (work[nn - 5] > work[nn - 7]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb2 = work[nn - 5] \\\/ work[nn - 7];\\n\\t\\t\\t\\t\\tnp = nn - 9;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnp = nn - (2 * pingPong);\\n\\t\\t\\t\\t\\tb2 = work[np - 2];\\n\\t\\t\\t\\t\\tgam = dN1;\\n\\t\\t\\t\\t\\tif (work[np - 4] > work[np - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ta2 = work[np - 4] \\\/ work[np - 2];\\n\\t\\t\\t\\t\\tif (work[nn - 9] > work[nn - 11]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb2 = work[nn - 9] \\\/ work[nn - 11];\\n\\t\\t\\t\\t\\tnp = nn - 13;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\\/\\\/ approximate contribution to norm squared from i < nn-1.\\n\\t\\t\\t\\ta2 = a2 + b2;\\n\\t\\t\\t\\tfor (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\\n\\t\\t\\t\\t\\tif (b2 == 0.0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb1 = b2;\\n\\t\\t\\t\\t\\tif (work[i4] > work[i4 - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb2 = b2 * (work[i4] \\\/ work[i4 - 2]);\\n\\t\\t\\t\\t\\ta2 = a2 + b2;\\n\\t\\t\\t\\t\\tif (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ta2 = cnst3 * a2;\\n\\n\\t\\t\\t\\t\\\/\\\/ rayleigh quotient residual bound.\\n\\t\\t\\t\\tif (a2 < cnst1) {\\n\\t\\t\\t\\t\\ts = (gam * (1 - java.lang.Math.sqrt(a2))) \\\/ (1 + a2);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttau = s;\\n\\n\\t\\t\\t}\\n\\t\\t} else if (dMin == dN2) {\\n\\n\\t\\t\\t\\\/\\\/ case 5.\\n\\t\\t\\ttType = -5;\\n\\t\\t\\tdouble s = 0.25 * dMin;\\n\\n\\t\\t\\t\\\/\\\/ compute contribution to norm squared from i > nn-2.\\n\\t\\t\\tfinal int np = nn - (2 * pingPong);\\n\\t\\t\\tdouble b1 = work[np - 2];\\n\\t\\t\\tdouble b2 = work[np - 6];\\n\\t\\t\\tfinal double gam = dN2;\\n\\t\\t\\tif ((work[np - 8] > b2) || (work[np - 4] > b1)) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdouble a2 = (work[np - 8] \\\/ b2) * (1 + (work[np - 4] \\\/ b1));\\n\\n\\t\\t\\t\\\/\\\/ approximate contribution to norm squared from i < nn-2.\\n\\t\\t\\tif ((end - start) > 2) {\\n\\t\\t\\t\\tb2 = work[nn - 13] \\\/ work[nn - 15];\\n\\t\\t\\t\\ta2 = a2 + b2;\\n\\t\\t\\t\\tfor (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\\n\\t\\t\\t\\t\\tif (b2 == 0.0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb1 = b2;\\n\\t\\t\\t\\t\\tif (work[i4] > work[i4 - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb2 = b2 * (work[i4] \\\/ work[i4 - 2]);\\n\\t\\t\\t\\t\\ta2 = a2 + b2;\\n\\t\\t\\t\\t\\tif (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ta2 = cnst3 * a2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (a2 < cnst1) {\\n\\t\\t\\t\\ttau = (gam * (1 - java.lang.Math.sqrt(a2))) \\\/ (1 + a2);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttau = s;\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t\\\/\\\/ case 6, no information to guide us.\\n\\t\\t\\tif (tType == (-6)) {\\n\\t\\t\\t\\tg += 0.333 * (1 - g);\\n\\t\\t\\t} else if (tType == (-18)) {\\n\\t\\t\\t\\tg = 0.25 * 0.333;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tg = 0.25;\\n\\t\\t\\t}\\n\\t\\t\\ttau = g * dMin;\\n\\t\\t\\ttType = -6;\\n\\n\\t\\t}\\n\\t\\tbreak;\\n\\n\\tcase 1 : \\t\\t\\\/\\\/ one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\\n\\t\\tif ((dMin1 == dN1) && (dMin2 == dN2)) {\\n\\n\\t\\t\\t\\\/\\\/ cases 7 and 8.\\n\\t\\t\\ttType = -7;\\n\\t\\t\\tdouble s = 0.333 * dMin1;\\n\\t\\t\\tif (work[nn - 5] > work[nn - 7]) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdouble b1 = work[nn - 5] \\\/ work[nn - 7];\\n\\t\\t\\tdouble b2 = b1;\\n\\t\\t\\tif (b2 != 0.0) {\\n\\t\\t\\t\\tfor (int i4 = ((4 * end) - 10) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\\n\\t\\t\\t\\t\\tfinal double oldB1 = b1;\\n\\t\\t\\t\\t\\tif (work[i4] > work[i4 - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb1 = b1 * (work[i4] \\\/ work[i4 - 2]);\\n\\t\\t\\t\\t\\tb2 = b2 + b1;\\n\\t\\t\\t\\t\\tif ((100 * java.lang.Math.max(b1, oldB1)) < b2) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tb2 = java.lang.Math.sqrt(cnst3 * b2);\\n\\t\\t\\tfinal double a2 = dMin1 \\\/ (1 + (b2 * b2));\\n\\t\\t\\tfinal double gap2 = (0.5 * dMin2) - a2;\\n\\t\\t\\tif ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\\n\\t\\t\\t\\ttau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 \\\/ gap2)) * b2)));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\\n\\t\\t\\t\\ttType = -8;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\n\\t\\t\\t\\\/\\\/ case 9.\\n\\t\\t\\ttau = 0.25 * dMin1;\\n\\t\\t\\tif (dMin1 == dN1) {\\n\\t\\t\\t\\ttau = 0.5 * dMin1;\\n\\t\\t\\t}\\n\\t\\t\\ttType = -9;\\n\\t\\t}\\n\\t\\tbreak;\\n\\n\\tcase 2 : \\t\\t\\\/\\\/ two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\\n\\n\\t\\t\\\/\\\/ cases 10 and 11.\\n\\t\\tif ((dMin2 == dN2) && ((2 * work[nn - 5]) < work[nn - 7])) {\\n\\t\\t\\ttType = -10;\\n\\t\\t\\tfinal double s = 0.333 * dMin2;\\n\\t\\t\\tif (work[nn - 5] > work[nn - 7]) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdouble b1 = work[nn - 5] \\\/ work[nn - 7];\\n\\t\\t\\tdouble b2 = b1;\\n\\t\\t\\tif (b2 != 0.0) {\\n\\t\\t\\t\\tfor (int i4 = ((4 * end) - 9) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\\n\\t\\t\\t\\t\\tif (work[i4] > work[i4 - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb1 *= work[i4] \\\/ work[i4 - 2];\\n\\t\\t\\t\\t\\tb2 += b1;\\n\\t\\t\\t\\t\\tif ((100 * b1) < b2) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tb2 = java.lang.Math.sqrt(cnst3 * b2);\\n\\t\\t\\tfinal double a2 = dMin2 \\\/ (1 + (b2 * b2));\\n\\t\\t\\tfinal double gap2 = ((work[nn - 7] + work[nn - 9]) - \\n\\t\\t\\t(java.lang.Math.sqrt(work[nn - 11]) * java.lang.Math.sqrt(work[nn - 9]))) - a2;\\n\\t\\t\\tif ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\\n\\t\\t\\t\\ttau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 \\\/ gap2)) * b2)));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\ttau = 0.25 * dMin2;\\n\\t\\t\\ttType = -11;\\n\\t\\t}\\n\\t\\tbreak;\\n\\n\\tdefault : \\t\\t\\\/\\\/ case 12, more than two realEigenvalues deflated. no information.\\n\\t\\ttau = 0.0;\\n\\t\\ttType = -12;}","BUGGY_CODE_TYPE":"CtSwitchImpl|CtBlockImpl","OPERATOR":"InsertBeforeOp","MODIFIED_FILE_PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-81\\\/\\\/src\\\/\\\/variant-384\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","LINE":"1445","MP_RANKING":"249","PATCH_HUNK_CODE":"dN2 = 0"}],"TIME":"260","GENERATION":"192","FOLDER_SOLUTION_CODE":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-81\\\/\\\/src\\\/\\\/variant-384","PATCH_DIFF_ORIG":"--- \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n+++ \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n@@ -1444 +1444 @@\\n-\\t\\tint nn = ((4 * end) + pingPong) - 1;\\n+\\t\\tint nn = ((4 * end) + pingPong) - 1; \\t\\tdN2 = 0;\\n\\n"}
Saving patch info at ./diffSolutions/patchinfo_384.json
Storing ing JSON at /Users/marekmazur/astor/./diffSolutions/patch_260819_384.diff
/Users/marekmazur/astor/./diffSolutions/patch_260819_384.diff:
{"VARIANT_ID":"384","VALIDATION":"|true|0|2103|[]|","patchhunks":[{"LOCATION":"org.apache.commons.math.linear.EigenDecompositionImpl","PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/defects4j\\\/math-81\\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","INGREDIENT_SCOPE":"LOCAL","SUSPICIOUNESS":"0,993","INGREDIENT_PARENT":"dN2 = 0","PATCH_HUNK_TYPE":"CtAssignmentImpl|CtBlockImpl","ORIGINAL_CODE":"switch (deflated) {\\n\\n\\tcase 0 : \\t\\t\\\/\\\/ no realEigenvalues deflated.\\n\\t\\tif ((dMin == dN) || (dMin == dN1)) {\\n\\n\\t\\t\\tdouble b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5]);\\n\\t\\t\\tdouble b2 = java.lang.Math.sqrt(work[nn - 7]) * java.lang.Math.sqrt(work[nn - 9]);\\n\\t\\t\\tdouble a2 = work[nn - 7] + work[nn - 5];\\n\\n\\t\\t\\tif ((dMin == dN) && (dMin1 == dN1)) {\\n\\t\\t\\t\\t\\\/\\\/ cases 2 and 3.\\n\\t\\t\\t\\tfinal double gap2 = (dMin2 - a2) - (dMin2 * 0.25);\\n\\t\\t\\t\\tfinal double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 \\\/ gap2) * b2 : b1 + b2);\\n\\t\\t\\t\\tif ((gap1 > 0.0) && (gap1 > b1)) {\\n\\t\\t\\t\\t\\ttau = java.lang.Math.max(dN - ((b1 \\\/ gap1) * b1), 0.5 * dMin);\\n\\t\\t\\t\\t\\ttType = -2;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdouble s = 0.0;\\n\\t\\t\\t\\t\\tif (dN > b1) {\\n\\t\\t\\t\\t\\t\\ts = dN - b1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (a2 > (b1 + b2)) {\\n\\t\\t\\t\\t\\t\\ts = java.lang.Math.min(s, a2 - (b1 + b2));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttau = java.lang.Math.max(s, 0.333 * dMin);\\n\\t\\t\\t\\t\\ttType = -3;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\\/\\\/ case 4.\\n\\t\\t\\t\\ttType = -4;\\n\\t\\t\\t\\tdouble s = 0.25 * dMin;\\n\\t\\t\\t\\tdouble gam;\\n\\t\\t\\t\\tint np;\\n\\t\\t\\t\\tif (dMin == dN) {\\n\\t\\t\\t\\t\\tgam = dN;\\n\\t\\t\\t\\t\\ta2 = 0.0;\\n\\t\\t\\t\\t\\tif (work[nn - 5] > work[nn - 7]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb2 = work[nn - 5] \\\/ work[nn - 7];\\n\\t\\t\\t\\t\\tnp = nn - 9;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnp = nn - (2 * pingPong);\\n\\t\\t\\t\\t\\tb2 = work[np - 2];\\n\\t\\t\\t\\t\\tgam = dN1;\\n\\t\\t\\t\\t\\tif (work[np - 4] > work[np - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ta2 = work[np - 4] \\\/ work[np - 2];\\n\\t\\t\\t\\t\\tif (work[nn - 9] > work[nn - 11]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb2 = work[nn - 9] \\\/ work[nn - 11];\\n\\t\\t\\t\\t\\tnp = nn - 13;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\\/\\\/ approximate contribution to norm squared from i < nn-1.\\n\\t\\t\\t\\ta2 = a2 + b2;\\n\\t\\t\\t\\tfor (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\\n\\t\\t\\t\\t\\tif (b2 == 0.0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb1 = b2;\\n\\t\\t\\t\\t\\tif (work[i4] > work[i4 - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb2 = b2 * (work[i4] \\\/ work[i4 - 2]);\\n\\t\\t\\t\\t\\ta2 = a2 + b2;\\n\\t\\t\\t\\t\\tif (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ta2 = cnst3 * a2;\\n\\n\\t\\t\\t\\t\\\/\\\/ rayleigh quotient residual bound.\\n\\t\\t\\t\\tif (a2 < cnst1) {\\n\\t\\t\\t\\t\\ts = (gam * (1 - java.lang.Math.sqrt(a2))) \\\/ (1 + a2);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttau = s;\\n\\n\\t\\t\\t}\\n\\t\\t} else if (dMin == dN2) {\\n\\n\\t\\t\\t\\\/\\\/ case 5.\\n\\t\\t\\ttType = -5;\\n\\t\\t\\tdouble s = 0.25 * dMin;\\n\\n\\t\\t\\t\\\/\\\/ compute contribution to norm squared from i > nn-2.\\n\\t\\t\\tfinal int np = nn - (2 * pingPong);\\n\\t\\t\\tdouble b1 = work[np - 2];\\n\\t\\t\\tdouble b2 = work[np - 6];\\n\\t\\t\\tfinal double gam = dN2;\\n\\t\\t\\tif ((work[np - 8] > b2) || (work[np - 4] > b1)) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdouble a2 = (work[np - 8] \\\/ b2) * (1 + (work[np - 4] \\\/ b1));\\n\\n\\t\\t\\t\\\/\\\/ approximate contribution to norm squared from i < nn-2.\\n\\t\\t\\tif ((end - start) > 2) {\\n\\t\\t\\t\\tb2 = work[nn - 13] \\\/ work[nn - 15];\\n\\t\\t\\t\\ta2 = a2 + b2;\\n\\t\\t\\t\\tfor (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\\n\\t\\t\\t\\t\\tif (b2 == 0.0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb1 = b2;\\n\\t\\t\\t\\t\\tif (work[i4] > work[i4 - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb2 = b2 * (work[i4] \\\/ work[i4 - 2]);\\n\\t\\t\\t\\t\\ta2 = a2 + b2;\\n\\t\\t\\t\\t\\tif (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ta2 = cnst3 * a2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (a2 < cnst1) {\\n\\t\\t\\t\\ttau = (gam * (1 - java.lang.Math.sqrt(a2))) \\\/ (1 + a2);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttau = s;\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t\\\/\\\/ case 6, no information to guide us.\\n\\t\\t\\tif (tType == (-6)) {\\n\\t\\t\\t\\tg += 0.333 * (1 - g);\\n\\t\\t\\t} else if (tType == (-18)) {\\n\\t\\t\\t\\tg = 0.25 * 0.333;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tg = 0.25;\\n\\t\\t\\t}\\n\\t\\t\\ttau = g * dMin;\\n\\t\\t\\ttType = -6;\\n\\n\\t\\t}\\n\\t\\tbreak;\\n\\n\\tcase 1 : \\t\\t\\\/\\\/ one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\\n\\t\\tif ((dMin1 == dN1) && (dMin2 == dN2)) {\\n\\n\\t\\t\\t\\\/\\\/ cases 7 and 8.\\n\\t\\t\\ttType = -7;\\n\\t\\t\\tdouble s = 0.333 * dMin1;\\n\\t\\t\\tif (work[nn - 5] > work[nn - 7]) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdouble b1 = work[nn - 5] \\\/ work[nn - 7];\\n\\t\\t\\tdouble b2 = b1;\\n\\t\\t\\tif (b2 != 0.0) {\\n\\t\\t\\t\\tfor (int i4 = ((4 * end) - 10) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\\n\\t\\t\\t\\t\\tfinal double oldB1 = b1;\\n\\t\\t\\t\\t\\tif (work[i4] > work[i4 - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb1 = b1 * (work[i4] \\\/ work[i4 - 2]);\\n\\t\\t\\t\\t\\tb2 = b2 + b1;\\n\\t\\t\\t\\t\\tif ((100 * java.lang.Math.max(b1, oldB1)) < b2) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tb2 = java.lang.Math.sqrt(cnst3 * b2);\\n\\t\\t\\tfinal double a2 = dMin1 \\\/ (1 + (b2 * b2));\\n\\t\\t\\tfinal double gap2 = (0.5 * dMin2) - a2;\\n\\t\\t\\tif ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\\n\\t\\t\\t\\ttau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 \\\/ gap2)) * b2)));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\\n\\t\\t\\t\\ttType = -8;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\n\\t\\t\\t\\\/\\\/ case 9.\\n\\t\\t\\ttau = 0.25 * dMin1;\\n\\t\\t\\tif (dMin1 == dN1) {\\n\\t\\t\\t\\ttau = 0.5 * dMin1;\\n\\t\\t\\t}\\n\\t\\t\\ttType = -9;\\n\\t\\t}\\n\\t\\tbreak;\\n\\n\\tcase 2 : \\t\\t\\\/\\\/ two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\\n\\n\\t\\t\\\/\\\/ cases 10 and 11.\\n\\t\\tif ((dMin2 == dN2) && ((2 * work[nn - 5]) < work[nn - 7])) {\\n\\t\\t\\ttType = -10;\\n\\t\\t\\tfinal double s = 0.333 * dMin2;\\n\\t\\t\\tif (work[nn - 5] > work[nn - 7]) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdouble b1 = work[nn - 5] \\\/ work[nn - 7];\\n\\t\\t\\tdouble b2 = b1;\\n\\t\\t\\tif (b2 != 0.0) {\\n\\t\\t\\t\\tfor (int i4 = ((4 * end) - 9) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\\n\\t\\t\\t\\t\\tif (work[i4] > work[i4 - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb1 *= work[i4] \\\/ work[i4 - 2];\\n\\t\\t\\t\\t\\tb2 += b1;\\n\\t\\t\\t\\t\\tif ((100 * b1) < b2) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tb2 = java.lang.Math.sqrt(cnst3 * b2);\\n\\t\\t\\tfinal double a2 = dMin2 \\\/ (1 + (b2 * b2));\\n\\t\\t\\tfinal double gap2 = ((work[nn - 7] + work[nn - 9]) - \\n\\t\\t\\t(java.lang.Math.sqrt(work[nn - 11]) * java.lang.Math.sqrt(work[nn - 9]))) - a2;\\n\\t\\t\\tif ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\\n\\t\\t\\t\\ttau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 \\\/ gap2)) * b2)));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\ttau = 0.25 * dMin2;\\n\\t\\t\\ttType = -11;\\n\\t\\t}\\n\\t\\tbreak;\\n\\n\\tdefault : \\t\\t\\\/\\\/ case 12, more than two realEigenvalues deflated. no information.\\n\\t\\ttau = 0.0;\\n\\t\\ttType = -12;}","BUGGY_CODE_TYPE":"CtSwitchImpl|CtBlockImpl","OPERATOR":"InsertBeforeOp","MODIFIED_FILE_PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-81\\\/\\\/src\\\/\\\/variant-384\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","LINE":"1445","MP_RANKING":"249","PATCH_HUNK_CODE":"dN2 = 0"}],"TIME":"260","GENERATION":"192","FOLDER_SOLUTION_CODE":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-81\\\/\\\/src\\\/\\\/variant-384","PATCH_DIFF_ORIG":"--- \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n+++ \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n@@ -1444 +1444 @@\\n-\\t\\tint nn = ((4 * end) + pingPong) - 1;\\n+\\t\\tint nn = ((4 * end) + pingPong) - 1; \\t\\tdN2 = 0;\\n\\n"}
Saving patch diff at /Users/marekmazur/astor/./diffSolutions/patch_260819_384.diff
End analysis generation - Solutions found:--> (384(SOLUTION)(f=0.0), )
Variants to next generation from: 2-->IDs: (384(f=0.0)[SOL], 383(f=1.0), )
Selected to next generation: IDs2--> (383(f=1.0), )
Max Solution found 1
Time Repair Loop (s): 260.828
generationsexecuted: 192
----SUMMARY_EXECUTION---
End Repair Search: Found solution
Solution stored at: /Users/marekmazur/astor/./output_astor/AstorMain-math-81//src/
Number solutions:1
f (sol): 0.0, [Variant id: 384 (SOL) , #gens: 383, #ops: 1, parent:383]
All variants:
f 1.0, [Variant id: 385, #gens: 382, #ops: 0, parent:-]
Number suspicious:1

 --SOLUTIONS DESCRIPTION--

 ----
ProgramVariant 384
 
time(sec)= 260
operation: InsertBeforeOp
location= org.apache.commons.math.linear.EigenDecompositionImpl
line= 1445
lineSuspiciousness= 0,993
lineSuspiciousness= 249
original statement= switch (deflated) {

	case 0 : 		// no realEigenvalues deflated.
		if ((dMin == dN) || (dMin == dN1)) {

			double b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5]);
			double b2 = java.lang.Math.sqrt(work[nn - 7]) * java.lang.Math.sqrt(work[nn - 9]);
			double a2 = work[nn - 7] + work[nn - 5];

			if ((dMin == dN) && (dMin1 == dN1)) {
				// cases 2 and 3.
				final double gap2 = (dMin2 - a2) - (dMin2 * 0.25);
				final double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 / gap2) * b2 : b1 + b2);
				if ((gap1 > 0.0) && (gap1 > b1)) {
					tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin);
					tType = -2;
				} else {
					double s = 0.0;
					if (dN > b1) {
						s = dN - b1;
					}
					if (a2 > (b1 + b2)) {
						s = java.lang.Math.min(s, a2 - (b1 + b2));
					}
					tau = java.lang.Math.max(s, 0.333 * dMin);
					tType = -3;
				}
			} else {
				// case 4.
				tType = -4;
				double s = 0.25 * dMin;
				double gam;
				int np;
				if (dMin == dN) {
					gam = dN;
					a2 = 0.0;
					if (work[nn - 5] > work[nn - 7]) {
						return;
					}
					b2 = work[nn - 5] / work[nn - 7];
					np = nn - 9;
				} else {
					np = nn - (2 * pingPong);
					b2 = work[np - 2];
					gam = dN1;
					if (work[np - 4] > work[np - 2]) {
						return;
					}
					a2 = work[np - 4] / work[np - 2];
					if (work[nn - 9] > work[nn - 11]) {
						return;
					}
					b2 = work[nn - 9] / work[nn - 11];
					np = nn - 13;
				}

				// approximate contribution to norm squared from i < nn-1.
				a2 = a2 + b2;
				for (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {
					if (b2 == 0.0) {
						break;
					}
					b1 = b2;
					if (work[i4] > work[i4 - 2]) {
						return;
					}
					b2 = b2 * (work[i4] / work[i4 - 2]);
					a2 = a2 + b2;
					if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {
						break;
					}
				}
				a2 = cnst3 * a2;

				// rayleigh quotient residual bound.
				if (a2 < cnst1) {
					s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);
				}
				tau = s;

			}
		} else if (dMin == dN2) {

			// case 5.
			tType = -5;
			double s = 0.25 * dMin;

			// compute contribution to norm squared from i > nn-2.
			final int np = nn - (2 * pingPong);
			double b1 = work[np - 2];
			double b2 = work[np - 6];
			final double gam = dN2;
			if ((work[np - 8] > b2) || (work[np - 4] > b1)) {
				return;
			}
			double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1));

			// approximate contribution to norm squared from i < nn-2.
			if ((end - start) > 2) {
				b2 = work[nn - 13] / work[nn - 15];
				a2 = a2 + b2;
				for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {
					if (b2 == 0.0) {
						break;
					}
					b1 = b2;
					if (work[i4] > work[i4 - 2]) {
						return;
					}
					b2 = b2 * (work[i4] / work[i4 - 2]);
					a2 = a2 + b2;
					if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {
						break;
					}
				}
				a2 = cnst3 * a2;
			}

			if (a2 < cnst1) {
				tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);
			} else {
				tau = s;
			}

		} else {

			// case 6, no information to guide us.
			if (tType == (-6)) {
				g += 0.333 * (1 - g);
			} else if (tType == (-18)) {
				g = 0.25 * 0.333;
			} else {
				g = 0.25;
			}
			tau = g * dMin;
			tType = -6;

		}
		break;

	case 1 : 		// one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.
		if ((dMin1 == dN1) && (dMin2 == dN2)) {

			// cases 7 and 8.
			tType = -7;
			double s = 0.333 * dMin1;
			if (work[nn - 5] > work[nn - 7]) {
				return;
			}
			double b1 = work[nn - 5] / work[nn - 7];
			double b2 = b1;
			if (b2 != 0.0) {
				for (int i4 = ((4 * end) - 10) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {
					final double oldB1 = b1;
					if (work[i4] > work[i4 - 2]) {
						return;
					}
					b1 = b1 * (work[i4] / work[i4 - 2]);
					b2 = b2 + b1;
					if ((100 * java.lang.Math.max(b1, oldB1)) < b2) {
						break;
					}
				}
			}
			b2 = java.lang.Math.sqrt(cnst3 * b2);
			final double a2 = dMin1 / (1 + (b2 * b2));
			final double gap2 = (0.5 * dMin2) - a2;
			if ((gap2 > 0.0) && (gap2 > (b2 * a2))) {
				tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));
			} else {
				tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));
				tType = -8;
			}
		} else {

			// case 9.
			tau = 0.25 * dMin1;
			if (dMin1 == dN1) {
				tau = 0.5 * dMin1;
			}
			tType = -9;
		}
		break;

	case 2 : 		// two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.

		// cases 10 and 11.
		if ((dMin2 == dN2) && ((2 * work[nn - 5]) < work[nn - 7])) {
			tType = -10;
			final double s = 0.333 * dMin2;
			if (work[nn - 5] > work[nn - 7]) {
				return;
			}
			double b1 = work[nn - 5] / work[nn - 7];
			double b2 = b1;
			if (b2 != 0.0) {
				for (int i4 = ((4 * end) - 9) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {
					if (work[i4] > work[i4 - 2]) {
						return;
					}
					b1 *= work[i4] / work[i4 - 2];
					b2 += b1;
					if ((100 * b1) < b2) {
						break;
					}
				}
			}
			b2 = java.lang.Math.sqrt(cnst3 * b2);
			final double a2 = dMin2 / (1 + (b2 * b2));
			final double gap2 = ((work[nn - 7] + work[nn - 9]) - 
			(java.lang.Math.sqrt(work[nn - 11]) * java.lang.Math.sqrt(work[nn - 9]))) - a2;
			if ((gap2 > 0.0) && (gap2 > (b2 * a2))) {
				tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));
			} else {
				tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));
			}
		} else {
			tau = 0.25 * dMin2;
			tType = -11;
		}
		break;

	default : 		// case 12, more than two realEigenvalues deflated. no information.
		tau = 0.0;
		tType = -12;}
buggy kind= CtSwitchImpl|CtBlockImpl
fixed statement= dN2 = 0
Patch kind= CtAssignmentImpl|CtBlockImpl
generation= 192
ingredientScope= LOCAL
validation=|true|0|2103|[]|
diffpatch=--- /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
+++ /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
@@ -1381,0 +1382 @@
+		dN2 = 0;


diffpatchoriginal=--- /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
+++ /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
@@ -1444 +1444 @@
-		int nn = ((4 * end) + pingPong) - 1;
+		int nn = ((4 * end) + pingPong) - 1; 		dN2 = 0;



Astor Output:

General stats:
EXECUTION_IDENTIFIER=
TOTAL_TIME=260.828
NR_GENERATIONS=192
NR_RIGHT_COMPILATIONS=141
NR_FAILLING_COMPILATIONS=51
NR_ERRONEOUS_VARIANCES=null
NR_FAILING_VALIDATION_PROCESS=null
OUTPUT_STATUS=STOP_BY_PATCH_FOUND
FAULT_LOCALIZATION=flacoco

Patch stats:

Patch 1
VARIANT_ID=384
TIME=260
VALIDATION=|true|0|2103|[]|
GENERATION=192
FOLDER_SOLUTION_CODE=/Users/marekmazur/astor/./output_astor/AstorMain-math-81//src//variant-384
--Patch Hunk #1
OPERATOR=InsertBeforeOp

LOCATION=org.apache.commons.math.linear.EigenDecompositionImpl

PATH=/Users/marekmazur/astor/defects4j/math-81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java

MODIFIED_FILE_PATH=/Users/marekmazur/astor/./output_astor/AstorMain-math-81//src//variant-384/org/apache/commons/math/linear/EigenDecompositionImpl.java

LINE=1445

SUSPICIOUNESS=0,993

MP_RANKING=249

ORIGINAL_CODE=switch (deflated) {

	case 0 : 		// no realEigenvalues deflated.
		if ((dMin == dN) || (dMin == dN1)) {

			double b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5]);
			double b2 = java.lang.Math.sqrt(work[nn - 7]) * java.lang.Math.sqrt(work[nn - 9]);
			double a2 = work[nn - 7] + work[nn - 5];

			if ((dMin == dN) && (dMin1 == dN1)) {
				// cases 2 and 3.
				final double gap2 = (dMin2 - a2) - (dMin2 * 0.25);
				final double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 / gap2) * b2 : b1 + b2);
				if ((gap1 > 0.0) && (gap1 > b1)) {
					tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin);
					tType = -2;
				} else {
					double s = 0.0;
					if (dN > b1) {
						s = dN - b1;
					}
					if (a2 > (b1 + b2)) {
						s = java.lang.Math.min(s, a2 - (b1 + b2));
					}
					tau = java.lang.Math.max(s, 0.333 * dMin);
					tType = -3;
				}
			} else {
				// case 4.
				tType = -4;
				double s = 0.25 * dMin;
				double gam;
				int np;
				if (dMin == dN) {
					gam = dN;
					a2 = 0.0;
					if (work[nn - 5] > work[nn - 7]) {
						return;
					}
					b2 = work[nn - 5] / work[nn - 7];
					np = nn - 9;
				} else {
					np = nn - (2 * pingPong);
					b2 = work[np - 2];
					gam = dN1;
					if (work[np - 4] > work[np - 2]) {
						return;
					}
					a2 = work[np - 4] / work[np - 2];
					if (work[nn - 9] > work[nn - 11]) {
						return;
					}
					b2 = work[nn - 9] / work[nn - 11];
					np = nn - 13;
				}

				// approximate contribution to norm squared from i < nn-1.
				a2 = a2 + b2;
				for (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {
					if (b2 == 0.0) {
						break;
					}
					b1 = b2;
					if (work[i4] > work[i4 - 2]) {
						return;
					}
					b2 = b2 * (work[i4] / work[i4 - 2]);
					a2 = a2 + b2;
					if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {
						break;
					}
				}
				a2 = cnst3 * a2;

				// rayleigh quotient residual bound.
				if (a2 < cnst1) {
					s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);
				}
				tau = s;

			}
		} else if (dMin == dN2) {

			// case 5.
			tType = -5;
			double s = 0.25 * dMin;

			// compute contribution to norm squared from i > nn-2.
			final int np = nn - (2 * pingPong);
			double b1 = work[np - 2];
			double b2 = work[np - 6];
			final double gam = dN2;
			if ((work[np - 8] > b2) || (work[np - 4] > b1)) {
				return;
			}
			double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1));

			// approximate contribution to norm squared from i < nn-2.
			if ((end - start) > 2) {
				b2 = work[nn - 13] / work[nn - 15];
				a2 = a2 + b2;
				for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {
					if (b2 == 0.0) {
						break;
					}
					b1 = b2;
					if (work[i4] > work[i4 - 2]) {
						return;
					}
					b2 = b2 * (work[i4] / work[i4 - 2]);
					a2 = a2 + b2;
					if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {
						break;
					}
				}
				a2 = cnst3 * a2;
			}

			if (a2 < cnst1) {
				tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);
			} else {
				tau = s;
			}

		} else {

			// case 6, no information to guide us.
			if (tType == (-6)) {
				g += 0.333 * (1 - g);
			} else if (tType == (-18)) {
				g = 0.25 * 0.333;
			} else {
				g = 0.25;
			}
			tau = g * dMin;
			tType = -6;

		}
		break;

	case 1 : 		// one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.
		if ((dMin1 == dN1) && (dMin2 == dN2)) {

			// cases 7 and 8.
			tType = -7;
			double s = 0.333 * dMin1;
			if (work[nn - 5] > work[nn - 7]) {
				return;
			}
			double b1 = work[nn - 5] / work[nn - 7];
			double b2 = b1;
			if (b2 != 0.0) {
				for (int i4 = ((4 * end) - 10) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {
					final double oldB1 = b1;
					if (work[i4] > work[i4 - 2]) {
						return;
					}
					b1 = b1 * (work[i4] / work[i4 - 2]);
					b2 = b2 + b1;
					if ((100 * java.lang.Math.max(b1, oldB1)) < b2) {
						break;
					}
				}
			}
			b2 = java.lang.Math.sqrt(cnst3 * b2);
			final double a2 = dMin1 / (1 + (b2 * b2));
			final double gap2 = (0.5 * dMin2) - a2;
			if ((gap2 > 0.0) && (gap2 > (b2 * a2))) {
				tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));
			} else {
				tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));
				tType = -8;
			}
		} else {

			// case 9.
			tau = 0.25 * dMin1;
			if (dMin1 == dN1) {
				tau = 0.5 * dMin1;
			}
			tType = -9;
		}
		break;

	case 2 : 		// two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.

		// cases 10 and 11.
		if ((dMin2 == dN2) && ((2 * work[nn - 5]) < work[nn - 7])) {
			tType = -10;
			final double s = 0.333 * dMin2;
			if (work[nn - 5] > work[nn - 7]) {
				return;
			}
			double b1 = work[nn - 5] / work[nn - 7];
			double b2 = b1;
			if (b2 != 0.0) {
				for (int i4 = ((4 * end) - 9) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {
					if (work[i4] > work[i4 - 2]) {
						return;
					}
					b1 *= work[i4] / work[i4 - 2];
					b2 += b1;
					if ((100 * b1) < b2) {
						break;
					}
				}
			}
			b2 = java.lang.Math.sqrt(cnst3 * b2);
			final double a2 = dMin2 / (1 + (b2 * b2));
			final double gap2 = ((work[nn - 7] + work[nn - 9]) - 
			(java.lang.Math.sqrt(work[nn - 11]) * java.lang.Math.sqrt(work[nn - 9]))) - a2;
			if ((gap2 > 0.0) && (gap2 > (b2 * a2))) {
				tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));
			} else {
				tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));
			}
		} else {
			tau = 0.25 * dMin2;
			tType = -11;
		}
		break;

	default : 		// case 12, more than two realEigenvalues deflated. no information.
		tau = 0.0;
		tType = -12;}

BUGGY_CODE_TYPE=CtSwitchImpl|CtBlockImpl

PATCH_HUNK_CODE=dN2 = 0

PATCH_HUNK_TYPE=CtAssignmentImpl|CtBlockImpl

INGREDIENT_SCOPE=LOCAL

INGREDIENT_PARENT=dN2 = 0

PATCH_DIFF_ORIG=--- /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
+++ /src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
@@ -1444 +1444 @@
-		int nn = ((4 * end) + pingPong) - 1;
+		int nn = ((4 * end) + pingPong) - 1; 		dN2 = 0;



Storing ing JSON at /Users/marekmazur/astor/./output_astor/AstorMain-math-81//astor_output.json
astor_output:
{"general":{"NR_RIGHT_COMPILATIONS":141,"NR_ERRONEOUS_VARIANCES":null,"EXECUTION_IDENTIFIER":"","FAULT_LOCALIZATION":"flacoco","OUTPUT_STATUS":"STOP_BY_PATCH_FOUND","NR_FAILLING_COMPILATIONS":51,"NR_GENERATIONS":192,"TOTAL_TIME":260.828,"NR_FAILING_VALIDATION_PROCESS":null},"patches":[{"VARIANT_ID":"384","VALIDATION":"|true|0|2103|[]|","patchhunks":[{"LOCATION":"org.apache.commons.math.linear.EigenDecompositionImpl","PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/defects4j\\\/math-81\\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","INGREDIENT_SCOPE":"LOCAL","SUSPICIOUNESS":"0,993","INGREDIENT_PARENT":"dN2 = 0","PATCH_HUNK_TYPE":"CtAssignmentImpl|CtBlockImpl","ORIGINAL_CODE":"switch (deflated) {\\n\\n\\tcase 0 : \\t\\t\\\/\\\/ no realEigenvalues deflated.\\n\\t\\tif ((dMin == dN) || (dMin == dN1)) {\\n\\n\\t\\t\\tdouble b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5]);\\n\\t\\t\\tdouble b2 = java.lang.Math.sqrt(work[nn - 7]) * java.lang.Math.sqrt(work[nn - 9]);\\n\\t\\t\\tdouble a2 = work[nn - 7] + work[nn - 5];\\n\\n\\t\\t\\tif ((dMin == dN) && (dMin1 == dN1)) {\\n\\t\\t\\t\\t\\\/\\\/ cases 2 and 3.\\n\\t\\t\\t\\tfinal double gap2 = (dMin2 - a2) - (dMin2 * 0.25);\\n\\t\\t\\t\\tfinal double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 \\\/ gap2) * b2 : b1 + b2);\\n\\t\\t\\t\\tif ((gap1 > 0.0) && (gap1 > b1)) {\\n\\t\\t\\t\\t\\ttau = java.lang.Math.max(dN - ((b1 \\\/ gap1) * b1), 0.5 * dMin);\\n\\t\\t\\t\\t\\ttType = -2;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdouble s = 0.0;\\n\\t\\t\\t\\t\\tif (dN > b1) {\\n\\t\\t\\t\\t\\t\\ts = dN - b1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (a2 > (b1 + b2)) {\\n\\t\\t\\t\\t\\t\\ts = java.lang.Math.min(s, a2 - (b1 + b2));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttau = java.lang.Math.max(s, 0.333 * dMin);\\n\\t\\t\\t\\t\\ttType = -3;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\\/\\\/ case 4.\\n\\t\\t\\t\\ttType = -4;\\n\\t\\t\\t\\tdouble s = 0.25 * dMin;\\n\\t\\t\\t\\tdouble gam;\\n\\t\\t\\t\\tint np;\\n\\t\\t\\t\\tif (dMin == dN) {\\n\\t\\t\\t\\t\\tgam = dN;\\n\\t\\t\\t\\t\\ta2 = 0.0;\\n\\t\\t\\t\\t\\tif (work[nn - 5] > work[nn - 7]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb2 = work[nn - 5] \\\/ work[nn - 7];\\n\\t\\t\\t\\t\\tnp = nn - 9;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnp = nn - (2 * pingPong);\\n\\t\\t\\t\\t\\tb2 = work[np - 2];\\n\\t\\t\\t\\t\\tgam = dN1;\\n\\t\\t\\t\\t\\tif (work[np - 4] > work[np - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ta2 = work[np - 4] \\\/ work[np - 2];\\n\\t\\t\\t\\t\\tif (work[nn - 9] > work[nn - 11]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb2 = work[nn - 9] \\\/ work[nn - 11];\\n\\t\\t\\t\\t\\tnp = nn - 13;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\\/\\\/ approximate contribution to norm squared from i < nn-1.\\n\\t\\t\\t\\ta2 = a2 + b2;\\n\\t\\t\\t\\tfor (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\\n\\t\\t\\t\\t\\tif (b2 == 0.0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb1 = b2;\\n\\t\\t\\t\\t\\tif (work[i4] > work[i4 - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb2 = b2 * (work[i4] \\\/ work[i4 - 2]);\\n\\t\\t\\t\\t\\ta2 = a2 + b2;\\n\\t\\t\\t\\t\\tif (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ta2 = cnst3 * a2;\\n\\n\\t\\t\\t\\t\\\/\\\/ rayleigh quotient residual bound.\\n\\t\\t\\t\\tif (a2 < cnst1) {\\n\\t\\t\\t\\t\\ts = (gam * (1 - java.lang.Math.sqrt(a2))) \\\/ (1 + a2);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttau = s;\\n\\n\\t\\t\\t}\\n\\t\\t} else if (dMin == dN2) {\\n\\n\\t\\t\\t\\\/\\\/ case 5.\\n\\t\\t\\ttType = -5;\\n\\t\\t\\tdouble s = 0.25 * dMin;\\n\\n\\t\\t\\t\\\/\\\/ compute contribution to norm squared from i > nn-2.\\n\\t\\t\\tfinal int np = nn - (2 * pingPong);\\n\\t\\t\\tdouble b1 = work[np - 2];\\n\\t\\t\\tdouble b2 = work[np - 6];\\n\\t\\t\\tfinal double gam = dN2;\\n\\t\\t\\tif ((work[np - 8] > b2) || (work[np - 4] > b1)) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdouble a2 = (work[np - 8] \\\/ b2) * (1 + (work[np - 4] \\\/ b1));\\n\\n\\t\\t\\t\\\/\\\/ approximate contribution to norm squared from i < nn-2.\\n\\t\\t\\tif ((end - start) > 2) {\\n\\t\\t\\t\\tb2 = work[nn - 13] \\\/ work[nn - 15];\\n\\t\\t\\t\\ta2 = a2 + b2;\\n\\t\\t\\t\\tfor (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\\n\\t\\t\\t\\t\\tif (b2 == 0.0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb1 = b2;\\n\\t\\t\\t\\t\\tif (work[i4] > work[i4 - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb2 = b2 * (work[i4] \\\/ work[i4 - 2]);\\n\\t\\t\\t\\t\\ta2 = a2 + b2;\\n\\t\\t\\t\\t\\tif (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ta2 = cnst3 * a2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (a2 < cnst1) {\\n\\t\\t\\t\\ttau = (gam * (1 - java.lang.Math.sqrt(a2))) \\\/ (1 + a2);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttau = s;\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t\\\/\\\/ case 6, no information to guide us.\\n\\t\\t\\tif (tType == (-6)) {\\n\\t\\t\\t\\tg += 0.333 * (1 - g);\\n\\t\\t\\t} else if (tType == (-18)) {\\n\\t\\t\\t\\tg = 0.25 * 0.333;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tg = 0.25;\\n\\t\\t\\t}\\n\\t\\t\\ttau = g * dMin;\\n\\t\\t\\ttType = -6;\\n\\n\\t\\t}\\n\\t\\tbreak;\\n\\n\\tcase 1 : \\t\\t\\\/\\\/ one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\\n\\t\\tif ((dMin1 == dN1) && (dMin2 == dN2)) {\\n\\n\\t\\t\\t\\\/\\\/ cases 7 and 8.\\n\\t\\t\\ttType = -7;\\n\\t\\t\\tdouble s = 0.333 * dMin1;\\n\\t\\t\\tif (work[nn - 5] > work[nn - 7]) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdouble b1 = work[nn - 5] \\\/ work[nn - 7];\\n\\t\\t\\tdouble b2 = b1;\\n\\t\\t\\tif (b2 != 0.0) {\\n\\t\\t\\t\\tfor (int i4 = ((4 * end) - 10) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\\n\\t\\t\\t\\t\\tfinal double oldB1 = b1;\\n\\t\\t\\t\\t\\tif (work[i4] > work[i4 - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb1 = b1 * (work[i4] \\\/ work[i4 - 2]);\\n\\t\\t\\t\\t\\tb2 = b2 + b1;\\n\\t\\t\\t\\t\\tif ((100 * java.lang.Math.max(b1, oldB1)) < b2) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tb2 = java.lang.Math.sqrt(cnst3 * b2);\\n\\t\\t\\tfinal double a2 = dMin1 \\\/ (1 + (b2 * b2));\\n\\t\\t\\tfinal double gap2 = (0.5 * dMin2) - a2;\\n\\t\\t\\tif ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\\n\\t\\t\\t\\ttau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 \\\/ gap2)) * b2)));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\\n\\t\\t\\t\\ttType = -8;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\n\\t\\t\\t\\\/\\\/ case 9.\\n\\t\\t\\ttau = 0.25 * dMin1;\\n\\t\\t\\tif (dMin1 == dN1) {\\n\\t\\t\\t\\ttau = 0.5 * dMin1;\\n\\t\\t\\t}\\n\\t\\t\\ttType = -9;\\n\\t\\t}\\n\\t\\tbreak;\\n\\n\\tcase 2 : \\t\\t\\\/\\\/ two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\\n\\n\\t\\t\\\/\\\/ cases 10 and 11.\\n\\t\\tif ((dMin2 == dN2) && ((2 * work[nn - 5]) < work[nn - 7])) {\\n\\t\\t\\ttType = -10;\\n\\t\\t\\tfinal double s = 0.333 * dMin2;\\n\\t\\t\\tif (work[nn - 5] > work[nn - 7]) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdouble b1 = work[nn - 5] \\\/ work[nn - 7];\\n\\t\\t\\tdouble b2 = b1;\\n\\t\\t\\tif (b2 != 0.0) {\\n\\t\\t\\t\\tfor (int i4 = ((4 * end) - 9) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\\n\\t\\t\\t\\t\\tif (work[i4] > work[i4 - 2]) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tb1 *= work[i4] \\\/ work[i4 - 2];\\n\\t\\t\\t\\t\\tb2 += b1;\\n\\t\\t\\t\\t\\tif ((100 * b1) < b2) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tb2 = java.lang.Math.sqrt(cnst3 * b2);\\n\\t\\t\\tfinal double a2 = dMin2 \\\/ (1 + (b2 * b2));\\n\\t\\t\\tfinal double gap2 = ((work[nn - 7] + work[nn - 9]) - \\n\\t\\t\\t(java.lang.Math.sqrt(work[nn - 11]) * java.lang.Math.sqrt(work[nn - 9]))) - a2;\\n\\t\\t\\tif ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\\n\\t\\t\\t\\ttau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 \\\/ gap2)) * b2)));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\ttau = 0.25 * dMin2;\\n\\t\\t\\ttType = -11;\\n\\t\\t}\\n\\t\\tbreak;\\n\\n\\tdefault : \\t\\t\\\/\\\/ case 12, more than two realEigenvalues deflated. no information.\\n\\t\\ttau = 0.0;\\n\\t\\ttType = -12;}","BUGGY_CODE_TYPE":"CtSwitchImpl|CtBlockImpl","OPERATOR":"InsertBeforeOp","MODIFIED_FILE_PATH":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-81\\\/\\\/src\\\/\\\/variant-384\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java","LINE":"1445","MP_RANKING":"249","PATCH_HUNK_CODE":"dN2 = 0"}],"TIME":"260","GENERATION":"192","FOLDER_SOLUTION_CODE":"\\\/Users\\\/marekmazur\\\/astor\\\/.\\\/output_astor\\\/AstorMain-math-81\\\/\\\/src\\\/\\\/variant-384","PATCH_DIFF_ORIG":"--- \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n+++ \\\/src\\\/main\\\/java\\\/org\\\/apache\\\/commons\\\/math\\\/linear\\\/EigenDecompositionImpl.java\\n@@ -1444 +1444 @@\\n-\\t\\tint nn = ((4 * end) + pingPong) - 1;\\n+\\t\\tint nn = ((4 * end) + pingPong) - 1; \\t\\tdN2 = 0;\\n\\n"}]}
Time Total(s): 461.127
